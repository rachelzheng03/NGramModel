public void function ( ) { DumpHttpRequest request = new DumpHttpRequest ( ) ; request . setVersion ( " HTTP/1.1 " ) ; request . setMethod ( " POST " ) ; request . setContent ( " proxy " ) ; request . addHeader ( " Cookie " , " loggedIn=true " ) ; request . addHeader ( " Host " , " localhost:12306 " ) ; DumpHttpRequest failover = new DumpHttpRequest ( ) ; failover . setVersion ( " HTTP/1.1 " ) ; failover . setMethod ( " POST " ) ; failover . setContent ( " proxy " ) ; failover . addHeader ( " Host " , " localhost:12306 " ) ; assertThat ( failover . match ( request ) , is ( true ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div><p><span>One</span></p></div> <div><p>Two</p></div> " ) ; Elements divs = doc . select ( " div:has(p:has(span)) " ) ; assertEquals ( 1 , divs . size ( ) ) ; assertEquals ( " One " , divs . first ( ) . text ( ) ) ; }
void function ( String . . . arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( ! logger . isTraceEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg0 ( arg0 , arg1 , arg2 )
public void function ( ) throws Exception { server . mount ( MOUNT_DIR , to ( " /dir " ) , exclude ( " *.response " ) ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . get ( remoteUrl ( " /dir/dir.response " ) ) ) ) ;
public void function ( final Request arg0 ) { writer . write ( formatter . format ( ( HttpRequest ) arg0 ) ) ; }
@Test public void function ( ) { String validAnchor = " <a href= \" #valid \" >Valid anchor</a> " ; String invalidAnchor = " <a href= \" #anchor with spaces \" >Invalid anchor</a> " ; String cleanHtml = Jsoup . clean ( validAnchor , Safelist . relaxed ( ) ) ; assertEquals ( " <a>Valid anchor</a> " , cleanHtml ) ; cleanHtml = Jsoup . clean ( invalidAnchor , Safelist . relaxed ( ) ) ; assertEquals ( " <a>Invalid anchor</a> " , cleanHtml ) ; Safelist relaxedWithAnchor = Safelist . relaxed ( ) . addProtocols ( " a " , " href " , " # " ) ; cleanHtml = Jsoup . clean ( validAnchor , relaxedWithAnchor ) ; assertEquals ( validAnchor , cleanHtml ) ; cleanHtml = Jsoup . clean ( invalidAnchor , relaxedWithAnchor ) ; assertEquals ( " <a>Invalid anchor</a> " , cleanHtml ) ; }
static public String function ( ) { String moduleVersion = slf4jVersionByModule ( ) ; if ( moduleVersion ! = null ) return moduleVersion ; Package pkg = Slf4jEnvUtil . class . getPackage ( ) ; if ( pkg = = null ) { return null ; } final String pkgVersion = pkg . getImplementationVersion ( ) ; return pkgVersion ; }
public Optional < WebsocketResponse > function ( final ChannelHandlerContext arg0 , final WebSocketFrame arg1 ) { DefaultWebsocketRequest request = new DefaultWebsocketRequest ( arg1 ) ; DefaultWebsocketResponse response = new DefaultWebsocketResponse ( ) ; SessionContext context = new SessionContext ( request , response , new ChannelSessionGroup ( this . group ) ) ; return this . getResponse ( context ) . flatMap ( this : : asWebsocketResponse ) ;
public void function ( ) throws IOException { runWithConfiguration ( " template_with_function.json " ) ; String response = helper . get ( remoteUrl ( " /random_template_without_arg " ) ) ; double result = Double . parseDouble ( response ) ; assertThat ( result , lessThan ( 1d ) ) ; assertThat ( result , greaterThan ( 0d ) ) ; }
String function ( final char . . . arg0 ) { bufferUp ( ) ; final int start = bufPos ; final int remaining = bufLength ; final char [ ] val = charBuf ; while ( bufPos < remaining ) { if ( Arrays . binarySearch ( arg0 , val [ bufPos ] ) > = 0 ) break ; bufPos + + ; } return bufPos > start ? cacheString ( charBuf , stringCache , start , bufPos - start ) : " " ; }
private void function ( ) { layoutManager . putConstraint ( SpringLayout . WEST , migrationLabel , BASIC_PADDING , SpringLayout . EAST , this ) ; layoutManager . putConstraint ( SpringLayout . NORTH , migrationLabel , BASIC_PADDING , SpringLayout . NORTH , this ) ; slh . placeToTheRight ( migrationLabel , radioJCL , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( radioJCL , radioLog4j , 0 , 0 ) ; slh . placeBelow ( migrationLabel , folderLabel , 0 , BASIC_PADDING * 5 ) ; slh . placeToTheRight ( folderLabel , folderTextField ) ; slh . placeToTheRight ( folderTextField , browseButton , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( folderLabel , warningLabel , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( warningLabel , awareCheckBox , 0 , ( int ) ( BASIC_PADDING * 1.5 ) ) ; slh . placeToTheRight ( awareCheckBox , awareLabel ) ; slh . placeBelow ( awareCheckBox , migrateButton , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( migrateButton , otherLabel , 0 , BASIC_PADDING * 2 ) ; slh . placeBelow ( otherLabel , progressBar , 0 , BASIC_PADDING ) ; }
private void function ( ) { s . add ( new Evaluator . IndexGreaterThan ( consumeIndex ( ) ) ) ; }
public Elements function ( Element arg0 ) { return new Elements ( match ( arg0 , arg0 , new ArrayList < Element > ( ) ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { logger . error ( String . valueOf ( arg0 ) , arg1 ) ; }
public static HttpRequest function ( final FullHttpRequest arg0 ) { QueryStringDecoder decoder = new QueryStringDecoder ( arg0 . uri ( ) ) ; ImmutableMap < String , String [ ] > queries = toQueries ( decoder ) ; return builder ( ) . withVersion ( HttpProtocolVersion . versionOf ( arg0 . protocolVersion ( ) . text ( ) ) )
void function ( Tokeniser arg0 , CharacterReader arg1 ) { Character c = arg0 . consumeCharacterReference ( null , false ) ; if ( c = = null ) arg0 . emit ( '&' ) ; else arg0 . emit ( c ) ; arg0 . transition ( Rcdata ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { JCLMatcher jclMatcher = new JCLMatcher ( ) ; assertEquals ( " protected Logger log = " , jclMatcher . getReplacement ( " protected Log log = " ) ) ; assertEquals ( "  LoggerFactory.getLogger(MyComponent.class); " , jclMatcher . getReplacement ( "  LogFactory.getLog(MyComponent.class); " ) ) ; assertEquals ( " protected Logger log  " , jclMatcher . getReplacement ( " protected Log log  " ) ) ; assertEquals ( "  = LoggerFactory.getLogger(MyComponent.class); " ,
public static ControllableInputStream function ( InputStream arg0 , int arg1 , int arg2 ) { return wrap ( arg0 , arg2 ) ; }
public void function ( ) { SLF4JBridgeHandler . install ( ) ; String msg = " msg " ; julLogger . info ( msg ) ; assertEquals ( 1 , listAppender . list . size ( ) ) ; LoggingEvent le = ( LoggingEvent ) listAppender . list . get ( 0 ) ; assertEquals ( LOGGER_NAME , le . getLoggerName ( ) ) ; assertEquals ( msg , le . getMessage ( ) ) ; LocationInfo li = le . getLocationInformation ( ) ; System . out . println ( li . fullInfo ) ; assertEquals ( " SLF4JBridgeHandlerTest.java " , li . getFileName ( ) ) ; assertEquals ( " testSmoke " , li . getMethodName ( ) ) ; }
private HttpServer function ( Iterable < ? extends RunnerSetting > arg0 , int arg1 ) { HttpServer server = createBaseHttpServer ( arg0 , arg1 ) ; server . request ( by ( uri ( " /favicon.ico " ) ) ) . response ( content ( pathResource ( " favicon.png " ) ) , header ( " Content-Type " , " image/png " ) ) ; return server ; }
@Test public void function ( ) throws MalformedURLException { URL url1 = new URL ( " https://test.com/foo bar/[One]?q=white space#frag " ) ; URL url2 = HttpConnection . encodeUrl ( url1 ) ; assertEquals ( " https://test.com/foo%20bar/%5BOne%5D?q=white%20space#frag " , url2 . toExternalForm ( ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { loggingEvent . setMessage ( arg0 ) ; loggingEvent . addArguments ( arg1 ) ; log ( loggingEvent ) ; }
public static @Nullable Element function ( Evaluator arg0 , Element arg1 ) { FirstFinder finder = new FirstFinder ( arg0 ) ; return finder . find ( arg1 , arg1 ) ; }
public static RequestExtractor < ? > extractor ( final String id ) { if ( extractors . containsKey ( id ) ) { return extractors . get ( id ) ; } throw new IllegalArgumentException ( format ( " unknown extractor for [%s] " , id ) ) ; }
public void function ( ) throws UnknownHostException { new AutobahnServer ( 9003 , new Draft_17 ( ) ) . start ( ) ; }
public void function ( ) throws Exception { server . response ( header ( " content-type " , " application/json " ) ) ; running ( server , new Runnable ( ) { @Override
@Test public void function ( ) { Document doc = Jsoup . parse ( " <font face=Arial><body class=name><div>One</div></body></font> " ) ; assertEquals ( " <html><head></head><body class= \" name \" ><font face= \" Arial \" ><div>One</div></font></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
public static RequestMatcher function ( final Object arg0 ) { return by ( toJson ( arg0 ) ) ; }
protected boolean function ( final int arg0 , final int arg1 ) { return arg0 < = arg1 ; }
public List < Node > function ( String arg0 , arg1 Element arg2 , String arg3 ) { return treeBuilder . parseFragment ( arg0 , arg2 , arg3 , this ) ; }
public void function ( Marker arg0 , String arg1 ) { delegate ( ) . debug ( arg0 , arg1 ) ; }
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { WebSocketImpl . DEBUG = true ; int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ServerRejectHandshakeExample s = new ServerRejectHandshakeExample ( port ) ; s . start ( ) ; System . out . println ( " Server started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
public void function ( ) throws Exception { byte [ ] buffer = BufferTools . stringToByteBuffer ( VALID_TAG_WITH_WHITESPACE , 0 , VALID_TAG_WITH_WHITESPACE . length ( ) ) ; replaceSpacesWithNulls ( buffer ) ; buffer [ buffer . length - 3 ] = 0x00 ; buffer [ buffer . length - 2 ] = 0x01 ; buffer [ buffer . length - 1 ] = 0x0D ; ID3v1Tag id3v1tag = new ID3v1Tag ( buffer ) ; assertEquals ( " TITLE " , id3v1tag . getTitle ( ) ) ; assertEquals ( " ARTIST " , id3v1tag . getArtist ( ) ) ; assertEquals ( " ALBUM " , id3v1tag . getAlbum ( ) ) ; assertEquals ( " 2001 " , id3v1tag . getYear ( ) ) ; assertEquals ( " COMMENT " , id3v1tag . getComment ( ) ) ; assertEquals ( " 1 " , id3v1tag . getTrack ( ) ) ; assertEquals ( 0x0d , id3v1tag . getGenre ( ) ) ; assertEquals ( " Pop " , id3v1tag . getGenreDescription ( ) ) ; }
private void function ( final CloseableHttpClient arg0 , final Request arg1 ) throws IOException { String targetUrl = url . readFor ( arg1 ) . toString ( ) ; HttpRequestBase httpRequest = createRequest ( targetUrl , arg1 ) ; for ( HttpHeader header : headers ) { httpRequest . setHeader ( header . getName ( ) , header . getValue ( ) . readFor ( null ) . toString ( ) ) ; } arg0 . execute ( httpRequest ) ; }
public boolean function ( String arg0 ) { String baseUri = ( safelist . preserveRelativeLinks ( ) ) ? DummyUri : " " ; Document clean = Document . createShell ( baseUri ) ; Document dirty = Document . createShell ( baseUri ) ; ParseErrorList errorList = ParseErrorList . tracking ( 1 ) ; List < Node > nodes = Parser . parseFragment ( arg0 , dirty . body ( ) , baseUri , errorList ) ; dirty . body ( ) . insertChildren ( 0 , nodes ) ; int numDiscarded = copySafeNodes ( dirty . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 & & errorList . isEmpty ( ) ; }
public Document function ( ) { Document clone = new Document ( baseUri ( ) ) ; if ( attributes ! = null ) clone . attributes = attributes . clone ( ) ; clone . outputSettings = this . outputSettings . clone ( ) ; return clone ; }
public static void function ( final long arg0 , final TimeUnit arg1 ) { try { arg1 . sleep ( arg0 ) ;
public void function ( ) { assertNull ( LoggerFactory . loadExplicitlySpecified ( " java.lang.String " ) ) ; assertThat ( mockedSyserr . toString ( ) , containsString ( " Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface " ) ) ;
private HttpRequestBase function ( String arg0 , String arg1 ) { if ( HttpMethod . GET . name ( ) . equalsIgnoreCase ( arg1 ) ) { return new HttpGet ( arg0 ) ; } throw new RuntimeException ( format ( " unknown HTTP method: %s " , arg1 ) ) ; }
public void function ( ) throws Exception { server . response ( header ( " foo " , template ( file ( " foo.response " ) ) ) ) ; running ( server , new Runnable ( ) { @Override
protected Optional < String > function ( final HttpRequest arg0 ) { Optional < ImmutableMap < String , String > > cookies = extractor . extract ( arg0 ) ; return cookies . map ( cookie - > cookie . get ( this . key ) ) ; }
public void function ( arg0 . arg1 . arg2 . Document arg3 , Document arg4 ) { if ( ! StringUtil . isBlank ( arg3 . location ( ) ) ) arg4 . setDocumentURI ( arg3 . location ( ) ) ; arg0 . arg1 . arg2 . Element rootEl = arg3 . child ( 0 ) ; NodeTraversor traversor = new NodeTraversor ( new W3CBuilder ( arg4 ) ) ; traversor . traverse ( rootEl ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; org . apache . http . HttpResponse response = helper . getResponse ( remoteUrl ( " /cookie " ) ) ; String value = response . getFirstHeader ( HttpHeaders . SET_COOKIE ) . getValue ( ) ; Cookie decodeCookie = ClientCookieDecoder . STRICT . decode ( value ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; }
public void function ( final HttpRequest arg0 ) { writer . write ( formatter . format ( arg0 ) ) ; }
public static ContentResource function ( final String arg0 , final String arg1 , final String arg2 , final String arg3 , final String arg4 ) { return arg0 ( text ( checkNotNullOrEmpty ( arg0 , " Template should not be null " ) ) , checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
private Elements function ( ) { String key = tq . consumeToAny ( " = " , " != " , " ^= " , " $= " , " *= " , " ~= " , " ] " ) ; Validate . notEmpty ( key ) ; if ( tq . matchChomp ( " ] " ) ) { return root . getElementsByAttribute ( key ) ;
protected void function ( ) { rulesMap = new TreeMap < PatternWrapper , ReplacementWrapper > ( ) ; rulesMap . put ( p0 , r0 ) ; rulesMap . put ( p1 , r1 ) ; rulesMap . put ( p2 , r2 ) ; rulesMap . put ( p3 , r2 ) ; rulesMap . put ( p4 , r3 ) ; rulesMap . put ( p5 , r3 ) ; rulesMap . put ( p6 , r4 ) ; }
public void function ( LoggingEvent arg0 ) { Level julLevel = slf4jLevelToJULLevel ( arg0 . getLevel ( ) ) ; if ( logger . isLoggable ( julLevel ) ) { LogRecord record = eventToRecord ( arg0 , julLevel ) ;
public void function ( ) { System . out . println ( " THREAD_COUNT= " + THREAD_COUNT ) ; LoggerFactoryFriend . reset ( ) ; }
public void function ( ) throws Exception { Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; String msg = " hello world  " + diff ; logger . info ( msg ) ; assertEquals ( 2 , sps . stringList . size ( ) ) ; String s0 = ( String ) sps . stringList . get ( 0 ) ; assertTrue ( s0 . startsWith ( " SLF4J(D): Connected with provider of type [org.slf4j.simple.SimpleServiceProvider] " ) ) ; String s1 = ( String ) sps . stringList . get ( 1 ) ; assertTrue ( s1 . contains ( msg ) ) ;
public void function ( ) { MutableInteger integer = new MutableInteger ( 8 ) ; assertFalse ( integer . equals ( null ) ) ; }
public int function ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + endOffset ; result = prime * result + endTime ; result = prime * result + ( ( id = = null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + startOffset ; result = prime * result + startTime ; result = prime * result + ( ( subframes = = null ) ? 0 : subframes . hashCode ( ) ) ; return result ; }
public String function ( ) { return " Framedata{ optcode: " + getOpcode ( ) + " , fin: " + isFin ( ) + " , rsv1: " + isRSV1 ( ) + " , rsv2: " + isRSV2 ( ) + " , rsv3: " + isRSV3 ( ) + " , payloadlength:[pos: " + unmaskedpayload . position ( ) + " , len: " + unmaskedpayload . remaining ( ) + " ], payload: " + ( unmaskedpayload . remaining ( ) > 1000 ? " (too big to display) " : new String ( unmaskedpayload . array ( ) ) ) + '}' ; }
public void function ( final ChannelHandlerContext arg0 ) { if ( websocketServer ! = null ) { websocketServer . disconnect ( arg0 . channel ( ) ) ;
public final boolean function ( final Request arg0 ) { Optional < T > extractContent = extractor . extract ( arg0 ) ; if ( ! extractContent . isPresent ( ) ) { return false ; } T target = extractContent . get ( ) ; if ( target instanceof String ) { return predicate . test ( ( String ) target ) ; } if ( target instanceof String [ ] ) { String [ ] contents = ( String [ ] ) target ; return Arrays . stream ( contents ) . filter ( Objects : : nonNull ) . anyMatch ( predicate ) ; } if ( target instanceof MessageContent ) { MessageContent actualTarget = ( MessageContent ) target ; return predicate . test ( actualTarget . toString ( ) ) ; } return false ; }
private void function ( byte [ ] arg0 , String arg1 , int arg2 , int arg3 ) { if ( arg1 ! = null ) { try {
FormElement function ( Token . StartTag arg0 , boolean arg1 ) { Tag tag = Tag . valueOf ( arg0 . name ( ) , settings ) ; FormElement el = new FormElement ( tag , baseUri , arg0 . attributes ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( arg1 ) stack . add ( el ) ; return el ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.5.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 700 ) ;
public void function ( ) { classUnderTest = null ; expected = null ; request = null ; extractor = null ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
Element function ( String arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; stack . remove ( pos ) ; if ( el . normalName ( ) . equals ( arg0 ) & & NamespaceHtml . equals ( el . tag ( ) . namespace ( ) ) ) { if ( currentToken instanceof Token . EndTag ) onNodeClosed ( el , currentToken ) ; return el ; } } return null ; }
public void function ( ) { runner . run ( ) ; fileMonitor . startMonitor ( ) ; }
private Runner function ( StartArgs arg0 ) { final File settingsFile = new File ( arg0 . getSettings ( ) . get ( ) ) ; final FileRunner fileRunner = createSettingFileRunner ( settingsFile , arg0 ) ; final SettingRunner runner = ( SettingRunner ) fileRunner . getRunner ( ) ; MocoRunnerMonitor fileMocoRunnerMonitor = monitorFactory . createSettingMonitor ( settingsFile , runner . getFiles ( ) , fileRunner ) ; return new MonitorRunner ( fileRunner , fileMocoRunnerMonitor ) ; }
boolean function ( char [ ] arg0 ) { return ! isEmpty ( ) & & Arrays . binarySearch ( arg0 , input [ pos ] ) > = 0 ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object [ ] arg3 , Throwable arg4 ) { SubstituteLoggingEvent loggingEvent = new SubstituteLoggingEvent ( ) ; loggingEvent . setTimeStamp ( System . currentTimeMillis ( ) ) ; loggingEvent . setLevel ( arg0 ) ; loggingEvent . setLogger ( logger ) ; loggingEvent . setLoggerName ( name ) ; loggingEvent . setMessage ( arg2 ) ; loggingEvent . setArgumentArray ( arg3 ) ; loggingEvent . setThrowable ( arg4 ) ; loggingEvent . setThreadName ( Thread . currentThread ( ) . getName ( ) ) ; eventList . add ( loggingEvent ) ; }
private String function ( final HttpRequest arg0 ) { return Joiner . on ( ' ' ) . join ( arg0 . getMethod ( ) . name ( ) , getUri ( arg0 ) , arg0 . getVersion ( ) . text ( ) ) ; }
public void function ( ) throws Exception { runTestScenarioReconnect ( false ) ; }
public void function ( ) { Log log = LogFactory . getLog ( InvokeJCLTest . class ) ; Exception e = new Exception ( " just testing " ) ; log . trace ( null ) ; log . trace ( " trace message " ) ; log . debug ( null ) ; log . debug ( " debug message " ) ; log . info ( null ) ; log . info ( " info  message " ) ; log . warn ( null ) ; log . warn ( " warn message " ) ; log . error ( null ) ; log . error ( " error message " ) ; log . fatal ( null ) ; log . fatal ( " fatal message " ) ; log . trace ( null , e ) ; log . trace ( " trace message " , e ) ; log . debug ( null , e ) ; log . debug ( " debug message " , e ) ; log . info ( null , e ) ; log . info ( " info  message " , e ) ; log . warn ( null , e ) ; log . warn ( " warn message " , e ) ; log . error ( null , e ) ; log . error ( " error message " , e ) ; log . fatal ( null , e ) ; log . fatal ( " fatal message " , e ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { arg1 . error ( this ) ; arg1 . setFosterInserts ( true ) ; arg1 . process ( arg0 , InBody ) ; arg1 . setFosterInserts ( false ) ; return true ; }
public static String function ( ) { return ProxyPassword = newPassword ( ) + " -proxy " ; }
public Iterator function ( ) ; }
public String function ( Map . Entry < String , String > arg0 ) { return arg0 . getValue ( ) ; }
public void function ( ) throws Exception { RequestRecorder recorder = new RequestRecorder ( ) ; server . request ( by ( uri ( " /record " ) ) ) . response ( record ( " foo " ) ) ; server . request ( by ( uri ( " /replay " ) ) ) . response ( replay ( " foo " ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /record " ) , " foo " ) ;
@Override protected int function ( ) { return 1 + evaluator . cost ( ) ; }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; assertFalse ( deflateExtension . isClientNoContextTakeover ( ) ) ; assertTrue ( deflateExtension . isServerNoContextTakeover ( ) ) ; assertEquals ( 1024 , deflateExtension . getThreshold ( ) ) ; assertEquals ( Deflater . DEFAULT_COMPRESSION , deflateExtension . getDeflaterLevel ( ) ) ; }
public LatencyContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_NUMBER_INT ) { return LatencyContainer . latency ( arg0 . getLongValue ( ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; InternalLatencyContainer container = arg0 . readValueAs ( InternalLatencyContainer . class ) ; return container . toLatencyContainer ( ) ; } return ( LatencyContainer ) arg1 . handleUnexpectedToken ( LatencyContainer . class , arg0 ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <div><p>1<p>2<p>3 " ) ; Element body = doc . body ( ) ; AtomicInteger seenCount = new AtomicInteger ( ) ; AtomicInteger deepest = new AtomicInteger ( ) ; body . traverse ( ( node , depth ) - > { seenCount . incrementAndGet ( ) ; if ( depth > deepest . get ( ) ) deepest . set ( depth ) ; } ) ; assertEquals ( 8 , seenCount . get ( ) ) ; assertEquals ( 3 , deepest . get ( ) ) ; }
protected ID3v2TextFrameData function ( String arg0 ) { ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { ID3v2Frame frame = ( ID3v2Frame ) frameSet . getFrames ( ) . get ( 0 ) ; ID3v2TextFrameData frameData ; try { frameData = new ID3v2TextFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; return frameData ; } catch ( InvalidDataException e ) { } } return null ; }
public void function ( ) { HttpServer server = httpserver ( port ( ) ) ; server . response ( " foo " ) ; runner = Runner . runner ( server ) ; runner . start ( ) ; helper = new MocoTestHelper ( ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo " ) ) ) . response ( seq ( text ( " bar " ) , text ( " blah " ) ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ;
public static byte [ ] function ( int arg0 ) { byte [ ] bytes = new byte [ 4 ] ; packSynchsafeInteger ( arg0 , bytes , 0 ) ; return bytes ; }
protected void function ( final ChannelHandlerContext arg0 , final ByteBuf arg1 ) { final InetSocketAddress address = ( InetSocketAddress ) arg0 . channel ( ) . remoteAddress ( ) ; MessageContent content = content ( ) . withContent ( new ByteBufInputStream ( arg1 ) ) . build ( ) ; SocketRequest request = new DefaultSocketRequest ( content , new Client ( address ) ) ; SessionContext context = new SessionContext ( request , new DefaultSocketResponse ( ) ) ; Optional < Response > response = server . getResponse ( context ) ; Response actual = response . orElseThrow ( ( ) - > new MocoException ( format ( " No handler found for request: %s " , context . getRequest ( ) . getContent ( ) ) ) ) ; arg0 . write ( ByteBufs . toByteBuf ( actual . getContent ( ) . getContent ( ) ) ) ; }
public Class < ? > resolveClass ( java . io . ObjectStreamClass streamClass ) throws java . io . IOException , ClassNotFoundException { Class c = Class . forName ( streamClass . getName ( ) , false , loader ) ; if ( c = = null ) { return super . resolveClass ( streamClass ) ;
public void function ( String arg0 , Throwable arg1 ) { log ( INFO_STR , arg0 . toString ( ) , arg1 ) ; }
private void function ( int arg0 , boolean arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { if ( arg0 < MINIMUM_BUFFER_LENGTH + 1 ) throw new IllegalArgumentException ( " Buffer too small " ) ; this . arg0 = arg0 ; this . arg1 = arg1 ; try ( RandomAccessFile randomAccessFile = new RandomAccessFile ( file . getPath ( ) , " r " ) ) { initId3v1Tag ( randomAccessFile ) ;
public boolean function ( final HttpRequest arg0 ) { Optional < T > extractContent = extractor . extract ( arg0 ) ; if ( ! extractContent . isPresent ( ) ) { return false ; } T target = extractContent . get ( ) ; if ( target instanceof String ) { return predicate . apply ( ( String ) target ) ; } if ( target instanceof String [ ] ) { String [ ] contents = ( String [ ] ) target ; return any ( newArrayList ( contents ) , predicate ) ; } return false ; }
public Object function ( ) { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { try { return threadCL . loadClass ( name ) ; } catch ( ClassNotFoundException ex ) { } } try { return Class . forName ( name ) ;
public void function ( ) { server . post ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . get ( remoteUrl ( " /foo " ) ) ) ) ;
protected void function ( LoggingEvent arg0 ) { if ( logger instanceof LoggingEventAware ) { ( ( LoggingEventAware ) logger ) . log ( arg0 ) ;
public void function ( LogRecord arg0 ) { recordList . add ( arg0 ) ; }
public void function ( ) throws IOException { Document doc = Jsoup . connect ( " http://jsoup.org/rez/osi_logo.png " ) . ignoreContentType ( true ) . get ( ) ; assertEquals ( " " , doc . title ( ) ) ; }
public static ResponseHandler function ( final Resource . . . arg0 ) { checkArgument ( arg0 . length > 0 , " Sequence contents should not be null " ) ; return newSeq ( FluentIterable . from ( copyOf ( arg0 ) ) . transform ( resourceToResourceHandler ( ) ) ) ; }
public void function ( ) { assertNull ( LoggerFactory . loadExplicitlySpecified ( " com.example.ServiceProvider " ) ) ; assertThat ( mockedSyserr . toString ( ) , containsString ( " Failed to instantiate the specified SLF4JServiceProvider (com.example.ServiceProvider) " ) ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element div = doc . getElementById ( " 1 " ) ; div . appendElement ( " p " ) . text ( " there " ) ; div . appendElement ( " P " ) . attr ( " class " , " second " ) . text ( " now " ) ; assertEquals ( " <html><head></head><body><div id= \" 1 \" ><p>Hello</p><p>there</p><p class= \" second \" >now</p></div></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws ServletException , IOException { String magnitude = arg0 . getParameter ( Magnitude ) ; magnitude = magnitude = = null ? " " : magnitude ; arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " <title>Something</title> " ) ; while ( sb . length ( ) < = CharacterReaderTest . maxBufferLen ) { sb . append ( " A suitable amount of data.  \ n " ) ; } sb . append ( " <p>Finale.</p> " ) ; String data = sb . toString ( ) ; int contentLength = magnitude . equals ( Larger ) ? data . length ( ) * 2 : data . length ( ) / 2 ; arg1 . setContentLength ( contentLength ) ; arg1 . getWriter ( ) . write ( data ) ;
@Test void function ( ) { Document doc = Jsoup . parse ( " <p>One</p><p>Two <span>Three</span> <span>Four</span> " ) ; boolean threw = false ; Element p = doc . expectFirst ( " P " ) ; try { Element span = p . expectFirst ( " span.doesNotExist " ) ; } catch ( ValidationException e ) { threw = true ; assertEquals ( " No elements matched the query 'span.doesNotExist' on element 'p'. " , e . getMessage ( ) ) ; } assertTrue ( threw ) ; }
protected void function ( Elements arg0 , String . . . arg1 ) { assertEquals ( arg1 . length , arg0 . size ( ) , " Number of elements " ) ; for ( int i = 0 ; i < arg1 . length ; i + + ) { assertNotNull ( arg0 . get ( i ) ) ;
public void function ( Object arg0 , Throwable arg1 ) { differentiatedLog ( null , CATEGORY_FQCN , LocationAwareLogger . WARN_INT , arg0 , arg1 ) ; }
public static VersionResource function ( final String arg0 ) { return arg0 ( text ( arg0 ) ) ; }
public void function ( ) { new DocumentType ( " " , " " , " " ) ; }
public final void function ( final HttpUriRequest arg0 ) { final URIBuilder uriBuilder = new URIBuilder ( arg0 . getURI ( ) ) ; final DefaultHttpRequest . Builder builder = DefaultHttpRequest . builder ( ) . withVersion ( HttpProtocolVersion . versionOf ( arg0 . getProtocolVersion ( ) . toString ( ) ) ) . withUri ( toPath ( arg0 . getURI ( ) ) ) . withQueries ( asQueries ( uriBuilder . getQueryParams ( ) ) ) . withMethod ( HttpMethod . valueOf ( arg0 . getMethod ( ) . toUpperCase ( ) ) ) . withHeaders ( asHeaders ( arg0 . getAllHeaders ( ) ) ) ; if ( arg0 instanceof HttpEntityEnclosingRequest ) { final HttpEntityEnclosingRequest entityRequest = ( HttpEntityEnclosingRequest ) arg0 ; try { builder . withContent ( MessageContent . content ( ) . withContent ( entityRequest . getEntity ( ) . getContent ( ) ) . build ( ) ) ; } catch ( IOException e ) { } } logger . info ( " Action Request:{} \ n " , requestDumper . dump ( builder . build ( ) ) ) ; }
public void function ( FullHttpRequest arg0 , FullHttpResponse arg1 ) { for ( ResponseHandler handler : handlers ) { handler . writeToResponse ( arg0 , arg1 ) ;
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isErrorEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( final ResponseHandler arg0 ) { this . pong = checkNotNull ( arg0 , " Pong message should not be null " ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " cookie.json " ) ; org . apache . http . HttpResponse response = helper . getResponse ( remoteUrl ( " /cookie-with-path " ) ) ; String value = response . getFirstHeader ( HttpHeaders . SET_COOKIE ) . getValue ( ) ; Cookie decodeCookie = ClientCookieDecoder . STRICT . decode ( value ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; assertThat ( decodeCookie . path ( ) , is ( " / " ) ) ; }
public Optional < String > function ( HttpRequest arg0 ) { Optional < ImmutableMap < String , String > > params = extractor . extract ( arg0 ) ; return params . isPresent ( ) ? fromNullable ( params . get ( ) . get ( this . param ) ) : Optional . < String > absent ( ) ;
public synchronized void function ( int arg0 , String arg1 , boolean arg2 ) { if ( readyState = = ReadyState . CLOSED ) { return ; } if ( readyState = = ReadyState . OPEN ) { if ( arg0 = = CloseFrame . ABNORMAL_CLOSE ) { readyState = ReadyState . CLOSING ; } } if ( key ! = null ) { key . cancel ( ) ; } if ( channel ! = null ) { try { channel . close ( ) ; } catch ( IOException e ) { if ( e . getMessage ( ) ! = null & & e . getMessage ( ) . equals ( " Broken pipe " ) ) { log . trace ( " Caught IOException: Broken pipe during closeConnection() " , e ) ; } else { log . error ( " Exception during channel.close() " , e ) ; wsl . onWebsocketError ( this , e ) ; } } } try { this . wsl . onWebsocketClose ( this , arg0 , arg1 , arg2 ) ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; } if ( draft ! = null ) draft . reset ( ) ; handshakerequest = null ; readyState = ReadyState . CLOSED ; }
public Element function ( Node arg0 ) { Validate . notNull ( arg0 ) ; reparentChild ( arg0 ) ; ensureChildNodes ( ) ; childNodes . add ( arg0 ) ; arg0 . setSiblingIndex ( childNodes . size ( ) - 1 ) ; return this ; }
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { this . handler . writeToResponse ( arg0 , arg1 ) ; }
public ImmutableList < GlobalSetting > function ( InputStream arg0 ) { return reader . read ( arg0 , GlobalSetting . class ) ; }
public void function ( ) { ClasspathFileResourceReader reader = new ClasspathFileResourceReader ( text ( " foo.response " ) , null ) ; assertThat ( reader . readFor ( null ) . toString ( ) , is ( " foo.response " ) ) ; }
public boolean function ( String arg0 ) { if ( arg0 . startsWith ( " open " ) ) return true ; return super . isSafeTag ( arg0 ) ; }
public Builder function ( final Integer arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) throws Exception { DefaultExtension defaultExtension0 = new DefaultExtension ( ) ; DefaultExtension defaultExtension1 = new DefaultExtension ( ) ; assertEquals ( defaultExtension0 . hashCode ( ) , defaultExtension1 . hashCode ( ) ) ; }
private Option function ( ) { Option opt = new Option ( " e " , true , " environment " ) ; opt . setType ( String . class ) ; opt . setRequired ( false ) ; return opt ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${foo} ${bar} " , ImmutableMap . of ( " foo " , " ANOTHER " , " bar " , " TEMPLATE " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isInfoEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 )
public void function ( ) { locLogger . info ( Production . APPLICATION_STOPPED ) ;
protected boolean function ( final Map < String , ? > arg0 , final Map < String , ? > arg1 ) { if ( arg0 = = null | | arg0 . isEmpty ( ) ) { return true ; } return arg0 . entrySet ( ) . stream ( ) . noneMatch ( entry - > notMatchMapValue ( entry . getValue ( ) , arg1 . get ( entry . getKey ( ) ) ) ) ;
private HttpServer function ( HttpServer arg0 , HttpServer arg1 ) { ActualHttpServer thisServer = ( ActualHttpServer ) arg0 ; return thisServer . mergeHttpServer ( arg1 ) ; }
public static RestSettingBuilder function ( ) { return BaseRestSettingBuilder . all ( HttpMethod . HEAD ) ; }
public void function ( ) { String html = " <html> \ n " + "   <body> \ n " + "     <a href='#1'> \ n " + "         <div> \ n " + "           <a href='#2'>child</a> \ n " + "         </div> \ n " + "     </a> \ n " + "   </body> \ n " + " </html> " ; String s = Jsoup . parse ( html ) . toString ( ) ; assertEquals ( " <html>  \ n " + "  <head></head> \ n " +
public void function ( ) throws Exception { final String jsonContent = " { \" foo \" : \" bar \" } " ; server . request ( by ( json ( jsonContent ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public static ContentResource function ( final String arg0 , Charset arg1 ) { return fileResource ( new File ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , of ( checkNotNull ( arg1 , " Charset should not be null " ) ) ) ; }
public void function ( ) throws Exception { server . response ( cors ( allowOrigin ( " https://www.github.com " ) , allowMethods ( " * " ) ) ) ; running ( server , ( ) - > { ClassicHttpResponse response = helper . putForResponseWithHeaders ( root ( ) , " " , of ( " Origin " , " https://www.github.com " ) ) ;
public static List < Element > function ( Evaluator arg0 , Element arg1 ) { List < Element > elements = new ArrayList < Element > ( ) ; accumulateMatches ( arg0 , elements , arg1 ) ; return Collections . unmodifiableList ( elements ) ; }
private static Option function ( ) { Option opt = new Option ( " p " , true , " port " ) ; opt . setType ( Integer . class ) ; opt . setRequired ( true ) ; return opt ; }
private MocoEventAction function ( MocoConfig arg0 , ContentResource arg1 ) { Resource content = arg1 . apply ( arg0 ) ; if ( content ! = arg1 ) { return new MocoRequestAction ( this . url , this . method , of ( ( ContentResource ) content ) ) ; } return this ; }
public void function ( ServiceReference arg0 , int arg1 , String arg2 ) { switch ( arg1 ) { case LOG_DEBUG :
private TextContainer function ( final JsonParser arg0 , final TextContainer . Builder arg1 ) throws IOException { Template template = arg0 . readValueAs ( Template . class ) ; arg0 . nextToken ( ) ; return arg1 . withText ( template . with ) . withProps ( template . toTemplateVars ( ) ) . build ( ) ; }
public static byte [ ] function ( String arg0 ) { try { return arg0 . getBytes ( " UTF8 " ) ;
public T function ( final MessageContent arg0 ) { this . arg0 = arg0 ; return self ( ) ; }
@Test public void function ( ) { String h = " <div class=head><p class=first>Hello</p><p>There</p></div><p>None</p> " ; Document doc = Jsoup . parse ( h ) ; Element root = doc . getElementsByClass ( " HEAD " ) . first ( ) ; Elements els = root . select ( " .head p " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " Hello " , els . get ( 0 ) . text ( ) ) ; assertEquals ( " There " , els . get ( 1 ) . text ( ) ) ; Elements p = root . select ( " p.first " ) ; assertEquals ( 1 , p . size ( ) ) ; assertEquals ( " Hello " , p . get ( 0 ) . text ( ) ) ; Elements empty = root . select ( " p .first " ) ; assertEquals ( 0 , empty . size ( ) ) ; Elements aboveRoot = root . select ( " body div.head " ) ; assertEquals ( 0 , aboveRoot . size ( ) ) ; }
public void function ( ) { EncodedText encodedText = new EncodedText ( EncodedText . TEXT_ENCODING_UTF_16 , " " ) ; assertTrue ( Arrays . equals ( new byte [ ] { } , encodedText . toBytes ( false , false ) ) ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) 0xff , ( byte ) 0xfe } , encodedText . toBytes ( true , false ) ) ) ; assertTrue ( Arrays . equals ( new byte [ ] { 0 , 0 } , encodedText . toBytes ( false , true ) ) ) ; assertTrue ( Arrays . equals ( new byte [ ] { ( byte ) 0xff , ( byte ) 0xfe , 0 , 0 } , encodedText . toBytes ( true , true ) ) ) ; }
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; for ( Character character : queue ) { accum . append ( character ) ; } return accum . toString ( ) ; }
public void function ( WebSocket arg0 , String arg1 ) { arg0 . close ( ) ; }
private void function ( ) { service . execute ( ShutdownMocoRunnerWatcher . this : : stop ) ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " testMarker " ) ; Marker blue = MarkerFactory . getMarker ( " BLUE " ) ; logger . debug ( blue , " hello " ) ; logger . info ( blue , " hello " ) ; logger . warn ( blue , " hello " ) ; logger . error ( blue , " hello " ) ; logger . debug ( blue , " hello {} " , " world " ) ; logger . info ( blue , " hello {} " , " world " ) ; logger . warn ( blue , " hello {} " , " world " ) ; logger . error ( blue , " hello {} " , " world " ) ; logger . debug ( blue , " hello {} and {}  " , " world " , " universe " ) ; logger . info ( blue , " hello {} and {}  " , " world " , " universe " ) ; logger . warn ( blue , " hello {} and {}  " , " world " , " universe " ) ; logger . error ( blue , " hello {} and {}  " , " world " , " universe " ) ; }
public void function ( ) throws Exception { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " TAG- " ; BufferTools . stringIntoByteBuffer ( s , 1 , 2 , buffer , 0 ) ; byte [ ] expectedBuffer = { BYTE_A , BYTE_G , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; assertTrue ( Arrays . equals ( expectedBuffer , buffer ) ) ; }
public Optional < WebsocketResponse > function ( final ChannelHandlerContext arg0 , final WebSocketFrame arg1 ) { DefaultWebsocketRequest request = new DefaultWebsocketRequest ( arg1 ) ; DefaultWebsocketResponse response = new DefaultWebsocketResponse ( ) ; SessionContext context = new SessionContext ( request , response , this . group ) ; return this . getResponse ( context ) . flatMap ( this : : asWebsocketResponse ) ;
public void function ( ) throws Exception { SubstitutableLogger log = new SubstitutableLogger ( " foo " ) ; assertTrue ( log . delegate ( ) instanceof NOPLogger ) ; Set < String > expectedMethodSignatures = determineMethodSignatures ( Logger . class ) ; LoggerInvocationHandler ih = new LoggerInvocationHandler ( ) ; Logger proxyLogger = ( Logger ) Proxy . newProxyInstance ( getClass ( ) . getClassLoader ( ) , new Class [ ] { Logger . class } , ih ) ; log . setDelegate ( proxyLogger ) ; invokeMethods ( log ) ; expectedMethodSignatures . removeAll ( ih . getInvokedMethodSignatures ( ) ) ; if ( ! expectedMethodSignatures . isEmpty ( ) ) { fail ( " Following methods are not delegated  " + expectedMethodSignatures . toString ( ) ) ;
public int function ( ByteBuffer arg0 ) throws IOException { if ( ! isHandShakeComplete ( ) ) { processHandshake ( ) ; return 0 ; } int num = socketChannel . write ( wrap ( arg0 ) ) ; if ( writeEngineResult . getStatus ( ) = = SSLEngineResult . Status . CLOSED ) { throw new EOFException ( " Connection is closed " ) ; } return num ;
void function ( Token . Doctype arg0 ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( arg0 . getName ( ) ) , arg0 . getPubSysKey ( ) , arg0 . getPublicIdentifier ( ) , arg0 . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; }
@Test public void function ( ) { String h = " <html><head><script></script><noscript></noscript></head><frameset><frame src=foo></frame><frame src=foo></frameset></html> " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <html><head><script></script><noscript></noscript></head><frameset><frame src= \" foo \"  /><frame src= \" foo \"  /></frameset><body></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
public void function ( ) throws IOException { assertThat ( helper . postContent ( remoteUrl ( " /template " ) , " { \ n \ t \" code \" :1, \ n \ t \" message \" : \" message \" \ n} " ) , is ( " 1 message " ) ) ; }
public void function ( HttpRequest arg0 , FullHttpResponse arg1 ) { writeResponse ( arg1 , failoverResponse ( arg0 ) ) ; }
public String function ( ) { ensureMetaCharset ( ) ; return super . html ( ) ; }
private List < RequestMatcher > function ( final RequestSetting arg0 ) { return StreamSupport . stream ( getFields ( RequestSetting . class ) . spliterator ( ) , false ) . filter ( isValidField ( arg0 ) )
protected HttpHeader [ ] function ( MocoConfig arg0 ) { HttpHeader [ ] appliedHeaders = new HttpHeader [ this . headers . length ] ; for ( int i = 0 ; i < headers . length ; i + + ) { HttpHeader header = headers [ i ] ; Resource appliedValue = header . getValue ( ) . apply ( arg0 ) ; appliedHeaders [ i ] = new HttpHeader ( header . getName ( ) , appliedValue ) ; } return appliedHeaders ; }
public void function ( ) { final String diffPrefix = " homonym " + diff ; final String PARENT_NAME = diffPrefix + PARENT_MARKER_STR ; final String CHILD_NAME = diffPrefix + CHILD_MARKER_STR ; Marker parent = factory . getMarker ( PARENT_NAME ) ; Marker child = factory . getMarker ( CHILD_NAME ) ; parent . add ( child ) ; IMarkerFactory otherFactory = new BasicMarkerFactory ( ) ; Marker otherParent = otherFactory . getMarker ( PARENT_NAME ) ; Marker otherChild = otherFactory . getMarker ( CHILD_NAME ) ; assertTrue ( parent . contains ( otherParent ) ) ; assertTrue ( parent . contains ( otherChild ) ) ; assertTrue ( parent . remove ( otherChild ) ) ; }
public void function ( ) { BinaryFrame frame = new BinaryFrame ( ) ; assertEquals ( " Frame must extend dataframe " , true , frame instanceof DataFrame ) ; }
public void function ( String arg0 , Object arg1 ) { delegate ( ) . trace ( arg0 , arg1 ) ; }
private void function ( Object arg0 , Collection < WebSocket > arg1 ) { String sData = null ; if ( arg0 instanceof String ) { sData = ( String ) arg0 ; } ByteBuffer bData = null ; if ( arg0 instanceof ByteBuffer ) { bData = ( ByteBuffer ) arg0 ; } if ( sData = = null & & bData = = null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : arg1 ) { if ( client ! = null ) {
public void function ( ) { loggerFactory = new JDK14LoggerFactory ( ) ; markerFactory = new BasicMarkerFactory ( ) ; mdcAdapter = new BasicMDCAdapter ( ) ; }
public ServerSetting function ( ) { return this . serverSetting ; }
public static HttpServer function ( final MocoConfig . . . arg0 ) { return ActualHttpServer . createQuietServer ( Optional . < Integer > absent ( ) , arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.3.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( Level arg0 , Throwable arg1 ) { if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( CATCHING_MARKER , FQCN , arg0 . arg0 ,
public void function ( ) throws Exception { final String MOUNT_DIR = " src/test/resources/test " ; server = httpserver ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . mount ( MOUNT_DIR , to ( " /dir " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { server . response ( version ( VERSION_1_0 ) ) ; running ( server , new Runnable ( ) { @Override
public static ContentResource function ( final Resource arg0 , final Optional < Charset > arg1 ) { return fileResource ( checkNotNull ( arg0 , " Filename should not be null " ) , arg1 , null ) ; }
void function ( ) { String html = " <div>One <span>Two</span> <a href></a> Three</div> " ; Document doc = Jsoup . parse ( html ) ; Element div = doc . selectFirst ( " div " ) ; Element a = doc . selectFirst ( " a " ) ; assertNotNull ( div ) ; assertNotNull ( a ) ; TextNode first = ( TextNode ) div . firstChild ( ) ; assertEquals ( " One  " , first . text ( ) ) ; TextNode last = ( TextNode ) div . lastChild ( ) ; assertEquals ( "  Three " , last . text ( ) ) ; assertNull ( a . firstChild ( ) ) ; assertNull ( a . lastChild ( ) ) ; Element firstEl = div . firstElementChild ( ) ; assertEquals ( " span " , firstEl . tagName ( ) ) ; Element lastEl = div . lastElementChild ( ) ; assertEquals ( " a " , lastEl . tagName ( ) ) ; assertNull ( a . firstElementChild ( ) ) ; assertNull ( a . lastElementChild ( ) ) ; assertNull ( firstEl . firstElementChild ( ) ) ; assertNull ( firstEl . lastElementChild ( ) ) ; }
public void function ( ) { BundleContext context = getBundleContext ( ) ; ServiceReference ref = context . getServiceReference ( Probe . class . getName ( ) ) ; assertNotNull ( " Service Reference is null " , ref ) ; Probe probe = null ; probe = ( Probe ) context . getService ( ref ) ; assertNotNull ( " Cannot find the probe service " , probe ) ; try { probe . testCommonslogging ( ) ; fail ( " The commons logging package should not be found. Instead an exception should be thrown. " ) ; } catch ( Throwable t ) { } context . ungetService ( ref ) ;
private Mp3File function ( File arg0 , int arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { Mp3File mp3File = loadAndCheckTestMp3 ( arg0 , arg1 ) ; return loadAndCheckTestMp3WithUnicodeFields ( mp3File ) ; }
static void function ( Throwable arg0 ) { INITIALIZATION_STATE = FAILED_INITIALIZATION ; Reporter . error ( " Failed to instantiate SLF4J LoggerFactory " , arg0 ) ; }
public void function ( ) { XPathRequestExtractor unitUnderTest = new XPathRequestExtractor ( " /request/parameters/id/text() " ) ; HttpRequest request = DefaultHttpRequest . builder ( ) . withStringContent ( " " ) . build ( ) ; Optional < String [ ] > result = unitUnderTest . extract ( request ) ; assertThat ( result . isPresent ( ) , is ( false ) ) ; }
public void function ( ) { assertEquals ( " http://github.com/mpatric/mp3agic " , Version . getUrl ( ) ) ; }
public void function ( ) throws Exception { httpServer = httpServer ( 12306 , context ( " /foo " ) ) ; anotherServer = httpServer ( 12306 , context ( " /bar " ) ) ; final HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , ( ) - > assertThat ( mergedServer . port ( ) , is ( 12306 ) ) ) ; }
private boolean function ( Token arg0 , TreeBuilder arg1 ) { boolean processed = arg1 . process ( new Token . EndTag ( " colgroup " ) ) ; if ( processed ) return arg1 . process ( arg0 ) ; return true ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>One</p><script>Two</script><style>Three</style> " ) ; List < DataNode > dataNodes = doc . select ( " p, script, style " ) . dataNodes ( ) ; assertEquals ( 2 , dataNodes . size ( ) ) ; assertEquals ( " Two " , dataNodes . get ( 0 ) . getWholeData ( ) ) ; assertEquals ( " Three " , dataNodes . get ( 1 ) . getWholeData ( ) ) ; doc = Jsoup . parse ( " <head><script type=application/json><crux></script><script src=foo>Blah</script> " ) ; Elements script = doc . select ( " script[type=application/json] " ) ; List < DataNode > scriptNode = script . dataNodes ( ) ; assertEquals ( 1 , scriptNode . size ( ) ) ; DataNode dataNode = scriptNode . get ( 0 ) ; assertEquals ( " <crux> " , dataNode . getWholeData ( ) ) ; dataNode . setWholeData ( " <cromulent> " ) ; assertEquals ( " <script type= \" application/json \" ><cromulent></script> " , script . outerHtml ( ) ) ; }
public Optional < SslHandler > function ( ) { if ( this . certificate ! = null ) { return Optional . of ( asSslHandler ( certificate ) ) ; } return absent ( ) ; }
@Test public void function ( ) throws IOException { String text = new String ( Character . toChars ( 135361 ) ) ; String escapedAscii = Entities . escape ( text , new OutputSettings ( ) . charset ( " ascii " ) . escapeMode ( base ) ) ; assertEquals ( " &#x210c1; " , escapedAscii ) ; String escapedUtf = Entities . escape ( text , new OutputSettings ( ) . charset ( " UTF-8 " ) . escapeMode ( base ) ) ; assertEquals ( text , escapedUtf ) ; }
public boolean function ( ) { return logger . isLoggable ( Level . FINEST ) ; }
private HttpServer function ( final MocoHttpServer arg0 , final MocoCertificate arg1 ) { Resource resource = getResource ( arg0 ) ; int port = arg0 . port ( ) ; if ( arg1 ! = null ) { return jsonHttpsServer ( port , resource , newCertificate ( arg1 ) ) ; } return jsonHttpServer ( port , resource ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>Hello \ nthere</p> " ) ; assertEquals ( " Hello \ nthere " , doc . getWholeText ( ) ) ; doc = Jsoup . parse ( " <p>Hello   \ n  there</p> " ) ; assertEquals ( " Hello   \ n  there " , doc . getWholeText ( ) ) ; doc = Jsoup . parse ( " <p>Hello  <div> \ n  there</div></p> " ) ; assertEquals ( " Hello   \ n  there " , doc . getWholeText ( ) ) ; }
protected String function ( String arg0 ) throws NumberFormatException { String value = arg0 . trim ( ) ; if ( value . length ( ) > 0 ) { if ( value . charAt ( 0 ) = = '(' ) { int pos = value . indexOf ( ')' ) ; if ( pos > 0 ) { return value . substring ( pos + 1 ) ; } } return value ; } return null ; }
private Function < BaseSetting , BaseSetting > function ( final MocoConfig [ ] arg0 ) { return new Function < BaseSetting , BaseSetting > ( ) { @Override
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { HttpHeaders . addHeader ( arg1 , name , value ) ; }
public void function ( ) throws Exception { final HttpServer server = jsonHttpsServer ( file ( " src/test/resources/foo.json " ) , DEFAULT_CERTIFICATE ) ; running ( server , ( ) - > assertThat ( helper . get ( httpsRoot ( server . port ( ) ) ) , is ( " foo " ) ) ) ; }
private static void function ( Element arg0 , StringBuilder arg1 ) { if ( arg0 . tag . normalName ( ) . equals ( " br " ) ) arg1 . append ( " \ n " ) ;
public void function ( ) throws Exception { server . response ( binary ( new byte [ ] { 1 , 2 , 3 } ) ) ; running ( server , ( ) - > { byte [ ] asBytes = helper . getAsBytes ( root ( ) ) ;
public ActualHttpServer function ( final Optional < Integer > arg0 , final MocoConfig [ ] arg1 ) { if ( isResource ( ) ) { ActualRestServer server = new ActualRestServer ( arg0 , Optional . < HttpsCertificate > absent ( ) , log ( ) , arg1 ) ; RestSetting [ ] settings = resource . getSettings ( ) ; server . resource ( resource . getName ( ) , settings [ 0 ] , Arrays . copyOfRange ( settings , 1 , settings . length ) ) ; return server ; } ActualHttpServer server = ActualHttpServer . createLogServer ( arg0 , arg1 ) ; bindTo ( server ) ; return server ; }
public static HttpServer function ( int arg0 ) { return new HttpServer ( arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { byte [ ] buffer = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; assertArrayEquals ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , BufferTools . copyBuffer ( buffer , 0 , buffer . length ) ) ; assertArrayEquals ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } , BufferTools . copyBuffer ( buffer , 1 , buffer . length - 1 ) ) ; assertArrayEquals ( new byte [ ] { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } , BufferTools . copyBuffer ( buffer , 0 , buffer . length - 1 ) ) ; assertArrayEquals ( new byte [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } , BufferTools . copyBuffer ( buffer , 1 , buffer . length - 2 ) ) ; assertArrayEquals ( new byte [ ] { 4 } , BufferTools . copyBuffer ( buffer , 4 , 1 ) ) ; }
public HandshakeBuilder function ( Handshakedata arg0 , HandshakeBuilder arg1 ) throws InvalidHandshakeException { super . postProcessHandshakeResponseAsServer ( arg0 , arg1 ) ; String key1 = arg0 . getFieldValue ( " Sec-WebSocket-Key1 " ) ; String key2 = arg0 . getFieldValue ( " Sec-WebSocket-Key2 " ) ; byte [ ] key3 = arg0 . getContent ( ) ; if ( key1 = = null | | key2 = = null | | key3 = = null | | key3 . length ! = 8 ) { throw new InvalidHandshakeException ( " Bad keys " ) ; } arg1 . setContent ( createChallenge ( key1 , key2 , key3 ) ) ; return arg1 ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 60 ) ; }
public void function ( ) { notyetconnected = 0 ; String payload = text . getText ( ) ; long time1 = System . currentTimeMillis ( ) ; synchronized ( websockets ) { for ( WebSocketClient cl : websockets ) { try { cl . send ( payload ) ; cl . flush ( ) ; } catch ( NotYetConnectedException e ) { notyetconnected + + ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } } System . out . println ( websockets . size ( ) + " / " + notyetconnected + "  clients sent  \" " + payload + " \" " + ( System . currentTimeMillis ( ) - time1 ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; HttpResponse response = helper . getResponse ( remoteUrl ( " /composite-response " ) ) ; assertThat ( response . getCode ( ) , is ( 200 ) ) ; assertThat ( response . getFirstHeader ( " foo " ) . getValue ( ) , is ( " bar " ) ) ; }
public static RestSetting function ( final String arg0 , final RequestMatcher arg1 , final ResponseHandler . . . arg2 ) { return new PutRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , Optional . of ( arg1 ) ,
private void function ( byte [ ] arg0 , int arg1 ) { preserveTag = BufferTools . checkBit ( arg0 [ arg1 + FLAGS1_OFFSET ] , PRESERVE_TAG_BIT ) ; preserveFile = BufferTools . checkBit ( arg0 [ arg1 + FLAGS1_OFFSET ] , PRESERVE_FILE_BIT ) ; readOnly = BufferTools . checkBit ( arg0 [ arg1 + FLAGS1_OFFSET ] , READ_ONLY_BIT ) ; group = BufferTools . checkBit ( arg0 [ arg1 + FLAGS2_OFFSET ] , GROUP_BIT ) ; compression = BufferTools . checkBit ( arg0 [ arg1 + FLAGS2_OFFSET ] , COMPRESSION_BIT ) ; encryption = BufferTools . checkBit ( arg0 [ arg1 + FLAGS2_OFFSET ] , ENCRYPTION_BIT ) ; unsynchronisation = BufferTools . checkBit ( arg0 [ arg1 + FLAGS2_OFFSET ] , UNSYNCHRONISATION_BIT ) ; dataLengthIndicator = BufferTools . checkBit ( arg0 [ arg1 + FLAGS2_OFFSET ] , DATA_LENGTH_INDICATOR_BIT ) ; }
private void function ( Class < ? extends Throwable > arg0 , int arg1 ) { LogRecord logRecord = listHandler . recordList . get ( arg1 ) ; Assert . assertNotNull ( logRecord ) ; assertEquals ( arg0 , logRecord . getThrown ( ) . getClass ( ) ) ; }
public Request function ( int arg0 ) { Validate . isTrue ( arg0 > = 0 , " Timeout milliseconds must be 0 (infinite) or greater " ) ; timeoutMilliseconds = arg0 ; return this ; }
public static Failover function ( final String arg0 ) { return new DefaultFailover ( new File ( arg0 ) ) ; }
private ImmutableMap < String , Object > function ( final SessionContext arg0 ) { return ImmutableMap . < String , Object > builder ( ) . putAll ( toVariableString ( arg0 . getRequest ( ) ) )
private Setting function ( final HttpMethod arg0 , final RequestMatcher arg1 ) { return request ( and ( by ( arg0 ( arg0 . name ( ) ) ) , arg1 ) ) ; }
public void function ( ) { logger . trace ( message , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . TRACE , null , exception ) ; }
public void function ( ) throws Exception { final PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; server . response ( Moco . json ( pojo ) ) ; running ( server , new Runnable ( ) { @Override
public final Optional < InputSource > function ( final Request arg0 , final ContentRequestExtractor arg1 ) { Optional < MessageContent > content = arg1 . extract ( arg0 ) ; if ( content . isPresent ( ) ) { return of ( new InputSource ( new ByteArrayInputStream ( content . get ( ) . getContent ( ) ) ) ) ; } return absent ( ) ; }
@Test public void function ( ) { CharacterReader r = new CharacterReader ( " Check \ tCheck \ tCheck \ tCHOKE \ tA string that is longer than 16 chars " ) ; String one = r . consumeTo ( '\t' ) ; r . consume ( ) ; String two = r . consumeTo ( '\t' ) ; r . consume ( ) ; String three = r . consumeTo ( '\t' ) ; r . consume ( ) ; String four = r . consumeTo ( '\t' ) ; r . consume ( ) ; String five = r . consumeTo ( '\t' ) ; assertEquals ( " Check " , one ) ; assertEquals ( " Check " , two ) ; assertEquals ( " Check " , three ) ; assertEquals ( " CHOKE " , four ) ; assertSame ( one , two ) ; assertSame ( two , three ) ; assertNotSame ( three , four ) ; assertNotSame ( four , five ) ; assertEquals ( five , " A string that is longer than 16 chars " ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.5.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { InputStream stream = SettingRunnerTest . class . getClassLoader ( ) . getResourceAsStream ( " multiple/fileroot-settings.json " ) ; runner = new SettingRunner ( stream , 12306 ) ; runner . run ( ) ; assertThat ( helper . get ( remoteUrl ( " /fileroot/fileroot " ) ) , is ( " foo.response " ) ) ; }
public final HttpArgs function ( ) { return new HttpArgs ( port , shutdownPort , configurationFile , settings , env , quiet , contentLength ) ; }
public static RestServer function ( final int arg0 , final MocoConfig . . . arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; checkNotNull ( arg1 , " Config should not be null " ) ; return new ActualRestServer ( of ( arg0 ) , Optional . < HttpsCertificate > absent ( ) , new QuietMonitor ( ) , arg1 ) ; }
private Mp3File function ( Mp3File arg0 ) { assertEquals ( 0x000 , arg0 . getXingOffset ( ) ) ; assertEquals ( 0x1A1 , arg0 . getStartOffset ( ) ) ; assertEquals ( 0xB34 , arg0 . getEndOffset ( ) ) ; assertFalse ( arg0 . hasId3v1Tag ( ) ) ; assertFalse ( arg0 . hasId3v2Tag ( ) ) ; assertFalse ( arg0 . hasCustomTag ( ) ) ; return arg0 ; }
@Test public void function ( ) { String q = " #parent [class*=child], .some-other-selector .nested " ; String parsed = sexpr ( q ) ; assertEquals ( " (Or (And (AttributeWithValueContaining '[class*=child]')(Ancestor (Id '#parent')))(And (Class '.nested')(Ancestor (Class '.some-other-selector')))) " , parsed ) ; assertEquals ( " (Or (Class '.some-other-selector')(And (AttributeWithValueContaining '[class*=child]')(Ancestor (Id '#parent')))) " , sexpr ( " #parent [class*=child], .some-other-selector " ) ) ; assertEquals ( " (Or (And (Id '#el')(AttributeWithValueContaining '[class*=child]'))(Class '.some-other-selector')) " , sexpr ( " #el[class*=child], .some-other-selector " ) ) ; assertEquals ( " (Or (And (AttributeWithValueContaining '[class*=child]')(Ancestor (Id '#parent')))(And (Class '.nested')(Ancestor (Class '.some-other-selector')))) " , sexpr ( " #parent [class*=child], .some-other-selector .nested " ) ) ; }
public static UrlResource function ( final String arg0 ) { return new UrlResource ( toUrl ( arg0 ) ) ; }
int [ ] function ( int [ ] arg0 ) { ArrayList < Integer > primesArray = new ArrayList < Integer > ( ) ; for ( int i = 0 ; i < originalArrrayLength ; i + + ) { int n = arg0 [ i ] ; if ( isPrime ( n ) ) { primesArray . add ( n ) ; } } int resultSize = primesArray . size ( ) ; int [ ] result = new int [ resultSize ] ; for ( int i = 0 ; i < resultSize ; i + + ) { result [ i ] = primesArray . get ( i ) ; } return result ; }
public void function ( ) throws Exception { Mp3File mp3File = new Mp3File ( new File ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ) ) ; testShouldThrowExceptionIfSavingMp3WithSameNameAsSourceFile ( mp3File ) ; }
public String function ( ) { return normaliseWhitespace ( getWholeText ( ) ) ; }
public void function ( ) { DefaultWebSocketServerFactory webSocketServerFactory = new DefaultWebSocketServerFactory ( ) ; CustomWebSocketAdapter webSocketAdapter = new CustomWebSocketAdapter ( ) ; WebSocketImpl webSocketImpl = webSocketServerFactory . createWebSocket ( webSocketAdapter , new Draft_6455 ( ) ) ; assertNotNull ( " webSocketImpl != null " , webSocketImpl ) ; webSocketImpl = webSocketServerFactory . createWebSocket ( webSocketAdapter , Collections . < Draft > singletonList ( new Draft_6455 ( ) ) ) ; assertNotNull ( " webSocketImpl != null " , webSocketImpl ) ; }
public Connection function ( String arg0 , int arg1 ) { req . proxy ( arg0 , arg1 ) ; return this ; }
public void function ( String arg0 , Throwable arg1 ) { recordEvent_0Args ( Level . DEBUG , null , arg0 , arg1 ) ; }
public void function ( ) { assertEquals ( " import org.slf4j.LoggerFactory; " , log4jConverter . getReplacement ( " import org.apache.log4j.LogManager; " ) ) ; assertEquals ( " import org.slf4j.Logger; " , log4jConverter . getReplacement ( " import org.apache.log4j.Logger; " ) ) ;
public boolean function ( HttpRequest arg0 ) { return this . matcher . match ( arg0 ) ; }
public void function ( ) throws NoSuchAlgorithmException { try { new SSLParametersWebSocketServerFactory ( null , null ) ; fail ( " IllegalArgumentException should be thrown " ) ; } catch ( IllegalArgumentException e ) { } try { new SSLParametersWebSocketServerFactory ( SSLContext . getDefault ( ) , null ) ; fail ( " IllegalArgumentException should be thrown " ) ; } catch ( IllegalArgumentException e ) { } try { new SSLParametersWebSocketServerFactory ( SSLContext . getDefault ( ) , new SSLParameters ( ) ) ; } catch ( IllegalArgumentException e ) { fail ( " IllegalArgumentException should not be thrown " ) ; } try { new SSLParametersWebSocketServerFactory ( SSLContext . getDefault ( ) , Executors . newCachedThreadPool ( ) , new SSLParameters ( ) ) ;
public void function ( ) throws Exception { final File response = File . createTempFile ( " response " , " .tmp " ) ; changeFileContent ( response , " foo " ) ; server . response ( file ( response . getAbsolutePath ( ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( HttpResponse arg0 ) { try { Response dumpedResponse = mapper . readValue ( this . file , Response . class ) ;
public ResponseSetting function ( final String arg0 ) { this . response ( status ( HttpResponseStatus . FOUND . code ( ) ) , header ( " Location " , checkNotNullOrEmpty ( arg0 , " URL should not be null " ) ) ) ; return this ; }
private void function ( File arg0 , String arg1 ) throws FileNotFoundException { PrintStream stream = new PrintStream ( new FileOutputStream ( arg0 ) ) ; stream . print ( arg1 ) ; }
public void function ( Priority arg0 , Object arg1 ) { int levelInt = priorityToLevelInt ( arg0 ) ; differentiatedLog ( null , CATEGORY_FQCN , levelInt , arg1 , null ) ; }
public static boolean function ( final String arg0 ) { return base . codepointForName ( arg0 ) ! = empty ; }
public void function ( ) { ByteBuffer source = ByteBuffer . wrap ( smallArray ) ; try { ByteBufferUtils . transferByteBuffer ( source , null ) ;
void function ( TokeniserState arg0 ) { if ( errors . canAddError ( ) ) errors . add ( new ParseError ( reader , " Unexpected character '%s' in input state [%s] " , reader . current ( ) , arg0 ) ) ;
private void function ( final ChannelHandlerContext arg0 , final FullHttpRequest arg1 ) { if ( ! arg1 . decoderResult ( ) . isSuccess ( ) | | ! upgradeWebsocket ( arg1 ) ) { FullHttpResponse response = handleRequest ( arg1 ) ; closeIfNotKeepAlive ( arg1 , arg0 . write ( response ) ) ; return ; } handleWebsocketRequest ( arg0 , arg1 ) ; }
public static ResponseHandler function ( final ProxyConfig arg0 , final Failover arg1 , final int . . . arg2 ) { return new ProxyBatchResponseHandler ( checkNotNull ( arg0 ) , checkNotNull ( arg1 ) , checkNotNull ( arg2 , " Proxy status should not be null " ) ) ;
public static Document function ( File arg0 , String arg1 , String arg2 ) throws IOException { return parseInputStream ( new FileInputStream ( arg0 ) , arg1 , arg2 , Parser . htmlParser ( ) ) ; }
public void function ( ) throws Exception { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_UTF_16 , TEST_DESCRIPTION_UNICODE ) , TEST_URL ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 1 , ( byte ) 0xff , ( byte ) 0xfe , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac , 0x03 , 0 , 0 , 'h' , 't' , 't' , 'p' , ':' , '/' , '/' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' } ; assertTrue ( Arrays . equals ( expectedBytes , bytes ) ) ; ID3v2UrlFrameData frameDataCopy = new ID3v2UrlFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
public boolean function ( Element arg0 , Element arg1 ) { if ( arg1 instanceof PseudoTextElement ) return true ; List < TextNode > textNodes = arg1 . textNodes ( ) ; for ( TextNode textNode : textNodes ) { PseudoTextElement pel = new PseudoTextElement ( org . jsoup . parser . Tag . valueOf ( arg1 . tagName ( ) ) , arg1 . baseUri ( ) , arg1 . attributes ( ) ) ; textNode . replaceWith ( pel ) ; pel . appendChild ( textNode ) ; } return false ; }
private static String function ( final HttpMessage arg0 ) { String type = arg0 . getHeader ( HttpHeaders . CONTENT_TYPE ) ; if ( isText ( type ) ) { return arg0 . getContent ( ) . toString ( ) ; } return " <content is binary> " ; }
protected String function ( String arg0 ) { int bsPos = arg0 . lastIndexOf ( '\\' ) ; int fsPos = arg0 . lastIndexOf ( '/' ) ; if ( bsPos > = 0 | | fsPos > = 0 ) { if ( fsPos = = - 1 | | bsPos > fsPos ) { return arg0 . substring ( 0 , bsPos + 1 ) ; } return arg0 . substring ( 0 , fsPos + 1 ) ; } return " " ; }
public void function ( ) { System . setProperty ( LoggerFactory . BINDING_PROP , " java.lang.String " ) ; assertNull ( LoggerFactory . loadExplicitlySpecified ( classLoaderOfLoggerFactory ) ) ; assertTrue ( mockedSyserr . toString ( ) . contains ( " Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface " ) ) ; }
public void function ( ) throws Exception { httpServer = httpsServer ( 12306 , DEFAULT_CERTIFICATE , context ( " /foo " ) ) ; httpServer . response ( " foo " ) ; anotherServer = httpsServer ( 12306 , DEFAULT_CERTIFICATE , context ( " /bar " ) ) ; anotherServer . request ( by ( uri ( " /bar " ) ) ) . response ( " bar " ) ; HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeHttpServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public void function ( ) { String h = " <div id=1><div id=2><div id = 3></div></div></div><div id=4></div> " ; Document doc = Jsoup . parse ( h ) ; Elements divs = SelectMatch . match ( doc , Parser . parse ( " div > div " ) ) ; assertEquals ( 2 , divs . size ( ) ) ; assertEquals ( " 2 " , divs . get ( 0 ) . id ( ) ) ; assertEquals ( " 3 " , divs . get ( 1 ) . id ( ) ) ; Elements div2 = SelectMatch . match ( doc , Parser . parse ( " div#1 > div " ) ) ; assertEquals ( 1 , div2 . size ( ) ) ; assertEquals ( " 2 " , div2 . get ( 0 ) . id ( ) ) ; }
public Element function ( ) { List < Element > siblings = parent ( ) . childElementsList ( ) ; return siblings . size ( ) > 1 ? siblings . get ( siblings . size ( ) - 1 ) : null ; }
private Runner function ( StartArgs arg0 ) { final File configuration = new File ( arg0 . getConfigurationFile ( ) ) ; final FileRunner fileRunner = new ConfigurationFileRunner ( configuration , arg0 . getPort ( ) ) ; Monitor fileMonitor = new FileMonitor ( configuration , createListener ( fileRunner ) ) ; return new MonitorRunner ( fileRunner , fileMonitor ) ; }
public MessageContent function ( final Optional < ? extends Request > arg0 ) { if ( ! arg0 . isPresent ( ) ) { throw new IllegalStateException ( " Request is required to render template " ) ; } MessageContent content = this . template . readFor ( arg0 ) ; try { Template targetTemplate = createTemplate ( content ) ;
public static SocketServer function ( final int arg0 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualSocketServer . createQuietServer ( arg0 ) ; }
public boolean function ( ) { return isLevelEnabled ( LOG_LEVEL_INFO ) ; }
Element function ( Token . StartTag arg0 ) { Tag tag = tagFor ( arg0 . name ( ) , settings ) ; if ( arg0 . hasAttributes ( ) ) arg0 . attributes . deduplicate ( settings ) ; Element el = new Element ( tag , null , settings . normalizeAttributes ( arg0 . attributes ) ) ; insertNode ( el , arg0 ) ; if ( arg0 . isSelfClosing ( ) ) { tag . setSelfClosing ( ) ; } else { stack . add ( el ) ; } return el ; }
public boolean function ( Marker arg0 ) { return logger . isWarnEnabled ( arg0 ) ; }
protected boolean function ( String arg0 ) { return expected . equals ( arg0 ) ; }
private @Nullable Map . Entry < String , List < String > > function ( String arg0 ) { String lc = lowerCase ( arg0 ) ; for ( Map . Entry < String , List < String > > entry : headers . entrySet ( ) ) { if ( lowerCase ( entry . getKey ( ) ) . equals ( lc ) ) return entry ; } return null ; }
public HttpServer function ( ActualHttpServer arg0 ) { ActualHttpServer newServer = createBaseServer ( this ) ; newServer . addSettings ( this . getSettings ( ) ) ; newServer . addSettings ( arg0 . getSettings ( ) ) ; newServer . anySetting ( configItem ( this . matcher , this . configs ) , configItem ( this . handler , this . configs ) ) ; newServer . anySetting ( configItem ( arg0 . matcher , arg0 . configs ) , configItem ( arg0 . handler , arg0 . configs ) ) ; newServer . addEvents ( this . eventTriggers ) ; newServer . addEvents ( arg0 . eventTriggers ) ; return newServer ; }
public final int function ( ) { return Objects . hashCode ( name ) ; }
protected final Option function ( ) { Option option = new Option ( null , " https " , true , " Https certificate filename " ) ; option . setType ( String . class ) ; option . setRequired ( false ) ; return option ; }
void function ( Evaluator arg0 ) { s . push ( arg0 ) ; }
public static void function ( String [ ] arg0 ) throws URISyntaxException { Draft_6455 draft_ocppOnly = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " ocpp2.0 " ) ) ) ; ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " ocpp2.0 " ) ) ; protocols . add ( new Protocol ( " " ) ) ; Draft_6455 draft_ocppAndFallBack = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ; ExampleClient c = new ExampleClient ( new URI ( " ws://echo.websocket.org " ) , draft_ocppAndFallBack ) ; c . connect ( ) ; }
public MocoRunnerWatcher function ( final File arg0 , final Iterable < File > arg1 , final FileRunner arg2 ) { ImmutableList < File > files = ImmutableList . < File > builder ( ) . add ( arg0 ) . addAll ( arg1 ) . build ( ) ; return factory . createWatcher ( arg2 , files . toArray ( new File [ 0 ] ) ) ; }
protected RequestMatcher function ( final Resource arg0 , final ContentRequestExtractor arg1 ) { return new XmlStructRequestMatcher ( arg0 , arg1 ) ; }
private ByteBuffer function ( ByteBuffer arg0 ) { return enlargeBuffer ( arg0 , engine . getSession ( ) . getPacketBufferSize ( ) ) ; }
private static void function ( Set arg0 ) { if ( isAmbiguousStaticLoggerBinderPathSet ( arg0 ) ) { Util . report ( " Class path contains multiple SLF4J bindings. " ) ;
public static void function ( String arg0 , Object . . . arg1 ) { throw new ValidationException ( String . format ( arg0 , arg1 ) ) ; }
public FullHttpRequest function ( ) { ByteBuf buffer = Unpooled . buffer ( ) ; MessageContent content = getContent ( ) ; if ( content ! = null ) { buffer . writeBytes ( content . getContent ( ) ) ; } QueryStringEncoder encoder = new QueryStringEncoder ( uri ) ; for ( Map . Entry < String , String [ ] > entry : queries . entrySet ( ) ) { String [ ] values = entry . getValue ( ) ; for ( String value : values ) { encoder . addParam ( entry . getKey ( ) , value ) ; } } FullHttpRequest request = new DefaultFullHttpRequest ( HttpVersion . valueOf ( getVersion ( ) . text ( ) ) , io . netty . handler . codec . http . HttpMethod . valueOf ( method . name ( ) ) , encoder . toString ( ) , buffer ) ; for ( Map . Entry < String , String > entry : getHeaders ( ) . entrySet ( ) ) { request . headers ( ) . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return request ; }
public void function ( Priority arg0 , Object arg1 , Throwable arg2 ) { int levelInt = priorityToLevelInt ( arg0 ) ; differentiatedLog ( null , CATEGORY_FQCN , levelInt , arg1 , arg2 ) ;
public String function ( String arg0 ) { Validate . notNull ( arg0 ) ; if ( attributes . hasKey ( arg0 ) ) return attributes . get ( arg0 ) ;
void function ( StringBuilder arg0 , Throwable arg1 ) { PrintStream targetStream = CONFIG_PARAMS . outputChoice . getTargetPrintStream ( ) ; try { lock . tryLock ( MAX_TRY_LOCK_DURATION , TimeUnit . MILLISECONDS ) ;
public void function ( ) { Logger logger = LoggerFactory . getLogger ( NoBindingTest . class ) ; logger . debug ( " hello " + diff ) ; assertTrue ( logger instanceof NOPLogger ) ; }
public void function ( ) throws Exception { server . resource ( " targets " , delete ( " 1 " , status ( 200 ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { List < Plain > plains = mapper . readValue ( helper . get ( remoteUrl ( " /targets?foo=bar " ) ) , new TypeReference < List < Plain > > ( ) { } ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; HttpResponse response = helper . getResponse ( remoteUrl ( " /targets " ) ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 404 ) ) ; }
@Test public void function ( ) { StringBuilder sb = new StringBuilder ( BufferSize ) ; do { sb . append ( " A Large Amount of Text " ) ; } while ( sb . length ( ) < BufferSize ) ; String text = sb . toString ( ) ; String html = " <p> " + text + " </p> " ; Document doc = Jsoup . parse ( html ) ; Elements els = doc . select ( " p " ) ; assertEquals ( 1 , els . size ( ) ) ; Element el = els . first ( ) ; assertNotNull ( el ) ; assertEquals ( text , el . text ( ) ) ; }
private File function ( ) { File fileSource = new File ( source ) ; if ( ! fileSource . isDirectory ( ) ) { logger . info ( " source path is not a valid source directory " ) ; } return fileSource ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public static RequestExtractor < String > function ( final String arg0 ) { if ( extractors . containsKey ( arg0 ) ) { return extractors . get ( arg0 ) ; } throw new IllegalArgumentException ( format ( " unknown extractor for [%s] " , arg0 ) ) ; }
@Test public void function ( ) throws IOException { Document doc = Jsoup . connect ( SlowRider . Url ) . data ( SlowRider . MaxTimeParam , " 2000 " ) . get ( ) ; Element h1 = doc . selectFirst ( " h1 " ) ; assertEquals ( " outatime " , h1 . text ( ) ) ; }
public void function ( ) throws Exception { String filename = MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ; String saveFilename = filename + " .copy " ; try { Mp3File mp3File = new Mp3File ( filename ) ;
public void function ( ) throws CertificateException , UnrecoverableKeyException , NoSuchAlgorithmException , KeyManagementException , KeyStoreException , IOException , URISyntaxException , InterruptedException { SSLWebSocketClient client = testIssueWithLocalServer ( " 127.0.0.1 " , SocketUtil . getAvailablePort ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , null ) ; assertFalse ( client . onOpen ) ; assertTrue ( client . onSSLError ) ; }
public void function ( ) { SimpleLogger . init ( ) ; SimpleLogger simpleLogger = new SimpleLogger ( " a " ) ; assertEquals ( " info " , simpleLogger . recursivelyComputeLevelString ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private void function ( ) { tq . consume ( " :not " ) ; String subQuery = tq . chompBalanced ( '(' , ')' ) ; Validate . notEmpty ( subQuery , " :not(selector) subselect must not be empty " ) ;
private SocketServer function ( Iterable < ? extends RunnerSetting > arg0 , StartArgs arg1 ) { SocketServer socketServer = ActualSocketServer . createLogServer ( arg1 . getPort ( ) ) ; for ( RunnerSetting setting : arg0 ) { SocketServer parsedServer = socketParser . parseServer ( setting . getStream ( ) , arg1 . getPort ( ) , toConfigs ( setting ) ) ; socketServer = mergeServer ( socketServer , parsedServer ) ; } return socketServer ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { arg1 . setStatus ( status . code ( ) ) ; }
public void function ( ) { check ( html . select ( " #pseudo :first-child " ) , " 1 " ) ; check ( html . select ( " html:first-child " ) ) ; }
public static < T > ContentResource function ( final ContentResource arg0 , final String arg1 , final RequestExtractor < T > arg2 ) { return templateResource ( checkNotNull ( arg0 , " Template should not be null " ) , ImmutableMap . of ( checkValidVariableName ( arg1 ) ,
public void function ( String arg0 , Throwable arg1 ) { logger . log ( FQCN , Level . WARN , arg0 , arg1 ) ; }
public void function ( ) throws Exception { SLF4JBridgeHandler . uninstall ( ) ; fileAppender . close ( ) ; log4jRoot . getLoggerRepository ( ) . resetConfiguration ( ) ; for ( Handler existingHandler : existingHandlers ) { julRootLogger . addHandler ( existingHandler ) ;
public void function ( ) { loggerFactory = new Reload4jLoggerFactory ( ) ; markerFactory = new BasicMarkerFactory ( ) ; mdcAdapter = new Reload4jMDCAdapter ( ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { if ( ! logger . isDebugEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { FormattingTuple ft = MessageFormatter . arg1 ( arg1 , arg2 ) ;
private HttpResponseSetting function ( final HttpMethod arg0 , final RequestMatcher arg1 ) { return request ( and ( by ( arg0 ( arg0 ) ) , arg1 ) ) ; }
public void function ( ) throws IOException { InputStream is = Resources . getResource ( " foo.response " ) . openStream ( ) ; server . request ( by ( uri ( " /foo " ) ) ) . response ( stream ( is ) ) ; running ( server , new Runnable ( ) { @Override
public WebSocketImpl function ( WebSocketAdapter arg0 , Draft arg1 , Socket arg2 ) { return new WebSocketImpl ( arg0 , arg1 ) ; }
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_FF , 0 , 2 , 3 , 4 , BYTE_FF , 0 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , BYTE_FF , 0 } ; byte [ ] expectedBuffer = { BYTE_FF , 0 , 0 , 2 , 3 , 4 , BYTE_FF , 0 , 0 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , BYTE_FF , 0 , 0 } ; byte [ ] unsynchronised = BufferTools . unsynchroniseBuffer ( buffer ) ; byte [ ] synchronised = BufferTools . synchroniseBuffer ( unsynchronised ) ; assertTrue ( Arrays . equals ( expectedBuffer , unsynchronised ) ) ; assertTrue ( Arrays . equals ( buffer , synchronised ) ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 )
public void function ( ) throws IOException { Connection con = Jsoup . connect ( echoUrl + " ?what=the " ) . userAgent ( " Mozilla " ) . referrer ( " http://example.com " ) . data ( " what " , " about & me? " ) ; Document doc = con . get ( ) ; assertEquals ( " what=the&what=about+%26+me%3F " , ihVal ( " Query String " , doc ) ) ; assertEquals ( " the, about & me? " , ihVal ( " what " , doc ) ) ; assertEquals ( " Mozilla " , ihVal ( " User-Agent " , doc ) ) ; assertEquals ( " http://example.com " , ihVal ( " Referer " , doc ) ) ; }
public void function ( ) throws Exception { byte [ ] buffer = BufferTools . stringToByteBuffer ( VALID_TAG , 0 , VALID_TAG . length ( ) ) ; buffer [ buffer . length - 1 ] = - 0x73 ; ID3v1Tag id3v1tag = new ID3v1Tag ( buffer ) ; assertEquals ( " TITLE1234567890123456789012345 " , id3v1tag . getTitle ( ) ) ; assertEquals ( " ARTIST123456789012345678901234 " , id3v1tag . getArtist ( ) ) ; assertEquals ( " ALBUM1234567890123456789012345 " , id3v1tag . getAlbum ( ) ) ; assertEquals ( " 2001 " , id3v1tag . getYear ( ) ) ; assertEquals ( " COMMENT12345678901234567890123 " , id3v1tag . getComment ( ) ) ; assertEquals ( null , id3v1tag . getTrack ( ) ) ; assertEquals ( 0x8D , id3v1tag . getGenre ( ) ) ; assertEquals ( " Synthpop " , id3v1tag . getGenreDescription ( ) ) ; }
private Resource function ( ContentResource arg0 ) { if ( with ! = null ) { return cache ( arg0 , with ( with . retrieveResource ( ) ) ) ; } return cache ( arg0 ) ; }
@Override public boolean function ( Element arg0 , Element arg1 ) { it . restart ( arg1 ) ; while ( it . hasNext ( ) ) { Element el = it . next ( ) ; if ( el = = arg1 ) continue ; if ( evaluator . matches ( arg1 , el ) ) return true ; } return false ; }
public final void function ( WebSocket arg0 , int arg1 , String arg2 , boolean arg3 ) { if ( writeThread ! = null & & writeThread . get ( ) ! = null ) writeThread . get ( ) . interrupt ( ) ; if ( readThread ! = null & & readThread . get ( ) ! = null ) readThread . get ( ) . interrupt ( ) ; try { if ( socket ! = null ) socket . close ( ) ; } catch ( IOException e ) { onWebsocketError ( this , e ) ; } onClose ( arg1 , arg2 , arg3 ) ; connectLatch . countDown ( ) ; closeLatch . countDown ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.4.4 " ) ; assertEquals ( " NON-STRICT " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 2100 ) ; }
void function ( ) { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( " WTF: No buffer left to unconsume. " ) ) ; bufPos - - ; }
public void function ( ) throws IOException { runWithConiguration ( " foo.json " ) ; assertThat ( helper . postContent ( " http://localhost:8080 " , " text_request " ) , is ( " response_for_text_request " ) ) ; }
public void function ( ) { if ( selectorthread ! = null ) throw new IllegalStateException ( " This instance of  " + getClass ( ) . getSimpleName ( ) + "  can only be started once the same time. " ) ; selectorthread = Thread . currentThread ( ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; server . socket ( ) . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; } catch ( IOException ex ) { onWebsocketError ( null , ex ) ; return ; } try { while ( ! selectorthread . isInterrupted ( ) ) {
public boolean function ( Handshakedata arg0 , Handshakedata arg1 ) throws InvalidHandshakeException { String seckey_challenge = arg0 . getFieldValue ( " Sec-WebSocket-Key " ) ; if ( seckey_challenge = = null ) throw new InvalidHandshakeException ( " missing Sec-WebSocket-Key " ) ; String seckey_answere = arg0 . getFieldValue ( " Sec-WebSocket-Key " ) ; if ( seckey_answere = = null ) throw new InvalidHandshakeException ( " missing Sec-WebSocket-Key " ) ; if ( generateFinalKey ( seckey_challenge ) . equals ( generateFinalKey ( seckey_answere ) ) ) return true ; return false ; }
public void function ( ) { for ( Level level : Level . values ( ) ) { threeParameterCheck ( level ) ;
public void function ( ) { Document doc = Jsoup . parse ( " <!-- a simple comment --> " ) ; doc . outputSettings ( ) . prettyPrint ( false ) ; assertEquals ( " <!-- a simple comment --><html><head></head><body></body></html> " , doc . html ( ) ) ; Node node = doc . childNode ( 0 ) ; Comment c1 = ( Comment ) node ; assertEquals ( " <!-- a simple comment --> " , c1 . outerHtml ( ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { slf4jLogger . warn ( convertToString ( arg0 ) , arg1 ) ; }
public final ResponseSetting function ( ) { ResponseSetting responseSetting = new ResponseSetting ( ) ; responseSetting . text = text ; responseSetting . file = file ; responseSetting . pathResource = pathResource ; responseSetting . status = status ; responseSetting . proxy = proxy ; responseSetting . headers = headers ; responseSetting . cookies = cookies ; responseSetting . latency = latency ; responseSetting . version = version ; responseSetting . json = json ; responseSetting . attachment = attachment ; responseSetting . seq = seq ; responseSetting . cycle = cycle ; return responseSetting ; }
public String function ( ) { return String . format ( " %s|* " , tagName ) ; }
protected RestSetting function ( final Optional < RequestMatcher > arg0 , final ResponseHandler arg1 ) { return new GetSingleRestSetting ( id , arg0 , arg1 ) ; }
@Test public void function ( ) { String cdataStart = " <![CDATA[ " ; String cdataEnd = " ]]> " ; int bufLen = maxBufferLen - cdataStart . length ( ) - 1 ; char [ ] cdataContentsArray = new char [ bufLen ] ; Arrays . fill ( cdataContentsArray , 'x' ) ; String cdataContents = new String ( cdataContentsArray ) ; String testMarkup = cdataStart + cdataContents + cdataEnd ; Parser parser = new Parser ( new HtmlTreeBuilder ( ) ) ; Document doc = parser . parseInput ( testMarkup , " " ) ; Node cdataNode = doc . body ( ) . childNode ( 0 ) ; assertTrue ( cdataNode instanceof CDataNode , " Expected CDATA node " ) ; assertEquals ( cdataContents , ( ( CDataNode ) cdataNode ) . text ( ) ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . request ( exist ( header ( " blah " ) ) ) . response ( " header " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . getWithHeader ( root ( ) , of ( " blah " , " any " ) ) ) ) ;
@Test public void function ( ) { String h = " <body><p>Hello</body><p>there</p></body></body></html><p>now " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( 3 , doc . select ( " p " ) . size ( ) ) ; assertEquals ( 3 , doc . getBody ( ) . children ( ) . size ( ) ) ; }
public static MocoEventAction function ( final Resource arg0 , final ContentResource arg1 , final HttpHeader arg2 , final HttpHeader . . . arg3 ) { Iterable < HttpHeader > httpHeaders = asIterable ( checkNotNull ( arg2 , " Header should not be null " ) , checkNotNull ( arg3 , " Header should not be null " ) ) ; return new MocoPostRequestAction ( checkNotNull ( arg0 , " URL should not be null " ) , checkNotNull ( arg1 , " Content should not be null " ) , toHeaders ( httpHeaders ) ) ;
private void function ( ) { int size = oqueue . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { WebSocketImpl conn = oqueue . remove ( ) ;
public void function ( ) { FramedataImpl1 binary = FramedataImpl1 . get ( Opcode . BINARY ) ; assertInstanceOf ( BinaryFrame . class , binary , " Frame must be binary " ) ; FramedataImpl1 text = FramedataImpl1 . get ( Opcode . TEXT ) ; assertInstanceOf ( TextFrame . class , text , " Frame must be text " ) ; FramedataImpl1 closing = FramedataImpl1 . get ( Opcode . CLOSING ) ; assertInstanceOf ( CloseFrame . class , closing , " Frame must be closing " ) ; FramedataImpl1 continuous = FramedataImpl1 . get ( Opcode . CONTINUOUS ) ; assertInstanceOf ( ContinuousFrame . class , continuous , " Frame must be continuous " ) ; FramedataImpl1 ping = FramedataImpl1 . get ( Opcode . PING ) ; assertInstanceOf ( PingFrame . class , ping , " Frame must be ping " ) ; FramedataImpl1 pong = FramedataImpl1 . get ( Opcode . PONG ) ; assertInstanceOf ( PongFrame . class , pong , " Frame must be pong " ) ; try { FramedataImpl1 . get ( null ) ;
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; org . apache . http . HttpResponse httpResponse = helper . headForResponse ( remoteUrl ( " /targets/1 " ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; assertThat ( httpResponse . getHeaders ( " ETag " ) [ 0 ] . getValue ( ) , is ( " Moco " ) ) ; }
public void function ( Object arg0 ) { log ( INFO_STR , arg0 . toString ( ) , null ) ; }
public void function ( ) { assertNull ( mdc . get ( " testKey " ) ) ; mdc . put ( " testKey " , " testValue " ) ; assertEquals ( mdc . get ( " testKey " ) , " testValue " ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 70 ) ; }
public void function ( ) { logger . debug ( marker , message ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . DEBUG , marker , null , null ) ; }
public void function ( ) { logger . debug ( message , param1 ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . DEBUG , oneParam , null ) ; }
public MessageContent function ( final Optional < ? extends Request > arg0 ) { return reader . readFor ( arg0 ) ; }
public void function ( ) { server . request ( eq ( text ( " foo " ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( ) . response ( toJson ( ImmutableList . of ( resource1 , resource2 ) ) ) ) ; running ( server , new Runnable ( ) { @Override
List < Token > function ( ) { List < Token > tokens = new ArrayList < Token > ( ) ; while ( hasNext ( ) ) { tokens . add ( next ( ) ) ; } return tokens ; }
public void function ( ) { Document doc = Jsoup . parse ( " <p><i>Hello</i></p> " ) ; Element p = doc . selectFirst ( " p " ) ; Element i = doc . selectFirst ( " i " ) ; String pH = p . shallowClone ( ) . toString ( ) ; String iH = i . shallowClone ( ) . toString ( ) ; assertEquals ( " <p></p> " , pH ) ; assertEquals ( " <i></i> " , iH ) ; assertEquals ( p . outerHtml ( ) , p . toString ( ) ) ; assertEquals ( i . outerHtml ( ) , i . toString ( ) ) ; }
public OutputSettings function ( ) { OutputSettings clone ; try { clone = ( OutputSettings ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . charset ( charset . name ( ) ) ; clone . escapeMode = Entities . EscapeMode . valueOf ( escapeMode . name ( ) ) ; return clone ; }
protected void function ( ) throws Exception { super . tearDown ( ) ; }
public void function ( ) { Document doc = new Document ( " " ) ; Element body = doc . appendElement ( " body " ) ; body . appendElement ( " div1 " ) ; body . appendElement ( " div2 " ) ; final Element div3 = body . appendElement ( " div3 " ) ; div3 . text ( " Check " ) ; final Element div4 = body . appendElement ( " div4 " ) ; ArrayList < Element > toMove = new ArrayList < Element > ( ) ; toMove . add ( div3 ) ; toMove . add ( div4 ) ; body . insertChildren ( 0 , toMove ) ; String result = doc . toString ( ) . replaceAll ( " \\ s+ " , " " ) ; assertEquals ( " <body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body> " , result ) ;
@Override public Element function ( String arg0 , String arg1 ) { super . attr ( arg0 , arg1 ) ; return this ; }
public void function ( ) { monitor . onMessageArrived ( request ) ; }
public void function ( ) { slf4jMessageFormatter ( RUN_LENGTH ) ; double avgDuration = slf4jMessageFormatter ( RUN_LENGTH ) ; long referencePerf = 1700 ; BogoPerf . assertDuration ( avgDuration , referencePerf , REFERENCE_BIPS ) ; }
public void function ( ) { for ( Level level : Level . values ( ) ) { singleMessageCheck ( level ) ;
final void function ( String arg0 ) { tagName = tagName = = null ? arg0 : tagName . concat ( arg0 ) ; normalName = tagName . toLowerCase ( ) ; }
public static ActualHttpServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoMonitor arg2 , final MocoConfig . . . arg3 ) { return new ActualHttpServer ( Optional . of ( arg0 ) , arg1 , arg2 , arg3 ) ; }
public void function ( ) throws InterruptedException , BrokenBarrierException { System . out . println ( " THREAD_COUNT= " + THREAD_COUNT ) ; LoggerAccessingThread [ ] accessors = harness ( ) ; for ( int i = 0 ; i < accessors . length ; i + + ) { LoggerAccessingThread accessor = accessors [ i ] ; EVENT_COUNT . getAndIncrement ( ) ; if ( accessor . logger = = null ) { fail ( " logger for LoggerAccessingThread  " + i + "  is not set " ) ; } accessor . logger . info ( " post harness " ) ; } Logger logger = LoggerFactory . getLogger ( packagePrefix + " .test " ) ; logger . info ( " hello " ) ; EVENT_COUNT . getAndIncrement ( ) ; List < LogRecord > records = getRecordedEvents ( ) ; assertEquals ( EVENT_COUNT . get ( ) , records . size ( ) ) ; }
public void function ( ) throws Exception { assertFalse ( Mp3Retag . parseArgs ( new String [ ] { } ) ) ; assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -i " } ) ) ; assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -p " } ) ) ; assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -p " , " filename " } ) ) ; assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -z " , " filename " } ) ) ; assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " filename " , " filename " } ) ) ; }
public void function ( ) { String msg = " Hello world. " ; logger . atDebug ( ) . addKeyValue ( " k " , " v " ) . log ( msg ) ; assertLogMessage ( " k=v Hello world. " , 0 ) ; int oldT = 15 ; int newT = 16 ; logger . atDebug ( ) . addKeyValue ( " oldT " , oldT ) . addKeyValue ( " newT " , newT ) . log ( " Temperature changed. " ) ; assertLogMessage ( " oldT=15 newT=16 Temperature changed. " , 1 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { this . runner . stop ( ) ; this . runner = newRunner ( ) ; this . runner . run ( ) ; }
private void function ( ) { migrationLabel = new JLabel ( ) ; migrationLabel . setText ( " Migration Type " ) ; }
public List < Framedata > function ( byte [ ] arg0 , boolean arg1 ) { throw new RuntimeException ( " not yet implemented " ) ; }
public boolean function ( String arg0 ) { Pattern pattern = Pattern . compile ( new String ( expected . asByteArray ( null ) ) ) ; return pattern . matcher ( arg0 ) . matches ( ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${req.xml.parameter.id} " ) ) ; running ( server , ( ) - > assertThat ( helper . postContent ( remoteUrl ( " /template " ) , " <?xml version= \" 1.0 \"  encoding= \" UTF-8 \" ?><request><parameter><id>1</id></parameter></request> " ) ,
public Connection . Request function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( Level arg0 , ResourceBundle arg1 , String arg2 , Throwable arg3 ) { String message = arg1 = = null ? arg2 : arg1 . getString ( arg2 ) ; switch ( arg0 ) { case ALL :
private static void function ( StringBuffer arg0 , String arg1 , StopWatch arg2 , DurationUnit arg3 ) { arg0 . append ( arg1 ) ; arg0 . append ( " |-- " ) ; arg0 . append ( "  Total elapsed time  " ) ; SpacePadder . leftPad ( arg0 , " [ " + arg2 . getName ( ) + " ] " , MIN_SW_NAME_LENGTH ) ; arg0 . append ( "   " ) ; String timeStr = Util . durationInDunrationUnitsAsStr ( arg2 . getResultInNanos ( ) , arg3 ) ; SpacePadder . leftPad ( arg0 , timeStr , MIN_SW_ELAPSED_TIME_NUMBER_LENGTH ) ; arg0 . append ( "   " ) ; Util . appendDurationUnitAsStr ( arg0 , arg3 ) ; arg0 . append ( SpacePadder . LINE_SEP ) ; }
private void function ( Tokeniser arg0 , CharacterReader arg1 ) { arg0 . emit ( " </ " + arg0 . dataBuffer . toString ( ) ) ; arg1 . unconsume ( ) ; arg0 . transition ( Rcdata ) ; }
public static ResponseHandler function ( final String arg0 , final Resource arg1 , final CookieAttribute . . . arg2 ) { return with ( header ( SET_COOKIE , cookieResource ( checkNotNullOrEmpty ( arg0 , " Cookie key should not be null " ) ,
@Test public void function ( ) { StringBuilder sb = new StringBuilder ( ) ; while ( sb . length ( ) < = CharacterReader . maxBufferLen ) { sb . append ( " A suitable amount of CData. \ n " ) ; } String cdata = sb . toString ( ) ; String h = " <div><![CDATA[ " + cdata + " ]]></div> " ; Document doc = Jsoup . parse ( h ) ; Element div = doc . selectFirst ( " div " ) ; CDataNode node = ( CDataNode ) div . textNodes ( ) . get ( 0 ) ; assertEquals ( cdata , node . text ( ) ) ; }
public void function ( ) throws Exception { server . request ( exist ( header ( " foo " ) ) ) . response ( text ( " header " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws IOException { runWithConfiguration ( " query.json " , port ( ) ) ; helper . get ( remoteUrl ( " /query?param2=foo " ) ) ; }
public String function ( Matcher arg0 ) { StringBuffer replacementBuffer = new StringBuffer ( ) ; String replacementText ; for ( int group = 1 ; group < = arg0 . groupCount ( ) ; group + + ) { replacementText = getReplacement ( group ) ; if ( replacementText ! = null ) { replacementBuffer . append ( replacementText ) ; } else { replacementBuffer . append ( arg0 . group ( group ) ) ; } } return replacementBuffer . toString ( ) ; }
public void function ( ) { ID3v2ObseletePictureFrameData frameData1 = new ID3v2ObseletePictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 0 , new EncodedText ( ( byte ) 1 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; ID3v2ObseletePictureFrameData frameData2 = new ID3v2ObseletePictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 0 , new EncodedText ( ( byte ) 1 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; assertEquals ( frameData1 , frameData2 ) ; }
public boolean function ( Element arg0 , Element arg1 ) { return arg1 . elementSiblingIndex ( ) = = index ; }
public void function ( ) { String expectedOutput = " <!DOCTYPE html PUBLIC  \" -//W3C//DTD HTML 4.0//EN \" " + "   \" http://www.w3.org/TR/REC-html40/strict.dtd \" > " ; for ( char q : quote ) { for ( char ws : whiteSpace ) {
@Test void function ( ) { String html = " <p>Hello<br>there<br>now.</p> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <p>Hello<br> \ n there<br> \ n now.</p> " , doc . body ( ) . html ( ) ) ; }
private StartArgs function ( int arg0 ) { return new StartArgs ( arg0 , null , null , null , null ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public Connection function ( String arg0 ) { req . header ( " User-Agent " , arg0 ) ; return this ; }
public void function ( String arg0 , ID3v2FrameSet arg1 ) { frameSets . put ( arg0 , arg1 ) ; }
public T function ( String arg0 , String arg1 ) { Validate . notEmpty ( arg0 , " Header name must not be empty " ) ; Validate . notNull ( arg1 , " Header value must not be null " ) ; removeHeader ( arg0 ) ; addHeader ( arg0 , arg1 ) ; return ( T ) this ; }
public XmlDeclaration function ( ) { return ( XmlDeclaration ) super . clone ( ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { char c = arg1 . consume ( ) ; switch ( c ) { case '\'' :
@Test public void function ( ) { Parser parser = Parser . htmlParser ( ) ; parser . setTrackErrors ( 10 ) ; Document document = parser . parseInput ( " <select><option>Option 1</option></select> " , " http://jsoup.org " ) ; assertEquals ( 0 , parser . getErrors ( ) . size ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 2300 ) ;
public void function ( ) throws Exception { server . response ( text ( ( request ) - > ( ( HttpRequest ) request ) . getUri ( ) ) ) ; running ( server , ( ) - > { String response = helper . get ( remoteUrl ( " /uri " ) ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element div = doc . getElementById ( " 1 " ) ; div . prependElement ( " p " ) . text ( " Before " ) ; assertEquals ( " Before " , div . child ( 0 ) . text ( ) ) ; assertEquals ( " Hello " , div . child ( 1 ) . text ( ) ) ; }
public void function ( VerificationData arg0 ) { int actualSize = arg0 . matchedSize ( ) ; if ( actualSize < min | | actualSize > max ) { throw new VerificationException ( arg0 . mismatchDescription ( actualSize , format ( " {%d, %d} " , min , max ) ) ) ;
private static InputStream function ( final Resource arg0 ) { Optional < Request > request = Optional . absent ( ) ; return new ByteArrayInputStream ( checkNotNull ( arg0 , " resource should not be null " ) . readFor ( request ) ) ; }
public static ResponseHandler function ( final ContentResource arg0 ) { RecorderConfigurations configurations = RecorderConfigurations . create ( new RecorderIdentifier ( arg0 ) ) ; return new DynamicRecordHandler ( configurations ) ; }
public boolean function ( ) { return ( ! connectionClosed & & ! closeHandshakeSent & & handshakeComplete ) ; }
public static RestSetting function ( final String arg0 , final RequestMatcher arg1 , final ResponseHandler arg2 , final ResponseHandler . . . arg3 ) { return new PutRestSetting ( checkId ( arg0 ) , Optional . of ( checkNotNull ( arg1 , " Put request matcher should no be null " ) ) ,
public void function ( ) { try { new EncodedText ( ( byte ) 4 , TEST_STRING ) ;
public OutputSettings function ( ) { OutputSettings clone ; try { clone = ( OutputSettings ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . charset ( charset . name ( ) ) ; clone . escapeMode = Entities . EscapeMode . valueOf ( escapeMode . name ( ) ) ; return clone ; }
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " ) ; ClassicHttpResponse httpResponse = helper . getResponse ( remoteUrl ( " /mount-response/mount.response " ) ) ; String value = httpResponse . getFirstHeader ( HttpHeaders . CONTENT_TYPE ) . getValue ( ) ; assertThat ( value , is ( " text/plain " ) ) ; String content = CharStreams . toString ( new InputStreamReader ( httpResponse . getEntity ( ) . getContent ( ) ) ) ; assertThat ( content , is ( " response from mount " ) ) ; }
public void function ( ) throws Exception { final ID3v24Tag id3tag = new ID3v24Tag ( ) ; final String recordingTime = " 01/01/2011 00:00:00 " ; id3tag . setRecordingTime ( recordingTime ) ; final byte [ ] bytes = id3tag . toBytes ( ) ; final ID3v24Tag newId3tag = new ID3v24Tag ( bytes ) ; assertEquals ( recordingTime , newId3tag . getRecordingTime ( ) ) ; }
protected void function ( HttpRequest arg0 , ChannelBuffer arg1 ) { try { arg1 . writeBytes ( toByteArray ( targetFile ( arg0 ) ) ) ;
@Nullable HtmlTreeBuilderState function ( ) { if ( tmplInsertMode . size ( ) > 0 ) { return tmplInsertMode . remove ( tmplInsertMode . size ( ) - 1 ) ;
public void function ( ) throws Exception { server . response ( header ( " content-type " , " text/html " ) , with ( " foo " ) ) ; running ( server , ( ) - > { Header [ ] headers = helper . getResponse ( root ( ) ) . getHeaders ( HttpHeaders . CONTENT_TYPE ) ;
public String function ( final char . . . arg0 ) { bufferUp ( ) ; final int start = bufPos ; final int remaining = bufLength ; final char [ ] val = charBuf ; OUTER : while ( bufPos < remaining ) { for ( char c : arg0 ) { if ( val [ bufPos ] = = c ) break OUTER ; } bufPos + + ; } return bufPos > start ? cacheString ( charBuf , stringCache , start , bufPos - start ) : " " ; }
public void function ( ) throws Exception { final ID3v22Tag id3tag = new ID3v22Tag ( ) ; final String publisher = " PUBLISHER " ; id3tag . setPublisher ( publisher ) ; final byte [ ] bytes = id3tag . toBytes ( ) ; final ID3v22Tag newId3tag = new ID3v22Tag ( bytes ) ; assertEquals ( publisher , newId3tag . getPublisher ( ) ) ; }
protected void function ( Level arg0 , Marker arg1 , String arg2 , Object [ ] arg3 , Throwable arg4 ) { List < Marker > markers = null ; if ( arg1 ! = null ) { markers = new ArrayList < Marker > ( ) ; markers . add ( arg1 ) ; } innerHandleNormalizedLoggingCall ( arg0 , markers , arg2 , arg3 , arg4 ) ; }
public final void function ( WebSocket arg0 , Handshakedata arg1 ) { if ( addConnection ( arg0 ) ) { onOpen ( arg0 , ( ClientHandshake ) arg1 ) ;
public void function ( Object arg0 ) { innerLog ( null , CATEGORY_FQCN , LocationAwareLogger . INFO_INT , arg0 , null ) ; }
public ClassicHttpResponse function ( final String arg0 ) throws IOException { return execute ( Request . head ( arg0 ) ) ; }
public int function ( ) { int result = ( fin ? 1 : 0 ) ; result = 31 * result + optcode . hashCode ( ) ; result = 31 * result + ( unmaskedpayload ! = null ? unmaskedpayload . hashCode ( ) : 0 ) ; result = 31 * result + ( transferemasked ? 1 : 0 ) ; result = 31 * result + ( rsv1 ? 1 : 0 ) ; result = 31 * result + ( rsv2 ? 1 : 0 ) ; result = 31 * result + ( rsv3 ? 1 : 0 ) ; return result ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.1.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 70 ) ; }
public static int function ( Handshakedata arg0 ) { String vers = arg0 . getFieldValue ( " Sec-WebSocket-Version " ) ; if ( vers . length ( ) > 0 ) { int v ; try { v = new Integer ( vers . trim ( ) ) ; return v ; } catch ( NumberFormatException e ) { return - 1 ; } } return - 1 ; }
public void function ( ) throws Exception { server . request ( eq ( form ( " password " ) , " hello " ) ) . response ( " foobar " ) ; server . response ( " foobar " ) ; running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " foobar " ) ) ) ; }
public Setting < T > function ( final MocoConfig arg0 ) { BaseSetting < T > setting = createSetting ( configMatcher ( this . matcher , arg0 ) ) ; setting . handler = configItem ( this . handler , arg0 ) ; setting . eventTriggers = configItems ( eventTriggers , arg0 ) ; return setting ; }
@Test public void function ( ) { assertThrows ( Selector . SelectorParseException . class , ( ) - > QueryParser . parse ( " " ) ) ; }
private static void function ( StringBuilder arg0 , double [ ] arg1 ) { arg0 . append ( '[' ) ; final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { arg0 . append ( arg1 [ i ] ) ; if ( i ! = len - 1 ) arg0 . append ( " ,  " ) ; } arg0 . append ( ']' ) ; }
public static ResponseHandler function ( final ContentResource arg0 ) { return new ContentHandler ( arg0 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " xml_struct.json " ) ; assertThat ( helper . postFile ( remoteUrl ( " /struct-xml " ) , " foo.xml " ) , is ( " response_for_xml_struct_request " ) ) ; assertThat ( helper . postContent ( remoteUrl ( " /struct-xml " ) , " <request><parameters><id>2</id></parameters></request> " ) , is ( " response_for_xml_struct_request " ) ) ; }
public void function ( ) throws Exception { RequestHit hit = requestHit ( ) ; HttpsServer server = httpsServer ( port ( ) , DEFAULT_CERTIFICATE , hit ) ; server . request ( by ( " foo " ) ) . response ( " bar " ) ; running ( server , ( ) - > assertThat ( helper . postContent ( httpsRoot ( ) , " foo " ) , is ( " bar " ) ) ) ; hit . verify ( by ( " foo " ) , once ( ) ) ; }
public static ActualHttpServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoMonitor arg2 , final ServerConfig arg3 , final MocoConfig . . . arg4 ) { return new ActualHttpServer ( arg0 , arg1 , arg2 , arg3 , arg4 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 3.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private void function ( final CloseableHttpClient arg0 , final Request arg1 ) throws IOException { HttpRequestBase targetRequest = createRequest ( url , arg1 ) ; if ( targetRequest instanceof HttpEntityEnclosingRequest & & content . isPresent ( ) ) { ( ( HttpEntityEnclosingRequest ) targetRequest ) . setEntity ( asEntity ( content . get ( ) , arg1 ) ) ; } arg0 . execute ( targetRequest ) ; }
public static < T > T function ( final String arg0 , final Object arg1 , final Object arg2 , final Class < T > arg3 , final Class < ? > arg4 , final Class < ? > arg5 ) { try { Method method = Moco . class . getMethod ( arg0 , arg4 , arg5 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.10.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) { Safelist safelist1 = Safelist . none ( ) . addTags ( TEST_TAG ) ; Safelist safelist2 = new Safelist ( safelist1 ) ; safelist1 . addTags ( " invalidTag " ) ; assertFalse ( safelist2 . isSafeTag ( " invalidTag " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.7.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 400 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.5.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public RequestMatcher function ( MocoConfig arg0 ) { return this ; }
public void function ( ) { ArrayList < String > loggingEvents = new ArrayList < > ( ) ; Logger configuredLogger = createLogger ( prepareSink ( loggingEvents ) , Level . INFO ) ; configuredLogger . trace ( " Simple trace message " ) ; configuredLogger . debug ( " Simple debug message " ) ; assertEquals ( " Lower levels should have been ignored " , 0 , loggingEvents . size ( ) ) ; assertTrue ( " Info level should be enabled for this test " , configuredLogger . isInfoEnabled ( ) ) ; configuredLogger . info ( " Simple info message " ) ; assertEquals ( " Info message should've been captured " , 1 , loggingEvents . size ( ) ) ; assertTrue ( " Message should be logged in debug level " , isInfoMessage ( loggingEvents . get ( 0 ) ) ) ; assertEquals ( " Supplied info message wasn't found in the log " , " Simple info message " , extractMessage ( loggingEvents . get ( 0 ) ) ) ; loggingEvents . clear ( ) ; configuredLogger . warn ( " Simple warn message " ) ; configuredLogger . error ( " Simple error message " ) ; assertEquals ( " The other levels should have been captured " , 2 , loggingEvents . size ( ) ) ; }
public void function ( ) throws Exception { webSocketServer . request ( by ( " foo " ) ) . response ( broadcast ( " bar " ) ) ; running ( server , ( ) - > { final Endpoint endpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws/ " ) ) ;
private static byte [ ] function ( byte [ ] arg0 , String arg1 , String arg2 ) { String data = new String ( arg0 ) ; String [ ] tokens = data . split ( arg1 ) ; tokens = tokens [ 1 ] . split ( arg2 ) ; return DatatypeConverter . parseBase64Binary ( tokens [ 0 ] ) ; }
public void function ( ) throws IOException { new FileWrapper ( ( java . io . File ) null ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${req.json.code} ${req.json.message} " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( final String arg0 , final Throwable arg1 ) { Log . i ( name , arg0 , arg1 ) ; }
final public static String function ( final String arg0 , Object arg1 , Object arg2 ) { return arrayFormat ( arg0 , new Object [ ] { arg1 , arg2 } ) ; }
public void function ( Object arg0 , Throwable arg1 ) { logger . log ( null , FQCN , LocationAwareLogger . ERROR_INT , String . valueOf ( arg0 ) , arg1 ) ;
public void function ( ) { Integer i1 = new Integer ( 1 ) ; Integer i2 = new Integer ( 2 ) ; Integer i3 = new Integer ( 3 ) ; Exception e = new Exception ( " This is a test exception. " ) ; Logger logger = LoggerFactory . getLogger ( " test2 " ) ; int index = 0 ; logger . debug ( " Hello world " ) ; assertLogMessage ( " Hello world " , index + + ) ; logger . debug ( " Hello world {} " , i1 ) ; assertLogMessage ( " Hello world  " + i1 , index + + ) ; logger . debug ( " val={} val={} " , i1 , i2 ) ; assertLogMessage ( " val=1 val=2 " , index + + ) ; logger . debug ( " val={} val={} val={} " , new Object [ ] { i1 , i2 , i3 } ) ; assertLogMessage ( " val=1 val=2 val=3 " , index + + ) ; logger . debug ( " Hello world 2 " , e ) ; assertLogMessage ( " Hello world 2 " , index ) ; assertException ( e . getClass ( ) , index + + ) ; logger . info ( " Hello world 2. " ) ; logger . warn ( " Hello world 3. " ) ; logger . warn ( " Hello world 3 " , e ) ; logger . error ( " Hello world 4. " ) ; logger . error ( " Hello world {} " , new Integer ( 3 ) ) ; logger . error ( " Hello world 4. " , e ) ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { String value = resource . readFor ( arg0 ) . toString ( ) ; arg1 . addHeader ( name , value ) ; }
private ElementMeta function ( Element arg0 ) { String sourceTag = arg0 . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , arg0 . baseUri ( ) , destAttrs ) ; int numDiscarded = 0 ; Attributes sourceAttrs = arg0 . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( safelist . isSafeAttribute ( sourceTag , arg0 , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; else numDiscarded + + ; } Attributes enforcedAttrs = safelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . addAll ( enforcedAttrs ) ; return new ElementMeta ( dest , numDiscarded ) ; }
public static Resource function ( String arg0 ) { try { return new UrlResource ( new URL ( checkNotNull ( arg0 , " Null url is not allowed " ) ) ) ;
public void function ( ) { SimpleLogger simpleLogger = new SimpleLogger ( " x.y " ) ; assertNull ( simpleLogger . recursivelyComputeLevelString ( ) ) ; }
protected void function ( String arg0 , String arg1 , boolean arg2 ) { super . initialiseParse ( arg0 , arg1 , arg2 ) ; stack . add ( doc ) ; }
public HandshakeBuilder function ( HandshakeBuilder arg0 ) { throw new RuntimeException ( " not yet implemented " ) ; }
private static void function ( Element arg0 ) { assertEquals ( Parser . NamespaceSvg , arg0 . tag ( ) . namespace ( ) ) ; }
private RequestMatcher function ( final String arg0 , final Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return by ( toJson ( arg1 ) ) ; } if ( Map . class . isInstance ( arg1 ) ) { return createCompositeMatcher ( arg0 , castToMap ( arg1 ) ) ; } if ( TextContainer . class . isInstance ( arg1 ) ) { return createSingleTextMatcher ( arg0 , TextContainer . class . cast ( arg1 ) ) ; } throw new IllegalArgumentException ( " unknown configuration : " + arg1 ) ; }
@Test void function ( ) throws IOException { String html = " <title>One</title><p id=1>P One</p><p id=2>P Two</p> " ; StreamParser parser = new StreamParser ( Parser . htmlParser ( ) ) . parse ( html , " " ) ; Element title = parser . expectFirst ( " title " ) ; assertEquals ( " One " , title . text ( ) ) ; Document partialDoc = title . ownerDocument ( ) ; assertNotNull ( partialDoc ) ; Elements ps = partialDoc . select ( " p " ) ; assertEquals ( 1 , ps . size ( ) ) ; assertEquals ( " " , ps . get ( 0 ) . text ( ) ) ; assertSame ( partialDoc , parser . document ( ) ) ; Element title2 = parser . selectFirst ( " title " ) ; assertSame ( title2 , title ) ; Element p1 = parser . expectNext ( " p " ) ; assertEquals ( " P One " , p1 . text ( ) ) ; Element p2 = parser . expectNext ( " p " ) ; assertEquals ( " P Two " , p2 . text ( ) ) ; Element pNone = parser . selectNext ( " p " ) ; assertNull ( pNone ) ; }
public void function ( String arg0 , Object arg1 ) { if ( ! logger . isDebugEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( null , fqcn , LocationAwareLogger . DEBUG_INT , arg0 , new Object [ ] { arg1 } , null ) ;
public ClientHandshakeBuilder function ( ClientHandshakeBuilder arg0 ) { arg0 . put ( " Upgrade " , " websocket " ) ; arg0 . put ( " Connection " , " Upgrade " ) ; arg0 . put ( " Sec-WebSocket-Version " , " 8 " ) ; byte [ ] random = new byte [ 16 ] ; reuseableRandom . nextBytes ( random ) ; arg0 . put ( " Sec-WebSocket-Key " , Base64 . encodeBytes ( random ) ) ; return arg0 ; }
public void function ( ) throws Exception { ID3v2 id3tag = new ID3v23Tag ( ) ; setTagFields ( id3tag ) ; id3tag . setGenreDescription ( " Jazz " ) ; assertEquals ( " Jazz " , id3tag . getGenreDescription ( ) ) ; assertEquals ( 8 , id3tag . getGenre ( ) ) ; Map < String , ID3v2FrameSet > frameSets = id3tag . getFrameSets ( ) ; ID3v2FrameSet frameSet = frameSets . get ( " TCON " ) ; List < ID3v2Frame > frames = frameSet . getFrames ( ) ; ID3v2Frame frame = frames . get ( 0 ) ; byte [ ] bytes = frame . getData ( ) ; String genre = BufferTools . byteBufferToString ( bytes , 1 , bytes . length - 1 ) ; assertEquals ( " (8)Jazz " , genre ) ; }
public void function ( String arg0 , Profiler arg1 ) { profilerMap . put ( arg0 , arg1 ) ; }
private void function ( String arg0 , Element arg1 ) { Elements elements = this . getElementsByTag ( arg0 ) ; Element master = elements . first ( ) ; if ( elements . size ( ) > 1 ) { List < Node > toMove = new ArrayList < > ( ) ; for ( int i = 1 ; i < elements . size ( ) ; i + + ) { Node dupe = elements . get ( i ) ; for ( Node node : dupe . childNodes ) toMove . add ( node ) ; dupe . remove ( ) ; } for ( Node dupe : toMove ) master . appendChild ( dupe ) ; } if ( ! master . parent ( ) . equals ( arg1 ) ) { arg1 . appendChild ( master ) ;
public void function ( ) { Evaluator . IsNthOfType evaluator = new Evaluator . IsNthOfType ( 2 , 3 ) ; assertEquals ( " :nth-of-type(2n+3) " , evaluator . toString ( ) ) ; }
public static void function ( String . . . arg0 ) throws IOException { Validate . isTrue ( arg0 . length = = 1 | | arg0 . length = = 2 , " usage: java -jar jsoup-examples.jar url [selector] " ) ; final String url = arg0 [ 0 ] ; final String selector = arg0 . length = = 2 ? arg0 [ 1 ] : null ; Connection session = Jsoup . newSession ( ) . userAgent ( userAgent ) . timeout ( timeout ) ; Document doc = session . newRequest ( url ) . get ( ) ; if ( selector ! = null ) { Elements elements = doc . select ( selector ) ;
public void function ( ) { get ( " 1 1 " ) . response ( status ( 200 ) ) ; }
public void function ( ) throws InvalidDataException { } }
public void function ( Set < WebSocket > arg0 , String arg1 ) throws IOException { if ( arg0 = = null ) { throw new NullPointerException ( " 'connections' cannot be null " ) ; } for ( WebSocket c : this . arg0 ) { if ( ! arg0 . contains ( c ) ) {
private void function ( ) { tq . consume ( " </ " ) ; String tagName = tq . consumeWord ( ) ; tq . chompTo ( " > " ) ; if ( ! tagName . isEmpty ( ) ) { Tag tag = Tag . valueOf ( tagName ) ;
public void function ( ) { ContinuousFrame frame = new ContinuousFrame ( ) ; assertEquals ( Opcode . CONTINUOUS , frame . getOpcode ( ) , " Opcode must be equal " ) ; assertTrue ( frame . isFin ( ) , " Fin must be set " ) ; assertFalse ( frame . getTransfereMasked ( ) , " TransferedMask must not be set " ) ; assertEquals ( 0 , frame . getPayloadData ( ) . capacity ( ) , " Payload must be empty " ) ; assertFalse ( frame . isRSV1 ( ) , " RSV1 must be false " ) ; assertFalse ( frame . isRSV2 ( ) , " RSV2 must be false " ) ; assertFalse ( frame . isRSV3 ( ) , " RSV3 must be false " ) ; try { frame . isValid ( ) ;
public W3CDom function ( boolean arg0 ) { this . arg0 = arg0 ; factory . setNamespaceAware ( arg0 ) ; return this ; }
public void function ( ) { Elements els = SelectMatch . match ( Jsoup . parse ( " <div><p id=foo>Hello</p><p id=foo>Foo two!</p></div> " ) , new ElementSelector ( null , null , " foo " ) ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " Hello " , els . get ( 0 ) . text ( ) ) ; Elements none = SelectMatch . match ( Jsoup . parse ( " <div id=1></div> " ) , new ElementSelector ( null , null , " foo " ) ) ; assertEquals ( 0 , none . size ( ) ) ; }
@Test public void function ( ) { String h = " <div id='1' /><script src='/foo' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <div id= \" 1 \" ></div><script src= \" /foo \" ></script><div id= \" 2 \" ><img /><img /></div><a id= \" 3 \" ></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public RunnerSetting function ( GlobalSetting arg0 ) { try { return new RunnerSetting ( new FileInputStream ( arg0 . getInclude ( ) ) ,
public void function ( String arg0 , Throwable arg1 ) { log ( Level . WARNING , arg0 , arg1 ) ; }
public void function ( ) throws Exception { assertMessageContent ( " application/json; charset=ISO-8859-1 " , EXPECTED_MESSAGE_BODY ) ; }
public boolean function ( Element arg0 ) { Element parent = arg0 . parent ( ) ; while ( parent ! = null ) { if ( sel . matches ( parent ) ) return true ; parent = parent . parent ( ) ; } return false ; }
public void function ( ) { final String diffPrefix = " homonym " + diff ; final String PARENT_NAME = diffPrefix + PARENT_MARKER_STR ; final String CHILD_NAME = diffPrefix + CHILD_MARKER_STR ; Marker parent = factory . getMarker ( PARENT_NAME ) ; Marker child = factory . getMarker ( CHILD_NAME ) ; parent . add ( child ) ; IMarkerFactory otherFactory = new BasicMarkerFactory ( ) ; Marker otherParent = otherFactory . getMarker ( PARENT_NAME ) ; Marker otherChild = otherFactory . getMarker ( CHILD_NAME ) ; assertTrue ( parent . contains ( otherParent ) ) ; assertTrue ( parent . contains ( otherChild ) ) ; assertTrue ( parent . remove ( otherChild ) ) ; }
private Mp3File function ( String arg0 , int arg1 ) throws IOException , UnsupportedTagException , InvalidDataException , NotSupportedException { String saveFilename = null ; try { Mp3File mp3file = loadAndCheckTestMp3WithCustomTag ( arg0 , arg1 ) ;
@Test void function ( ) { Attributes one = new Attributes ( ) . add ( " Key1 " , " Val1 " ) . add ( " Key2 " , " Val2 " ) . add ( " Key3 " , null ) ; Attributes two = one . clone ( ) ; assertEquals ( 3 , two . size ( ) ) ; assertEquals ( " Val2 " , two . get ( " Key2 " ) ) ; assertEquals ( one , two ) ; two . add ( " Key4 " , " Val4 " ) ; assertEquals ( 4 , two . size ( ) ) ; assertEquals ( 3 , one . size ( ) ) ; assertNotEquals ( one , two ) ;
public void function ( ) throws InterruptedException { assertEquals ( DurationUnit . NANOSECOND , Util . selectDurationUnitForDisplay ( 10 ) ) ; assertEquals ( DurationUnit . NANOSECOND , Util . selectDurationUnitForDisplay ( 9 * Util . NANOS_IN_ONE_MICROSECOND ) ) ; assertEquals ( DurationUnit . MICROSECOND , Util . selectDurationUnitForDisplay ( 11 * Util . NANOS_IN_ONE_MICROSECOND ) ) ; assertEquals ( DurationUnit . MICROSECOND , Util . selectDurationUnitForDisplay ( 9 * Util . NANOS_IN_ONE_MILLISECOND ) ) ; assertEquals ( DurationUnit . MILLISSECOND , Util . selectDurationUnitForDisplay ( 11 * Util . NANOS_IN_ONE_MILLISECOND ) ) ; assertEquals ( DurationUnit . SECOND , Util . selectDurationUnitForDisplay ( 11 * Util . NANOS_IN_ONE_SECOND ) ) ; }
public void function ( ) throws Exception { server . response ( header ( " Content-Type " , " text/html " ) , with ( " foo " ) ) ; running ( server , new Runnable ( ) { @Override
public static Document function ( URL arg0 , int arg1 ) throws IOException { Connection con = HttpConnection . connect ( arg0 ) ; con . timeout ( arg1 ) ; return con . get ( ) ; }
public Element function ( String arg0 ) throws IOException { return ( Element ) Validate . ensureNotNull ( selectFirst ( arg0 ) ,
private String function ( String arg0 ) { String seckey = arg0 . trim ( ) ; String acc = seckey + " 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 " ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( " SHA1 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
public static Document function ( String arg0 ) { return Parser . parse ( arg0 , " " ) ; }
private void function ( Handshakedata arg0 ) { log . trace ( " open using draft: {} " , draft ) ; readyState = ReadyState . OPEN ; try { wsl . onWebsocketOpen ( this , arg0 ) ;
public static void function ( String arg0 ) { if ( arg0 = = null | | arg0 . length ( ) = = 0 ) throw new IllegalArgumentException ( " String must not be empty " ) ;
public void function ( ) throws Exception { Protocol protocol0 = new Protocol ( " " ) ; try { Protocol protocol1 = new Protocol ( null ) ;
public MessageContent function ( Optional < ? extends Request > arg0 ) { String text = HttpProtocolVersion . versionOf ( version . readFor ( arg0 ) . toString ( ) ) . text ( ) ; return content ( ) . withContent ( text )
protected void function ( ) { while ( true ) { Token token = tokeniser . read ( ) ;
public void function ( ) throws Exception { server . request ( path ( uri ( " /path/{path} " ) ) ) . response ( template ( " ${req.path.path} " ) ) ; server . request ( path ( uri ( " /path/{path}/sub/{sub} " ) ) ) . response ( template ( " ${req.path.path}/${req.path.sub} " ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /path/hello " ) ) , is ( " hello " ) ) ;
private List < Session > function ( Session arg0 ) { List < Session > sessions = restoreSessions ( this . file ) ; Optional < Session > session = tryFind ( sessions , isForRequest ( arg0 . getRequest ( ) ) ) ; if ( session . isPresent ( ) ) { session . get ( ) . setResponse ( arg0 . getResponse ( ) ) ; } else { sessions . add ( arg0 ) ; } return sessions ; }
public boolean function ( String arg0 ) { for ( Element element : contents ) { if ( element . hasAttr ( arg0 ) ) return true ; } return false ; }
public static HttpServer function ( final MocoConfig . . . arg0 ) { return ActualHttpServer . createSilentServer ( 0 , arg0 ) ; }
boolean function ( Token arg0 , TreeBuilder arg1 ) { if ( arg0 . isStartTag ( ) & & StringUtil . in ( arg0 . asStartTag ( ) . name ( ) , " caption " , " table " , " tbody " , " tfoot " , " thead " , " tr " , " td " , " th " ) ) { arg1 . error ( this ) ;
public String [ ] function ( HttpRequest arg0 ) { return toStringArray ( jsonPath . read ( extractor . extract ( arg0 ) ) ) ; }
public ResponseSetting function ( final String arg0 , final MountTo arg1 , final MountPredicate . . . arg2 ) { File mountedDir = new File ( checkNotNull ( arg0 , " Directory should not be null " ) ) ; checkNotNull ( arg1 , " Target should not be null " ) ; this . request ( new MountMatcher ( mountedDir , arg1 , copyOf ( arg2 ) ) ) . response ( new MountHandler ( mountedDir , arg1 ) ) ; return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.8.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public boolean function ( ) { return isLevelEnabled ( LOG_LEVEL_DEBUG ) ; }
@Test public void function ( ) { Connection con = HttpConnection . connect ( " http://example.com " ) ; Map < String , String > headers = new HashMap < > ( ) ; headers . put ( " content-type " , " text/html " ) ; headers . put ( " Connection " , " keep-alive " ) ; headers . put ( " Host " , " http://example.com " ) ; con . headers ( headers ) ; assertEquals ( " text/html " , con . request ( ) . header ( " content-type " ) ) ; assertEquals ( " keep-alive " , con . request ( ) . header ( " Connection " ) ) ; assertEquals ( " http://example.com " , con . request ( ) . header ( " Host " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.10 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public static ControllableInputStream function ( InputStream arg0 , int arg1 , int arg2 ) { if ( arg0 instanceof ControllableInputStream ) return ( ControllableInputStream ) arg0 ;
public void function ( arg0 final Path arg1 ) throws IOException , InterruptedException { final File config = arg1 . resolve ( " config.json " ) . toFile ( ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foo \" " + " }}] " ) ; final File setting = arg1 . resolve ( " settings.json " ) . toFile ( ) ; String path = config . getAbsolutePath ( ) ; changeFileContent ( setting , " [{ " + " \" include \"  :  \" " + path + " \" " + " }] " ) ; RunnerFactory factory = new RunnerFactory ( " SHUTDOWN " ) ; runner = factory . createRunner ( httpArgs ( ) . withPort ( port ( ) ) . withShutdownPort ( 9090 ) . withSettings ( setting . getAbsolutePath ( ) ) . build ( ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foobar \" " + " }}] " ) ; waitChangeHappens ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foobar " ) ) ; }
public T function ( final InputStream arg0 , final Optional < Integer > arg1 , final MocoConfig . . . arg2 ) { try { return createServer ( reader . read ( arg0 , SessionSetting . class ) , arg1 , arg2 ) ;
@Test @MultiLocaleTest public void function ( ) throws Exception { ParseSettings parseSettings = new ParseSettings ( false , false ) ; String normalizedAttribute = parseSettings . normalizeAttribute ( " HIDDEN " ) ; assertEquals ( " hidden " , normalizedAttribute ) ; }
public boolean function ( String arg0 ) { return arg0 . startsWith ( new String ( expected . readFor ( Optional . < HttpRequest > absent ( ) ) ) ) ; }
public void function ( String arg0 , Serializable arg1 ) { this . eventData . put ( arg0 , arg1 ) ; }
final void function ( String arg0 , int arg1 , int arg2 ) { ensureAttrValue ( arg1 , arg2 ) ; if ( attrValueSb . length ( ) = = 0 ) { attrValue = arg0 ;
public Failover function ( ) { if ( this . status = = null ) { return playback ( file ) ; } return playback ( file , this . status ) ; }
public void function ( ) throws IOException , InterruptedException { final File config = File . createTempFile ( " config " , " .json " ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foo \" " + " }}] " ) ; runner = new DynamicRunner ( config . getAbsolutePath ( ) , port ( ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foobar \" " + " }}] " ) ; Thread . sleep ( FileMonitor . INTERVAL + 500 ) ; assertThat ( helper . get ( root ( ) ) , is ( " foobar " ) ) ; }
public void function ( ) { result = MessageFormatter . format ( null , i1 ) . getMessage ( ) ; assertEquals ( null , result ) ; }
public void function ( final ChannelHandlerContext arg0 ) { arg0 . flush ( ) ; }
public static ActualHttpServer function ( final Optional < Integer > arg0 , final MocoConfig . . . arg1 ) { return createHttpServerWithMonitor ( arg0 . or ( 0 ) , new Slf4jMonitor ( new HttpRequestDumper ( ) , new HttpResponseDumper ( ) ) , arg1 ) ;
public void function ( ) throws Exception { runTestScenario ( false ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${var} " , " var " , var ( ( ) - > " TEMPLATE " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
void function ( NodeVisitor arg0 ) { this . arg0 = arg0 ; }
public static void function ( String arg0 , Instrumentation arg1 ) { LogTransformer . Builder builder = new LogTransformer . Builder ( ) ; builder = builder . addEntryExit ( true ) ; if ( arg0 ! = null ) { Properties args = parseArguments ( arg0 , " , " ) ; if ( args . containsKey ( AgentOptions . VERBOSE ) ) { builder = builder . verbose ( true ) ; } if ( args . containsKey ( AgentOptions . TIME ) ) { printStartStopTimes ( ) ; } if ( args . containsKey ( AgentOptions . IGNORE ) ) { String ignore = args . getProperty ( AgentOptions . IGNORE ) ; builder = builder . ignore ( ignore . split ( " : " ) ) ; } if ( args . containsKey ( AgentOptions . LEVEL ) ) { builder = builder . level ( args . getProperty ( AgentOptions . LEVEL ) ) ; } } arg1 . addTransformer ( builder . build ( ) ) ; }
public void function ( ) throws Exception { server . response ( json ( ( request ) - > { PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; return pojo ; } ) ) ; final PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; running ( server , ( ) - > JsonSupport . assertEquals ( pojo , helper . getResponse ( root ( ) ) ) ) ; }
public HandshakeState function ( ByteBuffer arg0 ) throws IncompleteHandshakeException { arg0 . mark ( ) ; if ( arg0 . limit ( ) > Draft . FLASH_POLICY_REQUEST . length ) { return HandshakeState . NOT_MATCHED ;
public void function ( Marker arg0 , String arg1 , Object arg2 ) { recordEvent ( Level . DEBUG , arg0 , arg1 , new Object [ ] { arg2 } , null ) ; }
protected Optional < String > function ( final HttpRequest arg0 ) { return of ( this . url . get ( ) . toString ( ) ) ; }
public Document function ( ) { Document clone = new Document ( this . tag ( ) . namespace ( ) , baseUri ( ) ) ; if ( attributes ! = null ) clone . attributes = attributes . clone ( ) ; clone . outputSettings = this . outputSettings . clone ( ) ; return clone ; }
public void function ( String arg0 , Object arg1 ) { if ( logger . isEnabledFor ( Level . ERROR ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public ResponseHandler function ( Map . Entry < String , String > arg0 ) { return new HeaderResponseHandler ( arg0 . getKey ( ) , arg0 . getValue ( ) ) ; }
public boolean function ( ) { return StringUtils . isBlank ( normaliseWhitespace ( getWholeText ( ) ) ) ; }
public void function ( String arg0 ) { if ( isTraceEnabled ( ) ) { handle_0ArgsCall ( Level . TRACE , null , arg0 , null ) ;
public void function ( ) throws IOException , InterruptedException { final File config = tempFolder . newFile ( " config.json " ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foo \" " + " }}] " ) ; final File setting = tempFolder . newFile ( " settings.json " ) ; String path = FilenameUtils . separatorsToUnix ( config . getAbsolutePath ( ) ) ; changeFileContent ( setting , " [{ " + " \" include \"  :  \" " + path + " \" " + " }] " ) ; RunnerFactory factory = new RunnerFactory ( " SHUTDOWN " ) ; runner = factory . createRunner ( new StartArgs ( port ( ) , 9090 , null , setting . getAbsolutePath ( ) , null , null ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foobar \" " + " }}] " ) ; waitChangeHappens ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foobar " ) ) ; }
protected Setting < SocketResponseSetting > function ( RequestMatcher arg0 ) { return new SocketSetting ( arg0 ) ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws IOException { String magnitude = arg0 . getParameter ( Magnitude ) ; magnitude = magnitude = = null ? " " : magnitude ; arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( " <title>Something</title> " ) ; while ( sb . length ( ) < = 32 * 1024 ) { sb . append ( " <div>A suitable amount of data.</div> \ n " ) ; } sb . append ( " <p>Finale.</p> " ) ; String data = sb . toString ( ) ; int contentLength = magnitude . equals ( Larger ) ? data . length ( ) * 2 : data . length ( ) / 2 ; arg1 . setContentLength ( contentLength ) ; arg1 . getWriter ( ) . write ( data ) ;
private void function ( String arg0 , Element arg1 ) { Elements elements = this . getElementsByTag ( arg0 ) ; Element master = elements . first ( ) ; if ( elements . size ( ) > 1 ) { List < Node > toMove = new ArrayList < > ( ) ; for ( int i = 1 ; i < elements . size ( ) ; i + + ) { Node dupe = elements . get ( i ) ; toMove . addAll ( dupe . ensureChildNodes ( ) ) ; dupe . remove ( ) ; } for ( Node dupe : toMove ) master . appendChild ( dupe ) ; } if ( ! master . parent ( ) . equals ( arg1 ) ) { arg1 . appendChild ( master ) ;
public static ContentResource function ( final String arg0 , final Charset arg1 ) { return ApiUtils . file ( text ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , of ( checkNotNull ( arg1 , " Charset should not be null " ) ) ) ; }
private void function ( ) throws IOException { String path = uri . getPath ( ) ; if ( path . indexOf ( " / " ) ! = 0 ) { path = " / " + path ; } int port = getPort ( ) ; String host = uri . getHost ( ) + ( port ! = WebSocket . DEFAULT_PORT ? " : " + port : " " ) ; String origin = null ; HandshakedataImpl1 handshake = new HandshakedataImpl1 ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( " Upgrade " , " WebSocket " ) ; handshake . put ( " Connection " , " Upgrade " ) ; handshake . put ( " Host " , host ) ; handshake . put ( " Origin " , origin ) ; conn . startHandshake ( handshake ) ; }
private HttpServer function ( final MocoConfiguration arg0 , final MocoCertificate arg1 ) { Resource resource = getResource ( arg0 ) ; int port = arg0 . port ( ) ; if ( arg1 ! = null ) { return jsonHttpsServer ( port , resource , newCertificate ( arg1 ) ) ; } return jsonHttpServer ( port , resource ) ; }
public static MocoJunitRunner function ( final RestServer arg0 ) { checkNotNull ( arg0 , " Server should not be null " ) ; return httpRunner ( arg0 ) ; }
Opcode function ( byte arg0 ) throws InvalidFrameException { switch ( arg0 ) { case 0 :
public void function ( ) { setTrialEnabled ( false ) ; Logger logger = LoggerFactory . getLogger ( String . class ) ; assertEquals ( " java.lang.String " , logger . getName ( ) ) ; assertMismatchDetected ( false ) ; }
public static ActualHttpServer function ( final Optional < Integer > arg0 , final MocoMonitor arg1 , final MocoConfig . . . arg2 ) { return new ActualHttpServer ( arg0 , Optional . < HttpsCertificate > absent ( ) , arg1 , arg2 ) ; }
@Test public void function ( ) { CharacterReader r = new CharacterReader ( " One TWO three " ) ; assertTrue ( r . containsIgnoreCase ( " two " ) ) ; assertTrue ( r . containsIgnoreCase ( " three " ) ) ; assertFalse ( r . containsIgnoreCase ( " one " ) ) ; }
public Elements function ( ) { return new Elements ( childElementsList ( ) ) ; }
public void function ( String arg0 ) { Set < WebSocket > con = connections ( ) ; synchronized ( con ) { for ( WebSocket c : con ) {
public Element function ( String arg0 ) { Element child = new Element ( Tag . valueOf ( arg0 , NodeUtils . parser ( this ) . settings ( ) ) , baseUri ( ) ) ; appendChild ( child ) ; return child ; }
private static void function ( ClassLoader arg0 , LogFactory arg1 ) { if ( arg0 ! = null & & arg1 ! = null ) factories . put ( arg0 , arg1 ) ;
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( ! ( arg0 instanceof Tag ) ) return false ; Tag tag = ( Tag ) arg0 ; if ( ! tagName . equals ( tag . tagName ) ) return false ; if ( canContainInline ! = tag . canContainInline ) return false ; if ( empty ! = tag . empty ) return false ; if ( formatAsBlock ! = tag . formatAsBlock ) return false ; if ( isBlock ! = tag . isBlock ) return false ; if ( preserveWhitespace ! = tag . preserveWhitespace ) return false ; if ( selfClosing ! = tag . selfClosing ) return false ; if ( formList ! = tag . formList ) return false ; return formSubmit = = tag . formSubmit ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.2.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 800 ) ; }
@Test public void function ( ) { String html = " <body><form><input id=1><input id=2></form></body> " ; Document doc = Jsoup . parse ( html ) ; Element el = doc . select ( " form " ) . first ( ) ; assertTrue ( " Is form element " , el instanceof FormElement ) ; FormElement form = ( FormElement ) el ; Elements controls = form . elements ( ) ; assertEquals ( 2 , controls . size ( ) ) ; assertEquals ( " 1 " , controls . get ( 0 ) . id ( ) ) ; assertEquals ( " 2 " , controls . get ( 1 ) . id ( ) ) ; }
public Element function ( ) { Element html = htmlEl ( ) ; for ( Element el : html . childElementsList ( ) ) { if ( el . normalName ( ) . equals ( " head " ) ) return el ; } return html . prependElement ( " head " ) ; }
private int function ( ) { buffer . clear ( ) ; try { int charsRead = in . read ( buffer ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { switch ( arg1 . consume ( ) ) { case '/' :
private HttpServer function ( List < SessionSetting > arg0 , int arg1 , MocoConfig . . . arg2 ) { HttpServer server = new ActualHttpServer ( arg1 , arg2 ) ; for ( SessionSetting session : arg0 ) { logger . debug ( " Parse session: {} " , session ) ; if ( session . isMount ( ) ) { MountSetting mount = session . getMount ( ) ; server . mount ( mount . getDir ( ) , to ( mount . getUri ( ) ) , mount . getMountPredicates ( ) ) ; } else if ( session . isAnyResponse ( ) ) { server . response ( session . getResponseHandler ( ) ) ; } else if ( session . isRedirectResponse ( ) ) { server . request ( session . getRequestMatcher ( ) ) . redirectTo ( session . getRedirectTo ( ) ) ; } else { server . request ( session . getRequestMatcher ( ) ) . response ( session . getResponseHandler ( ) ) ; } } return server ; }
@Test public void function ( ) { String h = " <!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven  " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <!DOCTYPE html><html><head></head><body>OneTwoThree<link>FourFive Six Seven </body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
private static void function ( Element arg0 ) { assertEquals ( " var foo = 5 < 2; var bar = 1 && 2; " , arg0 . text ( ) ) ; assertEquals ( " var foo = 5 < 2; var bar = 1 && 2; " , arg0 . ownText ( ) ) ; assertEquals ( " var foo = 5 < 2; \ nvar bar = 1 && 2; " , arg0 . wholeText ( ) ) ; assertEquals ( " var foo = 5 &lt; 2; \ nvar bar = 1 &amp;&amp; 2; " , arg0 . html ( ) ) ; assertEquals ( " " , arg0 . data ( ) ) ; }
static public void function ( ) throws Exception { System . setErr ( SPS ) ; System . setProperty ( SIMPLE_LOGGER_THREAD_NAME_PROPERTY , " false " ) ; }
public Whitelist function ( String arg0 , String arg1 , String . . . arg2 ) { Validate . notEmpty ( arg0 ) ; Validate . notEmpty ( arg1 ) ; Validate . notNull ( arg2 ) ; TagName tagName = TagName . valueOf ( arg0 ) ; AttributeKey attrKey = AttributeKey . valueOf ( arg1 ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . arg2 . containsKey ( tagName ) ) { attrMap = this . arg2 . get ( tagName ) ; } else { attrMap = new HashMap < AttributeKey , Set < Protocol > > ( ) ; this . arg2 . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet < Protocol > ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : arg2 ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }
private MocoConfig [ ] function ( final RunnerSetting arg0 ) { ImmutableList . Builder < MocoConfig > builder = ImmutableList . builder ( ) ; arg0 . context ( ) . ifPresent ( builder : : add ) ; arg0 . fileRoot ( ) . ifPresent ( builder : : add ) ; arg0 . request ( ) . ifPresent ( builder : : add ) ; arg0 . response ( ) . ifPresent ( builder : : add ) ; return toArray ( builder . build ( ) , MocoConfig . class ) ; }
public static FileRunner function ( final Iterable < File > arg0 , final StartArgs arg1 ) { return new FileRunner ( ) { @Override
@Test public void function ( ) { String html = " <a =empty /> " ; Element el = Jsoup . parse ( html ) . getElementsByTag ( " a " ) . get ( 0 ) ; Attributes attr = el . attributes ( ) ; assertEquals ( 0 , attr . size ( ) ) ; }
public void function ( ) throws InterruptedException { assertEquals ( DurationUnit . NANOSECOND , Util . selectDurationUnitForDisplay ( 10 ) ) ; assertEquals ( DurationUnit . NANOSECOND , Util . selectDurationUnitForDisplay ( 9 * Util . NANOS_IN_ONE_MICROSECOND ) ) ; assertEquals ( DurationUnit . MICROSECOND , Util . selectDurationUnitForDisplay ( 11 * Util . NANOS_IN_ONE_MICROSECOND ) ) ; assertEquals ( DurationUnit . MICROSECOND , Util . selectDurationUnitForDisplay ( 9 * Util . NANOS_IN_ONE_MILLISECOND ) ) ; assertEquals ( DurationUnit . MILLISSECOND , Util . selectDurationUnitForDisplay ( 11 * Util . NANOS_IN_ONE_MILLISECOND ) ) ; assertEquals ( DurationUnit . SECOND , Util . selectDurationUnitForDisplay ( 11 * Util . NANOS_IN_ONE_SECOND ) ) ; }
public void function ( ) { logger . debug ( message , param1 , param2 , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . DEBUG , twoParams , exception ) ; }
public synchronized void function ( int arg0 , String arg1 , boolean arg2 ) { if ( getReadyState ( ) = = READYSTATE . CLOSED ) { return ; } if ( getReadyState ( ) = = READYSTATE . OPEN ) { if ( arg0 = = CloseFrame . ABNORMAL_CLOSE ) { setReadyState ( READYSTATE . CLOSING ) ; } } if ( key ! = null ) { key . cancel ( ) ; } if ( channel ! = null ) { try { channel . close ( ) ; } catch ( IOException e ) { if ( e . getMessage ( ) . equals ( " Broken pipe " ) ) { if ( WebSocketImpl . DEBUG ) { System . out . println ( " Caught IOException: Broken pipe during closeConnection() " ) ; } } else { wsl . onWebsocketError ( this , e ) ; } } } try { this . wsl . onWebsocketClose ( this , arg0 , arg1 , arg2 ) ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; } if ( draft ! = null ) draft . reset ( ) ; handshakerequest = null ; setReadyState ( READYSTATE . CLOSED ) ; }
public Handshakedata function ( ByteBuffer arg0 ) throws InvalidHandshakeException { HandshakeBuilder bui = translateHandshakeHttp ( arg0 ) ; ByteBuffer key3buf = readLine ( arg0 ) ; byte [ ] key3 = new byte [ key3buf . remaining ( ) ] ; key3buf . get ( key3 ) ; bui . setContent ( key3 ) ; return bui ; }
public final HttpArgs function ( ) { return new HttpArgs ( port , shutdownPort , configurationFile , settings , env ) ; }
public String function ( String arg0 , Variable arg1 ) { return arg1 . toString ( request ) ; }
public void function ( SessionContext arg0 ) { FullHttpResponse response = arg0 . getResponse ( ) ; ByteBuf buffer = Unpooled . buffer ( ) ; writeContentResponse ( arg0 . getRequest ( ) , buffer ) ; response . content ( ) . writeBytes ( buffer ) ; addHeader ( response , HttpHeaders . CONTENT_LENGTH , buffer . writerIndex ( ) ) ; if ( ! detector . hasContentType ( response ) ) { addHeader ( response , HttpHeaders . CONTENT_TYPE , getContentType ( arg0 . getRequest ( ) ) ) ;
private static Tag function ( String arg0 ) { Tag inline = new Tag ( arg0 ) ; inline . isBlock = false ; inline . canContainBlock = false ; return register ( inline ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
protected Runner function ( final String [ ] arg0 ) { StartArgs startArgs = parse ( ServerType . SOCKET , arg0 ) ; return factory . createRunner ( startArgs ) ; }
protected boolean function ( HttpRequest arg0 , HttpResponse arg1 ) { return " HEAD " . equalsIgnoreCase ( arg0 . getRequestLine ( ) . getMethod ( ) ) | | super . canResponseHaveBody ( arg0 , arg1 ) ;
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; logger . entry ( ) ; logger . entry ( 1 ) ; logger . entry ( " test " ) ; assertEquals ( 3 , listAppender . list . size ( ) ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 0 ) , " entry " ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 1 ) , " entry with (1) " ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 2 ) , " entry with (test) " ) ; }
private void function ( ) throws IOException { ByteBuffer ch = ByteBuffer . allocate ( ( this . remoteHandshake ! = null ? this . remoteHandshake . capacity ( ) : 0 ) + this . buffer . capacity ( ) ) ; if ( this . remoteHandshake ! = null ) { this . remoteHandshake . rewind ( ) ; ch . put ( this . remoteHandshake ) ; } ch . put ( this . buffer ) ; this . remoteHandshake = ch ; byte [ ] h = this . remoteHandshake . array ( ) ; if ( ( h . length > = 4 & & h [ h . length - 4 ] = = CR & & h [ h . length - 3 ] = = LF
public void function ( ) throws IOException { runWithConfiguration ( " jsonpath.json " ) ; assertThat ( helper . postContent ( remoteUrl ( " /jsonpath " ) , " { \" book \" :[{ \" price \" : \" 1 \" }]} " ) , is ( " response_for_json_path_request " ) ) ; }
private void function ( arg0 . arg1 . arg2 . Level arg3 , ResourceBundle arg4 , String arg5 , Throwable arg6 , Object . . . arg7 ) { String message = getResourceStringOrMessage ( arg4 , arg5 ) ; LoggingEventBuilder leb = slf4jLogger . makeLoggingEventBuilder ( arg3 ) ; if ( arg6 ! = null ) { leb = leb . setCause ( arg6 ) ; } if ( arg7 ! = null & & arg7 . length > 0 ) { for ( Object p : arg7 ) { leb = leb . addArgument ( p ) ; } message = String . format ( message , arg7 ) ; } if ( leb instanceof CallerBoundaryAware ) { CallerBoundaryAware cba = ( CallerBoundaryAware ) leb ; cba . setCallerBoundary ( PRESUMED_CALLER_BOUNDARY ) ; } leb . log ( message ) ; }
public void function ( Handshakedata arg0 ) { if ( handshakeComplete ) throw new IllegalStateException ( " Handshake has allready been sent. " ) ; this . handshakerequest = arg0 ;
static void function ( ) { if ( INITIALIZED ) { return ; } INITIALIZED = true ; loadProperties ( ) ; String defaultLogLevelString = getStringProperty ( DEFAULT_LOG_LEVEL_KEY , null ) ; if ( defaultLogLevelString ! = null ) DEFAULT_LOG_LEVEL = stringToLevel ( defaultLogLevelString ) ; SHOW_LOG_NAME = getBooleanProperty ( SHOW_LOG_NAME_KEY , SHOW_LOG_NAME ) ; SHOW_SHORT_LOG_NAME = getBooleanProperty ( SHOW_SHORT_LOG_NAME_KEY , SHOW_SHORT_LOG_NAME ) ; SHOW_DATE_TIME = getBooleanProperty ( SHOW_DATE_TIME_KEY , SHOW_DATE_TIME ) ; SHOW_THREAD_NAME = getBooleanProperty ( SHOW_THREAD_NAME_KEY , SHOW_THREAD_NAME ) ; DATE_TIME_FORMAT_STR = getStringProperty ( DATE_TIME_FORMAT_KEY , DATE_TIME_FORMAT_STR ) ; LEVEL_IN_BRACKETS = getBooleanProperty ( LEVEL_IN_BRACKETS_KEY , LEVEL_IN_BRACKETS ) ; WARN_LEVEL_STRING = getStringProperty ( WARN_LEVEL_STRING_KEY , WARN_LEVEL_STRING ) ; LOG_FILE = getStringProperty ( LOG_FILE_KEY , LOG_FILE ) ; TARGET_STREAM = computeTargetStream ( LOG_FILE ) ; if ( DATE_TIME_FORMAT_STR ! = null ) { try {
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { String requestOrigin = arg0 . getHeader ( " Origin " ) ; if ( Strings . isNullOrEmpty ( requestOrigin ) ) { return ; } if ( isSimpleRequest ( arg0 ) ) { writeSimpleResponse ( arg0 , arg1 , CorsConfig : : isSimpleRequestConfig ) ; return ; } if ( arg0 . getMethod ( ) = = HttpMethod . OPTIONS ) { writeOptionResponse ( arg0 , arg1 ) ; return ; } writeNoSimpleResponse ( arg0 , arg1 ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( isWarnEnabled ( ) ) { handleArgArrayCall ( Level . WARN , null , arg0 , arg1 ) ;
public static DefaultFailoverExecutor function ( final String arg0 ) { return new DefaultFailoverExecutor ( new File ( arg0 ) ) ; }
public void function ( ) { Evaluator . IndexEquals evaluator = new Evaluator . IndexEquals ( 5 ) ; assertEquals ( " :eq(5) " , evaluator . toString ( ) ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div class='mellow yellow'></div> " ) ; Element div = doc . select ( " div " ) . first ( ) ; div . addClass ( " green " ) ; assertEquals ( " mellow yellow green " , div . className ( ) ) ; div . removeClass ( " red " ) ; div . removeClass ( " yellow " ) ; assertEquals ( " mellow green " , div . className ( ) ) ; div . toggleClass ( " green " ) . toggleClass ( " red " ) ; assertEquals ( " mellow red " , div . className ( ) ) ; }
private void function ( ByteBuffer arg0 ) { List < Framedata > frames ; try { frames = draft . translateFrame ( arg0 ) ;
public byte [ ] function ( FullHttpRequest arg0 ) { return version . readFor ( arg0 ) ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { broadcast ( " new connection:  " + arg1 . getResourceDescriptor ( ) ) ;
public void function ( ) throws Exception { RequestHit hit = requestHit ( ) ; server = httpServer ( port ( ) , hit ) ; server . request ( by ( uri ( " /target " ) ) ) . response ( " proxy " ) ; final File file = tempFolder . newFile ( ) ; System . out . println ( file . getAbsolutePath ( ) ) ; server . request ( by ( uri ( " /proxy_playback " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) , playback ( file . getAbsolutePath ( ) ) ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /proxy_playback " ) ) , is ( " proxy " ) ) ; System . out . println ( " First request " ) ; assertThat ( helper . get ( remoteUrl ( " /proxy_playback " ) ) , is ( " proxy " ) ) ; System . out . println ( " Second request " ) ; } ) ; hit . verify ( by ( uri ( " /target " ) ) , once ( ) ) ; }
static String function ( String arg0 , CharsetEncoder arg1 , EscapeMode arg2 ) { StringBuilder accum = new StringBuilder ( arg0 . length ( ) * 2 ) ; Map < Character , String > map = arg2 = = EscapeMode . extended ? fullByVal : baseByVal ; for ( int pos = 0 ; pos < arg0 . length ( ) ; pos + + ) { Character c = arg0 . charAt ( pos ) ; if ( map . containsKey ( c ) ) accum . append ( '&' ) . append ( map . get ( c ) ) . append ( ';' ) ; else if ( arg1 . canEncode ( c ) ) accum . append ( c . charValue ( ) ) ; else accum . append ( " &# " ) . append ( ( int ) c ) . append ( ';' ) ; } return accum . toString ( ) ; }
public void function ( Thread arg0 , Throwable arg1 ) { if ( arg1 . getMessage ( ) . contains ( " Multiple threads " ) ) multiThreadExceptions . incrementAndGet ( ) ; else arg1 . printStackTrace ( ) ; exceptionCount . incrementAndGet ( ) ; }
protected static boolean function ( String arg0 , String arg1 , Document . OutputSettings arg2 ) { return ( arg1 = = null | | " " . equals ( arg1 ) | | arg1 . equalsIgnoreCase ( arg0 ) ) & & arg2 . syntax ( ) = = Document . OutputSettings . Syntax . html
private void function ( List < ByteBuffer > arg0 ) throws InterruptedException { for ( ByteBuffer b : arg0 ) { channelWrite ( b ) ;
public void function ( ) throws Exception { testProtocolRejection ( 28 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " opc " ) ) ) ) ; }
public final void function ( Object arg0 , Throwable arg1 ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_ERROR ) ) { log ( SimpleLog . LOG_LEVEL_ERROR , arg0 , arg1 ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeToAny ( '\t' , '\n' , '\r' , '\f' , ' ' , '&' , '>' , nullChar , '"' , '\'' , '<' , '=' , '`' ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\t' :
public void function ( Node arg0 , int arg1 ) { if ( ! arg0 . nodeName ( ) . equals ( " #text " ) ) arg0 . outerHtmlTail ( accum , arg1 , out ) ;
public RequestMatcher function ( RequestSetting arg0 ) { String file = arg0 . getFile ( ) ; if ( file = = null ) { return null ; } try { return by ( stream ( new FileInputStream ( file ) ) ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 60 ) ; }
public void function ( ) throws Exception { Mp3RenameForTesting mp3Rename = new Mp3RenameForTesting ( TRACK , null , TITLE , ALBUM , null , GENRE ) ; String newFilename = mp3Rename . composeNewFilename ( " WHATEVER " , " @N - @A - @T - @L - @Y - @G " ) ; assertEquals ( " 0 " + TRACK + "  - -  " + TITLE + "  -  " + ALBUM + "  - -  " + GENRE_DESCRIPTION , newFilename ) ; }
@Test public void function ( ) { String h = " <div><p>Hello<p>there<p>world</div> " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " Hello there world " , doc . select ( " div > * " ) . text ( ) ) ; }
public void function ( ServerHandshake arg0 ) { System . out . println ( " opened connection " ) ;
protected RestServer function ( final int arg0 ) { return restServer ( arg0 , log ( ) ) ; }
private ChannelFuture function ( HttpRequest arg0 , BaseRequestSetting arg1 , Channel arg2 ) { arg1 . handleRequest ( arg0 , arg2 ) ; return arg2 . write ( createResponse ( arg1 ) ) ; }
public void function ( ) throws IOException { Path in = getPath ( " /htmltests/fake-gzip.html.gz " ) ; Document doc = Jsoup . parse ( in , null ) ; assertEquals ( " This is not gzipped " , doc . title ( ) ) ; assertEquals ( " And should still be readable. " , doc . selectFirst ( " p " ) . text ( ) ) ; }
public void function ( ) { readingState = false ; this . currentFrame = null ; }
public void function ( Component arg0 , Component arg1 , int arg2 , int arg3 ) { sl . putConstraint ( SpringLayout . WEST , arg1 , arg2 , SpringLayout . WEST , arg0 ) ; sl . putConstraint ( SpringLayout . NORTH , arg1 , arg3 , SpringLayout . SOUTH , arg0 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public boolean function ( final Request arg0 ) { MessageContent pingContent = this . ping . readFor ( arg0 ) ; return arg0 . getContent ( ) . equals ( pingContent ) ; }
public void function ( ) throws IOException { String url = " https://jsoup.org " ; Document doc = Jsoup . parse ( new URL ( url ) , 10 * 1000 ) ; assertTrue ( doc . title ( ) . contains ( " jsoup " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public String function ( ) { return " </ " + toStringName ( ) + " > " ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div><p>Hello</p></div><div><p>There</p></div> " ) ; Elements divs = doc . select ( " div " ) ; assertEquals ( " <p>Hello</p> \ n<p>There</p> " , divs . html ( ) ) ; }
public void function ( Framedata arg0 ) throws InvalidDataException { if ( ( arg0 instanceof ContinuousFrame ) & & ( arg0 . isRSV1 ( ) | | arg0 . isRSV2 ( ) | | arg0 . isRSV3 ( ) ) ) { throw new InvalidFrameException ( " bad rsv RSV1:  " + arg0 . isRSV1 ( ) + "  RSV2:  " + arg0 . isRSV2 ( ) + "  RSV3:  " + arg0 . isRSV3 ( ) ) ; } super . isFrameValid ( arg0 ) ; }
public void function ( ) throws Exception { byte [ ] buffer = loadFile ( " src/test/resources/v23unicodetags.mp3 " ) ; ID3v2 id3tag = ID3v2TagFactory . createTag ( buffer ) ; assertEquals ( " \ u03B3 \ u03B5 \ u03B9 \ u03AC  \ u03C3 \ u03BF \ u03C5 " , id3tag . getArtist ( ) ) ; assertEquals ( " \ u4E2D \ u6587 " , id3tag . getTitle ( ) ) ; assertEquals ( " \ u3053 \ u3093 \ u306B \ u3061 \ u306F " , id3tag . getAlbum ( ) ) ; assertEquals ( " \ u0AB9 \ u0AC7 \ u0AB2 \ u0ACD \ u0AB2 \ u0ACB " , id3tag . getComposer ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { delegate ( ) . error ( arg0 , arg1 , arg2 ) ; }
public static SocketServer function ( Resource arg0 ) { Optional < Integer > port = Optional . absent ( ) ; return jsonSocketServer ( arg0 , port ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " xpath.json " , PORT ) ; assertThat ( helper . postFile ( " http://localhost:8080/xpath " , " foo.xml " ) , is ( " response_for_xpath_request " ) ) ; }
public String function ( ) { return String . format ( " :not(%s) " , evaluator ) ; }
@Test public void function ( ) throws IOException { File in = new ParseTest ( ) . getFile ( " /htmltests/yahoo-jp.html " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " , " http://www.yahoo.co.jp/index.html " ) ; String location = doc . location ( ) ; String baseUri = doc . baseUri ( ) ; assertEquals ( " http://www.yahoo.co.jp/index.html " , location ) ; assertEquals ( " http://www.yahoo.co.jp/_ylh=X3oDMTB0NWxnaGxsBF9TAzIwNzcyOTYyNjUEdGlkAzEyBHRtcGwDZ2Ex/ " , baseUri ) ; in = new ParseTest ( ) . getFile ( " /htmltests/nyt-article-1.html " ) ; doc = Jsoup . parse ( in , null , " http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp " ) ; location = doc . location ( ) ; baseUri = doc . baseUri ( ) ; assertEquals ( " http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp " , location ) ; assertEquals ( " http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp " , baseUri ) ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " testMarker " ) ; Marker blue = MarkerFactory . getMarker ( " BLUE " ) ; logger . trace ( blue , " hello " ) ; logger . debug ( blue , " hello " ) ; logger . info ( blue , " hello " ) ; logger . warn ( blue , " hello " ) ; logger . error ( blue , " hello " ) ; logger . debug ( blue , " hello {} " , " world " ) ; logger . info ( blue , " hello {} " , " world " ) ; logger . warn ( blue , " hello {} " , " world " ) ; logger . error ( blue , " hello {} " , " world " ) ; logger . debug ( blue , " hello {} and {}  " , " world " , " universe " ) ; logger . info ( blue , " hello {} and {}  " , " world " , " universe " ) ; logger . warn ( blue , " hello {} and {}  " , " world " , " universe " ) ; logger . error ( blue , " hello {} and {}  " , " world " , " universe " ) ; assertEquals ( 12 , listAppender . list . size ( ) ) ; }
public int function ( final int arg0 , ChannelHandler arg1 ) { ServerBootstrap bootstrap = new ServerBootstrap ( ) ; bootstrap . group ( bossGroup , workerGroup ) . channel ( NioServerSocketChannel . class ) . childHandler ( arg1 ) . option ( ChannelOption . TCP_NODELAY , true ) . childOption ( ChannelOption . SO_KEEPALIVE , true ) ; try { future = bootstrap . bind ( arg0 ) . sync ( ) ;
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; ProtocolVersion version = helper . execute ( Request . get ( remoteUrl ( " /version10 " ) ) ) . getVersion ( ) ; assertThat ( version . getProtocol ( ) , is ( " HTTP " ) ) ; assertThat ( version . getMajor ( ) , is ( 1 ) ) ; assertThat ( version . getMinor ( ) , is ( 0 ) ) ; }
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final String arg1 ) { return contain ( checkNotNull ( arg0 , " Extractor should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Expected resource should not be null " ) ) ) ;
private static Maps . EntryTransformer < String , TextContainer , RequestExtractor < ? > > toVariable ( ) { return new Maps . EntryTransformer < String , TextContainer , RequestExtractor < ? > > ( ) { @Override
private Predicate < Session > function ( final Request arg0 ) { return new Predicate < Session > ( ) { @Override
public void function ( ByteBuffer arg0 ) throws IllegalArgumentException , WebsocketNotConnectedException { if ( arg0 = = null ) throw new IllegalArgumentException ( " Cannot send 'null' data to a WebSocketImpl. " ) ; send ( draft . createFrames ( arg0 , role = = Role . CLIENT ) ) ; }
public void function ( Attributes arg0 ) { if ( arg0 . size ( ) = = 0 ) return ; if ( attributes = = null ) attributes = new LinkedHashMap < String , Attribute > ( arg0 . size ( ) ) ; attributes . putAll ( arg0 . attributes ) ; }
public void function ( String arg0 ) { if ( isDebugEnabled ( ) ) { handle_0ArgsCall ( Level . DEBUG , null , arg0 , null ) ;
public void function ( Object arg0 ) { logger . log ( null , FQCN , LocationAwareLogger . ERROR_INT , String . valueOf ( arg0 ) , null , null ) ; }
public void function ( ) throws Exception { ID3v2CommentFrameData frameData = new ID3v2CommentFrameData ( false , TEST_LANGUAGE , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , new EncodedText ( ( byte ) 0 , TEST_VALUE ) ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 0 , 'e' , 'n' , 'g' , 'D' , 'E' , 'S' , 'C' , 'R' , 'I' , 'P' , 'T' , 'I' , 'O' , 'N' , 0 , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' } ; assertTrue ( Arrays . equals ( expectedBytes , bytes ) ) ; ID3v2CommentFrameData frameDataCopy = new ID3v2CommentFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
int function ( Handshakedata arg0 ) { String vers = arg0 . getFieldValue ( " Sec-WebSocket-Version " ) ; if ( vers . length ( ) > 0 ) { int v ; try { v = new Integer ( vers . trim ( ) ) ; return v ; } catch ( NumberFormatException e ) { return - 1 ; } } return - 1 ; }
public boolean function ( ) throws InterruptedException { reset ( ) ; return connectBlocking ( ) ; }
public boolean function ( ) { return outCrypt . hasRemaining ( ) | | ! isHandShakeComplete ( ) ; }
public void function ( ) { Document doc = Jsoup . parse ( mixedCase , " " , Parser . xmlParser ( ) ) ; assertEquals ( 1 , doc . select ( " *|mixedCase " ) . size ( ) ) ; }
protected Setting < SocketResponseSetting > function ( final RequestMatcher arg0 , final MocoConfig arg1 ) { SocketSetting setting = new SocketSetting ( arg0 ) ; setting . handler = configItem ( this . handler , arg1 ) ; setting . eventTriggers = configItems ( eventTriggers , arg1 ) ; return setting ; }
public MocoEventAction function ( final MocoConfig arg0 ) { Resource appliedContent = this . content . apply ( arg0 ) ; if ( appliedContent ! = this . content ) { ImmutableMap . Builder < String , Resource > builder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , Resource > entry : headers . entrySet ( ) ) { builder . put ( entry . getKey ( ) , entry . getValue ( ) ) ; } return new MocoPostRequestAction ( this . getUrl ( ) , ( ContentResource ) appliedContent , builder . build ( ) ) ; } return this ; }
public static Document function ( File arg0 , String arg1 ) throws IOException { String html = DataUtil . load ( arg0 , arg1 ) ; return parse ( html , arg0 . getAbsolutePath ( ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>Hello " ) ; Element p = doc . select ( " p " ) . first ( ) ; assertTrue ( p . ownerDocument ( ) = = doc ) ; assertTrue ( doc . ownerDocument ( ) = = doc ) ; assertNull ( doc . parent ( ) ) ; }
public final boolean function ( ) { return isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ; }
private String function ( String arg0 , String arg1 ) throws IOException { InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( arg0 ) ; Content content = Request . Post ( arg1 ) . bodyByteArray ( toByteArray ( is ) ) . execute ( ) . returnContent ( ) ; return content . asString ( ) ; }
public void function ( arg0 final Path arg1 ) throws IOException { Path tempFile = arg1 . resolve ( " glob.json " ) ; java . nio . file . Files . createFile ( tempFile ) ; File file = tempFile . toFile ( ) ; String glob = Files . join ( arg1 . toFile ( ) . getAbsolutePath ( ) , " *.json " ) ; ImmutableList < String > files = Globs . glob ( glob ) ; assertThat ( files . contains ( file . getAbsolutePath ( ) ) , is ( true ) ) ; }
public OutputSettings function ( Entities . EscapeMode arg0 ) { this . arg0 = arg0 ; return this ; }
private void function ( ) { String tagName = tq . consumeWord ( ) ; Validate . notEmpty ( tagName ) ; elements . addAll ( root . getElementsByTag ( tagName ) ) ; }
public void function ( ) throws Exception { server . response ( json ( ( request ) - > { PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; return Jsons . toJson ( pojo ) ; } ) ) ; final PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; running ( server , ( ) - > JsonSupport . assertEquals ( pojo , helper . getResponse ( root ( ) ) ) ) ; }
public boolean function ( Element arg0 ) { return ( arg0 . hasAttr ( key ) ) ; }
private static String function ( final Connection . Request arg0 ) { boolean needsMulti = false ; for ( Connection . KeyVal keyVal : arg0 . data ( ) ) { if ( keyVal . hasInputStream ( ) ) { needsMulti = true ; break ; } } if ( needsMulti ) { final String bound = DataUtil . mimeBoundary ( ) ; arg0 . header ( CONTENT_TYPE , MULTIPART_FORM_DATA + " ; boundary= " + bound ) ; return bound ; } return null ; }
public void function ( Framedata arg0 ) { ByteBuffer b = arg0 . getPayloadData ( ) ; if ( unmaskedpayload = = null ) { unmaskedpayload = ByteBuffer . allocate ( b . remaining ( ) ) ; b . mark ( ) ; unmaskedpayload . put ( b ) ; b . reset ( ) ; } else { b . mark ( ) ; unmaskedpayload . position ( unmaskedpayload . limit ( ) ) ; unmaskedpayload . limit ( unmaskedpayload . capacity ( ) ) ; if ( b . remaining ( ) > unmaskedpayload . remaining ( ) ) { ByteBuffer tmp = ByteBuffer . allocate ( b . remaining ( ) + unmaskedpayload . capacity ( ) ) ; unmaskedpayload . flip ( ) ; tmp . put ( unmaskedpayload ) ; tmp . put ( b ) ; unmaskedpayload = tmp ; } else { unmaskedpayload . put ( b ) ; } unmaskedpayload . rewind ( ) ; b . reset ( ) ; } fin = arg0 . isFin ( ) ; }
protected final boolean function ( ) { return value instanceof Attributes ; }
@Test ( expected = IllegalArgumentException . class ) public void function ( ) { Attribute attr = new Attribute ( " One " , " Check " ) ; attr . setKey ( "   " ) ; }
private HttpRequestBase function ( final String arg0 , final String arg1 ) { if ( HttpMethod . GET . name ( ) . equalsIgnoreCase ( arg1 ) ) { return new HttpGet ( arg0 ) ; } if ( HttpMethod . POST . name ( ) . equalsIgnoreCase ( arg1 ) ) { return new HttpPost ( arg0 ) ; } throw new MocoException ( format ( " unknown HTTP method: %s " , arg1 ) ) ; }
static String function ( String arg0 ) { return arg0 . replaceFirst ( " ^ \\ s+ " , " " ) ; }
public void function ( final SessionContext arg0 ) { HttpRequest request = arg0 . getRequest ( ) ; Optional < URL > url = remoteUrl ( ( ( DefaultHttpRequest ) request ) . toFullHttpRequest ( ) ) ; if ( ! url . isPresent ( ) ) { return ; } writeResponse ( arg0 . getResponse ( ) , doProxy ( request , url . get ( ) ) ) ; }
public void function ( ) { byte [ ] buffer = new byte [ ID3v1Tag . TAG_LENGTH + 1 ] ; try { new ID3v1Tag ( buffer ) ;
public void function ( ) { DumpHttpRequest request = new DumpHttpRequest ( ) ; request . setVersion ( " HTTP/1.1 " ) ; request . setMethod ( " POST " ) ; request . setContent ( " proxy " ) ; request . addHeader ( " Cookie " , " loggedIn=true " ) ; request . addHeader ( " Host " , " localhost:12306 " ) ; request . setUri ( " /foo " ) ; DumpHttpRequest another = new DumpHttpRequest ( ) ; another . setVersion ( " HTTP/1.1 " ) ; another . setMethod ( " POST " ) ; another . setContent ( " proxy " ) ; another . addHeader ( " Cookie " , " loggedIn=true " ) ; another . addHeader ( " Host " , " localhost:12306 " ) ; another . setUri ( " /bar " ) ; assertThat ( new HttpRequestFailoverMatcher ( request ) . match ( another ) , is ( false ) ) ; }
private void function ( HtmlTreeBuilder arg0 ) { if ( arg0 . inTableScope ( " td " ) ) arg0 . process ( new Token . EndTag ( " td " ) ) ;
public void function ( ) throws Exception { final File response = File . createTempFile ( " response " , " .tmp " ) ; changeFileContent ( response , " foo " ) ; final File cacheFile = File . createTempFile ( " cache " , " .tmp " ) ; server . response ( cache ( file ( response . getAbsolutePath ( ) ) , with ( file ( cacheFile . getAbsolutePath ( ) ) ) ) ) ; running ( server , new Runnable ( ) { @Override
public Attributes function ( String arg0 , Object arg1 ) { Validate . notNull ( arg0 ) ; if ( ! isInternalKey ( arg0 ) ) arg0 = internalKey ( arg0 ) ; Validate . notNull ( arg1 ) ; int i = indexOfKey ( arg0 ) ; if ( i ! = NotFound ) vals [ i ] = arg1 ; else addObject ( arg0 , arg1 ) ; return this ; }
public void function ( final ChannelHandlerContext arg0 , final FullHttpRequest arg1 ) { WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( uri , null , false ) ; WebSocketServerHandshaker handshaker = wsFactory . newHandshaker ( arg1 ) ; Channel channel = arg0 . channel ( ) ; if ( handshaker = = null ) { WebSocketServerHandshakerFactory . sendUnsupportedVersionResponse ( channel ) ; return ; } handshaker . handshake ( channel , arg1 ) ; connect ( channel ) ; sendConnected ( channel ) ; }
public Setting function ( RequestMatcher arg0 ) { return request ( and ( by ( method ( HttpMethod . DELETE . name ( ) ) ) , arg0 ) ) ; }
public RequestRecorder function ( final String arg0 ) { RequestRecorder recorder = recorders . get ( arg0 ) ; if ( recorder ! = null ) { return recorder ; } return recorders . computeIfAbsent ( arg0 , s - > factory . newRecorder ( ) ) ; }
private Attribute function ( ) { consumeWhitespace ( ) ; String key = consumeWord ( ) ; String value = " " ; consumeWhitespace ( ) ; if ( matches ( " = " ) ) { consume ( " = " ) ; consumeWhitespace ( ) ; if ( matches ( SQ ) ) { consume ( SQ ) ; value = chompTo ( SQ ) ; } else if ( matches ( DQ ) ) { consume ( DQ ) ; value = chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ; while ( ! matches ( " /> " ) & & ! matches ( " > " ) & & ! Character . isWhitespace ( queue . peekFirst ( ) ) ) { valueAccum . append ( consume ( ) ) ; } value = valueAccum . toString ( ) ; } consumeWhitespace ( ) ; } if ( ! key . isEmpty ( ) ) return new Attribute ( key , value ) ;
public static int function ( final String arg0 , final int [ ] arg1 ) { String val = multipoints . get ( arg0 ) ; if ( val ! = null ) { arg1 [ 0 ] = val . codePointAt ( 0 ) ; arg1 [ 1 ] = val . codePointAt ( 1 ) ; return 2 ; } int codepoint = extended . codepointForName ( arg0 ) ; if ( codepoint ! = empty ) { arg1 [ 0 ] = codepoint ; return 1 ; } return 0 ; }
public void function ( ContentStream arg0 ) { this . response ( new ContentHandler ( arg0 . asInputStream ( ) ) ) ; }
protected void function ( ) throws Exception { super . tearDown ( ) ; SLF4JBridgeHandler . uninstall ( ) ; fileAppender . close ( ) ; log4jRoot . getLoggerRepository ( ) . resetConfiguration ( ) ; for ( int i = 0 ; i < existingHandlers . length ; i + + ) { julRootLogger . addHandler ( existingHandlers [ i ] ) ;
public byte [ ] function ( FullHttpRequest arg0 ) { return reader . readFor ( arg0 ) ; }
public Node function ( ) { List < Node > siblings = parentNode . childNodes ; Integer index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( index > 0 ) return siblings . get ( index - 1 ) ;
public final ProxyContainer function ( ) { if ( this . url ! = null & & ( this . from ! = null | | this . to ! = null ) ) { throw new IllegalArgumentException ( " Proxy cannot be set in multiple mode " ) ; } if ( this . url = = null & & ( this . from = = null | | this . to = = null ) ) { throw new IllegalArgumentException ( " Batch proxy needs both 'from' and 'to' " ) ; } ProxyContainer container = new ProxyContainer ( ) ; container . url = url ; container . from = from ; container . to = to ; container . failover = ( failover ! = null ) ? new FailoverContainer ( failover ) : null ; container . playback = ( playback ! = null ) ? new FailoverContainer ( playback ) : null ; return container ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.10 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( int arg0 , String arg1 ) { switch ( arg0 ) { case LOG_DEBUG :
public ResponseSetting function ( final String arg0 ) { return this . response ( text ( checkNotNullOrEmpty ( arg0 , " Content should not be null " ) ) ) ; }
public void function ( HttpServer arg0 ) { server = new MocoHttpServer ( arg0 ) ; logger . info ( " Server is started at {} " , arg0 . getPort ( ) ) ; server . start ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.7.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) ) ; server . post ( and ( by ( uri ( " /target " ) ) , by ( " proxy " ) ) ) . response ( " 0XCAFEBABE " ) ; final File tempFile = tempFolder . newFile ( ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) , failover ( tempFile . getAbsolutePath ( ) ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( HttpServer arg0 ) { ActualHttpServer actualHttpServer = ( ActualHttpServer ) arg0 ; server = new MocoHttpServer ( actualHttpServer ) ; server . start ( ) ; logger . info ( " Server is started at {} " , actualHttpServer . port ( ) ) ; }
int [ ] function ( int [ ] arg0 ) { ArrayList < Integer > primesArray = new ArrayList < > ( ) ; for ( int i = 0 ; i < originalArrrayLength ; i + + ) { int n = arg0 [ i ] ; if ( isPrime ( n ) ) { primesArray . add ( n ) ; } } int resultSize = primesArray . size ( ) ; int [ ] result = new int [ resultSize ] ; for ( int i = 0 ; i < resultSize ; i + + ) { result [ i ] = primesArray . get ( i ) ; } return result ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 2.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
boolean function ( ) { if ( currentToken . type = = Token . TokenType . EOF ) { if ( stack = = null ) { return false ; } if ( stack . isEmpty ( ) ) { onNodeClosed ( doc ) ; stack = null ; return true ; } pop ( ) ; return true ; } final Token token = tokeniser . read ( ) ; currentToken = token ; process ( token ) ; token . reset ( ) ; return true ; }
public void function ( ) { InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " foo.request " ) ; server . request ( eq ( stream ( is ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public static Failover function ( final String arg0 ) { return new Failover ( ApiUtils . failoverExecutor ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , FailoverStrategy . PLAYBACK ) ;
public void function ( ) { Profiler profiler = new Profiler ( " BAS " ) ; profiler . start ( " doX " ) ; doX ( 1 ) ; profiler . start ( " doYYYYY " ) ; for ( int i = 0 ; i < 5 ; i + + ) { doY ( i ) ; } profiler . start ( " doZ " ) ; doZ ( 2 ) ; profiler . stop ( ) . print ( ) ; }
public void function ( Object arg0 ) { slf4jLogger . warn ( convertToString ( arg0 ) ) ; }
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " none " , false ) ; doc . updateMetaCharset ( true ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; final String xmlCharsetUTF8 = " <?xml version= \" 1.0 \"  encoding= \" " + charsetUtf8 + " \" > \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetUTF8 , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetUtf8 , selectedNode . attr ( " encoding " ) ) ; }
public void function ( ) throws IOException { int port = SocketUtil . getAvailablePort ( ) ; InetSocketAddress inetSocketAddress = new InetSocketAddress ( port ) ; MyWebSocketServer server = new MyWebSocketServer ( port ) ; assertEquals ( inetSocketAddress , server . getAddress ( ) ) ; }
public static boolean function ( ByteBuffer arg0 ) { return isValidUTF8 ( arg0 , 0 ) ; }
protected void function ( ) { } }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; TextFrame frame = new TextFrame ( ) ; try { deflateExtension . isFrameValid ( frame ) ; fail ( " Frame not valid. RSV1 must be set. " ) ; } catch ( Exception e ) { } frame . setRSV1 ( true ) ; try { deflateExtension . isFrameValid ( frame ) ; } catch ( Exception e ) { fail ( " Frame is valid. " ) ; } frame . setRSV2 ( true ) ; try { deflateExtension . isFrameValid ( frame ) ; fail ( " Only RSV1 bit must be set. " ) ; } catch ( Exception e ) { } ContinuousFrame contFrame = new ContinuousFrame ( ) ; contFrame . setRSV1 ( true ) ; try { deflateExtension . isFrameValid ( contFrame ) ; fail ( " RSV1 must only be set for first fragments.Continuous frames can't have RSV1 bit set. " ) ; } catch ( Exception e ) { } contFrame . setRSV1 ( false ) ; try { deflateExtension . isFrameValid ( contFrame ) ;
public final boolean function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { arg1 . addHeader ( " Access-Control-Expose-Headers " , String . join ( " , " , headers ) ) ; return true ; }
protected void function ( HttpRequest arg0 , FullHttpResponse arg1 , arg2 . arg3 . arg4 . HttpResponse arg5 ) throws IOException { int statusCode = arg5 . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode = = HttpResponseStatus . BAD_REQUEST . code ( ) ) { failover . failover ( arg0 , arg1 ) ; return ; } setupNormalResponse ( arg1 , arg5 ) ; failover . onCompleteResponse ( arg0 , newResponse ( arg1 ) ) ; }
public static ContentResource function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return xmlResource ( ( request ) - > arg0 ) ; }
public void function ( ) { if ( instanceofLAL & & logger . isTraceEnabled ( ENTRY_MARKER ) ) { ( ( LocationAwareLogger ) logger ) . log ( EXIT_MARKER , FQCN , LocationAwareLogger . TRACE_INT , EXIT_MESSAGE_0 , null , null ) ;
public void function ( String arg0 , Object [ ] arg1 ) { if ( logger . isInfoEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( WebSocket arg0 , Framedata arg1 ) { FrameBuilder builder = ( FrameBuilder ) arg1 ; builder . setTransferemasked ( true ) ; getConnection ( ) . sendFrame ( arg1 ) ; }
public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( InterruptedServlet . Url ) . timeout ( 200 ) . execute ( ) ; boolean threw = false ; try { res . bufferUp ( ) ; } catch ( UncheckedIOException e ) { threw = true ; } assertEquals ( true , threw ) ;
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( ! ( arg0 instanceof Attribute ) ) return false ; Attribute attribute = ( Attribute ) arg0 ; if ( key ! = null ? ! key . equals ( attribute . key ) : attribute . key ! = null ) return false ; if ( value ! = null ? ! value . equals ( attribute . value ) : attribute . value ! = null ) return false ; return true ; }
public String function ( String arg0 , String arg1 ) { CookieEncoder cookieEncoder = new CookieEncoder ( true ) ; DefaultCookie cookie = new DefaultCookie ( arg0 , arg1 ) ; cookie . setPath ( " / " ) ; cookieEncoder . addCookie ( cookie ) ; return cookieEncoder . encode ( ) ; }
public String function ( Response arg0 ) { return arg0 . getContent ( ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${foo} ${bar} " , " foo " , " ANOTHER " , " bar " , " TEMPLATE " ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /template " ) ) , is ( " ANOTHER TEMPLATE " ) ) ) ; }
public void function ( ) { DumpHttpRequest request = new DumpHttpRequest ( ) ; request . setVersion ( " HTTP/1.1 " ) ; request . setMethod ( " POST " ) ; request . setContent ( " proxy " ) ; request . addHeader ( " Cookie " , " loggedIn=true " ) ; request . addHeader ( " Host " , " localhost:12306 " ) ; DumpHttpRequest failover = new DumpHttpRequest ( ) ; failover . setVersion ( null ) ; failover . setMethod ( " POST " ) ; failover . setContent ( " proxy " ) ; failover . addHeader ( " Cookie " , " loggedIn=true " ) ; failover . addHeader ( " Host " , " localhost:12306 " ) ; assertThat ( failover . match ( failover ) , is ( true ) ) ; }
static boolean function ( String arg0 , int arg1 ) { if ( arg1 > = 2 & & arg0 . charAt ( arg1 - 2 ) = = ESCAPE_CHAR ) {
public void function ( ) throws IOException { runWithConfiguration ( " rest.json " ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; assertThat ( helper . patchForResponse ( remoteUrl ( " /targets/1 " ) , " result " ) , is ( " patch result " ) ) ; }
@Test void function ( ) { String html = " <table>foo<tr>bar<td>baz</td>qux</tr>coo</table> " ; Document doc = Jsoup . parse ( html , TrackingHtmlParser ) ; StringBuilder track = new StringBuilder ( ) ; List < TextNode > textNodes = doc . nodeStream ( TextNode . class ) . peek ( node - > accumulatePositions ( node , track ) ) . collect ( Collectors . toList ( ) ) ; assertEquals ( 5 , textNodes . size ( ) ) ; assertEquals ( " foo " , textNodes . get ( 0 ) . text ( ) ) ; assertEquals ( " bar " , textNodes . get ( 1 ) . text ( ) ) ; assertEquals ( " baz " , textNodes . get ( 2 ) . text ( ) ) ; assertEquals ( " qux " , textNodes . get ( 3 ) . text ( ) ) ; assertEquals ( " coo " , textNodes . get ( 4 ) . text ( ) ) ; assertEquals ( " #text:7-10; #text:14-17; #text:21-24; #text:29-32; #text:37-40;  " , track . toString ( ) ) ; }
public void function ( ) { Log log = LogFactory . getLog ( InvokeJCLWithNOPTest . class ) ; assertFalse ( log . isTraceEnabled ( ) ) ; assertFalse ( log . isDebugEnabled ( ) ) ; assertFalse ( log . isInfoEnabled ( ) ) ; assertFalse ( log . isWarnEnabled ( ) ) ; assertFalse ( log . isErrorEnabled ( ) ) ; assertFalse ( log . isFatalEnabled ( ) ) ; }
public static JsonPathRequestExtractor function ( final String arg0 ) { return new JsonPathRequestExtractor ( checkNotNull ( arg0 , " Null JsonPath is not allowed " ) ) ; }
public FilterResult function ( Node arg0 , int arg1 ) { if ( arg0 . hasAttributes ( ) ) { found [ 0 ] = true ;
public void function ( ) throws IOException { runWithConfiguration ( " attachment.json " ) ; assertThat ( helper . get ( remoteUrl ( " /text_attachment " ) ) , is ( " text_attachment " ) ) ; }
public void function ( ) throws IOException , InterruptedException { Runner rawRunner = new DynamicRunner ( " src/test/resources/foo.json " , port ( ) ) ; File shutdownFile = File . createTempFile ( " shutdown " , " hook " ) ; shutdownFile . delete ( ) ; runner = new ShutdownMonitorRunner ( rawRunner , shutdownFile . getAbsolutePath ( ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; shutdownFile . createNewFile ( ) ; waitChangeHappens ( ) ; helper . get ( root ( ) ) ; }
public void function ( arg0 final Path arg1 ) throws Exception { server . get ( by ( uri ( " /target " ) ) ) . response ( " get_proxy " ) ; server . post ( and ( by ( uri ( " /target " ) ) , by ( " proxy " ) ) ) . response ( " post_proxy " ) ; final File tempFile = arg1 . resolve ( " tempfile " ) . toFile ( ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) , failover ( tempFile . getAbsolutePath ( ) ) ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /proxy " ) ) , is ( " get_proxy " ) ) ;
public static ActualHttpServer function ( final int arg0 , final boolean arg1 , final int arg2 ) { if ( arg1 ) { return createHttpServer ( arg0 , null , new QuietMonitor ( ) , new ServerConfig ( MAX_HEADER_SIZE , arg2 ) ) ; } return createHttpServer ( arg0 , null , new Slf4jMonitor ( new HttpRequestDumper ( ) , new HttpResponseDumper ( ) ) , new ServerConfig ( MAX_HEADER_SIZE , arg2 ) ) ;
public void function ( String arg0 ) { checkNotNull ( arg0 , " Null content is not allowed " ) ; this . response ( new ContentHandler ( arg0 ) ) ; }
public static ResponseHandler function ( final Resource arg0 , final Resource . . . arg1 ) { checkNotNull ( arg0 , " Cycle content should not be null " ) ; checkArgument ( arg1 . length > 0 , " Cycle contents should not be null " ) ; return newCycle ( FluentIterable . from ( asIterable ( arg0 , arg1 ) ) . transform ( resourceToResourceHandler ( ) ) ) ; }
@Test void function ( ) { String html = " <head><template id=1><meta name=tmpl></template><title>Test</title><style>One</style></head><body><p>Two</p> " ; Document doc = Jsoup . parse ( html ) ; String want = " <html><head><template id= \" 1 \" ><meta name= \" tmpl \" ></template><title>Test</title><style>One</style></head><body><p>Two</p></body></html> " ; assertEquals ( want , TextUtil . stripNewlines ( doc . html ( ) ) ) ; Elements template = doc . select ( " template#1 " ) ; template . select ( " meta " ) . attr ( " content " , " Yes " ) ; template . unwrap ( ) ; want = " <html><head><meta name= \" tmpl \"  content= \" Yes \" ><title>Test</title><style>One</style></head><body><p>Two</p></body></html> " ; assertEquals ( want , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " ) ; assertThrows ( HttpResponseException . class , ( ) - > { helper . get ( remoteUrl ( " /mount-include/foo.bar " ) ) ;
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { if ( configs . length = = 0 ) { arg1 . addHeader ( " Access-Control-Allow-Origin " , " * " ) ; arg1 . addHeader ( " Access-Control-Allow-Methods " , " * " ) ; arg1 . addHeader ( " Access-Control-Allow-Headers " , " * " ) ; return ; } for ( CorsConfig config : configs ) { config . configure ( arg1 ) ;
public final MessageContent function ( final Request arg0 ) { MessageContent messageContent = reader . readFor ( arg0 ) ; if ( transformer = = null ) { return messageContent ; } return transformer . apply ( messageContent ) ; }
private void function ( final ObjectOutputStream arg0 ) throws IOException { arg0 . defaultWriteObject ( ) ; arg0 . writeInt ( level ) ; arg0 . writeInt ( syslogEquivalent ) ; arg0 . writeUTF ( levelStr ) ; }
@Test public void function ( ) { String h = " <li>Point one<li>Point two " ; Document doc = Jsoup . parse ( h ) ; Elements ol = doc . select ( " ul " ) ; assertEquals ( 0 , ol . size ( ) ) ; Elements lis = doc . select ( " li " ) ; assertEquals ( 2 , lis . size ( ) ) ; assertEquals ( " body " , lis . first ( ) . parent ( ) . tagName ( ) ) ; String h2 = " <ol><li><p>Point the first<li><p>Point the second " ; Document doc2 = Jsoup . parse ( h2 ) ; assertEquals ( 0 , doc2 . select ( " ul " ) . size ( ) ) ; assertEquals ( 1 , doc2 . select ( " ol " ) . size ( ) ) ; assertEquals ( 2 , doc2 . select ( " ol li " ) . size ( ) ) ; assertEquals ( 2 , doc2 . select ( " ol li p " ) . size ( ) ) ; assertEquals ( 1 , doc2 . select ( " ol li " ) . get ( 0 ) . children ( ) . size ( ) ) ; }
public void function ( ) { for ( MocoEventTrigger eventTrigger : eventTriggers ) { if ( eventTrigger . isFor ( MocoEvent . COMPLETE ) ) {
public static boolean function ( WebSocketImpl arg0 , ByteChannel arg1 ) throws IOException { ByteBuffer buffer = arg0 . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer = = null ) { if ( arg1 instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) arg1 ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do { arg1 . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { arg0 . outQueue . poll ( ) ; buffer = arg0 . outQueue . peek ( ) ; } } while ( buffer ! = null ) ; } if ( arg0 . outQueue . isEmpty ( ) & & arg0 . isFlushAndClose ( ) & & arg0 . getDraft ( ) . getRole ( ) = = Role . SERVER ) { synchronized ( arg0 ) { arg0 . closeConnection ( ) ; } } return c ! = null ? ! ( ( WrappedByteChannel ) arg1 ) . isNeedWrite ( ) : true ; }
default public LoggingEventBuilder function ( ) { if ( isErrorEnabled ( ) ) { return makeLoggingEventBuilder ( ERROR ) ;
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; String str = " This is a highly compressable text " + " This is a highly compressable text " + " This is a highly compressable text " + " This is a highly compressable text " + " This is a highly compressable text " ; byte [ ] message = str . getBytes ( ) ; TextFrame frame = new TextFrame ( ) ; frame . setPayload ( ByteBuffer . wrap ( message ) ) ; deflateExtension . encodeFrame ( frame ) ; assertTrue ( message . length > frame . getPayloadData ( ) . array ( ) . length ) ; }
public Integer function ( ) { if ( parent ( ) = = null ) return 0 ; return indexInList ( this , parent ( ) . childElementsList ( ) ) ; }
@Test public void function ( ) { String h = " <p>Excl</p><div class=headline><p>Hello</p><p>There</p></div><div class=headline><h1>Headline</h1></div> " ; Document doc = Jsoup . parse ( h ) ; Elements els = doc . select ( " .headline " ) . select ( " p " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " Hello " , els . get ( 0 ) . text ( ) ) ; assertEquals ( " There " , els . get ( 1 ) . text ( ) ) ; }
private ByteBuffer function ( ByteBuffer arg0 , int arg1 ) { if ( arg1 > arg0 . capacity ( ) ) { arg0 = ByteBuffer . allocate ( arg1 ) ; } else { arg0 = ByteBuffer . allocate ( arg0 . capacity ( ) * 2 ) ; } return arg0 ; }
public static SSLContext function ( HttpsCertificate arg0 ) { String algorithm = Security . getProperty ( " ssl.KeyManagerFactory.algorithm " ) ; if ( algorithm = = null ) { algorithm = DEFAULT_ALGORITHM ; } try { KeyStore keyStore = KeyStore . getInstance ( " JKS " ) ;
protected Optional < String [ ] > function ( final HttpRequest arg0 ) { final ImmutableMap < String , String > headers = arg0 . getHeaders ( ) ; String [ ] extractedValues = from ( headers . entrySet ( ) ) . filter ( isForName ( name ) ) . transform ( toValue ( ) ) . toArray ( String . class ) ; if ( extractedValues . length > 0 ) { return of ( extractedValues ) ; } return absent ( ) ; }
final public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { } }
@Override protected int function ( ) { return 2 * evaluator . cost ( ) ; }
public void function ( ) { LineConverter trivialLC = new LineConverter ( new TrivialMatcher ( ) ) ; assertEquals ( " simple replacement with an unique capturing group " , trivialLC . getOneLineReplacement ( " import org.slf4j.converter " ) ) ; assertEquals ( " 1st group second group 4th group " , trivialLC . getOneLineReplacement ( " first group second group third group 4th group " ) ) ;
boolean function ( String arg0 ) { return false ; }
public static RequestExtractor function ( String arg0 ) { RequestExtractor extractor = extractors . get ( arg0 ) ; if ( extractor = = null ) { throw new RuntimeException ( format ( " unknown extractor for [%s] " , arg0 ) ) ; } return extractor ; }
void function ( int arg0 , int arg1 , float arg2 , ProgressContext arg3 ) ; }
private Maps . EntryTransformer < String , TextContainer , TextContainer > function ( ) { return new Maps . EntryTransformer < String , TextContainer , TextContainer > ( ) { @Override
public void function ( ) throws Exception { runTestScenario ( false ) ; }
public void function ( File arg0 ) { logger . info ( " {} change detected. " , arg0 . getName ( ) ) ; try { restartRunner ( port ) ;
public boolean function ( ) throws IOException { matcher = AbstractMatcher . getMatcherImpl ( conversionType ) ; if ( matcher = = null ) { return false ; } writer = new Writer ( ) ; File fileSource = new File ( source ) ; if ( ! fileSource . isDirectory ( ) ) { System . out . println ( " source path is not a valid source directory " ) ; return false ; } else { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; System . out . println ( " RUNNING CONVERTER WILL REPLACE JAVA FILES CONTAINED IN  " + source + " , DO YOU WANT TO CONTINUE Y / N ? " ) ; String response = in . readLine ( ) ; if ( response . equalsIgnoreCase ( " N " ) ) { return false ; } selectFiles ( fileSource ) ; if ( javaFiles . size ( ) > Constant . NB_FILES_MAX ) { System . out . println ( " THERE IS  " + javaFiles . size ( ) + "  FILES TO CONVERT, DO YOU WANT TO CONTINUE Y / N ? " ) ; response = in . readLine ( ) ; if ( response . equalsIgnoreCase ( " N " ) ) { return false ; } } } return true ; }
private void function ( final ObjectInputStream arg0 ) throws IOException , ClassNotFoundException { arg0 . defaultReadObject ( ) ; level = arg0 . readInt ( ) ; syslogEquivalent = arg0 . readInt ( ) ; levelStr = arg0 . readUTF ( ) ; if ( levelStr = = null ) { levelStr = " " ;
public String function ( ) { return attributes ( ) . getIgnoreCase ( " id " ) ; }
@Test public void function ( ) throws IOException { Document doc = Jsoup . connect ( SlowRider . Url ) . timeout ( 0 ) . data ( SlowRider . MaxTimeParam , " 2000 " ) . get ( ) ; Element h1 = doc . selectFirst ( " h1 " ) ; assertEquals ( " outatime " , h1 . text ( ) ) ; }
private boolean function ( String [ ] arg0 , String [ ] arg1 , arg2 String [ ] arg3 ) { final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; for ( int pos = bottom ; pos > = top ; pos - - ) { Element el = stack . get ( pos ) ; if ( ! el . tag ( ) . namespace ( ) . equals ( NamespaceHtml ) ) continue ; final String elName = el . normalName ( ) ; if ( inSorted ( elName , arg0 ) ) return true ; if ( inSorted ( elName , arg1 ) ) return false ; if ( arg3 ! = null & & inSorted ( elName , arg3 ) ) return false ; } return false ; }
public void function ( ) throws Exception { MocoEventAction action = mock ( MocoEventAction . class ) ; server . request ( by ( uri ( " /noevent " ) ) ) . response ( " noevent " ) ; server . request ( by ( uri ( " /event " ) ) ) . response ( " foo " ) . on ( complete ( action ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /noevent " ) ) , is ( " noevent " ) ) ) ; verify ( action , Mockito . never ( ) ) . execute ( any ( Request . class ) ) ; }
public void function ( ) { Evaluator . IsRoot evaluator = new Evaluator . IsRoot ( ) ; assertEquals ( " :root " , evaluator . toString ( ) ) ; }
protected Predicate < String > function ( final Predicate < byte [ ] > arg0 ) { return new Predicate < String > ( ) { @Override
Tag function ( String arg0 ) { tagName = arg0 ; return this ; }
public void function ( ) throws Exception { server . request ( by ( times ( " a " , 1025 ) ) ) . response ( line ( " long_a " ) ) ; running ( server , new Runnable ( ) { @Override
public final boolean function ( ) { return this . monitor . isQuiet ( ) ; }
protected abstract ResponseHandler function ( final Iterable < ResponseHandler > arg0 ) ; }
private String function ( final HttpRequest arg0 ) { String buf = arg0 . getMethod ( ) . name ( ) + ' ' + arg0 . getUri ( ) + asQuery ( arg0 . getQueries ( ) ) + ' ' + arg0 . getVersion ( ) . text ( ) ; return buf ; }
public void function ( int arg0 , String arg1 , boolean arg2 ) { countDownLatch . countDown ( ) ; }
private void function ( HttpResponse arg0 , StringBuilder arg1 ) { arg1 . append ( arg0 . getProtocolVersion ( ) . getText ( ) ) ; arg1 . append ( ' ' ) ; arg1 . append ( arg0 . getStatus ( ) . toString ( ) ) ; }
private void function ( ) { layoutManager . putConstraint ( SpringLayout . WEST , migrationLabel , BASIC_PADDING , SpringLayout . EAST , this ) ; layoutManager . putConstraint ( SpringLayout . NORTH , migrationLabel , BASIC_PADDING , SpringLayout . NORTH , this ) ; slh . placeToTheRight ( migrationLabel , radioJCL , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( radioJCL , radioLog4j , 0 , 0 ) ; slh . placeBelow ( migrationLabel , folderLabel , 0 , BASIC_PADDING * 5 ) ; slh . placeToTheRight ( folderLabel , folderTextField ) ; slh . placeToTheRight ( folderTextField , browseButton , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( folderLabel , warningLabel , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( warningLabel , awareCheckBox , 0 , ( int ) ( BASIC_PADDING * 1.5 ) ) ; slh . placeToTheRight ( awareCheckBox , awareLabel ) ; slh . placeBelow ( awareCheckBox , migrateButton , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( migrateButton , otherLabel , 0 , BASIC_PADDING * 2 ) ; slh . placeBelow ( otherLabel , progressBar , 0 , BASIC_PADDING * 2 ) ; }
public boolean function ( final HttpRequest arg0 ) { Optional < T > extractContent = extractor . extract ( arg0 ) ; if ( ! extractContent . isPresent ( ) ) { return false ; } T target = extractContent . get ( ) ; if ( target instanceof String ) { return predicate . apply ( ( String ) target ) ; } if ( target instanceof String [ ] ) { String [ ] contents = ( String [ ] ) target ; for ( String content : contents ) { if ( predicate . apply ( content ) ) { return true ; } } } return false ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 60 ) ;
public Connection function ( Parser arg0 ) { req . arg0 ( arg0 ) ; return this ; }
public LoggingEventBuilder function ( Object arg0 ) { this . parameter = arg0 ; return this ; }
public static < ExtractorType1 , ExtractorType2 > Resource function ( final String arg0 , final String arg1 , final RequestExtractor < ExtractorType1 > arg2 , final String arg3 , final RequestExtractor < ExtractorType2 > arg4 ) { return arg0 ( text ( checkNotNullOrEmpty ( arg0 , " Template should not be null " ) ) , checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { ChannelBuffer buffer = ChannelBuffers . dynamicBuffer ( ) ; writeContentResponse ( arg0 , buffer ) ; arg1 . setContent ( buffer ) ; arg1 . setHeader ( " Content-Length " , arg1 . getContent ( ) . writerIndex ( ) ) ; if ( ! detector . hasContentType ( arg1 ) ) { arg1 . setHeader ( " Content-Type " , getContentType ( arg0 ) ) ;
public void function ( ) throws Throwable { WithException withException = new WithException ( ) ; Other other = new Other ( ) ; threads [ 0 ] = new Thread ( withException ) ; threads [ 1 ] = new Thread ( other ) ; threads [ 0 ] . start ( ) ; threads [ 1 ] . start ( ) ; Thread . sleep ( 100 ) ; signal = true ; threads [ 0 ] . join ( ) ; threads [ 1 ] . join ( ) ; if ( withException . throwable ! = null ) { throw withException . throwable ; } if ( other . throwable ! = null ) { throw other . throwable ;
public List < Framedata > function ( String arg0 , boolean arg1 ) { FrameBuilder curframe = new FramedataImpl1 ( ) ; byte [ ] pay = Charsetfunctions . utf8Bytes ( arg0 ) ; curframe . setPayload ( pay ) ; curframe . setFin ( true ) ; curframe . setOptcode ( Opcode . TEXT ) ; curframe . setTransferemasked ( arg1 ) ; return Collections . singletonList ( ( Framedata ) curframe ) ; }
private Mp3File function ( Mp3File arg0 ) { assertEquals ( 0x44B , arg0 . getXingOffset ( ) ) ; assertEquals ( 0x5EC , arg0 . getStartOffset ( ) ) ; assertEquals ( 0xF7F , arg0 . getEndOffset ( ) ) ; assertTrue ( arg0 . hasId3v1Tag ( ) ) ; assertTrue ( arg0 . hasId3v2Tag ( ) ) ; assertFalse ( arg0 . hasCustomTag ( ) ) ; return arg0 ; }
boolean function ( final Element arg0 , final Element arg1 ) { IdentityHashMap < Element , IdentityHashMap < Element , Boolean > > rootMemo = threadMemo . get ( ) ; IdentityHashMap < Element , Boolean > memo = rootMemo . get ( arg0 ) ; if ( memo = = null ) { memo = new IdentityHashMap < > ( ) ; rootMemo . put ( arg0 , memo ) ; } Boolean matches = memo . get ( arg1 ) ; if ( matches = = null ) { matches = evaluator . matches ( arg0 , arg1 ) ; memo . put ( arg1 , matches ) ; } return matches ; }
void function ( Token . Comment arg0 ) { Comment comment = new Comment ( arg0 . getData ( ) , baseUri ) ; insertNode ( comment ) ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { arg0 . send ( " Welcome to the server! " ) ; broadcast ( " new connection:  " + arg1 . getResourceDescriptor ( ) ) ; if ( clients . get ( ) = = 0 ) { broadcast ( " You are the first client to join " ) ; } System . out . println ( arg0 . getRemoteSocketAddress ( ) . getAddress ( ) . getHostAddress ( ) + "  entered the room! " ) ; clients . incrementAndGet ( ) ; }
public static String function ( String arg0 , String arg1 ) { if ( arg0 . endsWith ( SEPARATOR ) ) { return arg0 + arg1 ; } if ( Strings . isNullOrEmpty ( arg1 ) ) { return arg0 ; } if ( arg1 . startsWith ( SEPARATOR ) ) { return arg0 + arg1 ; } return arg0 + SEPARATOR + arg1 ; }
public boolean function ( HttpRequest arg0 ) { return arg0 . getUri ( ) . equals ( uri ) ; }
@Test public void function ( ) { String cdataStart = " <![CDATA[ " ; String cdataEnd = " ]]> " ; int bufLen = BufferSize - cdataStart . length ( ) - 1 ; char [ ] cdataContentsArray = new char [ bufLen ] ; Arrays . fill ( cdataContentsArray , 'x' ) ; String cdataContents = new String ( cdataContentsArray ) ; String testMarkup = cdataStart + cdataContents + cdataEnd ; Parser parser = new Parser ( new HtmlTreeBuilder ( ) ) ; Document doc = parser . parseInput ( testMarkup , " " ) ; Node cdataNode = doc . body ( ) . childNode ( 0 ) ; assertTrue ( cdataNode instanceof CDataNode , " Expected CDATA node " ) ; assertEquals ( cdataContents , ( ( CDataNode ) cdataNode ) . text ( ) ) ; }
public void function ( ) { FileResourceReader reader = new FileResourceReader ( text ( new File ( " src/test/resources/foo.response " ) . getPath ( ) ) , Optional . < Charset > absent ( ) ) ; assertThat ( reader . readFor ( Optional . < Request > absent ( ) ) . toString ( ) , is ( " foo.response " ) ) ; }
public TextNode function ( String arg0 ) { this . arg0 = arg0 ; if ( attributes ! = null ) attributes . put ( TEXT_KEY , arg0 ) ; return this ; }
public boolean function ( String arg0 ) { String [ ] requestedExtensions = arg0 . split ( " , " ) ; for ( String extension : requestedExtensions ) { ExtensionRequestData extensionData = ExtensionRequestData . parseExtensionRequest ( extension ) ; if ( ! EXTENSION_REGISTERED_NAME . equalsIgnoreCase ( extensionData . getExtensionName ( ) ) ) continue ; Map < String , String > headers = extensionData . getExtensionParameters ( ) ; requestedParameters . putAll ( headers ) ; if ( requestedParameters . containsKey ( CLIENT_NO_CONTEXT_TAKEOVER ) ) clientNoContextTakeover = true ; return true ; } return false ; }
public boolean function ( ) { return RECORD_ALL_EVENTS ; }
public static Resource function ( final String arg0 ) { return methodResource ( checkNotNullOrEmpty ( arg0 , " HTTP method should not be null " ) ) ; }
private StartArgs function ( int arg0 ) { return httpArgs ( ) . withPort ( arg0 ) . build ( ) ; }
private < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final TextContainer arg1 ) { String text = arg1 . getText ( ) ; if ( " true " . equalsIgnoreCase ( text ) ) { return exist ( arg0 ) ; } if ( " false " . equalsIgnoreCase ( text ) ) { return not ( exist ( arg0 ) ) ; } throw new IllegalArgumentException ( String . format ( " Unknown exist parameter: [%s] " , text ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { recordEventArgArray ( Level . WARN , arg0 , arg1 , arg2 ) ; }
public boolean function ( String arg0 ) { return is ( QueryParser . parse ( arg0 ) ) ; }
public static MocoEventAction function ( final String arg0 , final String arg1 ) { return post ( checkNotNullOrEmpty ( arg0 , " URL should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Content should not be null " ) ) ) ; }
public ByteChannel function ( SelectionKey arg0 ) throws IOException { SSLEngine e = sslcontext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; return new SSLSocketChannel2 ( arg0 , e , exec ) ; }
public void function ( ) throws Exception { runTestScenario ( false ) ; }
public void function ( ) throws Exception { httpServer = httpserver ( 12306 , fileRoot ( " src/test/resources " ) ) ; httpServer . response ( file ( " foo.response " ) ) ; HttpServer mergedServer = ( ( ActualHttpServer ) httpServer ) . mergeHttpServer ( ( ActualHttpServer ) anotherServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public void function ( ) throws Exception { server . request ( struct ( xml ( " <request><parameters foo= \" bar \" ><id>1</id></parameters></request> " ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . postForResponse ( root ( ) , " <request><parameters bar= \" bar \" ><id>2</id></parameters></request> " ) . getCode ( ) , is ( 400 ) )
public static ResponseHandler function ( final String arg0 ) { return responseHandler ( arg0 ( arg0 ) ) ; }
public static Level function ( String arg0 , Level arg1 ) { if ( arg0 = = null ) return arg1 ; String s = arg0 . toUpperCase ( ) ; if ( s . equals ( " ALL " ) ) return Level . ALL ; if ( s . equals ( " DEBUG " ) ) return Level . DEBUG ; if ( s . equals ( " INFO " ) ) return Level . INFO ; if ( s . equals ( " WARN " ) ) return Level . WARN ; if ( s . equals ( " ERROR " ) ) return Level . ERROR ; if ( s . equals ( " FATAL " ) ) return Level . FATAL ; if ( s . equals ( " OFF " ) ) return Level . OFF ; if ( s . equals ( " TRACE " ) ) return Level . TRACE ; return arg1 ; }
Tag function ( ) { tagName = null ; pendingAttributeName = null ; reset ( pendingAttributeValue ) ; pendingAttributeValueS = null ; hasEmptyAttributeValue = false ; hasPendingAttributeValue = false ; selfClosing = false ; attributes = null ; return this ; }
protected void function ( Logger arg0 , LogRecord arg1 ) { int julLevelValue = arg1 . getLevel ( ) . intValue ( ) ; if ( julLevelValue < = TRACE_LEVEL_THRESHOLD ) { arg0 . trace ( arg1 . getMessage ( ) , arg1 . getThrown ( ) ) ;
Token function ( ) { while ( ! isEmitPending ) state . read ( this , reader ) ; if ( charsBuilder . length ( ) > 0 ) { String str = charsBuilder . toString ( ) ;
public void function ( ) { try { assertThat ( get ( " http://localhost:8080 " ) , is ( " foo " ) ) ;
@Test void function ( ) { Document doc = Jsoup . parse ( " <div>Hello world</div> " ) ; Element div = doc . select ( " div " ) . stream ( ) . findFirst ( ) . orElse ( null ) ; assertEquals ( " Hello world " , div . text ( ) ) ; div = doc . selectStream ( " div " ) . findFirst ( ) . orElse ( null ) ; assertEquals ( " Hello world " , div . text ( ) ) ; }
public void function ( ) throws Exception { server . request ( struct ( xml ( " <request><parameters><id>1</id></parameters></request> " ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . postContent ( root ( ) , " <!--comment--><request><parameters><id>2</id></parameters></request> " ) , is ( " foo " ) ) ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.1.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 375 ) ; }
@Test ( expected = IllegalArgumentException . class ) public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( echoURL ) . execute ( ) ; Document doc = res . parse ( ) ; assertTrue ( doc . title ( ) . contains ( " Environment " ) ) ; Document doc2 = res . parse ( ) ; }
public void function ( ActionEvent arg0 ) { timer . cancel ( ) ; stopAdjust ( ) ; start . setEnabled ( true ) ; stop . setEnabled ( false ) ; reset . setEnabled ( true ) ; joinrate . setEnabled ( true ) ; interval . setEnabled ( true ) ; clients . setEnabled ( true ) ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( message , param1 , param2 ) ; break ; case DEBUG : logger . debug ( message , param1 , param2 ) ; break ; case INFO : logger . info ( message , param1 , param2 ) ; break ; case WARN : logger . warn ( message , param1 , param2 ) ; break ; case ERROR : logger . error ( message , param1 , param2 ) ; break ; } verifyMessageWithoutMarker ( arg0 , twoParams , null ) ; }
public void function ( String arg0 , Throwable arg1 ) { if ( isInfoEnabled ( ) ) { handle_0ArgsCall ( Level . INFO , null , arg0 , arg1 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.16 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
protected void function ( byte [ ] arg0 ) throws InvalidDataException { try { url = BufferTools . byteBufferToString ( arg0 , 0 , arg0 . length ) ;
public final void function ( final SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; Response response = arg0 . getResponse ( ) ; if ( request instanceof HttpRequest & & response instanceof MutableHttpResponse ) { HttpRequest httpRequest = ( HttpRequest ) request ; MutableHttpResponse httpResponse = ( MutableHttpResponse ) response ; doWriteToResponse ( arg0 , httpRequest , httpResponse ) ; return ; } MutableResponse mutableResponse = ( MutableResponse ) response ; mutableResponse . setContent ( requireResponseContent ( arg0 ) ) ; }
public boolean function ( final RestAllSetting arg0 ) { return arg0 . getRequestMatcher ( name ) . match ( request ) ; }
public Connection function ( String arg0 , String arg1 , InputStream arg2 ) { req . data ( KeyVal . create ( arg0 , arg1 , arg2 ) ) ; return this ; }
public boolean function ( final GetSingleRestSetting arg0 ) { return arg0 . getRequestMatcher ( name ) . match ( request ) ; }
private static String function ( final String arg0 , final String arg1 ) { String joinPath = toJoinPath ( arg1 ) ; if ( arg0 . endsWith ( SEPARATOR ) ) { return arg0 + joinPath ; } if ( joinPath . isEmpty ( ) ) { return arg0 ; } return arg0 + SEPARATOR + joinPath ; }
public LoggingEventBuilder function ( String arg0 , Supplier < Object > arg1 ) { loggingEvent . addKeyValue ( arg0 , arg1 . get ( ) ) ; return this ; }
protected Runner function ( ) { return new SettingRunner ( toInputStream ( settingsFile ) , startArgs ) ; }
public void function ( ) throws IOException { assertThat ( helper . postFile ( root ( ) , " foo.xml " ) , is ( " foo " ) ) ; assertThat ( helper . postFile ( root ( ) , " bar.xml " ) , is ( " bar " ) ) ; }
public static String function ( Document arg0 , arg1 Map < String , String > arg2 ) { try { DOMSource domSource = new DOMSource ( arg0 ) ;
private Iterable < Session > function ( final Session arg0 , final ImmutableList < Session > arg1 ) { Optional < Session > session = arg1 . stream ( ) . filter ( isForRequest ( arg0 . getRequest ( ) ) ) . findFirst ( ) ; if ( session . isPresent ( ) ) { return arg1 . stream ( ) . filter ( isForRequest ( arg0 . getRequest ( ) ) . negate ( ) ) . collect ( Collectors . toList ( ) ) ; } return arg1 ; }
static void function ( StringBuilder arg0 , String arg1 , Document . OutputSettings arg2 , boolean arg3 , boolean arg4 , boolean arg5 ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; EscapeMode escapeMode = arg2 . escapeMode ( ) ; CharsetEncoder encoder = arg2 . encoder ( ) ; Map < Character , String > map = escapeMode . getMap ( ) ; final int length = arg1 . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset + = Character . charCount ( codePoint ) ) { codePoint = arg1 . codePointAt ( offset ) ;
private Watcher function ( final Function < File , Void > arg0 , File [ ] arg1 ) { return new CompositeWatcher ( from ( arg1 ) . transform ( new Function < File , Watcher > ( ) { @Override
private void function ( ContentHandler arg0 ) { this . handler . setAnyResponseHandler ( arg0 ) ; }
private static void function ( Set < URL > arg0 ) { if ( arg0 . isEmpty ( ) ) { return ; } Util . report ( " Class path contains SLF4J bindings targeting slf4j-api versions prior to 1.8. " ) ; for ( URL path : arg0 ) { Util . report ( " Ignoring binding found at [ " + path + " ] " ) ; } Util . report ( " See  " + IGNORED_BINDINGS_URL + "  for an explanation. " ) ;
private Runner function ( final StartArgs arg0 ) { final File configuration = new File ( arg0 . getConfigurationFile ( ) . get ( ) ) ; final FileRunner fileRunner = createConfigurationFileRunner ( configuration , arg0 ) ; MocoRunnerWatcher fileMocoRunnerWatcher = monitorFactory . createConfigurationWatcher ( configuration , fileRunner ) ; return new MonitorRunner ( fileRunner , fileMocoRunnerWatcher ) ; }
private Resource function ( String arg0 , TextContainer arg1 ) { if ( arg1 . isRawText ( ) ) { return invokeTarget ( arg0 , arg1 . getText ( ) , Resource . class ) ; } if ( arg1 . isForTemplate ( ) ) { if ( " version " . equalsIgnoreCase ( arg0 ) ) { return version ( template ( arg1 . getText ( ) ) ) ; } if ( arg1 . hasProperties ( ) ) { return template ( invokeTarget ( arg0 , arg1 . getText ( ) , ContentResource . class ) , arg1 . getProps ( ) ) ; } return template ( invokeTarget ( arg0 , arg1 . getText ( ) , ContentResource . class ) ) ; } throw new IllegalArgumentException ( format ( " unknown operation [%s] " , arg1 . getOperation ( ) ) ) ; }
protected void function ( LocationAwareLogger arg0 , LogRecord arg1 ) { int julLevelValue = arg1 . getLevel ( ) . intValue ( ) ; int slf4jLevel ; if ( julLevelValue < = TRACE_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . TRACE_INT ; } else if ( julLevelValue < = DEBUG_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . DEBUG_INT ; } else if ( julLevelValue < = INFO_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . INFO_INT ; } else if ( julLevelValue < = WARN_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . WARN_INT ; } else { slf4jLevel = LocationAwareLogger . ERROR_INT ; } arg0 . log ( null , FQCN , slf4jLevel , arg1 . getMessage ( ) , arg1 . getThrown ( ) ) ; }
public void function ( ) { ID3v2TextFrameData frameData1 = new ID3v2TextFrameData ( false , ( EncodedText ) null ) ; ID3v2TextFrameData frameData2 = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_TEXT ) ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
private void function ( Framedata arg0 ) throws InvalidDataException { if ( current_continuous_frame ! = null ) { log . trace ( " Protocol error: Previous continuous frame sequence not completed. " ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , " Previous continuous frame sequence not completed. " ) ; } current_continuous_frame = arg0 ; byteBufferList . add ( arg0 . getPayloadData ( ) ) ; }
private HttpServer function ( List < ? extends InputStream > arg0 , int arg1 ) { HttpServer server = createBaseHttpServer ( arg0 , arg1 ) ; server . request ( by ( uri ( " /favicon.ico " ) ) ) . response ( content ( pathResource ( " favicon.png " ) ) , header ( " Content-Type " , " image/png " ) ) ; return server ; }
public void function ( ) throws IOException { runWithConfiguration ( " template.json " ) ; final HttpResponse response = helper . postForResponse ( remoteUrl ( " /xml_template " ) , " blah " ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 400 ) ) ; }
public void function ( ) { byte [ ] buffer = { BYTE_FF , BYTE_FB , 2 , 3 , 4 , BYTE_FF , BYTE_E0 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , BYTE_FF , BYTE_F0 } ; byte [ ] expectedBuffer = { BYTE_FF , 0 , BYTE_FB , 2 , 3 , 4 , BYTE_FF , 0 , BYTE_E0 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , BYTE_FF , 0 , BYTE_F0 } ; byte [ ] unsynchronised = BufferTools . unsynchroniseBuffer ( buffer ) ; byte [ ] synchronised = BufferTools . synchroniseBuffer ( unsynchronised ) ; assertTrue ( Arrays . equals ( expectedBuffer , unsynchronised ) ) ; assertTrue ( Arrays . equals ( buffer , synchronised ) ) ; }
private Response function ( HttpRequest arg0 ) { final Request dumpedRequest = createDumpedRequest ( arg0 ) ; final Session session = Iterables . find ( restoreSessions ( this . file ) , isForRequest ( dumpedRequest ) ) ; return session . getResponse ( ) ; }
public static void function ( String [ ] arg0 ) { WebSocket . DEBUG = true ; int port ; try { port = new Integer ( arg0 [ 0 ] ) ; } catch ( Exception e ) { System . out . println ( " No port specified. Defaulting to 9001 " ) ; port = 9003 ; } new AutobahnServerTest ( port , new Draft_17 ( ) ) . start ( ) ; }
protected void function ( final ActualHttpServer arg0 ) { this . websocketServer = arg0 . websocketServer ; }
private void function ( ) { int leadingCharsToRemove = 0 ; if ( value . length > = 2 & & ( ( value [ 0 ] = = ( byte ) 0xfe & & value [ 1 ] = = ( byte ) 0xff ) | | ( value [ 0 ] = = ( byte ) 0xff & & value [ 1 ] = = ( byte ) 0xfe ) ) ) { leadingCharsToRemove = 2 ; } else if ( value . length > = 3 & & ( value [ 0 ] = = ( byte ) 0xef & & value [ 1 ] = = ( byte ) 0xbb & & value [ 2 ] = = ( byte ) 0xbf ) ) { leadingCharsToRemove = 3 ; } int trailingCharsToRemove = 0 ; for ( int i = 1 ; i < = 2 ; i + + ) { if ( ( value . length - leadingCharsToRemove - trailingCharsToRemove ) > i & & value [ value . length - i ] = = 0 ) { trailingCharsToRemove + + ; } else { break ; } } if ( leadingCharsToRemove + trailingCharsToRemove > 0 ) { byte [ ] newValue = new byte [ value . length - leadingCharsToRemove - trailingCharsToRemove ] ;
public void function ( Opcode arg0 , ByteBuffer arg1 , boolean arg2 ) { send ( draft . continuousFrame ( arg0 , arg1 , arg2 ) ) ; }
public void function ( ResponseHandler . . . arg0 ) { this . response ( new AndResponseHandler ( arg0 ) ) ; }
private static void function ( Element arg0 , StringBuilder arg1 ) { if ( arg0 . tag . normalName ( ) . equals ( " br " ) & & ! TextNode . lastCharIsWhitespace ( arg1 ) ) arg1 . append ( "   " ) ;
void function ( Token . Character arg0 ) { Node node ; String tagName = currentElement ( ) . tagName ( ) ; if ( tagName . equals ( " script " ) | | tagName . equals ( " style " ) ) node = new DataNode ( arg0 . getData ( ) , baseUri ) ; else node = new TextNode ( arg0 . getData ( ) , baseUri ) ; currentElement ( ) . appendChild ( node ) ; }
boolean function ( ) { return tag . preserveWhitespace ( ) | | parent ( ) ! = null & & parent ( ) . preserveWhitespace ( ) ; }
private boolean function ( Element arg0 , Attribute arg1 , Set < Protocol > arg2 ) { String value = arg0 . absUrl ( arg1 . getKey ( ) ) ; arg1 . setValue ( value ) ; for ( Protocol protocol : arg2 ) { String prot = protocol . toString ( ) + " : " ; if ( value . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }
public int function ( ByteBuffer arg0 ) throws SSLException { return readRemaining ( arg0 ) ; }
public static void function ( String arg0 , Instrumentation arg1 ) { LogTransformer . Builder builder = new LogTransformer . Builder ( ) ; builder = builder . addEntryExit ( true ) ; if ( arg0 ! = null ) { Properties args = parseArguments ( arg0 , " ; " ) ; if ( args . containsKey ( " verbose " ) ) { builder = builder . verbose ( true ) ; } if ( args . containsKey ( " time " ) ) { printStartStopTimes ( ) ; } if ( args . containsKey ( " ignore " ) ) { builder = builder . ignore ( args . getProperty ( " ignore " ) . split ( " , " ) ) ; } if ( args . containsKey ( " level " ) ) { builder = builder . level ( args . getProperty ( " level " ) ) ; } } arg1 . addTransformer ( builder . build ( ) ) ; }
public static RestIdMatcher function ( final String arg0 ) { return new BaseRestIdMatcher ( arg0 ) { @Override
public boolean function ( Marker arg0 ) { return RECORD_ALL_EVENTS ; }
public synchronized void function ( int arg0 , String arg1 , boolean arg2 ) { if ( getReadyState ( ) = = READYSTATE . CLOSED ) { return ; } if ( getReadyState ( ) = = READYSTATE . OPEN ) { if ( arg0 = = CloseFrame . ABNORMAL_CLOSE ) { setReadyState ( READYSTATE . CLOSING ) ; } } if ( key ! = null ) { key . cancel ( ) ; } if ( channel ! = null ) { try { channel . close ( ) ; } catch ( IOException e ) { if ( e . getMessage ( ) . equals ( " Broken pipe " ) ) { log . warn ( " Caught IOException: Broken pipe during closeConnection() " , e ) ; } else { log . error ( " Exception during channel.close() " , e ) ; wsl . onWebsocketError ( this , e ) ; } } } try { this . wsl . onWebsocketClose ( this , arg0 , arg1 , arg2 ) ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; } if ( draft ! = null ) draft . reset ( ) ; handshakerequest = null ; setReadyState ( READYSTATE . CLOSED ) ; }
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; logger . entry ( ) ; logger . entry ( 1 ) ; logger . entry ( " test " ) ; logger . entry ( " a " , " b " , " c " , " d " ) ; logger . entry ( " a " , " b " , " c " , " d " , " e " ) ; logger . entry ( " a " , " b " , " c " , " d " , " e " , " f " ) ; assertEquals ( 6 , listAppender . list . size ( ) ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 0 ) , " entry " ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 1 ) , " entry with (1) " ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 2 ) , " entry with (test) " ) ; }
@Test void function ( ) { Safelist safelist = Safelist . basic ( ) . preserveRelativeLinks ( false ) ; String html = " <a href= \" ja&Tab;vas&#0013;cript:alert(1) \" >Link</a> " ; String clean = Jsoup . clean ( html , " https:// " , safelist ) ; assertEquals ( " <a rel= \" nofollow \" >Link</a> " , clean ) ; }
public Connection function ( String arg0 , String arg1 ) { req . header ( arg0 , arg1 ) ; return this ; }
public static Document function ( InputStream arg0 , arg1 String arg2 , String arg3 ) throws IOException { return DataUtil . load ( arg0 , arg2 , arg3 ) ; }
public final void function ( WebSocket arg0 , Handshakedata arg1 ) { if ( this . connections . add ( arg0 ) ) { onOpen ( arg0 , ( ClientHandshake ) arg1 ) ;
protected ID3Wrapper function ( String arg0 ) throws IOException , UnsupportedTagException , InvalidDataException { return id3Wrapper ; }
public Document function ( OutputSettings arg0 ) { Validate . notNull ( arg0 ) ; this . arg0 = arg0 ; return this ; }
public static Document function ( File arg0 , String arg1 , String arg2 ) throws IOException { InputStream inStream = null ; try { inStream = new FileInputStream ( arg0 ) ;
public void function ( Marker arg0 , String arg1 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn ,
private static String function ( final String arg0 ) { checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) ; if ( arg0 . contains ( " / " ) ) { throw new IllegalArgumentException ( " REST ID should not contain '/' " ) ; } if ( ! URLs . isValidUrl ( arg0 ) ) { throw new IllegalArgumentException ( " ID should not contains invalid URI character " ) ; } return arg0 ; }
public boolean function ( Marker arg0 ) { return delegate ( ) . isErrorEnabled ( arg0 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div style='bold'><p title=qux><p><b style></b></p></div> " ) ; List < Element > els = doc . getElementsWithAttribute ( " style " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " div " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " b " , els . get ( 1 ) . tagName ( ) ) ; List < Element > none = doc . getElementsWithAttribute ( " class " ) ; assertEquals ( 0 , none . size ( ) ) ; }
public void function ( ) throws Exception { ArrayList < IProtocol > protocols = new ArrayList < > ( ) ; protocols . add ( new Protocol ( " chat1 " ) ) ; protocols . add ( new Protocol ( " chat2 " ) ) ; protocols . add ( new Protocol ( " chat3 " ) ) ; testProtocolRejection ( 21 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ) ; }
public void function ( ) { InputStream stream = getResourceAsStream ( " multiple/env-settings.json " ) ; List < GlobalSetting > globalSettings = parser . parse ( stream ) ; assertThat ( globalSettings . get ( 0 ) . getInclude ( ) , is ( join ( " src " , " test " , " resources " , " multiple " , " foo.json " ) ) ) ; assertThat ( globalSettings . get ( 0 ) . getContext ( ) , is ( " /foo " ) ) ; assertThat ( globalSettings . get ( 0 ) . getEnv ( ) , is ( " foo " ) ) ; assertThat ( globalSettings . get ( 1 ) . getInclude ( ) , is ( join ( " src " , " test " , " resources " , " multiple " , " bar.json " ) ) ) ; assertThat ( globalSettings . get ( 1 ) . getContext ( ) , is ( " /bar " ) ) ; assertThat ( globalSettings . get ( 1 ) . getEnv ( ) , is ( " bar " ) ) ; }
public void function ( ) throws IOException { Document doc = Jsoup . connect ( SlowRider . Url ) . timeout ( 0 ) . data ( SlowRider . MaxTimeParam , " 2000 " ) . get ( ) ; Element h1 = doc . selectFirst ( " h1 " ) ; assertEquals ( " outatime " , h1 . text ( ) ) ; }
public void function ( String arg0 , Object arg1 ) { if ( logger . isInfoEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public void function ( Node arg0 , int arg1 ) { if ( arg0 instanceof Element ) { Element element = ( Element ) arg0 ;
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { recordEventArgArray ( Level . DEBUG , arg0 , arg1 , arg2 ) ; }
public void function ( ChannelHandlerContext arg0 , FullHttpRequest arg1 ) { websocketServer . connectRequest ( arg0 , arg1 ) ; }
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " changeThis " , true ) ; doc . updateMetaCharset ( true ) ; doc . charset ( Charset . forName ( charsetIso8859 ) ) ; final String xmlCharsetISO = " <?xml version= \" 1.0 \"  encoding= \" " + charsetIso8859 + " \" > \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetISO , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetIso8859 , doc . charset ( ) . displayName ( ) ) ; assertEquals ( charsetIso8859 , selectedNode . attr ( " encoding " ) ) ; assertEquals ( doc . charset ( ) , doc . outputSettings ( ) . charset ( ) ) ; }
public void function ( ) throws Exception { httpServer = httpServer ( 12306 , context ( " /foo " ) ) ; anotherServer = httpServer ( 12307 , context ( " /bar " ) ) ; final HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , ( ) - > assertThat ( mergedServer . port ( ) , is ( 12307 ) ) ) ; }
public void function ( WindowEvent arg0 ) { if ( cc ! = null ) { cc . close ( ) ; } dispose ( ) ; }
public void function ( ) { NotSendableException notSendableException = new NotSendableException ( " Message " ) ; assertEquals ( " The message has to be the argument " , " Message " , notSendableException . getMessage ( ) ) ; Exception e = new Exception ( ) ; notSendableException = new NotSendableException ( e ) ; assertEquals ( " The throwable has to be the argument " , e , notSendableException . getCause ( ) ) ; notSendableException = new NotSendableException ( " Message " , e ) ; assertEquals ( " The message has to be the argument " , " Message " , notSendableException . getMessage ( ) ) ; assertEquals ( " The throwable has to be the argument " , e , notSendableException . getCause ( ) ) ; }
protected Optional < String [ ] > function ( final HttpRequest arg0 ) { final ImmutableMap < String , String > headers = arg0 . getHeaders ( ) ; String [ ] extractedValues = from ( headers . entrySet ( ) ) . filter ( isForHeaderName ( name ) ) . transform ( toValue ( ) ) . toArray ( String . class ) ; if ( extractedValues . length > 0 ) { return of ( extractedValues ) ; } return absent ( ) ; }
public static RequestMatcher function ( String arg0 ) { return eq ( text ( arg0 ) ) ; }
public static String function ( final String arg0 , final String arg1 ) { URL base ; try { try {
protected void function ( ) throws Exception { super . tearDown ( ) ; oos . close ( ) ; }
public void function ( final String arg0 , final int arg1 ) throws IOException { run ( new FileInputStream ( arg0 ) , arg1 ) ; fileMonitor . startMonitor ( new File ( arg0 ) , configurationChangeListener ( arg1 ) ) ; }
int function ( Handshakedata arg0 ) { String vers = arg0 . getFieldValue ( " Sec-WebSocket-Version " ) ; if ( vers . length ( ) > 0 ) { int v ; try { v = Integer . parseInt ( vers . trim ( ) ) ; return v ; } catch ( NumberFormatException e ) { return - 1 ; } } return - 1 ; }
public void function ( ) throws Exception { Request request = Request . Get ( root ( ) ) . version ( HttpVersion . HTTP_1_1 ) . addHeader ( " Connection " , " keep-alive " ) ; HttpResponse response = helper . execute ( request ) ; assertThat ( response . getFirstHeader ( " Connection " ) , nullValue ( ) ) ; }
public File function ( final GlobalSetting arg0 ) { return new File ( arg0 . getInclude ( ) ) ; }
public < T extends Appendable > T function ( T arg0 ) { outerHtml ( arg0 ) ; return arg0 ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws ServletException , IOException { arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; arg1 . setHeader ( " Content-Encoding " , " deflate " ) ; String doc = " <p>Hello, World!<p>That should be enough, right?<p>Hello, World!<p>That should be enough, right? " ; DeflaterOutputStream stream = new DeflaterOutputStream ( arg1 . getOutputStream ( ) , new Deflater ( Deflater . BEST_COMPRESSION , true ) ) ; stream . write ( doc . getBytes ( StandardCharsets . UTF_8 ) ) ; stream . close ( ) ; }
public void function ( ) throws Exception { server . request ( startsWith ( header ( " foo " ) , " bar " ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public int function ( ByteBuffer arg0 ) throws IOException { if ( ! proxyHandshake . hasRemaining ( ) ) { return super . write ( arg0 ) ;
public ProxyConfig function ( final String arg0 ) { return new ProxyConfig ( toBase ( localBase ) , toBase ( arg0 ) ) ; }
static AttributeValue function ( String arg0 ) { return new AttributeValue ( arg0 ) ; }
public void function ( ) throws Exception { byte [ ] buffer = loadFile ( " test-res/v1andv23tags.mp3 " ) ; byte [ ] tagBuffer = BufferTools . copyBuffer ( buffer , buffer . length - ID3v1Tag . TAG_LENGTH , ID3v1Tag . TAG_LENGTH ) ; ID3v1 id3tag = new ID3v1Tag ( tagBuffer ) ; assertEquals ( " 1 " , id3tag . getTrack ( ) ) ; assertEquals ( " ARTIST123456789012345678901234 " , id3tag . getArtist ( ) ) ; assertEquals ( " TITLE1234567890123456789012345 " , id3tag . getTitle ( ) ) ; assertEquals ( " ALBUM1234567890123456789012345 " , id3tag . getAlbum ( ) ) ; assertEquals ( " 2001 " , id3tag . getYear ( ) ) ; assertEquals ( 0x0d , id3tag . getGenre ( ) ) ; assertEquals ( " Pop " , id3tag . getGenreDescription ( ) ) ; assertEquals ( " COMMENT123456789012345678901 " , id3tag . getComment ( ) ) ; }
public static Request function ( FullHttpRequest arg0 ) { Request dumpedRequest = new Request ( ) ; dumpedRequest . setVersion ( arg0 . getProtocolVersion ( ) . text ( ) ) ; setContent ( arg0 , dumpedRequest ) ; dumpedRequest . setMethod ( arg0 . getMethod ( ) . name ( ) ) ; QueryStringDecoder decoder = new QueryStringDecoder ( arg0 . getUri ( ) ) ; for ( Map . Entry < String , List < String > > entry : decoder . parameters ( ) . entrySet ( ) ) { dumpedRequest . addQuery ( entry . getKey ( ) , entry . getValue ( ) . get ( 0 ) ) ; } for ( Map . Entry < String , String > entry : arg0 . headers ( ) ) { dumpedRequest . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } return dumpedRequest ; }
public void function ( ) throws Exception { runTestScenarioReconnect ( false ) ; }
public void function ( ) { for ( int i = 1 ; i < = 10 ; i + + ) { check ( html . select ( String . format ( " #pseudo :nth-child(%d) " , i ) ) , String . valueOf ( i ) ) ;
public SslHandler function ( HttpsCertificate arg0 ) { SSLEngine sslEngine = arg0 . createSSLEngine ( ) ; sslEngine . setUseClientMode ( false ) ; return new SslHandler ( sslEngine ) ; }
public void function ( SessionContext arg0 ) { this . writeToResponse ( arg0 . getRequest ( ) , arg0 . getResponse ( ) ) ; }
public void function ( ) throws Exception { assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -z " , " filename " } ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; String header = Request . Get ( remoteUrl ( " /favicon.ico " ) ) . execute ( ) . returnResponse ( ) . getFirstHeader ( HttpHeaders . CONTENT_TYPE ) . getValue ( ) ; assertThat ( header , is ( " image/png " ) ) ; }
public void function ( ) { String h = " <div id=1 /><div id=2 /><div title=foo /><div title=bar /> " ; Elements els = SelectMatch . match ( Jsoup . parse ( h ) , Parser . parse ( " [id],[title=foo] " ) ) ; assertEquals ( 3 , els . size ( ) ) ; assertEquals ( " 1 " , els . get ( 0 ) . id ( ) ) ; assertEquals ( " 2 " , els . get ( 1 ) . id ( ) ) ; assertEquals ( " foo " , els . get ( 2 ) . attr ( " title " ) ) ; }
public boolean function ( String arg0 ) { return arg0 . contains ( expected . readFor ( Optional . < Request > absent ( ) ) . toString ( ) ) ; }
@Test public void function ( ) { String query = " .foo.qux[attr=bar] > ol.bar, ol > li + li " ; String parsed = sexpr ( query ) ; assertEquals ( " (Or (And (Tag 'li')(ImmediatePreviousSibling (ImmediateParentRun (Tag 'ol')(Tag 'li'))))(ImmediateParentRun (And (AttributeWithValue '[attr=bar]')(Class '.foo')(Class '.qux'))(And (Tag 'ol')(Class '.bar')))) " , parsed ) ;
public void function ( ) { if ( VersionUtil . getJavaMajorVersion ( ) < 9 ) return ; MDCFriend . fixForJava9 ( ) ; String key = " MDCFriendTest.smoke " + diff ; String val = " val " + diff ; MDC . put ( key , val ) ; assertEquals ( val , MDC . get ( key ) ) ; MDC . clear ( ) ; assertNull ( MDC . get ( key ) ) ;
boolean function ( ) { if ( isEmpty ( ) ) return false ; char c = input . charAt ( pos ) ; return ( c > = 'A' & & c < = 'Z' ) | | ( c > = 'a' & & c < = 'z' ) ; }
private Optional < Integer > function ( final ActualHttpServer arg0 , final ActualHttpServer arg1 ) { Optional < Integer > optionalPort = arg0 . getPort ( ) . filter ( port - > port ! = 0 ) ; if ( optionalPort . isPresent ( ) ) { return optionalPort ; } return arg1 . getPort ( ) ; }
public static LatencyProcedure function ( final long arg0 ) { return new LatencyProcedure ( arg0 ) ; }
public void function ( ) { check ( html . select ( " div:not(#only) :last-of-type " ) , " 10 " , " 10 " , " 10 " , " 10 " , " 10 " ) ; }
public void function ( File arg0 ) { logger . info ( " {} change detected. " , arg0 . getName ( ) ) ; try { HttpServer httpServer = httpServerParser . parseServer ( new FileInputStream ( arg0 ) , port ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.23.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
void function ( Marker arg0 , String arg1 , int arg2 , Object arg3 , Throwable arg4 ) { String m = convertToString ( arg3 ) ; if ( locationAwareLogger ! = null ) { locationAwareLogger . log ( arg0 , arg1 , arg2 , m , arg4 ) ;
public static boolean function ( final String arg0 ) { if ( arg0 = = null | | arg0 . length ( ) = = 0 ) return true ; int l = arg0 . length ( ) ; for ( int i = 0 ; i < l ; i + + ) { if ( ! StringUtil . isWhitespace ( arg0 . codePointAt ( i ) ) ) return false ; } return true ; }
public void function ( ) throws Exception { server . response ( json ( ( request ) - > null ) ) ; running ( server , ( ) - > { int status = helper . getForStatus ( root ( ) ) ;
public HttpResponse function ( final String arg0 , String arg1 ) throws IOException { Request request = Request . Put ( arg0 ) . addHeader ( CONTENT_TYPE , PLAIN_TEXT_UTF_8 . toString ( ) ) . bodyByteArray ( arg1 . getBytes ( ) ) ; return EXECUTOR . execute ( request ) . returnResponse ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " any_response_with_file_and_charset.json " ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo.response " ) ) ; }
public void function ( ) { radioJCL . setEnabled ( false ) ; radioLog4j . setEnabled ( false ) ; browseButton . setEnabled ( false ) ; folderTextField . setEnabled ( false ) ; awareCheckBox . setEnabled ( false ) ; migrateButton . setText ( " Migration in progress " ) ; migrateButton . setEnabled ( false ) ;
public void function ( ) { String xml = " <!DOCTYPE HTML><!-- a comment -->One <qux />Two " ; XmlTreeBuilder tb = new XmlTreeBuilder ( ) ; Document doc = tb . parse ( xml , " http://foo.com/ " ) ; assertEquals ( " <!DOCTYPE HTML><!-- a comment -->One <qux />Two " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
public void function ( BundleContext arg0 ) throws Exception { Properties props = new Properties ( ) ; props . put ( " description " , " An slf4j implementation. " ) ; ServiceFactory factory = new LogServiceFactory ( ) ; arg0 . registerService ( LogService . class . getName ( ) , factory , props ) ; }
public void function ( Object arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . WARNING ) ) { if ( arg0 instanceof String ) {
public void function ( ) { DurationUnit du = Util . selectDurationUnitForDisplay ( globalStopWatch ) ; String r = buildString ( du , " + " , " " ) ; System . out . println ( r ) ; }
public void function ( ) { try { serverSocket = new ServerSocket ( 8887 ) ;
void function ( Token arg0 ) { Validate . isFalse ( isEmitPending ) ; emitPending = arg0 ; isEmitPending = true ; arg0 . startPos ( markupStartPos ) ; arg0 . endPos ( reader . pos ( ) ) ; charStartPos = Unset ; if ( arg0 . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) arg0 ;
private void function ( ) { final int pos = bufPos ; if ( pos < bufSplitPoint ) return ; try { final long skipped = reader . skip ( pos ) ;
public String function ( final String arg0 , String arg1 ) throws IOException { Request request = Request . Patch ( arg0 ) . bodyByteArray ( arg1 . getBytes ( ) ) ; return EXECUTOR . execute ( request ) . returnContent ( ) . asString ( ) ; }
public void function ( Exception arg0 ) { } } ; assertNull ( client . < WebSocketClient > getAttachment ( ) ) ; client . setAttachment ( client ) ; assertEquals ( client . < WebSocketClient > getAttachment ( ) , client ) ; client . setAttachment ( null ) ; assertNull ( client . < WebSocketClient > getAttachment ( ) ) ; } }
public Element function ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . childElementsList ( ) ; int index = indexInList ( this , siblings ) ; if ( siblings . size ( ) > index + 1 ) return siblings . get ( index + 1 ) ;
static boolean function ( StringBuilder arg0 ) { return arg0 . length ( ) ! = 0 & & arg0 . charAt ( arg0 . length ( ) - 1 ) = = ' ' ; }
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_T , BYTE_ESZETT , BYTE_G , BYTE_T } ; assertEquals ( - 1 , BufferTools . indexOfTerminator ( buffer , 0 , 1 ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private Function < Field , RequestMatcher > function ( final RequestSetting arg0 ) { return new Function < Field , RequestMatcher > ( ) { @Override
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( logger . isLoggable ( Level . INFO ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
public ByteBuffer function ( Framedata arg0 ) { getExtension ( ) . encodeFrame ( arg0 ) ; if ( WebSocketImpl . DEBUG ) System . out . println ( " afterEnconding( " + arg0 . getPayloadData ( ) . remaining ( ) + " ): { " + ( arg0 . getPayloadData ( ) . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . getPayloadData ( ) . array ( ) ) ) + " } " ) ; return super . createBinaryFrame ( arg0 ) ; }
public final Builder function ( final RequestSetting arg0 ) { this . arg0 = arg0 ; return this ; }
@Test public void function ( ) { CharacterReader reader = new CharacterReader ( " Hello! " ) ; assertFalse ( reader . isTrackNewlines ( ) ) ; reader . trackNewlines ( true ) ; assertTrue ( reader . isTrackNewlines ( ) ) ; reader . trackNewlines ( false ) ; assertFalse ( reader . isTrackNewlines ( ) ) ; }
public void function ( HttpResponse arg0 ) { logger . info ( " Response return: \ n \ n{} \ n " , responseDumper . dump ( arg0 ) ) ; }
private void function ( ) { buttonGroup = new ButtonGroup ( ) ; buttonGroup . add ( radioJCL ) ; buttonGroup . add ( radioLog4j ) ; buttonGroup . add ( radioJUL ) ; }
private < T extends SimpleRestSetting > Iterable < T > function ( final Iterable < RestSetting > arg0 , final Class < T > arg1 , final HttpMethod arg2 ) { return filter ( arg0 , arg1 ) . stream ( ) . filter ( input - > input . isSimple ( ) & & input . isFor ( arg2 ) )
private synchronized ByteBuffer function ( ByteBuffer arg0 ) throws SSLException { cTOs . clear ( ) ; res = sslEngine . wrap ( arg0 , cTOs ) ; cTOs . flip ( ) ; return cTOs ; }
private HttpResponse function ( HttpRequest arg0 , HttpResponseStatus arg1 ) { return new DefaultFullHttpResponse ( arg0 . getProtocolVersion ( ) , arg1 ) ; }
public void function ( ) throws Exception { server . get ( by ( uri ( " /target " ) ) ) . response ( " get_proxy " ) ; server . post ( and ( by ( uri ( " /target " ) ) , by ( " proxy " ) ) ) . response ( " post_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " put " ) ) , by ( " proxy " ) ) ) . response ( " put_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " delete " ) ) ) ) . response ( " delete_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " head " ) ) ) ) . response ( status ( 200 ) ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " options " ) ) ) ) . response ( " options_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " trace " ) ) ) ) . response ( " trace_proxy " ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " bla " ) ; logger . debug ( " hello " ) ; List < LogRecord > recordList = listHandler . recordList ; assertEquals ( 1 , recordList . size ( ) ) ; LogRecord logRecod = recordList . get ( 0 ) ; assertEquals ( this . getClass ( ) . getName ( ) , logRecod . getSourceClassName ( ) ) ; }
public boolean function ( GlobalSetting arg0 ) { return ! env . isPresent ( ) | | env . get ( ) . equalsIgnoreCase ( arg0 . getEnv ( ) ) ;
private static void function ( Token . StartTag arg0 , HtmlTreeBuilder arg1 ) { arg1 . insert ( arg0 ) ; arg1 . tokeniser . transition ( TokeniserState . Rcdata ) ; arg1 . markInsertionMode ( ) ; arg1 . transition ( Text ) ; }
public void function ( Node arg0 , int arg1 ) { if ( arg0 instanceof Element ) { Element el = ( Element ) arg0 ;
public void function ( ) { MDC . MDCCloseable closeable = MDC . putCloseable ( " k " , " v " ) ; assertNull ( MDC . get ( " k " ) ) ; closeable . close ( ) ; assertNull ( MDC . get ( " k " ) ) ; MDC . clear ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <abc_def id=1>Hello</abc_def> <abc-def id=2>There</abc-def> " ) ; Elements el1 = doc . select ( " abc_def " ) ; assertEquals ( 1 , el1 . size ( ) ) ; assertEquals ( " 1 " , el1 . first ( ) . id ( ) ) ; Elements el2 = doc . select ( " abc-def " ) ; assertEquals ( 1 , el2 . size ( ) ) ; assertEquals ( " 2 " , el2 . first ( ) . id ( ) ) ; }
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_T , BYTE_ESZETT , BYTE_G , BYTE_T , 0 , BYTE_G , BYTE_A , 0 , BYTE_G , BYTE_A } ; assertEquals ( 4 , BufferTools . indexOfTerminator ( buffer , 0 , 1 ) ) ; }
private List < String > function ( final List < String > arg0 ) { if ( arg0 . isEmpty ( ) ) { return null ; } return arg0 ; }
public void function ( ) throws NoSuchTagException { byte [ ] buffer = new byte [ ID3v1Tag . TAG_LENGTH - 1 ] ; new ID3v1Tag ( buffer ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.29 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public final ResponseHandler function ( final MocoConfig arg0 ) { HttpHeader appliedHeader = this . header . apply ( arg0 ) ; if ( appliedHeader ! = this . header ) { return new HttpHeaderResponseHandler ( appliedHeader ) ; } return this ; }
public ByteBuf function ( ) { ByteBuf buffer = Unpooled . buffer ( ) ; buffer . writeBytes ( request . getContent ( ) . getBytes ( ) ) ; return buffer ; }
private ID3v2PopmFrameData function ( final String arg0 ) { final ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { final ID3v2Frame frame = frameSet . getFrames ( ) . get ( 0 ) ; ID3v2PopmFrameData frameData ; try { frameData = new ID3v2PopmFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; return frameData ; } catch ( final InvalidDataException e ) { } } return null ; }
public void function ( String arg0 , Object . . . arg1 ) { delegate ( ) . error ( arg0 , arg1 ) ; }
public static ResponseHandler function ( final ResponseHandler . . . arg0 ) { return new SequenceContentHandler ( arg0 ) ; }
static void function ( ) { CONFIG_PARAMS = new SimpleLoggerConfiguration ( ) ; CONFIG_PARAMS . init ( ) ; }
public static byte [ ] function ( byte [ ] arg0 , int arg1 , int arg2 , int arg3 ) throws java . io . IOException { if ( arg0 = = null ) { throw new IllegalArgumentException ( " Cannot serialize a null array. " ) ; } if ( arg1 < 0 ) { throw new IllegalArgumentException ( " Cannot have negative offset:  " + arg1 ) ; } if ( arg2 < 0 ) { throw new IllegalArgumentException ( " Cannot have length offset:  " + arg2 ) ; } if ( arg1 + arg2 > arg0 . length ) { throw new IllegalArgumentException ( String . format ( " Cannot have offset of %d and length of %d with array of length %d " , arg1 , arg2 , arg0 . length ) ) ; } if ( ( arg3 & GZIP ) ! = 0 ) { java . io . ByteArrayOutputStream baos = null ;
public RunnerSetting function ( InputStream arg0 ) { return new RunnerSetting ( arg0 , null , null , null ) ; }
private static Elements function ( Collection < Element > arg0 , Collection < Element > arg1 ) { Elements filteredParents = new Elements ( ) ; for ( Element p : arg0 ) { for ( Element c : arg1 ) { if ( c . arg0 ( ) . contains ( p ) ) { filteredParents . add ( p ) ; } } } return filteredParents ; }
protected byte [ ] function ( ) { byte [ ] bytes = new byte [ getLength ( ) ] ; if ( comment ! = null ) bytes [ 0 ] = comment . getTextEncoding ( ) ; else bytes [ 0 ] = 0 ; String langPadded ; if ( language = = null ) { langPadded = DEFAULT_LANGUAGE ; } else if ( language . length ( ) > 3 ) { langPadded = language . substring ( 0 , 3 ) ; } else { langPadded = BufferTools . padStringRight ( language , 3 , ' \ 00 ' ) ; } try { BufferTools . stringIntoByteBuffer ( langPadded , 0 , 3 , bytes , 1 ) ; } catch ( UnsupportedEncodingException e ) { } int marker = 4 ; if ( description ! = null ) { byte [ ] descriptionBytes = description . toBytes ( true , true ) ; BufferTools . copyIntoByteBuffer ( descriptionBytes , 0 , descriptionBytes . length , bytes , marker ) ; marker + = descriptionBytes . length ; } if ( comment ! = null ) { byte [ ] commentBytes = comment . toBytes ( true , false ) ; BufferTools . copyIntoByteBuffer ( commentBytes , 0 , commentBytes . length , bytes , marker ) ; } return bytes ; }
public void function ( Object arg0 , Throwable arg1 ) { log ( ERROR_STR , arg0 . toString ( ) , arg1 ) ; }
public void function ( ) { request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_0 , HttpMethod . GET , " /foo " ) ; assertThat ( extractor . extract ( request ) , is ( HttpVersion . HTTP_1_0 . toString ( ) ) ) ;
public void function ( ) throws Exception { runTestScenario ( 4 ) ; }
public RequestMatcher function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . URI_ID ) ) { return context ( ( String ) arg0 . apply ( " " ) ) ; } if ( arg0 . isFor ( MocoConfig . REQUEST_ID ) ) { return ( RequestMatcher ) arg0 . apply ( anyRequest ( ) ) ; } return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private WatchKey function ( final Path arg0 ) { if ( directoryToKey . containsKey ( arg0 ) ) { return directoryToKey . get ( arg0 ) ; } try { WatchKey key = arg0 . register ( service , new WatchEvent . Kind [ ] { ENTRY_MODIFY } , HIGH ) ;
public boolean function ( ) { return log . isErrorEnabled ( ) ; }
public ContentResource function ( ) { ContentResource resource = super . retrieveResource ( ) ; if ( resource ! = null ) { return resource ; } ContentResource cacheResource = cache . retrieveResource ( ) ; if ( cacheResource ! = null ) { return cacheResource ; } throw new IllegalArgumentException ( " unknown response setting with  " + this ) ; }
public static MocoMonitor function ( String arg0 ) { return new FileMonitor ( arg0 ) ; }
private void function ( ) { System . out . println ( " moco -p port {-s [shutdown port]} [configuration file] " ) ; System . exit ( 1 ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( ! super . equals ( arg0 ) ) return false ; if ( getClass ( ) ! = arg0 . getClass ( ) ) return false ; ID3v2ChapterFrameData other = ( ID3v2ChapterFrameData ) arg0 ; if ( endOffset ! = other . endOffset ) return false ; if ( endTime ! = other . endTime ) return false ; if ( id = = null ) { if ( other . id ! = null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; if ( startOffset ! = other . startOffset ) return false ; if ( startTime ! = other . startTime ) return false ; if ( subframes = = null ) { if ( other . subframes ! = null ) return false ; } else if ( ! subframes . equals ( other . subframes ) ) return false ; return true ; }
public void function ( ) { logger . warn ( message , param1 , param2 , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . WARN , twoParams , exception ) ; }
public boolean function ( Element arg0 , Element arg1 ) { if ( arg0 = = arg1 ) return false ; Element parent = arg1 . parent ( ) ; while ( parent ! = arg0 ) { if ( sel . matches ( arg0 , parent ) ) return true ; parent = parent . parent ( ) ; } return false ; }
public void function ( ) throws IOException { String url = " http://direct.infohound.net/tools/q.pl " ; Connection con = Jsoup . connect ( url ) ; con . get ( ) ; Connection . Response res = con . response ( ) ; assertEquals ( " text/html " , res . header ( " Content-Type " ) ) ; assertEquals ( " no-cache, no-store " , res . header ( " Cache-Control " ) ) ; List < String > header = res . headers ( " Cache-Control " ) ; assertEquals ( 2 , header . size ( ) ) ; assertEquals ( " no-cache " , header . get ( 0 ) ) ; assertEquals ( " no-store " , header . get ( 1 ) ) ; }
void function ( int arg0 , arg1 . arg2 . arg3 . Level arg4 ) { LoggingEvent le = ( LoggingEvent ) listAppender . list . get ( arg0 ) ; assertEquals ( arg4 , le . getLevel ( ) ) ; }
public Element function ( String arg0 ) { return ( Element ) Validate . ensureNotNull ( Selector . selectFirst ( arg0 , this ) ,
public void function ( final DefaultCookie arg0 ) { arg0 . setHttpOnly ( true ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 1 , new Draft_6455 ( ) ) ; }
private ActualHttpServer function ( final Optional < Integer > arg0 , final Optional < HttpsCertificate > arg1 ) { if ( arg1 . isPresent ( ) ) { return createHttpsLogServer ( arg0 , arg1 . get ( ) ) ; } return createLogServer ( arg0 ) ; }
public void function ( WebSocket arg0 , Exception arg1 ) { arg1 . printStackTrace ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.2.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.23.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " 0<p>0</p> " ) ; assertEquals ( " 0 \ n<p>0</p> " , doc . body ( ) . html ( ) ) ; }
public void function ( ) { ID3v2PopmFrameData iD3v2PopmFrameData1 = new ID3v2PopmFrameData ( false , 1 ) ; iD3v2PopmFrameData1 . setAddress ( " Address1 " ) ; ID3v2PopmFrameData iD3v2PopmFrameData2 = new ID3v2PopmFrameData ( false , 1 ) ; iD3v2PopmFrameData1 . setAddress ( null ) ; assertFalse ( iD3v2PopmFrameData1 . equals ( iD3v2PopmFrameData2 ) ) ; }
private Predicate < ? super GlobalSetting > function ( final String arg0 ) { return globalSetting - > arg0 = = null | | arg0 . equalsIgnoreCase ( globalSetting . getEnv ( ) ) ; }
void function ( StringBuilder arg0 , int arg1 ) { arg0 . append ( getWholeData ( ) ) ; }
private boolean function ( String arg0 ) { Document html = Jsoup . parse ( arg0 ) ; Document xml = Jsoup . parse ( arg0 , " " , Parser . xmlParser ( ) ) ; int htmlElementCount = html . getAllElements ( ) . size ( ) ; int xmlElementCount = xml . getAllElements ( ) . size ( ) ; return htmlElementCount > xmlElementCount ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( file ( template ( " src/test/resources/${var} " , " var " , " foo.response " ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /template " ) ) , is ( " foo.response " ) ) ) ; }
public void function ( ) { Map < String , String > map = inheritableThreadLocalMap . get ( ) ; if ( map ! = null ) { map . clear ( ) ;
public void function ( ) throws Exception { Plain resource = new Plain ( ) ; resource . code = 1 ; resource . message = " hello " ; server . resource ( " targets " , get ( anyId ( ) ) . response ( json ( resource ) ) ) ; running ( server , ( ) - > { Plain response1 = getResource ( " /targets/1 " ) ;
public void function ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > { runWithConfiguration ( " rest/rest_error_without_response.json " ) ;
public void function ( ) { NDC . push ( " peek " ) ; String back = NDC . peek ( ) ; assertEquals ( " peek " , back ) ; }
public void function ( ) { Profiler profiler = new Profiler ( " BAS " ) ; profiler . start ( " doX " ) ; doX ( 1 ) ; profiler . start ( " doY " ) ; doY ( 10 ) ; profiler . start ( " doZ " ) ; doZ ( 2 ) ; profiler . stop ( ) ; profiler . sanityCheck ( ) ; StopWatch gSW = profiler . globalStopWatch ; assertEquals ( TimeInstrumentStatus . STOPPED , gSW . status ) ; assertEquals ( 3 , profiler . childTimeInstrumentList . size ( ) ) ; assertNotNull ( profiler . getLastTimeInstrument ( ) ) ; assertEquals ( " doZ " , profiler . getLastTimeInstrument ( ) . getName ( ) ) ; }
public void function ( ) throws Exception { RequestRecorder recorder = new RequestRecorder ( ) ; server . request ( by ( uri ( " /record " ) ) ) . response ( record ( recorder ) ) ; server . request ( by ( uri ( " /replay " ) ) ) . response ( replay ( recorder ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /record " ) , " foo " ) ;
public void function ( ) { FramedataImpl1 frame = FramedataImpl1 . get ( Opcode . BINARY ) ; frame . setFin ( false ) ; assertEquals ( " Fin must not be set " , false , frame . isFin ( ) ) ; frame . setTransferemasked ( true ) ; assertEquals ( " transferredMask must be set " , true , frame . getTransfereMasked ( ) ) ; ByteBuffer buffer = ByteBuffer . allocate ( 100 ) ; frame . setPayload ( buffer ) ; assertEquals ( " Payload must be of size 100 " , 100 , frame . getPayloadData ( ) . capacity ( ) ) ; frame . setRSV1 ( true ) ; assertEquals ( " RSV1 must be true " , true , frame . isRSV1 ( ) ) ; frame . setRSV2 ( true ) ; assertEquals ( " RSV2 must be true " , true , frame . isRSV2 ( ) ) ; frame . setRSV3 ( true ) ; assertEquals ( " RSV3 must be true " , true , frame . isRSV3 ( ) ) ; }
public Whitelist function ( String arg0 , String arg1 , String . . . arg2 ) { super . addProtocols ( arg0 , arg1 , arg2 ) ; return this ; }
public boolean function ( ) { for ( Element element : this ) { if ( element . hasText ( ) ) return true ; } return false ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.1.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 20 ) ; }
public void function ( ) throws UnsupportedEncodingException { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " \ u03B3 \ u03B5 \ u03B9 \ u03AC " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 2 , " UTF-16BE " ) ; byte [ ] expectedBuffer = { 0 , 0 , 0x03 , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
public boolean function ( final String arg0 ) { return Arrays . equals ( arg0 . getBytes ( ) , expected . readFor ( Optional . < Request > absent ( ) ) . getContent ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.7.11 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public String function ( ) { return attributes . hasKey ( " class " ) ? attributes . get ( " class " ) : " " ; }
private static ImmutableList < String > function ( final Path arg0 , final Path arg1 ) { final PathMatcher matcher = FileSystems . getDefault ( ) . getPathMatcher ( " glob: " + arg0 ) ; try { final ImmutableList . Builder < String > builder = ImmutableList . builder ( ) ;
Evaluator function ( ) { return evaluators . size ( ) > 0 ? evaluators . get ( evaluators . size ( ) - 1 ) : null ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://infohound.net/tools/302.pl " ) ; Document doc = con . get ( ) ; assertTrue ( doc . title ( ) . contains ( " jsoup " ) ) ; }
public void function ( String arg0 , Object arg1 ) { recordEvent_1Args ( Level . DEBUG , null , arg0 , arg1 ) ; }
boolean function ( ) { if ( lastStartTag = = null ) return false ; return tagPending . tagName . equals ( lastStartTag . tagName ) ; }
protected StartArgs function ( CommandLine arg0 ) { String port = arg0 . getOptionValue ( " p " ) ; String config = arg0 . getOptionValue ( " c " ) ; String shutdownPort = arg0 . getOptionValue ( " s " ) ; if ( config = = null ) { throw new ParseArgException ( " config is required " ) ; } if ( arg0 . getArgs ( ) . length ! = 1 ) { throw new ParseArgException ( " only one args allowed " ) ; } return StartArgs . builder ( ) . withType ( ServerType . SOCKET ) . withPort ( getPort ( port ) ) . withShutdownPort ( getPort ( shutdownPort ) ) . withConfigurationFile ( config ) . build ( ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( logger . isDebugEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public static String function ( arg0 . arg1 . Serializable arg2 ) throws arg0 . arg1 . IOException { return encodeObject ( arg2 , NO_OPTIONS ) ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { Optional < URL > url = remoteUrl ( arg0 ) ; if ( ! url . isPresent ( ) ) { return ; } HttpResponse response = doProxy ( arg0 , url . get ( ) ) ; doWritHttpResponse ( response , arg1 ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { Token . Doctype d = arg0 . asDoctype ( ) ; DocumentType doctype = new DocumentType ( arg1 . settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) ) ; doctype . setPubSysKey ( d . getPubSysKey ( ) ) ; arg1 . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) arg1 . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ; arg1 . transition ( BeforeHtml ) ; } else { arg1 . transition ( BeforeHtml ) ; return arg1 . process ( arg0 ) ; } return true ; }
protected void function ( final ChannelHandlerContext arg0 , final ByteBuf arg1 ) throws Exception { MessageContent content = content ( ) . withContent ( new ByteBufInputStream ( arg1 ) ) . build ( ) ; SocketRequest request = new DefaultSocketRequest ( content ) ; SessionContext context = new SessionContext ( request , new DefaultSocketResponse ( ) ) ; Optional < Response > response = server . getResponse ( context ) ; Response actual = response . orElseThrow ( ( ) - > new MocoException ( format ( " No handler found for request: %s " , context . getRequest ( ) . getContent ( ) ) ) ) ; arg0 . write ( Unpooled . wrappedBuffer ( actual . getContent ( ) . getContent ( ) ) ) ; }
private static String function ( byte [ ] arg0 ) { StringBuffer hexString = new StringBuffer ( ) ; for ( int i = 0 ; i < arg0 . length ; i + + ) { if ( i > 0 ) hexString . append ( ' ' ) ; String hex = Integer . toHexString ( 0xff & arg0 [ i ] ) ; if ( hex . length ( ) = = 1 ) hexString . append ( '0' ) ; hexString . append ( hex ) ; } return hexString . toString ( ) ; }
@Test @MultiLocaleTest public void function ( ) { ParseSettings parseSettings = new ParseSettings ( false , false ) ; Attributes attributes = new Attributes ( ) ; attributes . put ( " ITEM " , " 1 " ) ; Attributes normalizedAttributes = parseSettings . normalizeAttributes ( attributes ) ; assertEquals ( " item " , normalizedAttributes . asList ( ) . get ( 0 ) . getKey ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { if ( ! logger . isInfoEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . INFO_INT , arg1 , null , arg2 ) ;
public static Session function ( DefaultRequest arg0 , Response arg1 ) { Session session = new Session ( ) ; session . setRequest ( arg0 ) ; session . setResponse ( arg1 ) ; return session ; }
public void function ( ) { StartArgs args = parse ( ServerType . HTTP , " start " , " -p " , " 12306 " , " -c " , " foo.json " ) ; assertThat ( args . getPort ( ) . get ( ) , is ( 12306 ) ) ; assertThat ( args . getConfigurationFile ( ) . get ( ) , is ( " foo.json " ) ) ; }
public Element function ( String arg0 ) { Validate . notNull ( arg0 ) ; childNodes . clear ( ) ; elementChildren . clear ( ) ; TextNode textNode = new TextNode ( arg0 ) ; addChild ( textNode ) ; return this ; }
public void function ( byte [ ] arg0 ) throws NotYetConnectedException , InterruptedException { if ( conn ! = null ) { conn . send ( arg0 ) ;
public void function ( ) { Integer i1 = new Integer ( 1 ) ; Integer i2 = new Integer ( 2 ) ; Integer i3 = new Integer ( 3 ) ; Exception e = new Exception ( " This is a test exception. " ) ; Logger logger = LoggerFactory . getLogger ( " test2 " ) ; logger . debug ( " Hello world 1. " ) ; logger . debug ( " Hello world {} " , i1 ) ; logger . debug ( " val={} val={} " , i1 , i2 ) ; logger . debug ( " val={} val={} val={} " , new Object [ ] { i1 , i2 , i3 } ) ; logger . debug ( " Hello world 2 " , e ) ; logger . info ( " Hello world 2. " ) ; logger . warn ( " Hello world 3. " ) ; logger . warn ( " Hello world 3 " , e ) ; logger . error ( " Hello world 4. " ) ; logger . error ( " Hello world {} " , new Integer ( 3 ) ) ; logger . error ( " Hello world 4. " , e ) ; }
public void function ( ) { when ( request . getUri ( ) ) . thenReturn ( " /foo?param=&param2=value " ) ; assertThat ( extractor . extract ( request ) . get ( ) , is ( " " ) ) ; }
public void function ( String arg0 ) { delegateToParent . add ( arg0 ) ; }
public static CorsConfig function ( String . . . arg0 ) { return new CorsHeadersConfig ( arg0 ) ; }
public void function ( ) { frame . progressBar . setVisible ( false ) ; frame . otherLabel . setText ( " <html><font color='BLUE'>Scanned  " + addFileCount + "  java files,  " + inplaceConversionCount + "  files were modified.</font></html> " ) ; frame . migrateButton . setActionCommand ( MigratorFrame . EXIT_COMMAND ) ; frame . migrateButton . setText ( " Exit " ) ; frame . migrateButton . setToolTipText ( " Click on this button to exit this application. " ) ; frame . migrateButton . setEnabled ( true ) ;
private boolean function ( final MessageContent arg0 , final MessageContent arg1 ) { return arg0 = = null | | arg0 . equals ( arg1 ) | | ( arg1 ! = null & & arg0 . toString ( ) . equals ( arg1 . toString ( ) ) ) ;
public XmlDeclaration function ( ) { String data = getData ( ) ; Document doc = Jsoup . parse ( " < " + data . substring ( 1 , data . length ( ) - 1 ) + " > " , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( doc . getParser ( ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( " ! " ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ; } return decl ; }
public void function ( ) throws Exception { testHandshakeRejection ( 4 ) ; }
public void function ( Exception arg0 ) { } } ; String actualURI = client . getURI ( ) . getScheme ( ) + " :// " + client . getURI ( ) . getHost ( ) ; assertEquals ( " ws://localhost " , actualURI ) ; } }
public void function ( final String arg0 , final Throwable arg1 ) { Log . w ( name , arg0 , arg1 ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div class= \" c1 c2 \" >C</div> " ) ; Element div = doc . select ( " div " ) . get ( 0 ) ; assertEquals ( " c1 c2 " , div . className ( ) ) ; final Set < String > set1 = div . classNames ( ) ; final Object [ ] arr1 = set1 . toArray ( ) ; assertEquals ( 2 , arr1 . length ) ; assertEquals ( " c1 " , arr1 [ 0 ] ) ; assertEquals ( " c2 " , arr1 [ 1 ] ) ; set1 . add ( " c3 " ) ; assertEquals ( 2 , div . classNames ( ) . size ( ) ) ; assertEquals ( " c1 c2 " , div . className ( ) ) ; final Set < String > newSet = new LinkedHashSet < > ( 3 ) ; newSet . addAll ( set1 ) ; newSet . add ( " c3 " ) ; div . classNames ( newSet ) ; assertEquals ( " c1 c2 c3 " , div . className ( ) ) ; final Set < String > set2 = div . classNames ( ) ; final Object [ ] arr2 = set2 . toArray ( ) ; assertEquals ( 3 , arr2 . length ) ; assertEquals ( " c1 " , arr2 [ 0 ] ) ; assertEquals ( " c2 " , arr2 [ 1 ] ) ; assertEquals ( " c3 " , arr2 [ 2 ] ) ; }
void function ( StringBuilder arg0 ) { arg0 . append ( String . format ( " <!--%s--> " , getData ( ) ) ) ; }
public HttpsCertificate function ( HttpsArg arg0 ) { return arg0 . getCertificate ( ) ; }
public void function ( Object arg0 ) { lbLogger . debug ( TRACE_MARKER , ( String ) arg0 ) ; }
public void function ( String arg0 ) { recordEvent_0Args ( Level . WARN , null , arg0 , null ) ; }
public void function ( ChangeEvent arg0 ) { joinratelabel . setText ( " Joinrate:  " + joinrate . getValue ( ) + "  ms  " ) ; }
public void function ( Marker arg0 , String arg1 , Object [ ] arg2 ) { if ( ! logger . isInfoEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg1 , arg2 ) ;
public void function ( ) { CloseFrame frame = new CloseFrame ( ) ; assertEquals ( " Frame must extend dataframe " , true , frame instanceof ControlFrame ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 20 ) ;
public void function ( ) throws Exception { ID3v1Tag id3v1tag = new ID3v1Tag ( ) ; id3v1tag . setTitle ( " TITLE " ) ; id3v1tag . setArtist ( " ARTIST " ) ; id3v1tag . setAlbum ( " ALBUM " ) ; id3v1tag . setYear ( " 2001 " ) ; id3v1tag . setComment ( " COMMENT " ) ; id3v1tag . setTrack ( " 1 " ) ; id3v1tag . setGenre ( 0x0d ) ; byte [ ] expectedBuffer = BufferTools . stringToByteBuffer ( VALID_TAG_WITH_WHITESPACE , 0 , VALID_TAG_WITH_WHITESPACE . length ( ) ) ; TestHelper . replaceSpacesWithNulls ( expectedBuffer ) ; expectedBuffer [ expectedBuffer . length - 3 ] = 0x00 ; expectedBuffer [ expectedBuffer . length - 2 ] = 0x01 ; expectedBuffer [ expectedBuffer . length - 1 ] = 0x0D ; assertArrayEquals ( expectedBuffer , id3v1tag . toBytes ( ) ) ; }
public void function ( InputStream arg0 , int arg1 ) { HttpServer httpServer = createServer ( arg0 , arg1 ) ; stop ( ) ; run ( httpServer ) ; }
public void function ( ) { if ( writeThread ! = null ) { engine . close ( CloseFrame . NORMAL ) ;
public void function ( ) throws Exception { HttpsServer server = httpsServer ( port ( ) , DEFAULT_CERTIFICATE ) ; server . request ( by ( " foo " ) ) . response ( " bar " ) ; running ( server , ( ) - > { assertThat ( helper . postContent ( httpsRoot ( ) , " foo " ) , is ( " bar " ) ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( isTraceEnabled ( ) ) { handle2ArgsCall ( Level . TRACE , null , arg0 , arg1 , arg2 ) ;
public static void function ( String [ ] arg0 ) throws IOException { Document doc = Jsoup . connect ( " https://en.wikipedia.org/ " ) . get ( ) ; log ( doc . title ( ) ) ; Elements newsHeadlines = doc . select ( " #mp-itn b a " ) ; for ( Element headline : newsHeadlines ) { log ( " %s \ n \ t%s " , headline . attr ( " title " ) , headline . absUrl ( " href " ) ) ;
protected ResponseHandler function ( final MocoConfig arg0 ) { RecorderModifier applied = this . modifier . apply ( arg0 ) ; if ( applied ! = this . modifier ) { RecorderConfigurations configurations = RecorderConfigurations . create ( ImmutableList . < RecorderConfig > of ( group ( this . registry . getGroup ( ) ) , this . identifier , modifier ) ) ; return new DynamicReplayHandler ( configurations ) ; } return this ; }
public void function ( Object arg0 , Throwable arg1 ) { logger . log ( Level . SEVERE , arg0 . toString ( ) , arg1 ) ; }
private void function ( ) throws IOException , InvalidHandshakeException { if ( client . isConnectionPending ( ) ) { client . finishConnect ( ) ; } client . register ( selector , SelectionKey . OP_READ ) ; sendHandshake ( ) ; }
public static ActualHttpServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoConfig . . . arg2 ) { return createHttpsServerWithMonitor ( arg0 , arg1 , new Slf4jMonitor ( new HttpRequestDumper ( ) , new HttpResponseDumper ( ) ) , arg2 ) ;
public void function ( ) throws Exception { server . request ( or ( by ( " foo " ) , by ( uri ( " /foo " ) ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public static Tag function ( String arg0 , ParseSettings arg1 ) { Validate . notNull ( arg0 ) ; Tag tag = tags . get ( arg0 ) ; if ( tag = = null ) { arg0 = arg1 . normalizeTag ( arg0 ) ; Validate . notEmpty ( arg0 ) ; tag = tags . get ( arg0 ) ; if ( tag = = null ) { tag = new Tag ( arg0 ) ; tag . isBlock = false ; tag . canContainBlock = true ; } } return tag ; }
public void function ( ) throws IOException { runWithConiguration ( " foo.json " ) ; assertThat ( helper . get ( " http://localhost:8080/foo " ) , is ( " bar " ) ) ; }
public void function ( ) { synchronized ( this ) { if ( selectorthread ! = null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + "  can only be started once. " ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return ; } } selectorthread . setName ( " WebsocketSelector " + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocket . RCVBUF ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return ; } try { while ( ! selectorthread . isInterrupted ( ) ) {
public boolean function ( ) { return updateMetaCharset ; }
public static SocketServer function ( final int arg0 , final MocoMonitor arg1 , final MocoMonitor arg2 , final MocoMonitor . . . arg3 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualSocketServer . createServerWithMonitor ( arg0 , ApiUtils . mergeMonitor ( checkNotNull ( arg1 , " Monitor should not be null " ) ,
public static VerificationMode function ( final int arg0 , final int arg1 ) { return new BetweenVerification ( arg0 , arg1 ) ; }
protected void function ( ) throws Exception { super . tearDown ( ) ; root . setLevel ( oldLevel ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /record " ) ) ) . response ( record ( group ( " foo " ) ) ) ; server . request ( by ( uri ( " /replay " ) ) ) . response ( replay ( group ( " foo " ) , modifier ( template ( " ${req.content} " ) , header ( " X-REPLAY " , template ( " ${req.queries['type']} " ) ) ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /record?type=blah " ) , " foo " ) ;
private HttpServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { HttpServer targetServer = createBaseHttpServer ( arg0 , arg1 ) ; targetServer . request ( by ( uri ( " /favicon.ico " ) ) ) . response ( with ( pathResource ( " favicon.png " ) ) , header ( HttpHeaders . CONTENT_TYPE , MediaType . PNG . toString ( ) ) ) ; return targetServer ; }
public Set < String > function ( ) { if ( classNames = = null ) { String [ ] names = className ( ) . split ( " \\ s+ " ) ; classNames = new LinkedHashSet < String > ( Arrays . asList ( names ) ) ; } return classNames ; }
private Runner function ( final Server arg0 ) { if ( arg0 instanceof HttpServer ) { return Runner . runner ( ( HttpServer ) arg0 ) ; } if ( arg0 instanceof SocketServer ) { return Runner . runner ( ( SocketServer ) arg0 ) ; } throw new IllegalArgumentException ( " Unknown Server " ) ; }
public static Resource function ( final String arg0 ) { return arg0 ( text ( arg0 ) ) ; }
protected boolean function ( String arg0 , Element arg1 , Attribute arg2 ) { return super . isSafeAttribute ( arg0 , arg1 , arg2 ) ; }
protected boolean function ( final int arg0 ) { return arg0 > = count ; }
public Optional < ImmutableMap < String , String > > function ( FullHttpRequest arg0 ) { String cookieString = arg0 . headers ( ) . get ( HttpHeaders . Names . COOKIE ) ; if ( cookieString = = null ) { return absent ( ) ; } return of ( doExtract ( cookieString ) ) ; }
public void function ( ) throws Exception { HttpResponse httpResponse = helper . putForResponse ( remoteUrl ( " /targets/1 " ) , mapper . writeValueAsString ( resource1 ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 409 ) ) ; }
String function ( ) { bufferUp ( ) ; final int start = bufPos ; final int remaining = bufLength ; final char [ ] val = charBuf ; while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = '\t' | | c = = '\n' | | c = = '\r' | | c = = '\f' | | c = = ' ' | | c = = '/' | | c = = '>' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; } return bufPos > start ? cacheString ( charBuf , stringCache , start , bufPos - start ) : " " ; }
public void function ( ) { if ( id3v2Tag ! = null ) { id3v2Tag . clearFrameSet ( AbstractID3v2Tag . ID_COMMENT ) ; } if ( id3v1Tag ! = null ) { id3v1Tag . setComment ( null ) ;
public boolean function ( Element arg0 , Element arg1 ) { return arg0 = = arg1 ; }
public void function ( ) throws IOException { Log log = LogFactory . getLog ( " testing " ) ; oos . writeObject ( log ) ; }
public Resource function ( ) { if ( text ! = null ) { if ( text . isRawText ( ) ) { return text ( text . getText ( ) ) ; } if ( " template " . equalsIgnoreCase ( text . getOperation ( ) ) ) { return template ( text . getText ( ) ) ; } } if ( file ! = null ) { return file ( file ) ; } if ( pathResource ! = null ) { return pathResource ( pathResource ) ; } if ( version ! = null ) { return version ( version ) ; } throw new IllegalArgumentException ( " unknown response setting with  " + this ) ; }
public void function ( ) throws Exception { HttpsServer server = httpsServer ( port ( ) , DEFAULT_CERTIFICATE ) ; server . response ( " foo " ) ; running ( server , ( ) - > { assertThat ( helper . get ( httpsRoot ( ) ) , is ( " foo " ) ) ;
public void function ( WebSocket arg0 , Exception arg1 ) { if ( arg1 instanceof BindException ) { wasBindException = true ;
public boolean function ( ) { return ( _delegate instanceof LoggingEventAware ) ; }
public String function ( ) { if ( bufLength - bufPos < 0 ) return " " ; return new String ( charBuf , bufPos , bufLength - bufPos ) ; }
public void function ( final SessionContext arg0 ) { responseHandler . writeToResponse ( arg0 ) ;
private void function ( ) { principalPan = new JPanel ( ) ; principalPan . setLayout ( new BorderLayout ( ) ) ; conversionPan = new JPanel ( new GridLayout ( 2 , 2 , 10 , 10 ) ) ; JLabel lab = new JLabel ( " Conversion Mode " ) ; conversionPan . add ( lab ) ; combo = new JComboBox ( conversionMode ) ; conversionPan . add ( combo ) ; butCancel = new JButton ( " Cancel " ) ; butCancel . addActionListener ( this ) ; conversionPan . add ( butCancel ) ; butNext = new JButton ( " Next " ) ; butNext . addActionListener ( this ) ; conversionPan . add ( butNext ) ; consolePan = new JScrollPane ( ) ; console = new JTextArea ( ) ; console . setEditable ( false ) ; console . setLineWrap ( true ) ; console . setMargin ( new Insets ( 5 , 5 , 5 , 5 ) ) ; consolePan . setViewportView ( console ) ; principalPan . add ( conversionPan , BorderLayout . NORTH ) ; principalPan . add ( consolePan , BorderLayout . CENTER ) ; setContentPane ( principalPan ) ; pack ( ) ; }
@Test public void function ( ) { StringBuilder commentData = new StringBuilder ( maxBufferLen ) ; do { commentData . append ( " blah blah blah blah  " ) ; } while ( commentData . length ( ) < maxBufferLen ) ; String expectedCommentData = commentData . toString ( ) ; String testMarkup = " <html><body><! " + expectedCommentData + " ></body></html> " ; Parser parser = new Parser ( new HtmlTreeBuilder ( ) ) ; Document doc = parser . parseInput ( testMarkup , " " ) ; Node commentNode = doc . body ( ) . childNode ( 0 ) ; assertTrue ( commentNode instanceof Comment , " Expected comment node " ) ; assertEquals ( expectedCommentData , ( ( Comment ) commentNode ) . getData ( ) ) ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( message , param1 , param2 ) ; break ; case DEBUG : logger . debug ( message , param1 , param2 ) ; break ; case INFO : logger . info ( message , param1 , param2 ) ; break ; case WARN : logger . warn ( message , param1 , param2 ) ; break ; case ERROR : logger . error ( message , param1 , param2 ) ; break ; } verifyMessageWithoutMarker ( arg0 , twoParams , null ) ; }
public void function ( ) { try { String json = Request . Get ( " http://localhost:9090 " ) . execute ( ) . returnResponse ( ) . getHeaders ( " content-type " ) [ 0 ] . getValue ( ) ;
private void function ( HttpRequest arg0 , MutableHttpResponse arg1 ) { if ( configs . length = = 0 ) { arg1 . addHeader ( " Access-Control-Allow-Origin " , " * " ) ; arg1 . addHeader ( " Access-Control-Allow-Methods " , " * " ) ; arg1 . addHeader ( " Access-Control-Allow-Headers " , " * " ) ; return ; } writeCorsResponse ( arg0 , arg1 , CorsConfig : : isNonSimpleRequestConfig , true ) ; }
public static ActualHttpServer function ( final int arg0 , final MocoConfig . . . arg1 ) { return createHttpServerWithMonitor ( arg0 , new Slf4jMonitor ( new HttpRequestDumper ( ) , new HttpResponseDumper ( ) ) , arg1 ) ;
public void function ( ) throws Exception { server . get ( by ( uri ( " /target " ) ) ) . response ( " get_proxy " ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( template ( " http://localhost:12306/${var} " , " var " , " target " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { getSLF4JSystemLoggerFinder ( ) ; }
public final void function ( Object arg0 ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_WARN ) ) { log ( SimpleLog . LOG_LEVEL_WARN , arg0 , null ) ;
public Connection function ( arg0 Proxy arg1 ) { req . arg1 ( arg1 ) ; return this ; }
public void function ( final String arg0 ) { this . pong ( text ( checkNotNullOrEmpty ( arg0 , " Pong message should not be null " ) ) ) ; }
public void function ( int arg0 , String arg1 , boolean arg2 ) { if ( arg0 ! = CloseFrame . PROTOCOL_ERROR ) { fail ( " There should be a protocol error " ) ; } close ( ) ; latch . countDown ( ) ; }
public void function ( ) throws Exception { InputStream stream = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " foo.request " ) ; assertThat ( helper . postStream ( root ( ) , stream ) , is ( " foo " ) ) ; }
private org . apache . log4j . spi . LoggingEvent function ( LoggingEvent arg0 , Level arg1 ) { String formattedMessage = MessageFormatter . basicArrayFormat ( arg0 . getMessage ( ) , arg0 . getArgumentArray ( ) ) ; LocationInfo locationInfo = null ; String fcqn = null ; if ( arg0 instanceof SubstituteLoggingEvent ) { locationInfo = new LocationInfo ( NA_SUBST , NA_SUBST , NA_SUBST , " 0 " ) ; fcqn = FQCN_SUBSTITUE ; } else { fcqn = FQCN_FLUENT ; } ThrowableInformation ti = null ; Throwable t = arg0 . getThrowable ( ) ; if ( t ! = null ) ti = new ThrowableInformation ( t ) ; org . apache . log4j . spi . LoggingEvent log4jEvent = new org . apache . log4j . spi . LoggingEvent ( fcqn , logger , arg0 . getTimeStamp ( ) , arg1 , formattedMessage , arg0 . getThreadName ( ) , ti , null , locationInfo , null ) ; return log4jEvent ; }
private void function ( final SessionContext arg0 ) { for ( Setting setting : settings ) { if ( setting . match ( arg0 . getRequest ( ) ) ) { setting . writeToResponse ( arg0 ) ; return ; } } if ( anySetting . match ( arg0 . getRequest ( ) ) ) { anySetting . writeToResponse ( arg0 ) ; return ; } this . monitor . onUnexpectedMessage ( arg0 . getRequest ( ) ) ; throw new MocoException ( format ( " No handler found for request: %s " , arg0 . getRequest ( ) . getContent ( ) ) ) ; }
public void function ( ) throws IOException { assertThat ( helper . postContent ( root ( ) , jsonText ) , is ( " foo " ) ) ; }
public void function ( String arg0 ) { try { this . reconnect ( ) ;
public Element function ( String arg0 ) { return ( Element ) Validate . ensureNotNull ( Selector . selectFirst ( arg0 , this ) ) ; }
public void function ( ) throws Exception { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " TAG- " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 0 ) ; byte [ ] expectedBuffer = { BYTE_T , BYTE_A , BYTE_G , BYTE_DASH , 0 , 0 , 0 , 0 , 0 , 0 } ; assertTrue ( Arrays . equals ( expectedBuffer , buffer ) ) ; }
public String function ( ) { if ( ! id ( ) . isEmpty ( ) ) return " # " + id ( ) ; StringBuilder selector = new StringBuilder ( tagName ( ) ) ; String classes = StringUtil . join ( classNames ( ) , " . " ) ; if ( ! classes . isEmpty ( ) ) selector . append ( '.' ) . append ( classes ) ; if ( parent ( ) = = null | | parent ( ) instanceof Document ) return selector . toString ( ) ; selector . insert ( 0 , "  >  " ) ; if ( parent ( ) . select ( selector . toString ( ) ) . size ( ) > 1 ) selector . append ( String . format ( " :nth-child(%d) " , elementSiblingIndex ( ) + 1 ) ) ; return parent ( ) . cssSelector ( ) + selector . toString ( ) ; }
public static HttpServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoMonitor arg2 , final MocoMonitor arg3 , final MocoMonitor . . . arg4 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualHttpServer . createHttpsServerWithMonitor ( of ( arg0 ) , checkNotNull ( arg1 , " Certificate should not be null " ) , ApiUtils . mergeMonitor ( arg2 , arg3 , arg4 ) ) ;
private static void function ( Token . StartTag arg0 , TreeBuilder arg1 ) { arg1 . insert ( arg0 ) ; arg1 . tokeniser . transition ( TokeniserState . Rawtext ) ; arg1 . markInsertionMode ( ) ; arg1 . transition ( Text ) ; }
public boolean function ( ) { return isLevelEnabled ( LOG_LEVEL_ERROR ) ; }
public ResponseHandler function ( final MocoConfig arg0 ) { ResponseHandler handler = super . apply ( arg0 ) ; if ( handler ! = this ) { return handler ; } Resource resource = this . resource . apply ( arg0 ) ; if ( resource ! = this . resource ) { return new ContentHandler ( ( ContentResource ) resource ) ; } return this ; }
default public LoggingEventBuilder function ( Level arg0 ) { return makeLoggingEventBuilder ( arg0 ) ; }
public static String [ ] function ( Collection < String > arg0 ) { if ( arg0 = = null | | arg0 . isEmpty ( ) ) { return EMPTY_STRING_ARRAY ; } return arg0 . toArray ( EMPTY_STRING_ARRAY ) ; }
boolean function ( Element arg0 ) { return arg0 . attr ( key ) . toLowerCase ( ) . contains ( value ) ; }
private Level function ( int arg0 ) { Level log4jLevel ; switch ( arg0 ) { case LocationAwareLogger . TRACE_INT : log4jLevel = traceCapable ? Level . TRACE : Level . DEBUG ; break ; case LocationAwareLogger . DEBUG_INT : log4jLevel = Level . DEBUG ; break ; case LocationAwareLogger . INFO_INT : log4jLevel = Level . INFO ; break ; case LocationAwareLogger . WARN_INT : log4jLevel = Level . WARN ; break ; case LocationAwareLogger . ERROR_INT : log4jLevel = Level . ERROR ; break ; default : throw new IllegalStateException ( " Level number  " + arg0 + "  is not recognized. " ) ; } return log4jLevel ; }
public void function ( ) { Document doc = Jsoup . parse ( " <p>Two</p> <p><span>Three</span></p> " ) ; Elements el1 = doc . body ( ) . select ( " :not(p) " ) ; assertEquals ( 2 , el1 . size ( ) ) ; assertEquals ( " body " , el1 . first ( ) . tagName ( ) ) ; assertEquals ( " span " , el1 . last ( ) . tagName ( ) ) ; }
public final HttpArgs function ( ) { return new HttpArgs ( port , shutdownPort , configurationFile , settings , env , quiet ) ; }
void function ( String arg0 ) { while ( ( arg0 ! = null & & ! currentElement ( ) . nodeName ( ) . equals ( arg0 ) ) & & inSorted ( currentElement ( ) . nodeName ( ) , TagSearchEndTags ) )
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { arg1 . setHeader ( name , value ) ; }
private Function < SimpleRestSetting , ResponseHandler > function ( ) { return new Function < SimpleRestSetting , ResponseHandler > ( ) { @Override
void function ( Token . Doctype arg0 ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( arg0 . getName ( ) ) , arg0 . getPublicIdentifier ( ) , arg0 . getSystemIdentifier ( ) , baseUri ) ; insertNode ( doctypeNode ) ; }
public void function ( ) throws Exception { byte [ ] buffer = loadFile ( " test-res/obselete.mp3 " ) ; ID3v2 id3tag = ID3v2TagFactory . createTag ( buffer ) ; assertEquals ( " 2009 " , id3tag . getYear ( ) ) ; assertEquals ( " 4/15 " , id3tag . getTrack ( ) ) ; assertEquals ( " image/png " , id3tag . getAlbumImageMimeType ( ) ) ; assertEquals ( 40 , id3tag . getGenre ( ) ) ; assertEquals ( " Alt Rock " , id3tag . getGenreDescription ( ) ) ; assertEquals ( " NAME1234567890123456789012345678901234567890 " , id3tag . getTitle ( ) ) ; assertEquals ( " ARTIST1234567890123456789012345678901234567890 " , id3tag . getArtist ( ) ) ; assertEquals ( " COMPOSER1234567890123456789012345678901234567890 " , id3tag . getComposer ( ) ) ; assertEquals ( " ALBUM1234567890123456789012345678901234567890 " , id3tag . getAlbum ( ) ) ; assertEquals ( " COMMENTS1234567890123456789012345678901234567890 " , id3tag . getComment ( ) ) ; }
public int function ( ) { return childElementsList ( ) . size ( ) ; }
public void function ( ) { server . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
private void function ( FullHttpRequest arg0 , FullHttpResponse arg1 ) { if ( isKeepAlive ( arg0 ) ) { setKeepAlive ( arg1 , true ) ;
public Builder function ( final Map < String , String > arg0 ) { if ( arg0 ! = null ) { ImmutableMap . Builder < String , String [ ] > builder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { builder . put ( entry . getKey ( ) , new String [ ] { entry . getValue ( ) } ) ; } this . arg0 = builder . build ( ) ; } return this ; }
public boolean function ( final arg0 . arg1 . arg2 . HttpResponse arg3 ) { int statusCode = arg3 . getStatusLine ( ) . getStatusCode ( ) ; return statuses . contains ( statusCode ) ; }
public static ContentResource function ( final String arg0 , final Charset arg1 ) { return file ( text ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , of ( checkNotNull ( arg1 , " Charset should not be null " ) ) ) ; }
public void function ( final String [ ] arg0 ) { try { if ( arg0 . length < 1 ) {
private void function ( FrameworkEvent arg0 ) { Throwable t = arg0 . getThrowable ( ) ; String tString = null ; if ( t ! = null ) { tString = t . toString ( ) ; } System . out . println ( " Framework ERROR: " + " , source  " + arg0 . getSource ( ) + " , bundle= " + arg0 . getBundle ( ) + " , ex= " + tString ) ; if ( t ! = null ) { t . printStackTrace ( ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( logger . isInfoEnabled ( ) ) { String msgStr = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
public static ContentResource function ( final String arg0 , final Optional < Charset > arg1 ) { return pathResource ( text ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , checkNotNull ( arg1 , " Charset should not be null " ) ) ; }
public void function ( ) throws URISyntaxException { runWithConfiguration ( " websocket/websocket_with_broadcast.json " ) ; final Endpoint fooEndpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws " ) ) ; final Endpoint subscribeEndpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws " ) ) ; subscribeEndpoint . sendTextMessage ( " subscribe_with_file " ) ; assertThat ( fooEndpoint . getMessageAsText ( ) , is ( " foo.response " ) ) ; }
static private Level function ( ) { String verbosityStr = System . getProperty ( SLF4J_INTERNAL_VERBOSITY_KEY ) ; if ( verbosityStr = = null | | verbosityStr . isEmpty ( ) ) { return Level . INFO ; } if ( verbosityStr . equalsIgnoreCase ( " DEBUG " ) ) { return Level . DEBUG ; } if ( verbosityStr . equalsIgnoreCase ( " ERROR " ) ) { return Level . ERROR ; } if ( verbosityStr . equalsIgnoreCase ( " WARN " ) ) { return Level . WARN ; } return Level . INFO ; }
public void function ( int arg0 , String arg1 ) { close ( arg0 , arg1 , false ) ; }
public static HttpServer function ( final int arg0 , final MocoConfig < ? > . . . arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualHttpServer . createQuietServer ( arg0 , checkNotNull ( arg1 , " Configuration should not be null " ) ) ; }
public void function ( ) throws Exception { server . request ( and ( by ( uri ( " /foo " ) ) , eq ( query ( " param " ) , " " ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
private void function ( ChannelHandlerContext arg0 , HttpRequest arg1 ) { HttpResponse response = getResponse ( arg1 ) ; eventBus . post ( response ) ; arg0 . writeAndFlush ( response ) ; arg0 . disconnect ( ) ; arg0 . close ( ) ; }
public void function ( Profiler arg0 ) { arg0 . start ( " n1 " ) ; doX ( 1 ) ; arg0 . start ( " n2 " ) ; doX ( 5 ) ; arg0 . stop ( ) ; }
@Test public void function ( ) { TokenStream ts = TokenStream . create ( " <html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html> " ) ; Document doc = new Parser ( ts ) . parse ( ) ; Element body = doc . getChildren ( ) . get ( 1 ) ; Comment comment = ( Comment ) body . getChildNodes ( ) . get ( 0 ) ; assertEquals ( " <table><tr><td></table> " , comment . getData ( ) ) ; Element p = body . getChildren ( ) . get ( 0 ) ; TextNode text = ( TextNode ) p . getChildNodes ( ) . get ( 0 ) ; assertEquals ( " Hello " , text . getWholeText ( ) ) ; }
public void function ( ) { Elements els = SelectMatch . match ( Jsoup . parse ( " <p id=0 class='one two'><p id=1 class='one'><p id=2 class='two'> " ) , new ElementSelector ( " p " , " one " , null ) ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " 0 " , els . get ( 0 ) . id ( ) ) ; assertEquals ( " 1 " , els . get ( 1 ) . id ( ) ) ; Elements none = SelectMatch . match ( Jsoup . parse ( " <div class='one'></div> " ) , new ElementSelector ( null , " foo " , null ) ) ; assertEquals ( 0 , none . size ( ) ) ; Elements els2 = SelectMatch . match ( Jsoup . parse ( " <div class='one-two'></div> " ) , new ElementSelector ( null , " one-two " , null ) ) ; assertEquals ( 1 , els2 . size ( ) ) ; }
public static MocoEventAction function ( final Resource arg0 ) { return new MocoRequestAction ( checkNotNull ( arg0 , " URL should not be null " ) , HttpMethod . GET , Optional . < ContentResource > absent ( ) ) ; }
Element function ( String arg0 ) { Element el = new Element ( tagFor ( arg0 , settings ) , null ) ; insert ( el ) ; return el ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div> \ n <p>Hello</p> </div> " ) ; assertEquals ( " <p>Hello</p> " , doc . getElementsByTag ( " div " ) . get ( 0 ) . html ( ) ) ; }
public void function ( ) throws IOException { thrown . expect ( IllegalArgumentException . class ) ; Base64 . encodeBytesToBytes ( new byte [ ] { 83 , 10 , 91 , 67 , 42 , - 1 , 107 , 62 , 91 , 67 } , 8 , 6 , 26 ) ; }
public List < Node > function ( ) { return childNodes ; }
public Element function ( String arg0 ) { return ( Element ) super . after ( arg0 ) ; }
public void function ( ) throws Exception { try { new Mp3File ( NOT_AN_MP3 ) ;
boolean function ( Element arg0 ) { return ( arg0 . attr ( key ) ! = null ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.14 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public List < Attribute > function ( ) { List < Attribute > list = new ArrayList < Attribute > ( attributes . size ( ) ) ; for ( Map . Entry < String , Attribute > entry : attributes . entrySet ( ) ) { list . add ( entry . getValue ( ) ) ; } return Collections . unmodifiableList ( list ) ; }
@Test public void function ( ) throws IOException { int cap = 5 * 1024 ; String url = FileServlet . urlTo ( " /htmltests/large.html " ) ; try ( BufferedInputStream stream = Jsoup . connect ( url )
private void function ( ) throws IOException , InvalidHandshakeException { String path = uri . getPath ( ) ; if ( path . indexOf ( " / " ) ! = 0 ) { path = " / " + path ; } int port = getPort ( ) ; String host = uri . getHost ( ) + ( port ! = WebSocket . DEFAULT_PORT ? " : " + port : " " ) ; String origin = " x " ; HandshakedataImpl1 handshake = new HandshakedataImpl1 ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( " Host " , host ) ; handshake . put ( " Origin " , origin ) ; conn . startHandshake ( handshake ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " record_replay.json " ) ; helper . postContent ( remoteUrl ( " /record-template?type=foo " ) , " foo " ) ; helper . postContent ( remoteUrl ( " /record-template?type=bar " ) , " bar " ) ; assertThat ( helper . get ( remoteUrl ( " /replay-template?type=foo " ) ) , is ( " foo " ) ) ; assertThat ( helper . get ( remoteUrl ( " /replay-template?type=bar " ) ) , is ( " bar " ) ) ; }
public final Optional < SslHandler > function ( ) { if ( this . certificate ! = null ) { return Optional . of ( asSslHandler ( certificate ) ) ; } return absent ( ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { if ( ! logger . isTraceEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . TRACE_INT , arg1 , new Object [ ] { arg2 } , null ) ;
public void function ( ) { PingFrame frame = new PingFrame ( ) ; try { frame . isValid ( ) ; } catch ( InvalidDataException e ) { fail ( " InvalidDataException should not be thrown " ) ; } frame . setFin ( false ) ; try { frame . isValid ( ) ; fail ( " InvalidDataException should be thrown " ) ; } catch ( InvalidDataException e ) { } frame . setFin ( true ) ; frame . setRSV1 ( true ) ; try { frame . isValid ( ) ; fail ( " InvalidDataException should be thrown " ) ; } catch ( InvalidDataException e ) { } frame . setRSV1 ( false ) ; frame . setRSV2 ( true ) ; try { frame . isValid ( ) ; fail ( " InvalidDataException should be thrown " ) ; } catch ( InvalidDataException e ) { } frame . setRSV2 ( false ) ; frame . setRSV3 ( true ) ; try { frame . isValid ( ) ;
@Test public void function ( ) { String html = " foo <b>bar</b> baz " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " foo bar baz " , doc . text ( ) ) ;
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; assertTrue ( deflateExtension . isServerNoContextTakeover ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.1.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
boolean function ( String arg0 ) { if ( arg0 = = null ) { return false ; } File file = new File ( arg0 ) ; if ( file . exists ( ) & & file . isDirectory ( ) ) { return true ;
private void function ( SeekableByteChannel arg0 ) throws IOException { int bufferLength = ( int ) ( getLength ( ) - ( endOffset + 1 ) ) ; if ( hasId3v1Tag ( ) ) bufferLength - = ID3v1Tag . TAG_LENGTH ; if ( bufferLength < = 0 ) { customTag = null ;
public static Function < RestPutSetting , RestSetting > function ( ) { return new Function < RestPutSetting , RestSetting > ( ) { @Override
public void function ( ) { JsonPathRequestExtractor unitUnderTest = new JsonPathRequestExtractor ( " $.detail_item_list[*].number " ) ; HttpRequest request = DefaultHttpRequest . builder ( ) . withContent ( " { \ n " + "      \" detail_item_list \" :[ \ n " + "     { \ n " + "          \" number \" : 100 \ n " + "      }] \ n " + " } " + " \" number \" : 100 " + " }]} " ) . build ( ) ; Optional < Object > result = unitUnderTest . extract ( request ) ; assertThat ( result . isPresent ( ) , is ( true ) ) ; String [ ] texts = ( String [ ] ) result . get ( ) ; assertThat ( texts [ 0 ] , is ( " 100 " ) ) ; }
public void function ( ) throws IOException { assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " 0XCAFEBABE " ) ) ; assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " 0XCAFEBABE " ) ) ; assertThat ( Files . toString ( tempFile , Charset . defaultCharset ( ) ) , countString ( " /proxy " , 1 ) ) ; }
private static Elements function ( String arg0 , Document arg1 ) { return arg1 . select ( " th:contains( " + arg0 + " ) + td " ) ; }
public void function ( ) { final Document doc = createHtmlDocument ( " changeThis " ) ; doc . updateMetaCharset ( true ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; final String htmlCharsetUTF8 = " <html> \ n " + "  <head> \ n " + "   <meta charset= \" " + charsetUtf8 + " \" > \ n " + "  </head> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( htmlCharsetUTF8 , doc . toString ( ) ) ; Element selectedElement = doc . select ( " meta[charset] " ) . first ( ) ; assertEquals ( charsetUtf8 , doc . charset ( ) . displayName ( ) ) ; assertEquals ( charsetUtf8 , selectedElement . attr ( " charset " ) ) ; assertEquals ( doc . charset ( ) , doc . outputSettings ( ) . charset ( ) ) ; }
public final T function ( final RequestMatcher . . . arg0 ) { checkNotNull ( arg0 , " Matcher should not be null " ) ; return request ( or ( head ( arg0 ) , tail ( arg0 ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /event-with-unit " ) ) , is ( " post_foo " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " 0XCAFEBABE " ) ) ; }
public void function ( final String arg0 , final MountTo arg1 , final MountPredicate . . . arg2 ) { File mountedDir = new File ( arg0 ) ; this . request ( new MountMatcher ( mountedDir , arg1 , copyOf ( arg2 ) ) ) . response ( new MountHandler ( mountedDir , arg1 ) ) ; }
static Set < URL > function ( ) { Set < URL > staticLoggerBinderPathSet = new LinkedHashSet < URL > ( ) ; try { ClassLoader loggerFactoryClassLoader = LoggerFactory . class . getClassLoader ( ) ; Enumeration < URL > paths ; if ( loggerFactoryClassLoader = = null ) { paths = ClassLoader . getSystemResources ( STATIC_LOGGER_BINDER_PATH ) ; } else { paths = loggerFactoryClassLoader . getResources ( STATIC_LOGGER_BINDER_PATH ) ; } while ( paths . hasMoreElements ( ) ) { URL path = paths . nextElement ( ) ; staticLoggerBinderPathSet . add ( path ) ; } } catch ( IOException ioe ) { Util . report ( " Error getting resources from path " , ioe ) ; } return staticLoggerBinderPathSet ; }
protected String function ( String arg0 ) { return BufferTools . substitute ( arg0 , " \" " , " \" \" " ) ; }
public final ReplayContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return new ReplayContainer ( null , helper . text ( arg0 ) , null ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; InternalReplayContainer value = arg0 . readValueAs ( InternalReplayContainer . class ) ; return value . toContainer ( ) ; } return ( ReplayContainer ) arg1 . handleUnexpectedToken ( ReplayContainer . class , arg0 ) ; }
public static Function < RestHeadSetting , RestSetting > function ( ) { return new Function < RestHeadSetting , RestSetting > ( ) { @Override
public void function ( ) throws Exception { String result = helper . getWithHeader ( root ( ) , of ( " foo " , " bar " ) ) ; assertThat ( result , is ( " blah " ) ) ;
public void function ( ) throws Exception { InputStream stream = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " gbk.response " ) ; assertThat ( helper . getAsBytes ( remoteUrl ( " /template " ) ) , is ( ByteStreams . toByteArray ( stream ) ) ) ; }
public void function ( WebSocket arg0 , String arg1 ) { arg0 . send ( arg1 ) ; }
protected RestSettingBuilder function ( ) { return MocoRest . delete ( id ( ) ) ; }
public void function ( ) { logger . debug ( message ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . DEBUG , null , null ) ; }
public Builder function ( final String arg0 ) { this . arg0 = arg0 ; return this ; }
private RequestMatcher function ( String arg0 , TextContainer arg1 ) { if ( arg1 . isRawText ( ) ) { return createSingleMatcher ( arg0 , arg1 . getText ( ) ) ; } if ( " exist " . equals ( arg1 . getOperation ( ) ) ) { return existMatcher ( Extractors . extractor ( arg0 ) , arg1 ) ; } return createRequestMatcherWithResource ( arg1 . getOperation ( ) , createResource ( arg0 , arg1 . getText ( ) ) ) ; }
public void function ( ) throws IOException { InputStream stream = SettingRunnerTest . class . getClassLoader ( ) . getResourceAsStream ( " multiple/env-settings.json " ) ; runner = new SettingRunner ( stream , createStartArgs ( 12306 , " bar " ) ) ; runner . run ( ) ; helper . get ( remoteUrl ( " /foo/foo " ) ) ; }
static void function ( Element arg0 , String arg1 ) { NodeIterator < Node > it = NodeIterator . from ( arg0 ) ; assertIterates ( it , arg1 ) ; }
public void function ( ) { Attributes a = new Attributes ( ) ; String [ ] [ ] datas = { { " Tot " , " raul " } , { " Hello " , " pismuth " } , { " data-name " , " Jsoup " } } ; for ( String [ ] atts : datas ) { a . put ( atts [ 0 ] , atts [ 1 ] ) ; } Iterator < Attribute > iterator = a . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; int i = 0 ; for ( Attribute attribute : a ) { assertEquals ( datas [ i ] [ 0 ] , attribute . getKey ( ) ) ; assertEquals ( datas [ i ] [ 1 ] , attribute . getValue ( ) ) ; i + + ; } assertEquals ( datas . length , i ) ; }
public void function ( ) throws Exception { server . response ( template ( file ( " foo.response " ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " foo.response " ) ) ) ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws ServletException , IOException { arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; PrintWriter w = arg1 . getWriter ( ) ; int maxTime = - 1 ; String maxTimeP = arg0 . getParameter ( MaxTimeParam ) ; if ( maxTimeP ! = null ) { maxTime = Integer . valueOf ( maxTimeP ) ; } long startTime = System . currentTimeMillis ( ) ; while ( true ) { w . println ( " <p>Are you still there? " ) ;
protected boolean function ( final JsonNode arg0 , final JsonNode arg1 ) { return arg0 . equals ( arg1 ) ; }
public void function ( ) throws Exception { File temp = File . createTempFile ( " temp " , Long . toString ( System . nanoTime ( ) ) ) ; server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( group ( " foo " ) , tape ( temp . getPath ( ) ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( group ( " foo " ) , tape ( temp . getPath ( ) ) , identifier ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /foo-record?type=bar " ) , " bar " ) ; helper . postContent ( remoteUrl ( " /foo-record?type=blah " ) , " blah " ) ; } ) ; HttpServer newServer = createServer ( port ( ) ) ; newServer . request ( by ( uri ( " /tape-replay " ) ) ) . response ( replay ( group ( " foo " ) , tape ( temp . getPath ( ) ) , identifier ( " ${req.queries['type']} " ) ) ) ; running ( newServer , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /tape-replay?type=bar " ) ) , is ( " bar " ) ) ;
public void function ( ) { String html = " <html><head></head><body style= \" color: red \"   \"  name \" ></body></html> " ; org . jsoup . nodes . Document jsoupDoc ; jsoupDoc = Jsoup . parse ( html ) ; Element body = jsoupDoc . select ( " body " ) . first ( ) ; assertTrue ( body . hasAttr ( " \" " ) ) ; assertTrue ( body . hasAttr ( " name \" " ) ) ; Document w3Doc = new W3CDom ( ) . fromJsoup ( jsoupDoc ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { String name = arg0 . asEndTag ( ) . normalName ( ) ; ArrayList < Element > stack = arg1 . getStack ( ) ; for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element node = stack . get ( pos ) ; if ( node . nodeName ( ) . equals ( name ) ) { arg1 . generateImpliedEndTags ( name ) ; if ( ! name . equals ( arg1 . currentElement ( ) . nodeName ( ) ) ) arg1 . error ( this ) ; arg1 . popStackToClose ( name ) ; break ; } else { if ( arg1 . isSpecial ( node ) ) { arg1 . error ( this ) ; return false ; } } } return true ; }
public void function ( String arg0 , Throwable arg1 ) { recordEventwithoutMarkerArgArray ( Level . WARN , arg0 , null , arg1 ) ; }
public void function ( ) { logger = LoggerFactory . getLogger ( Converter . class ) ; matcher = AbstractMatcher . getMatcherImpl ( ) ; writer = new Writer ( ) ; matcher . setWriter ( writer ) ; }
public boolean function ( ) { return serverNoContextTakeover ; }
public void function ( ) throws IOException { org . apache . http . HttpResponse response = helper . getResponse ( root ( ) ) ; Header header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " foo.response " ) ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , response ( header ( HttpHeaders . CONTENT_TYPE , " text/plain " ) ) ) ; server . response ( version ( VERSION_1_0 ) ) ; running ( server , ( ) - > { HttpResponse response = helper . getResponse ( root ( ) ) ;
Token function ( ) { reset ( data ) ; dataS = null ; bogus = false ; return this ; }
public void function ( ) throws Exception { server . mount ( MOUNT_DIR , to ( " /dir " ) , exclude ( " *.response " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) { ID3v2ChapterFrameData frameData1 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2ChapterFrameData frameData2 = new ID3v2ChapterFrameData ( false , " ch1 " , 2 , 380 , 3 , 400 ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
public Builder function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) { server . mount ( " unknown_dir " , to ( " /dir " ) ) ; }
public void function ( ) { ID3v2CommentFrameData frameData1 = new ID3v2CommentFrameData ( false , TEST_LANGUAGE , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , null ) ; ID3v2CommentFrameData frameData2 = new ID3v2CommentFrameData ( false , TEST_LANGUAGE , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , new EncodedText ( ( byte ) 0 , TEST_VALUE ) ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 19 , new Draft_6455 ( ) ) ; }
void function ( TokeniserState arg0 ) { reader . advance ( ) ; this . arg0 = arg0 ; }
public int function ( int arg0 ) throws LimitExedeedException , InvalidDataException { if ( arg0 < 0 ) throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , " Negative count " ) ; return arg0 ; }
public static ActualSocketServer function ( final int arg0 , final MocoMonitor arg1 ) { return new ActualSocketServer ( Optional . of ( arg0 ) , arg1 ) ; }
public final ResponseHandler function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . RESPONSE_ID ) ) { return ( ResponseHandler ) arg0 . apply ( this ) ; } return this ; }
public void function ( ) throws Exception { ID3v2ObseletePictureFrameData frameData1 = new ID3v2ObseletePictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 0 , new EncodedText ( ( byte ) 1 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; ID3v2ObseletePictureFrameData frameData2 = new ID3v2ObseletePictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 0 , new EncodedText ( ( byte ) 1 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; assertEquals ( frameData1 , frameData2 ) ; }
@Test public void function ( ) { TokenQueue q = new TokenQueue ( " p \\ \\ p p \\ .p p \\ :p p \\ !p " ) ; assertEquals ( " p \\ p " , q . consumeElementSelector ( ) ) ; assertTrue ( q . consumeWhitespace ( ) ) ; assertEquals ( " p.p " , q . consumeElementSelector ( ) ) ; assertTrue ( q . consumeWhitespace ( ) ) ; assertEquals ( " p:p " , q . consumeElementSelector ( ) ) ; assertTrue ( q . consumeWhitespace ( ) ) ; assertEquals ( " p!p " , q . consumeElementSelector ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; }
public String function ( ) { return super . toStringHelper ( ) . add ( " uri " , this . uri )
public void function ( ChannelHandlerContext arg0 , MessageEvent arg1 ) throws Exception { Object message = arg1 . getMessage ( ) ; if ( message instanceof HttpRequest ) { httpRequestReceived ( ( HttpRequest ) message , arg1 . getChannel ( ) ) ;
private void function ( ) { layoutManager . putConstraint ( SpringLayout . WEST , migrationLabel , BASIC_PADDING , SpringLayout . EAST , this ) ; layoutManager . putConstraint ( SpringLayout . NORTH , migrationLabel , BASIC_PADDING , SpringLayout . NORTH , this ) ; slh . placeToTheRight ( migrationLabel , radioJCL , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( radioJCL , radioLog4j , 0 , 0 ) ; slh . placeBelow ( migrationLabel , folderLabel , 0 , BASIC_PADDING * 5 ) ; slh . placeToTheRight ( folderLabel , folderTextField ) ; slh . placeToTheRight ( folderTextField , browseButton , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( folderLabel , warningLabel , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( warningLabel , awareCheckBox , 0 , ( int ) ( BASIC_PADDING * 1.5 ) ) ; slh . placeToTheRight ( awareCheckBox , awareLabel ) ; slh . placeBelow ( awareCheckBox , migrateButton , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( migrateButton , otherLabel , 0 , BASIC_PADDING * 2 ) ; slh . placeBelow ( otherLabel , progressBar , 0 , BASIC_PADDING ) ; }
public void function ( ) { SimpleLogger . init ( ) ; SimpleLogger simpleLogger = new SimpleLogger ( this . getClass ( ) . getName ( ) ) ; System . setErr ( replacement ) ; simpleLogger . info ( " hello " ) ; replacement . flush ( ) ; assertTrue ( bout . toString ( ) . contains ( " INFO org.slf4j.impl.SimpleLoggerTest - hello " ) ) ; }
static final public void function ( String arg0 ) { System . err . println ( " SLF4J:  " + arg0 ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${random(-10)} " ) ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( HttpRequest arg0 ) { return doMatch ( failover . getUri ( ) , arg0 . getUri ( ) ) & & doMatch ( failover . getVersion ( ) , arg0 . getVersion ( ) )
public void function ( ) throws IOException { InputStream stream = getResourceAsStream ( " settings/context-settings.json " ) ; runner = new SettingRunner ( stream , createStartArgs ( 12306 ) ) ; runner . run ( ) ; assertThat ( helper . get ( remoteUrl ( " /foo/foo " ) ) , is ( " foo " ) ) ; assertThat ( helper . get ( remoteUrl ( " /bar/bar " ) ) , is ( " bar " ) ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) { return true ; } if ( ! ( arg0 instanceof Message ) ) { return false ; } Message that = ( Message ) arg0 ; return doEquals ( version , that . version ) & & doEquals ( content , that . content )
public ContentResource function ( ) { if ( this . content = = null ) { return null ; } return this . content . asTemplateResource ( ) ; }
protected ActualSocketServer function ( final ActualSocketServer arg0 ) { return newBaseServer ( this . getPort ( ) . orElseGet ( ( ) - > arg0 . getPort ( ) . orElse ( 0 ) ) ) ; }
public void function ( ) { Elements els = SelectMatch . match ( Jsoup . parse ( " <p id=0 class='one two'><p id=1 class='one'><p id=2 class='two'> " ) , Parser . parse ( " p.one " ) ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " 0 " , els . get ( 0 ) . id ( ) ) ; assertEquals ( " 1 " , els . get ( 1 ) . id ( ) ) ; Elements none = SelectMatch . match ( Jsoup . parse ( " <div class='one'></div> " ) , Parser . parse ( " .foo " ) ) ; assertEquals ( 0 , none . size ( ) ) ; Elements els2 = SelectMatch . match ( Jsoup . parse ( " <div class='one-two'></div> " ) , Parser . parse ( " .one-two " ) ) ; assertEquals ( 1 , els2 . size ( ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { logger . error ( String . valueOf ( arg0 ) , arg1 ) ; }
@Test public void function ( ) { CharacterReader r = new CharacterReader ( " One Two Two Four " ) ; assertEquals ( " One  " , r . consumeTo ( " Two " ) ) ; assertEquals ( 'T' , r . consume ( ) ) ; assertEquals ( " wo  " , r . consumeTo ( " Two " ) ) ; assertEquals ( 'T' , r . consume ( ) ) ; StringBuilder builder = new StringBuilder ( ) ; String part ; do { part = r . consumeTo ( " Qux " ) ; builder . append ( part ) ; } while ( ! part . isEmpty ( ) ) ; assertEquals ( " wo Four " , builder . toString ( ) ) ; }
private static boolean function ( Token arg0 ) { if ( arg0 . isCharacter ( ) ) { String data = arg0 . asCharacter ( ) . getData ( ) ; return isWhitespace ( data ) ; } return false ; }
public void function ( ) { if ( thread ! = null ) throw new IllegalStateException ( " already/still connected " ) ; thread = new Thread ( this ) ; thread . start ( ) ; }
boolean function ( String arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; String elName = el . nodeName ( ) ; if ( elName . equals ( arg0 ) ) return true ; if ( ! StringUtil . in ( elName , TagSearchSelectScope ) ) return false ; } Validate . fail ( " Should not be reachable " ) ; return false ; }
public static String function ( String arg0 ) { return arg0 . toLowerCase ( Locale . ENGLISH ) ; }
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 ) { return new ExistMatcher < T > ( checkNotNull ( arg0 , " Extractor should not be null " ) ) ; }
public Connection function ( CookieStore arg0 ) { req . cookieManager = new CookieManager ( arg0 , null ) ; return this ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( by ( uri ( " /path " ) ) ) ) ; final String jsonContent = " { \" foo \" : \" bar \" } " ; server . request ( json ( text ( jsonContent ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; deflateExtension . setThreshold ( 0 ) ; String str = " This is a highly compressable text " + " This is a highly compressable text " + " This is a highly compressable text " + " This is a highly compressable text " + " This is a highly compressable text " ; byte [ ] message = str . getBytes ( ) ; TextFrame frame = new TextFrame ( ) ; frame . setPayload ( ByteBuffer . wrap ( message ) ) ; deflateExtension . encodeFrame ( frame ) ; assertTrue ( message . length > frame . getPayloadData ( ) . array ( ) . length ) ; }
@Test public void function ( ) { CharacterReader r = new CharacterReader ( " One Two Two Four " ) ; assertEquals ( " One  " , r . consumeTo ( " Two " ) ) ; assertEquals ( 'T' , r . consume ( ) ) ; assertEquals ( " wo  " , r . consumeTo ( " Two " ) ) ; assertEquals ( 'T' , r . consume ( ) ) ; assertEquals ( " wo Four " , r . consumeTo ( " Qux " ) ) ; }
public static ResponseHandler function ( final ProxyConfig arg0 ) { return proxy ( checkNotNull ( arg0 ) , Failover . DEFAULT_FAILOVER ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( InvalidDataException arg0 ) { close ( arg0 . getCloseCode ( ) , arg0 . getMessage ( ) ) ; }
private StartArgs function ( int arg0 , String arg1 ) { return new StartArgs ( arg0 , null , null , null , arg1 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( file ) ) ; assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " post_foo " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) , containsString ( " 0XCAFEBABE " ) ) ; }
public static ContentResource function ( final Resource arg0 ) { checkNotNull ( arg0 , " Json should not be null " ) ; return json ( ( ) - > arg0 ) ; }
private ResponseHandler function ( final String arg0 , final String arg1 , final CookieContainer arg2 ) { try { Method method = Moco . class . getMethod ( arg0 , String . class , Resource . class , CookieAttribute [ ] . class ) ;
private static String function ( byte arg0 ) { try { return characterSets [ arg0 ] ;
public int function ( ByteBuffer arg0 ) throws IOException { if ( SSL = = 4 ) { return sc . write ( wrap ( arg0 ) ) ; } return sc . write ( arg0 ) ; }
private void function ( ) { TokenQueue cq = new TokenQueue ( tq . chompBalanced ( '[' , ']' ) ) ; String key = cq . consumeToAny ( " = " , " != " , " ^= " , " $= " , " *= " , " ~= " ) ; Validate . notEmpty ( key ) ; cq . consumeWhitespace ( ) ; if ( cq . isEmpty ( ) ) { if ( key . startsWith ( " ^ " ) )
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { this . sendToAll ( " new connection:  " + arg1 . getResourceDescriptor ( ) ) ; System . out . println ( arg0 + "  entered the room! " ) ; }
@Test public void function ( ) { String t = " <textarea>one < two </TEXTarea> " ; TokenQueue tq = new TokenQueue ( t ) ; String data = tq . chompToIgnoreCase ( " </textarea " ) ; assertEquals ( " <textarea>one < two  " , data ) ; tq = new TokenQueue ( " <textarea> one two < three </oops> " ) ; data = tq . chompToIgnoreCase ( " </textarea " ) ; assertEquals ( " <textarea> one two < three </oops> " , data ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " template.json " ) ; assertThat ( helper . get ( remoteUrl ( " /file_template " ) ) , is ( " GET " ) ) ; }
public void function ( ) throws Exception { PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; server . request ( json ( pojo ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
private final static void function ( ) { try { List < SLF4JServiceProvider > providersList = findServiceProviders ( ) ;
public @Nullable XmlDeclaration function ( ) { String data = getData ( ) ; Document doc = Jsoup . parse ( " < " + data . substring ( 1 , data . length ( ) - 1 ) + " > " , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( " ! " ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ; } return decl ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( Files . newOutputStream ( file . toPath ( ) ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /event-with-unit " ) ) , is ( " post_foo " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) , containsString ( " 0XCAFEBABE " ) ) ; }
public List < Framedata > function ( String arg0 , boolean arg1 ) { TextFrame curframe = new TextFrame ( ) ; curframe . setPayload ( ByteBuffer . wrap ( Charsetfunctions . utf8Bytes ( arg0 ) ) ) ; curframe . setTransferemasked ( arg1 ) ; try { curframe . isValid ( ) ; } catch ( InvalidDataException e ) { throw new NotSendableException ( e ) ; } return Collections . singletonList ( ( Framedata ) curframe ) ; }
public StringJoiner function ( Object arg0 ) { Validate . notNull ( sb ) ; sb . append ( arg0 ) ; return this ; }
public static < T > Resource function ( final String arg0 , final String arg1 , final RequestExtractor < T > arg2 ) { return arg0 ( text ( checkNotNullOrEmpty ( arg0 , " Template should not be null " ) ) , checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
public void function ( ) throws IOException , InterruptedException { final File config = tempFolder . newFile ( ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foo \" " + " }}] " ) ; RunnerFactory factory = new RunnerFactory ( " SHUTDOWN " ) ; runner = factory . createRunner ( httpArgs ( ) . withPort ( port ( ) ) . withShutdownPort ( 9090 ) . withConfigurationFile ( config . getAbsolutePath ( ) ) . build ( ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foobar \" " + " }}] " ) ; waitChangeHappens ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foobar " ) ) ; }
public static RestServer function ( final int arg0 , final MocoMonitor arg1 , final MocoMonitor arg2 , final MocoMonitor . . . arg3 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return new ActualRestServer ( of ( arg0 ) , Optional . < HttpsCertificate > absent ( ) , mergeMonitor ( checkNotNull ( arg1 , " Monitor should not be null " ) ,
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { delegate ( ) . error ( arg0 , arg1 , arg2 ) ; }
public void function ( String FQCN , Priority arg0 , Object arg1 , Throwable arg2 ) { int levelInt = priorityToLevelInt ( arg0 ) ; if ( locationAwareLogger ! = null ) { if ( arg1 ! = null ) {
public boolean function ( final String arg0 ) { return RESPONSE_ID . equalsIgnoreCase ( arg0 ) ; }
protected boolean function ( Map < String , String > arg0 , Map < String , String > arg1 ) { if ( arg0 = = null ) { return true ; } for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { if ( ! doMatch ( entry . getValue ( ) , arg1 . get ( entry . getKey ( ) ) ) ) { return false ; } } return true ; }
public boolean function ( ) { return getReadyState ( ) = = READYSTATE . CLOSED ; }
private String function ( DurationUnit arg0 , String arg1 , String arg2 ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( arg1 ) ; buf . append ( "  Profiler [ " ) ; buf . append ( name ) ; buf . append ( " ] " ) ; buf . append ( SpacePadder . LINE_SEP ) ; for ( Object child : childList ) { if ( child instanceof StopWatch ) { buildStringForChildStopWatch ( buf , arg2 , ( StopWatch ) child , arg0 ) ; } else if ( child instanceof Profiler ) { Profiler profiler = ( Profiler ) child ; profiler . stop ( ) ; String subString = profiler . buildString ( arg0 , " |--+ " , arg2 + "     " ) ; buf . append ( subString ) ; } } buildStringForGlobalStopWatch ( buf , arg2 , globalStopWatch , arg0 ) ; return buf . toString ( ) ; }
protected final boolean function ( Document . OutputSettings arg0 ) { return shouldCollapseAttribute ( key , val , arg0 ) ; }
protected Optional < String [ ] > function ( final HttpRequest arg0 ) { String content = extractor . extract ( arg0 ) . get ( ) ; try { Object jsonPathContent = jsonPath . read ( content ) ;
public void function ( ) throws Exception { final HttpServer server = httpServer ( ) ; server . port ( ) ; }
static ByteBuffer function ( InputStream arg0 , int arg1 ) throws IOException { Validate . isTrue ( arg1 > = 0 , " maxSize must be 0 (unlimited) or larger " ) ; final boolean capped = arg1 > 0 ; byte [ ] buffer = new byte [ bufferSize ] ; ByteArrayOutputStream outStream = new ByteArrayOutputStream ( bufferSize ) ; int read ; int remaining = arg1 ; while ( true ) { read = arg0 . read ( buffer ) ; if ( read = = - 1 ) break ; if ( capped ) { if ( read > remaining ) { outStream . write ( buffer , 0 , remaining ) ; break ; } remaining - = read ; } outStream . write ( buffer , 0 , read ) ; } ByteBuffer byteData = ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; return byteData ; }
public void function ( ) { ByteBuffer small = ByteBuffer . wrap ( smallArray ) ; ByteBuffer empty = ByteBufferUtils . getEmptyByteBuffer ( ) ; ByteBufferUtils . transferByteBuffer ( small , empty ) ; assertArrayEquals ( " Small bytebuffer should not change " , smallArray , small . array ( ) ) ; assertEquals ( " Capacity of the empty bytebuffer should still be 0 " , 0 , empty . capacity ( ) ) ; }
public void function ( Locale arg0 ) { Locale . setDefault ( arg0 ) ; ParseSettings parseSettings = new ParseSettings ( false , false ) ; Attributes attributes = new Attributes ( ) ; attributes . put ( " ITEM " , " 1 " ) ; Attributes normalizedAttributes = parseSettings . normalizeAttributes ( attributes ) ; assertEquals ( " item " , normalizedAttributes . asList ( ) . get ( 0 ) . getKey ( ) ) ; }
@Test void function ( ) { String html = " <head> \ n<script>foo; \ nbar() \ n5 <= 4;</script> " ; Document doc = Jsoup . parse ( html , TrackingHtmlParser ) ; Element script = doc . expectFirst ( " script " ) ; assertNotNull ( script ) ; assertEquals ( " 2,1:7-2,9:15 " , script . sourceRange ( ) . toString ( ) ) ; DataNode data = ( DataNode ) script . firstChild ( ) ; assertNotNull ( data ) ; assertEquals ( " 2,9:15-4,8:33 " , data . sourceRange ( ) . toString ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.1.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 750 ) ; }
public void function ( ) throws Exception { server . request ( eq ( form ( " password " ) , " hello " ) ) . response ( " foobar " ) ; server . response ( " foobar " ) ; running ( server , new Runnable ( ) { @Override
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return accum . toString ( ) ; }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; assertTrue ( deflateExtension . acceptProvidedExtensionAsServer ( " permessage-deflate " ) ) ; assertTrue ( deflateExtension . acceptProvidedExtensionAsServer ( " some-other-extension, permessage-deflate " ) ) ; assertFalse ( deflateExtension . acceptProvidedExtensionAsServer ( " wrong-permessage-deflate " ) ) ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { if ( " get " . equalsIgnoreCase ( arg0 . getMethod ( ) ) ) { getGetHandler ( arg0 ) . writeToResponse ( new SessionContext ( arg0 , arg1 ) ) ; return ; } throw new UnsupportedOperationException ( " Unsupported REST request " ) ; }
T function ( T arg0 ) ; String FILE_ID = " file " ; String URI_ID = " uri " ; String REQUEST_ID = " request " ; String RESPONSE_ID = " response " ; }
public void function ( ) { Log log = LogFactory . getLog ( InvokeJCLTest . class ) ; Exception e = new Exception ( " just testing " ) ; log . trace ( " trace message " ) ; log . debug ( " debug message " ) ; log . info ( " info  message " ) ; log . warn ( " warn message " ) ; log . error ( " error message " ) ; log . fatal ( " fatal message " ) ; log . trace ( " trace message " , e ) ; log . debug ( " debug message " , e ) ; log . info ( " info  message " , e ) ; log . warn ( " warn message " , e ) ; log . error ( " error message " , e ) ; log . fatal ( " fatal message " , e ) ; }
public static MocoMonitor function ( final String arg0 ) { return ApiUtils . log ( ApiUtils . fileLogWriter ( checkNotNullOrEmpty ( arg0 , " Filename should not be null or empty " ) , Optional . < Charset > absent ( ) ) ) ; }
public TextContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return text ( arg0 ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; return textContainer ( arg0 , arg1 ) ; } throw arg1 . mappingException ( TextContainer . class , currentToken ) ; }
public void function ( ) { var logger = getSLF4JSystemLogger ( ) ; assertNotNull ( " LoggerFinder must return logger " , logger ) ; }
public void function ( ) { InputStream stream = getResourceAsStream ( " settings/fileroot-settings.json " ) ; List < GlobalSetting > globalSettings = parser . parse ( stream ) ; assertThat ( globalSettings . get ( 0 ) . getInclude ( ) , is ( join ( " src " , " test " , " resources " , " settings " , " fileroot.json " ) ) ) ; assertThat ( globalSettings . get ( 0 ) . getContext ( ) , is ( " /fileroot " ) ) ; assertThat ( globalSettings . get ( 0 ) . getFileRoot ( ) , is ( " src/test/resources " ) ) ; }
public void function ( ) { CloseFrame frame = new CloseFrame ( ) ; assertEquals ( " Opcode must be equal " , Opcode . CLOSING , frame . getOpcode ( ) ) ; assertEquals ( " Fin must be set " , true , frame . isFin ( ) ) ; assertEquals ( " transferredMask must not be set " , false , frame . getTransfereMasked ( ) ) ; assertEquals ( " Payload must be 2 (close code) " , 2 , frame . getPayloadData ( ) . capacity ( ) ) ; assertEquals ( " RSV1 must be false " , false , frame . isRSV1 ( ) ) ; assertEquals ( " RSV2 must be false " , false , frame . isRSV2 ( ) ) ; assertEquals ( " RSV3 must be false " , false , frame . isRSV3 ( ) ) ; try { frame . isValid ( ) ;
public void function ( Level arg0 , Throwable arg1 ) { if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( THROWING_MARKER , FQCN ,
public static RestSetting function ( final String arg0 , final RequestMatcher arg1 , final ResponseHandler arg2 , final ResponseHandler . . . arg3 ) { return new GetSingleRestSetting ( checkId ( arg0 ) , Optional . of ( checkNotNull ( arg1 , " Get request matcher should no be null " ) ) ,
public void function ( ) { final DefaultHttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /hello " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( HttpMethod . GET ) . withQueries ( ImmutableMap . of ( " foo " , new String [ ] { " fooValue " } , " bar " , new String [ ] { " barValue " } ) ) . build ( ) ; HttpRequestDumper dumper = new HttpRequestDumper ( ) ; final String result = dumper . dump ( request ) ; assertThat ( result . trim ( ) , is ( " GET /hello?foo=fooValue&bar=barValue HTTP/1.1 " ) ) ; }
protected void function ( final SocketChannel arg0 ) { ChannelPipeline pipeline = arg0 . pipeline ( ) ; if ( serverSetting . isSecure ( ) ) { pipeline . addFirst ( " ssl " , serverSetting . sslHandler ( ) . get ( ) ) ; } ServerConfig serverConfig = serverSetting . getServerConfig ( ) ; pipeline . addLast ( " codec " , new HttpServerCodec ( MAX_INITIAL_LINE_LENGTH , serverConfig . getHeaderSize ( ) , MAX_CHUNK_SIZE , false ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( serverConfig . getContentLength ( ) ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
public void function ( String arg0 ) { assertTrue ( arg0 . contains ( " Sec-WebSocket-Version: " ) ) ; }
public int function ( CharacterRef arg0 , CharacterRef arg1 ) { return arg0 . name . compareTo ( arg1 . name ) ; }
public static ResponseHandler function ( final String arg0 , final Resource arg1 ) { return header ( SET_COOKIE , cookieResource ( checkNotNullOrEmpty ( arg0 , " Cookie key should not be null " ) ,
private Optional < Response > function ( SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; for ( Setting < T > setting : this . getSettings ( ) ) { if ( setting . match ( request ) ) { setting . writeToResponse ( arg0 ) ; return Optional . of ( arg0 . getResponse ( ) ) ; } } Setting < T > anySetting = this . getAnySetting ( ) ; if ( anySetting . match ( request ) ) { anySetting . writeToResponse ( arg0 ) ; return Optional . of ( arg0 . getResponse ( ) ) ; } monitor . onUnexpectedMessage ( request ) ; return Optional . empty ( ) ; }
protected byte [ ] function ( ) { byte [ ] bytes = new byte [ getLength ( ) ] ; if ( text ! = null ) bytes [ 0 ] = text . getTextEncoding ( ) ; else bytes [ 0 ] = 0 ; byte [ ] textBytes = text . toBytes ( true , false ) ; if ( textBytes . length > 0 ) { BufferTools . copyIntoByteBuffer ( textBytes , 0 , textBytes . length , bytes , 1 ) ; } return bytes ; }
public static void function ( int arg0 , byte [ ] arg1 , int arg2 ) { arg1 [ arg2 + 3 ] = ( byte ) ( arg0 & 0x7F ) ; arg1 [ arg2 + 2 ] = ( byte ) ( ( arg0 > > 7 ) & 0x7F ) ; arg1 [ arg2 + 1 ] = ( byte ) ( ( arg0 > > 14 ) & 0x7F ) ; arg1 [ arg2 + 0 ] = ( byte ) ( ( arg0 > > 21 ) & 0x7F ) ; }
boolean function ( char arg0 ) { return ! isEmpty ( ) & & charBuf [ bufPos ] = = arg0 ;
public static MutableHttpResponse function ( ) { return new DefaultMutableHttpResponse ( ) ; }
public static HttpHeader function ( final String arg0 , final Resource arg1 ) { return new HttpHeader ( checkNotNullOrEmpty ( arg0 , " Header name should not be null " ) , checkNotNull ( arg1 , " Header value should not be null " ) ) ;
public void function ( ServiceEvent arg0 ) { String [ ] objectClass = ( String [ ] ) arg0 . getServiceReference ( ) . getProperty ( " objectClass " ) ; if ( arg0 . getType ( ) = = ServiceEvent . REGISTERED ) { log . info ( " SimpleBundle: Service of type {} registered. " ,
public void function ( ) { InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " foo.response " ) ; server . response ( stream ( is ) ) ; running ( server , new Runnable ( ) { @Override
public String function ( ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( " StopWatch [ " ) ; buf . append ( name ) ; buf . append ( " ]  " ) ; switch ( status ) { case STARTED : buf . append ( " STARTED " ) ; break ; case STOPPED : buf . append ( " elapsed time:  " ) ; buf . append ( Util . durationInDurationUnitsAsStr ( elapsedTime ( ) , DurationUnit . MICROSECOND ) ) ; break ; default : throw new IllegalStateException ( " Status  " + status + "  is not expected " ) ; } return buf . toString ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.2.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 350 ) ; }
public boolean function ( ) { return this . template ! = null ; }
private void function ( String arg0 , Level arg1 , String arg2 , Object [ ] arg3 , Throwable arg4 ) { LogRecord record = new LogRecord ( arg1 , arg2 ) ; record . setLoggerName ( getName ( ) ) ; record . setParameters ( arg3 ) ; record . setThrown ( arg4 ) ; fillCallerData ( arg0 , record ) ; logger . log ( record ) ;
public HandshakeBuilder function ( HandshakeBuilder arg0 ) { return arg0 ; }
public void function ( String [ ] arg0 ) { StartArgs startArgs = parse ( arg0 ) ; if ( conflictWithDefaultShutdownPort ( startArgs , defaultShutdownPort ) ) { System . err . println ( " port is same as default shutdown port, please specify another port or shutdown port. " ) ; System . exit ( 1 ) ; } Runner runner = new DynamicRunner ( startArgs . getConfigurationFile ( ) , startArgs . getPort ( ) ) ; new SocketShutdownMonitorRunner ( runner , startArgs . getShutdownPort ( defaultShutdownPort ) , defaultShutdownKey ) . run ( ) ; }
public void function ( ) throws InterruptedException , BrokenBarrierException { @SuppressWarnings ( " unused " ) LoggerAccessingThread [ ] accessors = harness ( ) ; Logger logger = LoggerFactory . getLogger ( loggerName + diff ) ; logger . info ( " hello " ) ; eventCount . getAndIncrement ( ) ; int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3 ; assertAllSubstLoggersAreFixed ( ) ; long expected = eventCount . get ( ) + NUM_LINES_IN_SLF4J_REPLAY_WARNING ; int actual = sps . stringList . size ( ) ; int LENIENCY_COUNT = 16 ; assertTrue ( expected + "  >=  " + actual , expected > = actual ) ; assertTrue ( expected + "  <  " + actual + "  +  " + LENIENCY_COUNT , expected < actual + LENIENCY_COUNT ) ;
public void function ( ) throws Exception { server . response ( cors ( allowOrigin ( " foo " ) , allowMethods ( " GET " ) ) ) ; running ( server , ( ) - > { ClassicHttpResponse response = helper . getResponseWithHeader ( root ( ) , of ( " Origin " , " https://www.github.com/ " ) ) ;
public static void function ( final SocketServer arg0 , final Runnable arg1 ) throws Exception { doRunning ( runner ( arg0 ) , arg1 ) ; }
public void function ( ) { byte [ ] frameData = { BYTE_FF , BYTE_EB , BYTE_A2 , BYTE_40 } ; try { new MpegFrameForTesting ( frameData ) ;
public boolean function ( HttpRequest arg0 ) { return HttpMethod . POST . equals ( arg0 . getMethod ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.2.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public HttpSetting function ( final MocoConfig arg0 ) { RequestMatcher appliedMatcher = configItem ( this . matcher , arg0 ) ; if ( arg0 . isFor ( " uri " ) & & this . matcher = = appliedMatcher ) { appliedMatcher = new AndRequestMatcher ( of ( appliedMatcher , InternalApis . context ( ( String ) arg0 . apply ( " " ) ) ) ) ; } HttpSetting setting = new HttpSetting ( appliedMatcher ) ; setting . handler = configItem ( this . handler , arg0 ) ; setting . eventTriggers = configItems ( eventTriggers , arg0 ) ; return setting ; }
public void function ( ) { this . runner . run ( ) ; this . watcher . start ( ) ; }
public void function ( String arg0 , Object arg1 ) { delegate ( ) . warn ( arg0 , arg1 ) ; }
public String function ( ) { return String . format ( " :parent%s " , sel ) ; }
private static boolean function ( String arg0 ) { return arg0 . length ( ) > 4 & & xmlDeclPattern . matcher ( arg0 ) . matches ( ) ; }
public long function ( ) { return bufferQueueTotalAmount . get ( ) ; }
public void function ( ) throws Exception { Protocol protocol0 = new Protocol ( " " ) ; assertTrue ( protocol0 . acceptProvidedProtocol ( " " ) ) ; assertTrue ( protocol0 . acceptProvidedProtocol ( " chat " ) ) ; assertTrue ( protocol0 . acceptProvidedProtocol ( " chat, test " ) ) ; assertTrue ( protocol0 . acceptProvidedProtocol ( " chat, test, " ) ) ; Protocol protocol1 = new Protocol ( " chat " ) ; assertTrue ( protocol1 . acceptProvidedProtocol ( " chat " ) ) ; assertFalse ( protocol1 . acceptProvidedProtocol ( " test " ) ) ; assertTrue ( protocol1 . acceptProvidedProtocol ( " chat, test " ) ) ; assertTrue ( protocol1 . acceptProvidedProtocol ( " test, chat " ) ) ; assertTrue ( protocol1 . acceptProvidedProtocol ( " test,chat " ) ) ; assertTrue ( protocol1 . acceptProvidedProtocol ( " chat,test " ) ) ; assertTrue ( protocol1 . acceptProvidedProtocol ( " asdchattest,test, chat " ) ) ; }
public void function ( ) { ID3v2CommentFrameData frameData1 = new ID3v2CommentFrameData ( false , TEST_LANGUAGE , null , new EncodedText ( ( byte ) 0 , TEST_VALUE ) ) ; ID3v2CommentFrameData frameData2 = new ID3v2CommentFrameData ( false , TEST_LANGUAGE , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , new EncodedText ( ( byte ) 0 , TEST_VALUE ) ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
public void function ( ) { System . setProperty ( LoggerFactory . PROVIDER_PROPERTY_KEY , " java.lang.String " ) ; assertNull ( LoggerFactory . loadExplicitlySpecified ( classLoaderOfLoggerFactory ) ) ; assertTrue ( mockedSyserr . toString ( ) . contains ( " Specified SLF4JServiceProvider (java.lang.String) does not implement SLF4JServiceProvider interface " ) ) ; }
public static DefaultMutableHttpResponse function ( HttpRequest arg0 , int arg1 ) { DefaultMutableHttpResponse httpResponse = new DefaultMutableHttpResponse ( ) ; httpResponse . version = arg0 . getVersion ( ) ; httpResponse . arg1 = arg1 ; return httpResponse ; }
public String function ( final String arg0 , final byte [ ] arg1 ) throws IOException { Request request = Request . Post ( arg0 ) . addHeader ( CONTENT_TYPE , PLAIN_TEXT_UTF_8 . toString ( ) ) . bodyByteArray ( arg1 ) ; return executor . execute ( request ) . returnContent ( ) . asString ( ) ; }
private < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final TextContainer arg1 ) { String text = arg1 . getText ( ) ; if ( " true " . equalsIgnoreCase ( text ) ) { return exist ( arg0 ) ; } if ( " false " . equalsIgnoreCase ( text ) ) { return not ( exist ( arg0 ) ) ; } throw new RuntimeException ( String . format ( " Unknown exist parameter: [%s] " , text ) ) ; }
@Override public boolean function ( Predicate < ? super Element > arg0 ) { boolean anyRemoved = false ; for ( Iterator < Element > it = this . iterator ( ) ; it . hasNext ( ) ; ) { Element el = it . next ( ) ; if ( arg0 . test ( el ) ) { it . remove ( ) ; anyRemoved = true ; } } return anyRemoved ; }
private String function ( LoggingEvent arg0 , String arg1 ) { if ( arg0 . getKeyValuePairs ( ) ! = null ) { StringBuilder sb = new StringBuilder ( ) ;
public Object function ( ) { return super . clone ( ) ; }
public ResponseHandler function ( final RestSetting arg0 ) { return arg0 . getHandler ( ) ; }
@Test void function ( ) throws IOException { InputStream stream = null ; Document doc = Jsoup . parse ( stream , null , " " ) ; assertNotNull ( doc ) ; assertEquals ( " " , doc . title ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.19 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 1100 ) ;
@Test public void function ( ) { assertEquals ( " \\ & " , TokenQueue . unescape ( " \\ \\ \\ & " ) ) ; }
public String function ( Character arg0 , Character arg1 ) { StringBuilder accum = new StringBuilder ( ) ; int depth = 0 ; Character last = null ; do { if ( queue . isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = null | | ! last . equals ( ESC ) ) { if ( c . equals ( arg0 ) ) depth + + ; else if ( c . equals ( arg1 ) ) depth - - ; } if ( depth > 0 & & last ! = null ) accum . append ( c ) ; last = c ; } while ( depth > 0 ) ; return accum . toString ( ) ; }
public static HttpResponse function ( FullHttpResponse arg0 ) { HttpResponse dumpedResponse = new HttpResponse ( ) ; dumpedResponse . setStatusCode ( arg0 . getStatus ( ) . code ( ) ) ; dumpedResponse . setVersion ( arg0 . getProtocolVersion ( ) . text ( ) ) ; for ( Map . Entry < String , String > entry : arg0 . headers ( ) ) { dumpedResponse . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } setContent ( arg0 , dumpedResponse ) ; return dumpedResponse ; }
public void function ( ) { FileResourceReader reader = new FileResourceReader ( text ( new File ( " src/test/resources/foo.response " ) . getPath ( ) ) ) ; assertThat ( reader . readFor ( ( Request ) null ) . toString ( ) , is ( " foo.response " ) ) ; }
public void function ( ) throws Exception { assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -i " } ) ) ; }
public void function ( ) throws Exception { HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( mergedServer , ( ) - > helper . get ( remoteUrl ( " /bar/anything " ) ) ) ) ;
public Builder function ( final String arg0 ) { this . arg0 = arg0 . getBytes ( ) ; return this ; }
public void function ( ) { final Document doc = createHtmlDocument ( " dontTouch " ) ; doc . updateMetaCharset ( true ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; final String htmlCharsetUTF8 = " <html> \ n " + "  <head> \ n " + "   <meta charset= \" " + charsetUtf8 + " \" > \ n " + "  </head> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( htmlCharsetUTF8 , doc . toString ( ) ) ; }
String function ( ) { String data = new String ( input . substring ( pos , input . length ( ) ) ) ; pos = input . length ( ) ; return data ; }
public Element function ( ) { return findFirstElementByTagName ( " body " , this ) ; }
public Transformer < byte [ ] > function ( final Function < byte [ ] , byte [ ] > arg0 ) { this . arg0 = checkNotNull ( arg0 , " Transformer should not be null " ) ; return this ; }
@Test public void function ( ) { String h = " <!DOCTYPE html><body><img async checked='checked' src='&<> \" '>&lt;&gt;&amp;&quot;<foo />bar " ; Document doc = Jsoup . parse ( h ) ; doc . outputSettings ( ) . syntax ( Syntax . html ) ; assertEquals ( " <!doctype html> \ n " + " <html> \ n " + "  <head></head> \ n " + "  <body> \ n " + "   <img async checked src= \" &amp;<>&quot; \" >&lt;&gt;&amp; \" \ n " + "   <foo />bar \ n " + "  </body> \ n " + " </html> " , doc . html ( ) ) ; doc . outputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml ) ; assertEquals ( " <!DOCTYPE html> \ n " + " <html> \ n " +
private static void function ( StringBuffer arg0 , char [ ] arg1 ) { arg0 . append ( '[' ) ; final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { arg0 . append ( arg1 [ i ] ) ; if ( i ! = len - 1 ) arg0 . append ( " ,  " ) ; } arg0 . append ( ']' ) ; }
@Test public void function ( ) { String h1 = " <p " ; Document doc = Jsoup . parse ( h1 ) ; assertEquals ( 0 , doc . getElementsByTag ( " p " ) . size ( ) ) ; assertEquals ( " " , doc . text ( ) ) ; String h2 = " <div id=1<p id='2' " ; doc = Jsoup . parse ( h2 ) ; assertEquals ( " " , doc . text ( ) ) ; }
public void function ( final String arg0 , final Object arg1 , final Object arg2 ) { if ( Log . isLoggable ( name , Log . DEBUG ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
private Optional < Charset > function ( final Optional < String > arg0 ) { if ( charset . isPresent ( ) ) { return charset ; } if ( ! arg0 . isPresent ( ) ) { return of ( Charsets . UTF_8 ) ; } return absent ( ) ; }
public Iterable < Map . Entry < String , String > > function ( final Map . Entry < String , String [ ] > arg0 ) { String key = arg0 . getKey ( ) ; ImmutableList . Builder < Map . Entry < String , String > > builder = ImmutableList . builder ( ) ; for ( String value : arg0 . getValue ( ) ) { builder . add ( Maps . immutableEntry ( key , value ) ) ; } return builder . build ( ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isWarnEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public boolean function ( final byte [ ] arg0 ) { return new String ( arg0 ) . endsWith ( expected . readFor ( Optional . < Request > absent ( ) ) . toString ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${foo} " , " foo " , jsonPath ( " $.book.price " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws IOException { File in = getFile ( " /htmltests/xwiki-1324.html " ) ; Document doc = Jsoup . parse ( in , null , " https://localhost/ " ) ; assertEquals ( " XWiki Jetty HSQLDB 12.1-SNAPSHOT " , doc . select ( " #xwikiplatformversion " ) . text ( ) ) ; String wantHtml = " <a class= \" list-group-item \"  data-id= \" userdirectory \"  href= \" /xwiki/bin/admin/XWiki/XWikiPreferences?editor=globaladmin&amp;section=userdirectory \"  title= \" Customize the user directory live table. \" >User Directory</a> " ; assertEquals ( wantHtml , doc . select ( " [data-id=userdirectory] " ) . outerHtml ( ) ) ; }
public void function ( ) throws IOException { int statusCode = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) . getStatusLine ( ) . getStatusCode ( ) ; assertThat ( statusCode , is ( 200 ) ) ; }
private static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { return new EndsWithMatcher < T > ( checkNotNull ( arg0 , " Extractor should not be null " ) , checkNotNull ( arg1 , " Expected resource should not be null " ) ) ;
public boolean function ( ) { assert ( readystate = = READYSTATE . OPEN ? ! flushandclosestate : true ) ; return readystate = = READYSTATE . OPEN ; }
private void function ( ) { hasAttrValue = true ; if ( attrValueS ! = null ) { attrValue . append ( attrValueS ) ;
public void function ( HttpServer arg0 ) { server = new MocoHttpServer ( arg0 ) ; logger . info ( " Server is started at {} " , arg0 . getPort ( ) ) ; server . start ( ) ; }
void function ( ) { pendingTableCharacters = new ArrayList < > ( ) ; }
public void function ( ) throws Exception { ArrayList < IProtocol > protocols = new ArrayList < > ( ) ; protocols . add ( new Protocol ( " chat2 " ) ) ; protocols . add ( new Protocol ( " chat3 " ) ) ; protocols . add ( new Protocol ( " chat1 " ) ) ; testProtocolRejection ( 22 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ) ; }
public static Level function ( int arg0 , Level arg1 ) { switch ( arg0 ) { case ALL_INT :
public ResponseHandler function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . RESPONSE_ID ) ) { return super . apply ( arg0 ) ; } if ( arg0 . isFor ( MocoConfig . URI_ID ) ) { return new MountHandler ( this . dir , this . target . apply ( arg0 ) ) ; } if ( arg0 . isFor ( MocoConfig . FILE_ID ) ) { return new MountHandler ( new File ( ( String ) arg0 . apply ( this . dir . getName ( ) ) ) , this . target ) ; } return this ; }
public void function ( ) { Document doc2 = Jsoup . parse ( " <html><body><div><p>before1</p><p>before2</p><p>XXX</p><p>after1</p><p>after2</p></div></body></html> " , " " ) ; Element body = doc2 . select ( " body " ) . first ( ) ; Elements elems = body . select ( " p:matchesOwn(XXX) " ) ; Element xElem = elems . first ( ) ; Elements afterX = xElem . parent ( ) . getElementsByIndexGreaterThan ( xElem . elementSiblingIndex ( ) ) ; for ( Element p : afterX ) { p . remove ( ) ; } assertEquals ( " <body><div><p>before1</p><p>before2</p><p>XXX</p></div></body> " , TextUtil . stripNewlines ( body . outerHtml ( ) ) ) ; }
public void function ( ) throws IOException { File in = getFile ( " /htmltests/gzip.html.gz " ) ; Document doc = Jsoup . parse ( in , null ) ; assertEquals ( " Gzip test " , doc . title ( ) ) ; assertEquals ( " This is a gzipped HTML file. " , doc . selectFirst ( " p " ) . text ( ) ) ; }
private Runner function ( final StartArgs arg0 ) { final File configuration = new File ( arg0 . getConfigurationFile ( ) . get ( ) ) ; final FileRunner fileRunner = createConfigurationFileRunner ( configuration , arg0 ) ; Watcher watcher = factory . createConfigurationWatcher ( configuration , fileRunner ) ; return new WatcherRunner ( fileRunner , watcher ) ; }
public ByteChannel function ( ByteChannel arg0 ) { return super . createProxyChannel ( arg0 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " cookie.json " ) ; Cookie decodeCookie = getCookie ( " /cookie-with-http-only " ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; assertThat ( decodeCookie . isHttpOnly ( ) , is ( true ) ) ; }
public String function ( ) { return MoreObjects . toStringHelper ( ProxyContainer . class ) . add ( " url " , this . url )
public HandshakeBuilder function ( ClientHandshake arg0 , ServerHandshakeBuilder arg1 ) throws InvalidHandshakeException { arg1 . setHttpStatusMessage ( " Web Socket Protocol Handshake " ) ; arg1 . put ( " Upgrade " , " WebSocket " ) ; arg1 . put ( " Connection " , arg0 . getFieldValue ( " Connection " ) ) ; arg1 . put ( " WebSocket-Origin " , arg0 . getFieldValue ( " Origin " ) ) ; String location = " ws:// " + arg0 . getFieldValue ( " Host " ) + arg0 . getResourceDescriptor ( ) ; arg1 . put ( " WebSocket-Location " , location ) ; return arg1 ; }
void function ( TokeniserState arg0 ) { switch ( arg0 ) { case TagOpen : markupStartPos = reader . pos ( ) ; break ; case Data : if ( charStartPos = = Unset ) charStartPos = reader . pos ( ) ; } this . state = arg0 ; }
public static boolean function ( String arg0 ) { if ( arg0 = = null | | arg0 . length ( ) = = 0 ) return true ; int l = arg0 . length ( ) ; for ( int i = 0 ; i < l ; i + + ) { if ( ! StringUtil . isWhitespace ( arg0 . codePointAt ( i ) ) ) return false ; } return true ; }
private static < T > Matcher < T > function ( final ClassLoader arg0 ) { return new BaseMatcher < T > ( ) {
public final void function ( WebSocket arg0 , String arg1 ) { onMessage ( arg0 , arg1 ) ; }
public RequestMatcher function ( final MocoConfig arg0 ) { Resource applied = resource . apply ( arg0 ) ; if ( applied = = this ) { return this ; } return new XmlRequestMatcher ( this . extractor , applied ) ; }
public boolean function ( ) { return inData . hasRemaining ( ) | | ( inCrypt . hasRemaining ( ) & & engineResult . getStatus ( ) ! = Status . BUFFER_UNDERFLOW & & engineResult . getStatus ( ) ! = Status . CLOSED ) ;
boolean function ( ) { if ( isEmpty ( ) ) return false ; char c = charBuf [ bufPos ] ; return ( c > = 'A' & & c < = 'Z' ) | | ( c > = 'a' & & c < = 'z' ) ; }
public void function ( final SessionContext arg0 ) { arg0 . register ( ContextKey . PATH , getExpected ( ) ) ; }
public void function ( ) { if ( thread = = null ) thread = Thread . currentThread ( ) ; interruptableRun ( ) ; try { selector . close ( ) ; } catch ( IOException e ) { onError ( e ) ; } closelock . lock ( ) ; selector = null ; closelock . unlock ( ) ; try { channel . close ( ) ; } catch ( IOException e ) { onError ( e ) ; } channel = null ; thread = null ; }
public static void function ( byte [ ] arg0 ) throws NoSuchTagException , UnsupportedTagException { if ( arg0 . length < AbstractID3v2Tag . HEADER_LENGTH ) { throw new NoSuchTagException ( " Buffer too short " ) ; } if ( ! AbstractID3v2Tag . TAG . equals ( BufferTools . byteBufferToString ( arg0 , 0 , AbstractID3v2Tag . TAG . length ( ) ) ) ) { throw new NoSuchTagException ( ) ; } int majorVersion = arg0 [ AbstractID3v2Tag . MAJOR_VERSION_OFFSET ] ; if ( majorVersion ! = 2 & & majorVersion ! = 3 & & majorVersion ! = 4 ) { int minorVersion = arg0 [ AbstractID3v2Tag . MINOR_VERSION_OFFSET ] ;
public static String function ( String arg0 ) { return unescape ( arg0 , false ) ; }
public void function ( ) throws IOException , InterruptedException { final File config = tempFolder . newFile ( " config.json " ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foo \" " + " }}] " ) ; RunnerFactory factory = new RunnerFactory ( " SHUTDOWN " ) ; String absolutePath = config . getParent ( ) ; String result = Files . join ( absolutePath , " *.json " ) ; runner = factory . createRunner ( httpArgs ( ) . withPort ( port ( ) ) . withShutdownPort ( 9090 ) . withConfigurationFile ( result ) . build ( ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; }
public void function ( final ExtensionContext arg0 ) throws Exception { Runner runner = arg0 . getStore ( MOCO ) . get ( SERVER , Runner . class ) ; runner . stop ( ) ;
public void function ( ) { ID3v2TextFrameData frameData = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_TEXT ) ) ; assertFalse ( frameData . equals ( " 8 " ) ) ; }
final private void function ( String arg0 , LogRecord arg1 ) { StackTraceElement [ ] steArray = new Throwable ( ) . getStackTrace ( ) ; int selfIndex = - 1 ; for ( int i = 0 ; i < steArray . length ; i + + ) { final String className = steArray [ i ] . getClassName ( ) ; if ( className . equals ( arg0 ) | | className . equals ( SUPER ) ) { selfIndex = i ; break ; } } int found = - 1 ; for ( int i = selfIndex + 1 ; i < steArray . length ; i + + ) { final String className = steArray [ i ] . getClassName ( ) ; if ( ! ( className . equals ( arg0 ) | | className . equals ( SUPER ) ) ) { found = i ; break ; } } if ( found ! = - 1 ) { StackTraceElement ste = steArray [ found ] ;
public void function ( ) { NotSupportedException exception = new NotSupportedException ( " A message " ) ; assertEquals ( " A message " , exception . getMessage ( ) ) ; assertNull ( exception . getCause ( ) ) ; }
public boolean function ( ) { return logger . isErrorEnabled ( ) ; }
Token . Tag function ( boolean arg0 ) { tagPending = arg0 ? new Token . StartTag ( ) : new Token . EndTag ( ) ; return tagPending ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; HttpResponse response = Request . Get ( remoteUrl ( " /url " ) ) . execute ( ) . returnResponse ( ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; }
public void function ( ) { MutableInteger integer = new MutableInteger ( 8 ) ; assertEquals ( integer . hashCode ( ) , integer . hashCode ( ) ) ; }
public WebSocketImpl function ( WebSocketAdapter arg0 , Draft arg1 , Socket arg2 ) { return new WebSocketImpl ( arg0 , arg1 , arg2 ) ; }
@Test public void function ( ) { String html = " <!doctype HTML><IMG ALT=One></DIV> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <!doctype html> <html> <head></head> <body> <img alt= \" One \" > </body> </html> " , StringUtil . normaliseWhitespace ( doc . outerHtml ( ) ) ) ; }
Map < String , Object > function ( ) { final Map < String , Object > userData ; int i = indexOfKey ( SharedConstants . UserDataKey ) ; if ( i = = NotFound ) { userData = new HashMap < > ( ) ; addObject ( SharedConstants . UserDataKey , userData ) ; } else { userData = ( Map < String , Object > ) vals [ i ] ; } assert userData ! = null ; return userData ; }
public boolean function ( ) { return this . type = = ServerType . SOCKET ; }
public void function ( Object arg0 , Throwable arg1 ) { innerLog ( null , CATEGORY_FQCN , LocationAwareLogger . ERROR_INT , arg0 , arg1 ) ; }
public static SocketServer function ( ) { return ActualSocketServer . createQuietServer ( 0 ) ; }
public void function ( String arg0 , Object . . . arg1 ) { recordEventArgArray ( Level . DEBUG , null , arg0 , arg1 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div><p>Hello</p><p>There</p></div> " ) ; Element p = doc . select ( " p " ) . first ( ) ; p . wrap ( " <div class='head'></div> " ) ; assertEquals ( " <div><div class= \" head \" ><p>Hello</p></div><p>There</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; Element ret = p . wrap ( " <div><div class=foo></div><p>What?</p></div> " ) ; assertEquals ( " <div><div class= \" head \" ><div><div class= \" foo \" ><p>Hello</p></div><p>What?</p></div></div><p>There</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; assertEquals ( ret , p ) ; }
public void function ( ) throws Exception { RestServer server = restServer ( 12306 , context ( " /rest " ) , Moco . response ( header ( " foo " , " bar " ) ) ) ; Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , MocoRest . get ( " 1 " , toJson ( resource1 ) ) , MocoRest . get ( " 2 " , toJson ( resource2 ) ) ) ; running ( server , new Runnable ( ) { @Override
@Test void function ( ) { String html = " <div>Div</div<> <a>One<a<b>Hello</b> " ; Document doc = Jsoup . parse ( html ) ; Element body = doc . body ( ) ; assertEquals ( " <div> Div <a>One<a<b> Hello </a<b></a></div> " , TextUtil . normalizeSpaces ( body . html ( ) ) ) ; Elements abs = doc . getElementsByTag ( " a<b " ) ; assertEquals ( 1 , abs . size ( ) ) ; Element ab = abs . first ( ) ; assertEquals ( " Hello " , ab . text ( ) ) ; assertEquals ( " a<b " , ab . tag ( ) . normalName ( ) ) ; }
public void function ( ) throws IOException { String [ ] types = { " text/xml " , " application/xml " , " application/rss+xml " , " application/xhtml+xml " } ; for ( String type : types ) { fetchHandlesXml ( type ) ;
public Builder function ( InputStream arg0 ) { try { this . content = toByteArray ( arg0 ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { if ( arg1 . matchesLetter ( ) ) { String name = arg1 . consumeLetterSequence ( ) ; arg0 . tagPending . appendTagName ( name . toLowerCase ( ) ) ; arg0 . dataBuffer . append ( name ) ; arg1 . advance ( ) ; return ; } if ( arg0 . isAppropriateEndTagToken ( ) & & ! arg1 . isEmpty ( ) ) { char c = arg1 . consume ( ) ;
public Iterator < Attribute > function ( ) { if ( attributes = = null | | attributes . isEmpty ( ) ) { return Collections . < Attribute > emptyList ( ) . iterator ( ) ; } return attributes . values ( ) . iterator ( ) ; }
public void function ( ) { runner . stop ( ) ; stopwatch . stop ( ) ; logger . info ( " Total time:  " + stopwatch ) ; }
protected void function ( final HttpRequest arg0 , ByteBuf arg1 ) { try { arg1 . writeBytes ( toByteArray ( targetFile ( arg0 ) ) ) ;
private void function ( Handshakedata arg0 ) { log . info ( " open using draft:  " + draft ) ; setReadyState ( READYSTATE . OPEN ) ; try { wsl . onWebsocketOpen ( this , arg0 ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { if ( arg1 . matchesLetter ( ) ) { arg0 . createTagPending ( false ) ;
public Node function ( ) { if ( parentNode = = null ) return null ; final List < Node > siblings = parentNode . ensureChildNodes ( ) ; final int index = siblingIndex + 1 ; if ( siblings . size ( ) > index ) return siblings . get ( index ) ;
public boolean function ( ) { return i < size ; }
protected HttpServer function ( final ImmutableList < SessionSetting > arg0 , final int arg1 , final boolean arg2 , final MocoConfig . . . arg3 ) { ActualHttpServer targetServer = arg2 ? ActualHttpServer . createQuietServer ( arg1 , arg3 ) : ActualHttpServer . createLogServer ( arg1 , arg3 ) ; for ( SessionSetting session : arg0 ) { logger . debug ( " Parse session: {} " , session ) ; targetServer = targetServer . mergeServer ( session . newHttpServer ( arg1 , arg2 , arg3 ) ) ; } return targetServer ; }
public void function ( ) { try { barrier . await ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } state = DoubleCheckedInt . getState ( ) ; }
@Test public void function ( ) { Tag foo = Tag . valueOf ( " foo " ) ; Tag foo2 = Tag . valueOf ( " FOO " ) ; assertEquals ( foo , foo2 ) ; assertTrue ( foo . isInline ( ) ) ; assertTrue ( foo . formatAsBlock ( ) ) ; }
public boolean function ( SocketAddress arg0 ) throws IOException { return socketChannel . connect ( arg0 ) ; }
public void function ( Exception arg0 ) { if ( arg0 instanceof SSLHandshakeException ) { this . onSSLError = true ;
Document function ( Reader arg0 , String arg1 , Parser arg2 ) { initialiseParse ( arg0 , arg1 , arg2 ) ; runParser ( ) ; return doc ; }
CharsetEncoder function ( ) { return encoder . get ( ) ; }
public void function ( ) { logger . debug ( message , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . DEBUG , null , exception ) ; }
public static byte [ ] function ( byte [ ] arg0 ) { int count = sizeUnsynchronisationWouldAdd ( arg0 ) ; if ( count = = 0 ) return arg0 ; byte [ ] newBuffer = new byte [ arg0 . length + count ] ; int j = 0 ; for ( int i = 0 ; i < arg0 . length - 1 ; i + + ) { newBuffer [ j + + ] = arg0 [ i ] ; if ( arg0 [ i ] = = ( byte ) 0xff & & ( ( arg0 [ i + 1 ] & ( byte ) 0xe0 ) = = ( byte ) 0xe0 | | arg0 [ i + 1 ] = = 0 ) ) { newBuffer [ j + + ] = 0 ; } } newBuffer [ j + + ] = arg0 [ arg0 . length - 1 ] ; if ( arg0 [ arg0 . length - 1 ] = = ( byte ) 0xff ) { newBuffer [ j + + ] = 0 ; } return newBuffer ; }
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; ClassicHttpResponse httpResponse = helper . postForResponse ( remoteUrl ( " /targets " ) , Jsons . toJson ( resource1 ) ) ; assertThat ( httpResponse . getCode ( ) , is ( 201 ) ) ; assertThat ( httpResponse . getFirstHeader ( " Location " ) . getValue ( ) , is ( " /targets/123 " ) ) ; }
public void function ( ) throws Exception { final File file = tempFolder . newFile ( ) ; HttpServer server = httpServer ( 12306 , context ( " / " ) ) ; server . get ( match ( uri ( " /repos/.* " ) ) ) . response ( proxy ( from ( " /repos " ) . to ( " https://api.github.com/repos " ) , playback ( file . getAbsolutePath ( ) ) ) ) ; running ( server , new Runnable ( ) { @Override
public String function ( final String arg0 , final InputStream arg1 ) throws IOException { return postBytes ( arg0 , toByteArray ( arg1 ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { recordEventwithoutMarkerArgArray ( Level . TRACE , arg0 , arg1 , null ) ; }
protected void function ( ) { SingleConversionRule cr = new SingleConversionRule ( Pattern . compile ( " import org.slf4j.converter " ) , " simple replacement with an unique capturing group " ) ; MultiGroupConversionRule cr1 = new MultiGroupConversionRule ( Pattern . compile ( " (first group)( second group)( third group)( 4th group) " ) ) ; cr1 . addReplacement ( Constant . INDEX_1 , " 1st group " ) ; cr1 . addReplacement ( Constant . INDEX_3 , " " ) ; rules = new ArrayList < ConversionRule > ( ) ; rules . add ( cr ) ; rules . add ( cr1 ) ; }
public void function ( ) throws URISyntaxException { runWithConfiguration ( " websocket/websocket.json " ) ; final Endpoint endpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws " ) ) ; assertThat ( endpoint . getMessageAsText ( ) , is ( " connected " ) ) ; endpoint . ping ( " ping " ) ; assertThat ( endpoint . getMessageAsText ( ) , is ( " pong " ) ) ; endpoint . sendTextMessage ( " foo " ) ; assertThat ( endpoint . getMessageAsText ( ) , is ( " bar " ) ) ; }
private void function ( ) { tq . consume ( " < " ) ; Attributes attributes = new Attributes ( ) ; String tagName = tq . consumeWord ( ) ; while ( ! tq . matches ( " < " ) & & ! tq . matches ( " /> " ) & & ! tq . matches ( " > " ) & & ! tq . isEmpty ( ) ) { Attribute attribute = parseAttribute ( ) ; if ( attribute ! = null ) attributes . put ( attribute ) ; } Tag tag = Tag . valueOf ( tagName ) ; StartTag startTag = new StartTag ( tag , attributes ) ; Element child = new Element ( startTag ) ; boolean emptyTag ; if ( tq . matchChomp ( " /> " ) ) { emptyTag = true ; } else { tq . matchChomp ( " > " ) ; emptyTag = false ; } if ( tag . equals ( htmlTag ) ) { doc . getAttributes ( ) . mergeAttributes ( attributes ) ;
@Override boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isCharacter ( ) ) { arg1 . insert ( arg0 . asCharacter ( ) ) ; } else if ( arg0 . isEOF ( ) ) { arg1 . error ( this ) ; arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; } return true ; }
public void function ( ) throws Exception { final String MOUNT_DIR = " src/test/resources/test " ; server = httpserver ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . mount ( MOUNT_DIR , to ( " /dir " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { for ( WebSocket conn : connections ( ) ) { conn . sendPing ( ) ;
public List < Framedata > function ( Opcode arg0 , ByteBuffer arg1 , boolean arg2 ) { if ( arg0 ! = Opcode . BINARY & & arg0 ! = Opcode . TEXT ) { throw new IllegalArgumentException ( " Only Opcode.BINARY or  Opcode.TEXT are allowed " ) ; } DataFrame bui = null ; if ( continuousFrameType ! = null ) { bui = new ContinuousFrame ( ) ; } else { continuousFrameType = arg0 ; if ( arg0 = = Opcode . BINARY ) { bui = new BinaryFrame ( ) ; } else if ( arg0 = = Opcode . TEXT ) { bui = new TextFrame ( ) ; } } bui . setPayload ( arg1 ) ; bui . setFin ( arg2 ) ; try { bui . isValid ( ) ; } catch ( InvalidDataException e ) { throw new IllegalArgumentException ( e ) ; } if ( arg2 ) { continuousFrameType = null ; } else { continuousFrameType = arg0 ; } return Collections . singletonList ( ( Framedata ) bui ) ; }
public String function ( ) { prepareByteData ( ) ; String body = ( charset = = null ? DataUtil . defaultCharset : Charset . forName ( charset ) ) . decode ( byteData ) . toString ( ) ; ( ( Buffer ) byteData ) . rewind ( ) ; return body ; }
protected void function ( byte [ ] arg0 ) throws InvalidDataException { int marker ; for ( marker = 1 ; marker < arg0 . length ; marker + + ) { if ( arg0 [ marker ] = = 0 ) break ; } description = new EncodedText ( arg0 [ 0 ] , BufferTools . copyBuffer ( arg0 , 1 , marker - 1 ) ) ; int length = 0 ; for ( int i = marker + 1 ; i < arg0 . length ; i + + ) { if ( arg0 [ i ] = = 0 ) break ; length + + ; } try { url = BufferTools . byteBufferToString ( arg0 , marker + 1 , length ) ;
private SocketServer function ( SocketServer arg0 , SocketServer arg1 ) { ActualSocketServer thisServer = ( ActualSocketServer ) arg0 ; return thisServer . mergeHttpServer ( ( ActualSocketServer ) arg1 ) ; }
protected void function ( Node arg0 ) { Validate . isTrue ( arg0 . parentNode = = this ) ; int index = arg0 . siblingIndex ( ) ; childNodes . remove ( index ) ; reindexChildren ( ) ; arg0 . parentNode = null ; }
public void function ( ) throws Exception { HttpServer server = Moco . httpServer ( 12306 ) ; WebSocketServer webSocketServer = server . websocket ( " /ws " ) ; webSocketServer . request ( by ( binary ( new byte [ ] { 1 , 2 , 3 } ) ) ) . response ( binary ( new byte [ ] { 4 , 5 , 6 } ) ) ; running ( server , ( ) - > { final Endpoint endpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws/ " ) ) ;
public ClassicHttpResponse function ( final Request arg0 ) throws IOException { return ( ClassicHttpResponse ) executor . execute ( arg0 ) . returnResponse ( ) ; }
public static RequestMatcher function ( final RequestMatcher . . . arg0 ) { return new OrRequestMatcher ( arg0 ) ; }
public void function ( ) { MDC . put ( " k " , " v " ) ; assertNotNull ( MDC . get ( " k " ) ) ; assertEquals ( " v " , MDC . get ( " k " ) ) ; MDC . remove ( " k " ) ; assertNull ( MDC . get ( " k " ) ) ; MDC . put ( " k1 " , " v1 " ) ; assertEquals ( " v1 " , MDC . get ( " k1 " ) ) ; MDC . clear ( ) ; assertNull ( MDC . get ( " k1 " ) ) ; try { MDC . put ( null , " x " ) ;
public static int function ( byte [ ] arg0 ) { int count = 0 ; for ( int i = 0 ; i < arg0 . length - 1 ; i + + ) { if ( arg0 [ i ] = = ( byte ) 0xff & & ( ( arg0 [ i + 1 ] & ( byte ) 0xe0 ) = = ( byte ) 0xe0 | | arg0 [ i + 1 ] = = 0 ) ) { count + + ; } } if ( arg0 . length > 0 & & arg0 [ arg0 . length - 1 ] = = ( byte ) 0xff ) count + + ; return count ; }
public void function ( Object arg0 , Throwable arg1 ) { differentiatedLog ( null , CATEGORY_FQCN , LocationAwareLogger . INFO_INT , arg0 , arg1 ) ; }
protected void function ( final SocketChannel arg0 ) { ChannelPipeline pipeline = arg0 . pipeline ( ) ; if ( serverSetting . isSecure ( ) ) { pipeline . addFirst ( " ssl " , serverSetting . getRequiredSslHandler ( ) ) ; } ServerConfig serverConfig = serverSetting . getServerConfig ( ) ; pipeline . addLast ( " codec " , new HttpServerCodec ( MAX_INITIAL_LINE_LENGTH , serverConfig . getHeaderSize ( ) , MAX_CHUNK_SIZE , false ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( serverConfig . getContentLength ( ) ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p class='tab-nav'>Check</p> " ) ; Elements els = doc . getElementsByClass ( " tab-nav " ) ; assertEquals ( 1 , els . size ( ) ) ; assertEquals ( " Check " , els . text ( ) ) ; }
public void function ( ) { int [ ] a = new int [ ] { } ; BubbleSort . sort ( a ) ; }
public void function ( ) { try { helper . get ( " http://localhost:8080/dir/unknown.response " ) ;
void function ( StringBuilder arg0 , int arg1 ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element & & ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( siblingIndex ( ) = = 0 & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) & & ! isBlank ( ) ) indent ( arg0 , arg1 ) ; arg0 . append ( html ) ; }
public void function ( ) throws IOException { String json = helper . getResponse ( root ( ) ) . getFirstHeader ( HttpHeaders . CONTENT_TYPE ) . getValue ( ) ; assertThat ( json , is ( " application/json " ) ) ; String bar = helper . getResponse ( root ( ) ) . getFirstHeader ( " foo " ) . getValue ( ) ; assertThat ( bar , is ( " bar " ) ) ; }
public HandshakeState function ( ClientHandshake arg0 ) { if ( arg0 . getFieldValue ( " Upgrade " ) . equals ( " WebSocket " ) & & arg0 . getFieldValue ( " Connection " ) . contains ( " Upgrade " ) & & arg0 . getFieldValue ( " Sec-WebSocket-Key1 " ) . length ( ) > 0 & & ! arg0 . getFieldValue ( " Sec-WebSocket-Key2 " ) . isEmpty ( ) & & arg0 . hasFieldValue ( " Origin " ) ) return HandshakeState . MATCHED ; return HandshakeState . NOT_MATCHED ; }
public void function ( ) { if ( VersionUtil . getJavaMajorVersion ( ) < 9 ) return ; MDCFriend . fixForJava9 ( ) ; String key = " MDCFriendTest.smoke " + diff ; String val = " val " + diff ; MDC . put ( key , val ) ; assertEquals ( val , MDC . get ( key ) ) ; MDC . clear ( ) ; assertNull ( MDC . get ( key ) ) ;
public static RecorderTape function ( final String arg0 ) { return new RecorderTape ( checkNotNullOrEmpty ( arg0 , " tape should not be empty " ) ) ; }
public void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { String requestOrigin = arg0 . getHeader ( " Origin " ) ; if ( origin . equals ( requestOrigin ) | | origin . equals ( " * " ) | | Strings . isNullOrEmpty ( requestOrigin ) ) { arg1 . addHeader ( " Access-Control-Allow-Origin " , origin ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private org . apache . log4j . spi . LoggingEvent function ( LoggingEvent arg0 , Level arg1 ) { String formattedMessage = MessageFormatter . basicArrayFormat ( arg0 . getMessage ( ) , arg0 . getArgumentArray ( ) ) ; LocationInfo locationInfo = null ; String fqcn = null ; if ( arg0 instanceof SubstituteLoggingEvent ) { locationInfo = new LocationInfo ( NA_SUBST , NA_SUBST , NA_SUBST , " 0 " ) ; fqcn = FQCN_SUBSTITUE ; } else { fqcn = FQCN_FLUENT ; } ThrowableInformation ti = null ; Throwable t = arg0 . getThrowable ( ) ; if ( t ! = null ) ti = new ThrowableInformation ( t ) ; org . apache . log4j . spi . LoggingEvent log4jEvent = new org . apache . log4j . spi . LoggingEvent ( fqcn , logger , arg0 . getTimeStamp ( ) , arg1 , formattedMessage , arg0 . getThreadName ( ) , ti , null , locationInfo , null ) ; return log4jEvent ; }
void function ( ) { boolean threw = false ; Safelist safelist = null ; try { safelist = Safelist . none ( ) . addTags ( " NOSCRIPT " ) ; } catch ( ValidationException validationException ) { threw = true ; assertTrue ( validationException . getMessage ( ) . contains ( " unsupported " ) ) ; } assertTrue ( threw ) ; assertNull ( safelist ) ; }
public String function ( ) { if ( attributes ! = null & & attributes . size ( ) > 0 ) return " < " + name ( ) + "   " + attributes . toString ( ) + " > " ;
public String function ( String arg0 ) { int offset = lcQueue . indexOf ( arg0 . toLowerCase ( ) , pos ) ; if ( offset ! = - 1 ) { String consumed = queue . substring ( pos , offset ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { delegate ( ) . debug ( arg0 , arg1 , arg2 , arg3 ) ; }
public void function ( ) throws Exception { String source = " %1-%2 something %1-%3 " ; assertEquals ( " ONE-%2 something ONE-%3 " , BufferTools . substitute ( source , " %1 " , " ONE " ) ) ; assertEquals ( " %1-TWO something %1-%3 " , BufferTools . substitute ( source , " %2 " , " TWO " ) ) ; assertEquals ( " %1-%2 something %1-THREE " , BufferTools . substitute ( source , " %3 " , " THREE " ) ) ; }
public Document function ( ) { Element htmlEl = findFirstElementByTagName ( " html " , this ) ; if ( htmlEl = = null ) htmlEl = appendElement ( " html " ) ; if ( head ( ) = = null ) htmlEl . prependElement ( " head " ) ; if ( body ( ) = = null ) htmlEl . appendElement ( " body " ) ; normaliseTextNodes ( head ( ) ) ; normaliseTextNodes ( htmlEl ) ; normaliseTextNodes ( this ) ; normaliseStructure ( " head " , htmlEl ) ; normaliseStructure ( " body " , htmlEl ) ; ensureMetaCharset ( ) ; return this ; }
public void function ( ) throws IOException { assertThat ( MocoTestHelper . get ( " http://localhost:8080/foo " ) , is ( " bar " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.8.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 400 ) ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( by ( uri ( " /path " ) ) ) ) ; server . request ( xml ( text ( " <request><parameters><id>1</id></parameters></request> " ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
String function ( ) { bufferUp ( ) ; int start = bufPos ; while ( bufPos < bufLength ) { char c = charBuf [ bufPos ] ; if ( ( c > = 'A' & & c < = 'Z' ) | | ( c > = 'a' & & c < = 'z' ) | | Character . isLetter ( c ) ) bufPos + + ; else break ; } while ( ! isEmptyNoBufferUp ( ) ) { char c = charBuf [ bufPos ] ; if ( c > = '0' & & c < = '9' ) bufPos + + ; else break ; } return cacheString ( charBuf , stringCache , start , bufPos - start ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { readData ( arg0 , arg1 , this , ScriptDataLessthanSign ) ; }
public Optional < String > function ( FullHttpRequest arg0 ) { HttpPostRequestDecoder decoder = null ; try { decoder = new HttpPostRequestDecoder ( arg0 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 3.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public StartArgs function ( ServerType arg0 , String [ ] arg1 ) { try { return doParse ( arg0 , arg1 ) ;
public void function ( ) { nodelistChanged ( ) ; }
public void function ( ) { ID3v1 id3v1Tag = new ID3v1TagForTesting ( ) ; ID3Wrapper wrapper = new ID3Wrapper ( id3v1Tag , null ) ; assertEquals ( null , wrapper . getId3v2Tag ( ) ) ; }
protected void function ( Node arg0 ) { super . removeChild ( arg0 ) ; linkedEls . remove ( arg0 ) ; }
public void function ( ) throws Exception { httpServer = httpsServer ( 12306 , DEFAULT_CERTIFICATE , context ( " /foo " ) ) ; httpServer . response ( " foo " ) ; anotherServer = httpsServer ( 12306 , DEFAULT_CERTIFICATE , context ( " /bar " ) ) ; anotherServer . request ( by ( uri ( " /bar " ) ) ) . response ( " bar " ) ; HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , ( ) - > { assertThat ( helper . get ( remoteHttpsUrl ( " /foo/anything " ) ) , is ( " foo " ) ) ;
protected final boolean function ( final Resource arg0 ) { return this . arg0 = = arg0 ; }
public void function ( ) { ShutdownArgs args = parse ( new String [ ] { " shutdown " } ) ; assertThat ( Optional . < Integer > absent ( ) , is ( args . getShutdownPort ( ) ) ) ; }
private final void function ( ) { try { String host = uri . getHost ( ) ; int port = getPort ( ) ; tryToConnect ( new InetSocketAddress ( host , port ) ) ; conn = ( WebSocketImpl ) wf . createWebSocket ( this , draft , channel . socket ( ) ) ; conn . channel = wrappedchannel = wf . wrapChannel ( channel , null , host , port ) ; timeout = 0 ; sendHandshake ( ) ; readthread = new Thread ( new WebsocketWriteThread ( ) ) ; readthread . start ( ) ; } catch ( ClosedByInterruptException e ) { onWebsocketError ( null , e ) ; return ; } catch ( Exception e ) { onWebsocketError ( conn , e ) ; conn . closeConnection ( CloseFrame . NEVER_CONNECTED , e . getMessage ( ) ) ; return ; } ByteBuffer buff = ByteBuffer . allocate ( WebSocket . RCVBUF ) ; try { while ( channel . isOpen ( ) ) {
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { recordEvent ( Level . WARN , arg0 , arg1 , new Object [ ] { arg2 , arg3 } , null ) ;
public static MocoEventTrigger function ( MocoEventAction arg0 ) { return new MocoEventTrigger ( MocoEvent . COMPLETE , arg0 ) ; }
public void function ( ) throws Exception { ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " chat " ) ) ; protocols . add ( new Protocol ( " chat2 " ) ) ; testProtocolRejection ( 15 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ) ; }
@Test public void function ( ) { Cleaner cleaner = new Cleaner ( Whitelist . basic ( ) ) ; Document doc = Jsoup . parse ( " <script>Script</script><p>Text</p> " ) ; Document clean = cleaner . clean ( doc ) ; assertEquals ( " <p>Text</p> " , clean . body ( ) . html ( ) ) ; }
public static ResourceConfigApplier function ( final ContentResource arg0 , final ImmutableMap < String , Object > arg1 ) { return new EmbeddedResourceConfigApplier ( arg0 ) { @Override
Element function ( Token . StartTag arg0 ) { if ( arg0 . isSelfClosing ( ) ) { Element el = insertEmpty ( arg0 ) ; stack . add ( el ) ; tokeniser . emit ( new Token . EndTag ( el . tagName ( ) ) ) ; return el ; } Element el = new Element ( Tag . valueOf ( arg0 . name ( ) ) , baseUri , arg0 . attributes ) ; insert ( el ) ; return el ; }
public void function ( ) { String xhtml = " <html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html> " ; Document doc = Jsoup . parse ( xhtml , Parser . xmlParser ( ) ) ; Elements elements = doc . selectXpath ( " //*[local-name()='body'] " ) ; assertEquals ( 1 , elements . size ( ) ) ; assertEquals ( " One " , elements . first ( ) . id ( ) ) ; }
public void function ( ) throws Exception { String url = " https://certs.cac.washington.edu/CAtest/ " ; try { Connection . Response defaultRes = Jsoup . connect ( url ) . execute ( ) ; } catch ( IOException e ) { } Connection . Response defaultRes = Jsoup . connect ( url ) . setSecure ( false ) . execute ( ) ; assertThat ( defaultRes . statusCode ( ) , is ( 200 ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " path_resource.json " ) ; InputStream asStream = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " path.request " ) ; assertThat ( helper . postBytes ( root ( ) , ByteStreams . toByteArray ( asStream ) ) , is ( " path resource " ) ) ; }
static Set < URL > function ( ) { Set < URL > staticLoggerBinderPathSet = new LinkedHashSet < URL > ( ) ; try { ClassLoader loggerFactoryClassLoader = LoggerFactory . class . getClassLoader ( ) ; Enumeration < URL > paths ; if ( loggerFactoryClassLoader = = null ) { paths = ClassLoader . getSystemResources ( STATIC_LOGGER_BINDER_PATH ) ; } else { paths = loggerFactoryClassLoader . getResources ( STATIC_LOGGER_BINDER_PATH ) ; } while ( paths . hasMoreElements ( ) ) { URL path = paths . nextElement ( ) ; staticLoggerBinderPathSet . add ( path ) ; } } catch ( IOException ioe ) { Util . report ( " Error getting resources from path " , ioe ) ; } return staticLoggerBinderPathSet ; }
public T function ( String arg0 , String arg1 ) { Validate . notEmpty ( arg0 , " Header name must not be empty " ) ; Validate . notNull ( arg1 , " Header value must not be null " ) ; removeHeader ( arg0 ) ; headers . put ( arg0 , arg1 ) ; return ( T ) this ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " test1 " ) ; logger . debug ( " Hello world. " ) ; assertLogMessage ( " Hello world. " , 0 ) ; }
public static HttpServer function ( final MocoMonitor arg0 , final MocoConfig . . . arg1 ) { return ActualHttpServer . createHttpServerWithMonitor ( Optional . < Integer > absent ( ) , checkNotNull ( arg0 , " Monitor should not be null " ) , arg1 ) ; }
public static Document function ( String arg0 ) { return Parser . parseBodyFragment ( arg0 , " " ) ; }
public void function ( Node arg0 , int arg1 ) { arg0 . outerHtmlTail ( accum , arg1 , out ) ; }
static String function ( CtBehavior arg0 , LocalVariableAttribute arg1 , int arg2 ) { if ( arg1 = = null ) { return Integer . toString ( arg2 + 1 ) ; } int modifiers = arg0 . getModifiers ( ) ; int j = arg2 ; if ( Modifier . isSynchronized ( modifiers ) ) { j + + ; } if ( Modifier . isStatic ( modifiers ) = = false ) { j + + ; } String variableName = arg1 . variableName ( j ) ; return variableName ; }
public Request function ( Connection . KeyVal arg0 ) { Validate . notNullParam ( arg0 , " arg0 " ) ; data . add ( arg0 ) ; return this ; }
private static String function ( arg0 String arg1 ) { if ( arg1 = = null ) return arg1 ; byte [ ] bytes = arg1 . getBytes ( ISO_8859_1 ) ; if ( looksLikeUtf8 ( bytes ) ) return new String ( bytes , UTF_8 ) ;
public void function ( ) { BaseActualServer < T , U > setting = serverSetting ( ) ; int port = this . server . start ( setting . getPort ( ) . or ( 0 ) , channelInitializer ( ) ) ; setting . setPort ( port ) ; }
public String function ( ) { String result = super . toString ( ) ; if ( getExtension ( ) ! = null ) { result + = "  extension:  " + getExtension ( ) . toString ( ) ; } if ( getProtocol ( ) ! = null ) { result + = "  protocol:  " + getProtocol ( ) . toString ( ) ; } result + = "  max frame size:  " + this . maxFrameSize ; return result ; }
public ReplayContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return new ReplayContainer ( helper . text ( arg0 ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . FIELD_NAME & & " identifier " . equalsIgnoreCase ( strip ( arg0 . getText ( ) ) ) ) { arg0 . nextToken ( ) ; arg0 . nextToken ( ) ; return new ReplayContainer ( helper . textContainer ( arg0 , arg1 ) ) ; } } return ( ReplayContainer ) arg1 . handleUnexpectedToken ( ReplayContainer . class , arg0 ) ; }
public void function ( ) throws Exception { String uri = " /targets " ; List < Plain > plains = getResources ( uri ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; }
public void function ( ) throws Exception { final MocoMonitor monitor = mock ( MocoMonitor . class ) ; final HttpServer server = httpServer ( port ( ) , monitor ) ; server . get ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ) ; verify ( monitor ) . onMessageArrived ( any ( HttpRequest . class ) ) ; verify ( monitor ) . onMessageLeave ( any ( HttpResponse . class ) ) ; verify ( monitor , Mockito . never ( ) ) . onException ( any ( Exception . class ) ) ; }
public RequestMatcher function ( final MocoConfig arg0 ) { Resource appliedResource = expected . apply ( arg0 ) ; if ( appliedResource = = expected ) { return this ; } return new EqRequestMatcher ( extractor , appliedResource ) ; }
public static MocoEventAction function ( final Resource arg0 , final String arg1 ) { return post ( checkNotNull ( arg0 , " URL should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Content should not be null " ) ) ) ; }
public void function ( String arg0 , Object arg1 ) { if ( log . isWarnEnabled ( ) ) { String msgStr = MessageFormatter . arg0 ( arg0 , arg1 ) ;
protected boolean function ( Token arg0 ) { switch ( arg0 . type ) { case StartTag : insert ( arg0 . asStartTag ( ) ) ; break ; case EndTag : popStackToClose ( arg0 . asEndTag ( ) ) ; break ; case Comment : insert ( arg0 . asComment ( ) ) ; break ; case Character : insert ( arg0 . asCharacter ( ) ) ; break ; case Doctype : insert ( arg0 . asDoctype ( ) ) ; break ; case EOF : break ; default : Validate . fail ( " Unexpected token type:  " + arg0 . type ) ; } return true ; }
public void function ( ) { Integer i1 = Integer . valueOf ( 1 ) ; Integer i2 = Integer . valueOf ( 2 ) ; Integer i3 = Integer . valueOf ( 3 ) ; Exception e = new Exception ( " This is a test exception. " ) ; Logger logger = LoggerFactory . getLogger ( " test2 " ) ; logger . trace ( " Hello trace. " ) ; logger . debug ( " Hello world 1. " ) ; logger . debug ( " Hello world {} " , i1 ) ; logger . debug ( " val={} val={} " , i1 , i2 ) ; logger . debug ( " val={} val={} val={} " , new Object [ ] { i1 , i2 , i3 } ) ; logger . debug ( " Hello world 2 " , e ) ; logger . info ( " Hello world 2. " ) ; logger . warn ( " Hello world 3. " ) ; logger . warn ( " Hello world 3 " , e ) ; logger . error ( " Hello world 4. " ) ; logger . error ( " Hello world {} " , Integer . valueOf ( 3 ) ) ; logger . error ( " Hello world 4. " , e ) ; assertEquals ( 11 , listAppender . list . size ( ) ) ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( RedirectServlet . Url ) . data ( RedirectServlet . CodeParam , " 302 " ) . data ( RedirectServlet . SetCookiesParam , " true " ) . data ( RedirectServlet . LocationParam , echoUrl ) ; Connection . Response res = con . execute ( ) ; Map < String , String > cookies = res . cookies ( ) ; assertEquals ( " asdfg123 " , cookies . get ( " token " ) ) ; assertEquals ( " jhy " , cookies . get ( " uid " ) ) ; Document doc = Jsoup . connect ( echoUrl ) . cookies ( cookies ) . get ( ) ; assertEquals ( " token=asdfg123; uid=jhy " , ihVal ( " Cookie " , doc ) ) ; }
@Test public void function ( ) { String html = " <p>One<br>Two</p> " ; Document doc = Jsoup . parse ( html ) ; String origHtml = doc . html ( ) ; Elements one = doc . select ( " p:matchText:first-child " ) ; assertEquals ( " One " , one . first ( ) . text ( ) ) ; Elements two = doc . select ( " p:matchText:last-child " ) ; assertEquals ( " Two " , two . first ( ) . text ( ) ) ; assertEquals ( origHtml , doc . html ( ) ) ; assertEquals ( " Two " , doc . select ( " p:matchText + br + * " ) . text ( ) ) ; }
public Optional < String > function ( FullHttpRequest arg0 ) { try { HttpPostRequestDecoder decoder = new HttpPostRequestDecoder ( new DefaultHttpDataFactory ( false ) , arg0 ) ;
private Optional < Charset > function ( String arg0 ) { if ( arg0 = = null ) { return absent ( ) ; } return fromNullable ( Charset . forName ( arg0 ) ) ; }
public int function ( int arg0 ) throws LimitExedeedException , InvalidDataException { if ( arg0 < 0 ) throw new InvalidDataException ( " Negative count " ) ; return arg0 ; }
private static void function ( SubstituteLoggingEvent arg0 ) { if ( arg0 = = null ) return ; SubstituteLogger substLogger = arg0 . getLogger ( ) ; String loggerName = substLogger . getName ( ) ; if ( substLogger . isDelegateNull ( ) ) { throw new IllegalStateException ( " Delegate logger cannot be null at this state. " ) ; } if ( substLogger . isDelegateNOP ( ) ) {
public boolean function ( Element arg0 ) { Element prev = arg0 . previousElementSibling ( ) ; if ( prev ! = null & & sel . matches ( prev ) ) return true ; return false ; }
static ByteBuffer function ( InputStream arg0 , int arg1 ) throws IOException { Validate . isTrue ( arg1 > = 0 , " maxSize must be 0 (unlimited) or larger " ) ; byte [ ] buffer = new byte [ bufferSize ] ; ByteArrayOutputStream outStream = new ByteArrayOutputStream ( bufferSize ) ; int read , totalRead = 0 ; while ( true ) { read = arg0 . read ( buffer ) ; totalRead + = read ; if ( read = = - 1 ) break ; outStream . write ( buffer , 0 , read ) ; if ( arg1 > 0 & & totalRead > = arg1 ) break ; } ByteBuffer byteData = ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; return byteData ; }
public RequestMatcher function ( MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . URI_ID ) ) { return context ( ( String ) arg0 . apply ( " " ) ) ; } return this ; }
private static void function ( StringBuffer arg0 , long [ ] arg1 ) { arg0 . append ( '[' ) ; final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { arg0 . append ( arg1 [ i ] ) ; if ( i ! = len - 1 ) arg0 . append ( " ,  " ) ; } arg0 . append ( ']' ) ; }
public void function ( HttpServer arg0 ) { com . github . dreamhead . moco . ResponseSetting setting = bindToSession ( arg0 ) ; if ( hasEvent ( ) ) { for ( MocoEventTrigger trigger : on . createTriggers ( ) ) {
public Element function ( ) { Element html = htmlEl ( ) ; for ( Element el : html . childElementsList ( ) ) { if ( " body " . equals ( el . normalName ( ) ) | | " frameset " . equals ( el . normalName ( ) ) ) return el ; } return html . appendElement ( " body " ) ; }
private Predicate < SimpleRestSetting > function ( ) { return new Predicate < SimpleRestSetting > ( ) { @Override
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { if ( arg1 . matches ( '-' ) ) { arg0 . emit ( '-' ) ;
public void function ( ) { Evaluator . IsFirstOfType evaluator = new Evaluator . IsFirstOfType ( ) ; assertEquals ( " :first-of-type " , evaluator . toString ( ) ) ; }
public void function ( byte [ ] arg0 , int arg1 ) throws NotSupportedException { throw ( new NotSupportedException ( " Packing Obselete frames is not supported " ) ) ; }
public static boolean function ( ) { java . util . logging . Logger rootLogger = getRootLogger ( ) ; Handler [ ] handlers = rootLogger . getHandlers ( ) ; for ( int i = 0 ; i < handlers . length ; i + + ) { if ( handlers [ i ] instanceof SLF4JBridgeHandler ) { return true ; } } return false ; }
private ID3v2PictureFrameData function ( ) { byte [ ] imageData = new byte [ TEST_IMAGE_DATA_LENGTH ] ; for ( int i = 0 ; i < imageData . length ; i + + ) { imageData [ i ] = ( byte ) i ; } ID3v2PictureFrameData frameData = new ID3v2PictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 3 , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , imageData ) ; return frameData ; }
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; int line = 137 ; logger . exit ( ) ; logger . debug ( " hello " ) ; assertEquals ( 2 , listAppender . list . size ( ) ) ; { LoggingEvent e = listAppender . list . get ( 0 ) ; LocationInfo li = e . getLocationInformation ( ) ; assertEquals ( this . getClass ( ) . getName ( ) , li . getClassName ( ) ) ; assertEquals ( " " + line , li . getLineNumber ( ) ) ; } { LoggingEvent e = listAppender . list . get ( 1 ) ;
public static void function ( double arg0 , long arg1 , double arg2 ) throws AssertionFailedError { double ajustedPerf = adjustExpectedPerformance ( arg1 , arg2 ) ; if ( arg0 * SLACK_FACTOR < ajustedPerf ) { throw new AssertionFailedError ( arg0 + "  below expected  " + ajustedPerf + "  (adjusted),  " + arg1 + "  (raw) " ) ;
private FullHttpResponse function ( FullHttpRequest arg0 ) { FullHttpResponse response = defaultResponse ( arg0 , HttpResponseStatus . OK ) ; for ( BaseSetting setting : settings ) { if ( setting . match ( arg0 ) ) { setting . writeToResponse ( arg0 , response ) ; return response ; } } if ( anySetting . match ( arg0 ) ) { anySetting . writeToResponse ( arg0 , response ) ; return response ; } monitor . onUnexpectedMessage ( arg0 ) ; return defaultResponse ( arg0 , HttpResponseStatus . BAD_REQUEST ) ; }
public void function ( ) { for ( FileMonitor monitor : monitors ) { monitor . startMonitor ( ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 2.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { final long latency = 1000 ; final long delta = 200 ; runWithConfiguration ( " foo.json " ) ; long start = System . currentTimeMillis ( ) ; helper . get ( remoteUrl ( " /latency " ) ) ; long stop = System . currentTimeMillis ( ) ; long gap = stop - start + delta ; assertThat ( gap , greaterThan ( latency ) ) ; }
public void function ( ) throws Exception { final String MOUNT_DIR = " src/test/resources/test " ; server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . mount ( MOUNT_DIR , to ( " /dir " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { byte [ ] bytes = { 0x00 , 'P' , 'N' , 'G' , 0x01 , 'D' , 'E' , 'S' , 'C' , 'R' , 'I' , 'P' , 'T' , 'I' , 'O' , 'N' , 0x00 , 1 , 2 , 3 , 4 , 5 } ; ID3v2ObseletePictureFrameData frameData = new ID3v2ObseletePictureFrameData ( false , bytes ) ; assertEquals ( TEST_MIME_TYPE , frameData . getMimeType ( ) ) ; assertEquals ( ( byte ) 1 , frameData . getPictureType ( ) ) ; assertEquals ( new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , frameData . getDescription ( ) ) ; assertArrayEquals ( DUMMY_IMAGE_DATA , frameData . getImageData ( ) ) ; }
public static Document function ( String arg0 ) { TokenStream ts = TokenStream . create ( arg0 ) ; Parser parser = new Parser ( ts ) ; return parser . parse ( ) ; }
RequestRecorder function ( ) ; RecorderFactory IN_MEMORY = InMemoryRequestRecorder : : new ; }
public static ResponseHandler function ( final String arg0 , final String arg1 ) { return header ( checkNotNullOrEmpty ( arg0 , " Header name should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Header value should not be null " ) ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.9 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public static MocoJunitRunner function ( final int arg0 , final String arg1 ) { return new MocoJunitRunner ( Runner . runner ( jsonHttpServer ( arg0 , file ( arg1 ) ) ) ) ; }
public final boolean function ( ) { return this . type = = ServerType . SOCKET ; }
public ImmutableList < GlobalSetting > function ( final InputStream arg0 ) { return Jsons . toList ( arg0 , GlobalSetting . class ) ; }
public static void function ( ) throws Exception { LogManager . getLogManager ( ) . readConfiguration ( ) ; }
public void function ( ) throws Exception { ID3v2ChapterTOCFrameData frameData = new ID3v2ChapterTOCFrameData ( false , true , false , " toc1 " , new String [ ] { " ch1 " , " ch2 " } ) ; assertEquals ( frameData , frameData ) ; }
public static ResponseHandler function ( final ResponseHandler arg0 , final ResponseHandler [ ] arg1 ) { if ( arg1 . length = = 0 ) { return arg0 ; } return new AndResponseHandler ( asIterable ( arg0 , arg1 ) ) ; }
@Override ParseSettings function ( ) { return ParseSettings . htmlDefault ; }
public void function ( ) { LoggerFactoryFriend . reset ( ) ; System . setErr ( sps ) ; }
private void function ( ) { if ( ! hasAttributes ( ) ) { Object coreValue = value ;
public static void function ( arg0 Object arg1 , String arg2 ) { if ( arg1 = = null ) throw new ValidationException ( arg2 ) ;
public MountTo function ( MocoConfig arg0 ) { if ( arg0 . isFor ( " uri " ) ) { return new MountTo ( arg0 . apply ( this . target ) ) ; } return this ; }
public void function ( ) throws UnsupportedEncodingException { byte [ ] buffer = new byte [ 10 ] ; String s = " TAG- " ; try { BufferTools . stringIntoByteBuffer ( s , - 1 , 1 , buffer , 0 ) ; fail ( " StringIndexOutOfBoundsException expected but not thrown " ) ; } catch ( StringIndexOutOfBoundsException e ) { } try { BufferTools . stringIntoByteBuffer ( s , s . length ( ) , 1 , buffer , 0 ) ;
public void function ( ) { doStop ( ) ; if ( address ! = null ) { await ( ) . atMost ( DEFAULT_TIMEOUT , TimeUnit . SECONDS ) . until ( serverIsClosed ( address ) ) ;
public void function ( ) throws IOException { String localPath = " /htmltests/escapes-across-buffer.html " ; String localUrl = FileServlet . urlTo ( localPath ) ; Document docFromLocalServer = Jsoup . connect ( localUrl ) . get ( ) ; Document docFromFileRead = Jsoup . parse ( ParseTest . getFile ( localPath ) , " UTF-8 " ) ; String text = docFromLocalServer . body ( ) . text ( ) ; assertEquals ( 14766 , text . length ( ) ) ; assertEquals ( text , docFromLocalServer . body ( ) . text ( ) ) ; assertEquals ( text , docFromFileRead . body ( ) . text ( ) ) ; }
public Node function ( NodeFilter arg0 ) { Validate . notNull ( arg0 ) ; NodeTraversor . filter ( arg0 , this ) ; return this ; }
public void function ( Object arg0 ) { logger . log ( null , FQCN , LocationAwareLogger . ERROR_INT , String . valueOf ( arg0 ) , null ) ; }
boolean function ( Token arg0 , HtmlTreeBuilderState arg1 ) { currentToken = arg0 ; return arg1 . process ( arg0 , this ) ; }
public void function ( ) throws Exception { webSocketServer . request ( by ( " subscribeFoo " ) ) . response ( with ( " fooSubscribed " ) , join ( group ( " foo " ) ) ) ; webSocketServer . request ( by ( " subscribeBar " ) ) . response ( with ( " barSubscribed " ) , join ( group ( " bar " ) ) ) ; webSocketServer . request ( by ( " foo " ) ) . response ( broadcast ( text ( " foo " ) , group ( " foo " ) ) ) ; running ( server , ( ) - > { final Endpoint endpointFoo = new Endpoint ( new URI ( " ws://localhost:12306/ws/ " ) ) ;
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; while ( ! queue . isEmpty ( ) & & ( Character . isLetterOrDigit ( c ) | | c . equals ( '-' ) | | c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; c = queue . peek ( ) ; } return accum . toString ( ) ; }
public void function ( String arg0 , String arg1 ) { if ( arg0 = = null ) { throw new IllegalArgumentException ( " key cannot be null " ) ; } Map < String , String > map = inheritableThreadLocal . get ( ) ; if ( map = = null ) { map = new HashMap < > ( ) ; inheritableThreadLocal . set ( map ) ; } map . put ( arg0 , arg1 ) ; }
private ResponseHandler function ( String arg0 , Object arg1 ) { if ( isResource ( arg0 ) & & TextContainer . class . isInstance ( arg1 ) ) { TextContainer container = TextContainer . class . cast ( arg1 ) ; return with ( resourceFrom ( arg0 , container ) ) ; } if ( Map . class . isInstance ( arg1 ) ) { return createCompositeHandler ( arg0 , castToMap ( arg1 ) ) ; } if ( " status " . equalsIgnoreCase ( arg0 ) ) { return invokeTarget ( arg0 , Integer . parseInt ( arg1 . toString ( ) ) , ResponseHandler . class ) ; } if ( " latency " . equalsIgnoreCase ( arg0 ) ) { return invokeTarget ( arg0 , Long . parseLong ( arg1 . toString ( ) ) , ResponseHandler . class ) ; } if ( ProxyContainer . class . isInstance ( arg1 ) ) { return createProxy ( ( ProxyContainer ) arg1 ) ; } throw new IllegalArgumentException ( format ( " unknown field [%s] " , arg0 ) ) ; }
public void function ( ) throws IOException { new FileWrapper ( ( java . nio . file . Path ) null ) ; }
public void function ( Marker arg0 , String arg1 ) { if ( ! logger . isDebugEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn ,
static CoreCharset function ( final String arg0 ) { if ( arg0 . equals ( " US-ASCII " ) ) return ascii ; if ( arg0 . startsWith ( " UTF- " ) ) return utf ; return fallback ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.27 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { RunnerFactory factory = new RunnerFactory ( SHUTDOWN_MOCO_KEY ) ; runner = factory . createRunner ( new StartArgs ( port ( ) , null , " src/test/resources/foo.json " , null , null ) ) ; runner . run ( ) ; try { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; } catch ( HttpHostConnectException e ) { fail ( e . getMessage ( ) ) ; } ShutdownRunner shutdownRunner = ( ShutdownRunner ) runner ; int port = shutdownRunner . shutdownPort ( ) ; shutdownMoco ( port , SHUTDOWN_MOCO_KEY ) ; waitChangeHappens ( ) ; helper . get ( root ( ) ) ; }
public void function ( ) throws Exception { server . request ( match ( header ( " foo " ) , " bar|blah " ) ) . response ( " header " ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( ) { return this . sessions ! = null & & ! this . sessions . isEmpty ( ) ; }
public static String function ( ) { int next = size ( ) ; if ( next = = 0 ) { return " " ; } int last = next - 1 ; String key = PREFIX + last ; String val = MDC . get ( key ) ; MDC . remove ( key ) ; return val ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div class=left>One</div><div class=right id=1><p>Two</p></div> " ) ; Elements el1 = SelectMatch . match ( doc , Parser . parse ( " div:not(.left) " ) ) ; assertEquals ( 1 , el1 . size ( ) ) ; assertEquals ( " 1 " , el1 . first ( ) . id ( ) ) ; }
public void function ( Object arg0 ) { lbLogger . error ( FATAL_MARKER , ( String ) arg0 ) ; }
void function ( Token arg0 ) { Validate . isFalse ( isEmitPending , " There is an unread token pending! " ) ; emitPending = arg0 ; isEmitPending = true ; if ( arg0 . type = = Token . TokenType . StartTag ) { Token . StartTag startTag = ( Token . StartTag ) arg0 ;
Element function ( String arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ; stack . remove ( pos ) ; if ( el . normalName ( ) . equals ( arg0 ) ) { if ( currentToken instanceof Token . EndTag ) onNodeClosed ( el , currentToken ) ; return el ; } } return null ; }
private ImmutableList < Session > function ( Session arg0 ) { if ( file . length ( ) = = 0 ) { return of ( arg0 ) ; } return ImmutableList . < Session > builder ( ) . addAll ( toUniqueSessions ( arg0 , restoreSessions ( this . file ) ) ) . add ( arg0 ) . build ( ) ; }
public void function ( ) throws Exception { byte [ ] buffer = loadFile ( " src/test/resources/obselete.mp3 " ) ; ID3v2 id3tag = ID3v2TagFactory . createTag ( buffer ) ; assertEquals ( " 2009 " , id3tag . getYear ( ) ) ; assertEquals ( " 4/15 " , id3tag . getTrack ( ) ) ; assertEquals ( " image/png " , id3tag . getAlbumImageMimeType ( ) ) ; assertEquals ( 40 , id3tag . getGenre ( ) ) ; assertEquals ( " Alt Rock " , id3tag . getGenreDescription ( ) ) ; assertEquals ( " NAME1234567890123456789012345678901234567890 " , id3tag . getTitle ( ) ) ; assertEquals ( " ARTIST1234567890123456789012345678901234567890 " , id3tag . getArtist ( ) ) ; assertEquals ( " COMPOSER1234567890123456789012345678901234567890 " , id3tag . getComposer ( ) ) ; assertEquals ( " ALBUM1234567890123456789012345678901234567890 " , id3tag . getAlbum ( ) ) ; assertEquals ( " COMMENTS1234567890123456789012345678901234567890 " , id3tag . getComment ( ) ) ; }
public Element function ( ) { Element clone = ( Element ) super . clone ( ) ; clone . classNames = null ; return clone ; }
public void function ( String arg0 , Object [ ] arg1 ) { formatAndLog ( LOG_LEVEL_ERROR , arg0 , arg1 ) ; }
public void function ( ) { RunnerFactory factory = new RunnerFactory ( SHUTDOWN_MOCO_KEY ) ; runner = factory . createRunner ( httpArgs ( ) . withPort ( port ( ) )
public void function ( ResponseHandler . . . arg0 ) { this . arg0 = new AndResponseHandler ( arg0 ) ; }
public static HttpProtocolVersion function ( final String arg0 ) { HttpProtocolVersion [ ] values = HttpProtocolVersion . values ( ) ; return Arrays . stream ( values ) . filter ( value - > value . text . equalsIgnoreCase ( arg0 ) )
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { counter + + ; System . out . println ( " ///////////Opened connection number " + counter ) ; }
protected Option function ( ) { Option opt = new Option ( " g " , true , " global settings " ) ; opt . setType ( String . class ) ; opt . setRequired ( false ) ; return opt ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { DefaultHttpRequest request = new DefaultHttpRequest ( ) ; request . setVersion ( " HTTP/1.1 " ) ; request . setMethod ( " POST " ) ; request . setContent ( " proxy " ) ; request . addHeader ( " Cookie " , " loggedIn=true " ) ; request . addHeader ( " Host " , " localhost:12306 " ) ; assertThat ( request . match ( request ) , is ( true ) ) ; }
public void function ( ) throws InvalidDataException { byte [ ] frameData = { BYTE_FF , BYTE_FB , BYTE_A2 , BYTE_40 } ; MpegFrameForTesting mpegFrame = new MpegFrameForTesting ( frameData ) ; assertEquals ( MpegFrame . MPEG_VERSION_1_0 , mpegFrame . getVersion ( ) ) ; assertEquals ( MpegFrame . MPEG_LAYER_3 , mpegFrame . getLayer ( ) ) ; assertEquals ( 160 , mpegFrame . getBitrate ( ) ) ; assertEquals ( 44100 , mpegFrame . getSampleRate ( ) ) ; assertEquals ( MpegFrame . CHANNEL_MODE_JOINT_STEREO , mpegFrame . getChannelMode ( ) ) ; assertEquals ( " None " , mpegFrame . getModeExtension ( ) ) ; assertEquals ( " None " , mpegFrame . getEmphasis ( ) ) ; assertEquals ( true , mpegFrame . isProtection ( ) ) ; assertEquals ( true , mpegFrame . hasPadding ( ) ) ; assertEquals ( false , mpegFrame . isPrivate ( ) ) ; assertEquals ( false , mpegFrame . isCopyright ( ) ) ; assertEquals ( false , mpegFrame . isOriginal ( ) ) ; assertEquals ( 523 , mpegFrame . getLengthInBytes ( ) ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , response ( header ( " foo " , " bar " ) ) ) ; server . response ( header ( " blah " , " param " ) ) ; running ( server , new Runnable ( ) { @Override
private boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { arg1 . error ( this ) ; arg1 . process ( new Token . EndTag ( " noscript " ) ) ; return arg1 . process ( arg0 ) ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://infohound.net/tools/302.pl " ) . followRedirects ( false ) ; Connection . Response res = con . execute ( ) ; assertEquals ( 302 , res . statusCode ( ) ) ; assertEquals ( " http://jsoup.org " , res . header ( " Location " ) ) ; }
public void function ( String arg0 , Object [ ] arg1 ) { if ( logger . isDebugEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( Framedata arg0 ) throws InvalidFrameException { if ( unmaskedpayload = = null ) { unmaskedpayload = ByteBuffer . wrap ( arg0 . getPayloadData ( ) ) ;
private void function ( Framedata arg0 ) throws InvalidDataException { if ( arg0 . getOpcode ( ) = = Opcode . TEXT ) { wsl . onWebsocketMessage ( this , Charsetfunctions . stringUtf8 ( arg0 . getPayloadData ( ) ) ) ;
public void function ( ) throws IOException { File in = getFile ( " /htmltests/gzip.html.gz " ) ; Document doc = Jsoup . parse ( in , null ) ; assertEquals ( " Gzip test " , doc . title ( ) ) ; assertEquals ( " This is a gzipped HTML file. " , doc . selectFirst ( " p " ) . text ( ) ) ; }
public void function ( ) throws URISyntaxException { runWithConfiguration ( " websocket/websocket_with_broadcast.json " ) ; final Endpoint fooEndpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws " ) ) ; final Endpoint subscribeEndpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws " ) ) ; subscribeEndpoint . sendTextMessage ( " subscribe-with-group " ) ; assertThat ( subscribeEndpoint . getMessageAsText ( ) , is ( " subscribed " ) ) ; subscribeEndpoint . clearMessage ( ) ; fooEndpoint . sendTextMessage ( " broadcast-with-group " ) ; assertThat ( subscribeEndpoint . getMessageAsText ( ) , is ( " broadcast-with-group " ) ) ; }
@Test void function ( ) throws IOException { boolean caught = false ; try ( StreamParser streamParser = Jsoup . connect ( SlowRider . Url ) . data ( SlowRider . MaxTimeParam , " 10000 " ) . data ( SlowRider . IntroSizeParam , " 8000 " ) . timeout ( 4000 ) . execute ( ) . streamParser ( ) ) { try { long count = streamParser . stream ( ) . count ( ) ; } catch ( Exception e ) { caught = true ; UncheckedIOException ioe = ( UncheckedIOException ) e ; IOException cause = ioe . getCause ( ) ; assertInstanceOf ( IOException . class , cause ) ; } } assertTrue ( caught ) ; }
private void function ( ) { if ( readFully | | bufPos < bufSplitPoint ) return ; final int pos ; final int offset ; if ( bufMark ! = - 1 ) { pos = bufMark ; offset = bufPos - bufMark ; } else { pos = bufPos ; offset = 0 ; } try { final long skipped = reader . skip ( pos ) ;
public void function ( Set < WebSocket > arg0 , String arg1 ) throws InterruptedException { if ( arg0 = = null ) { throw new NullPointerException ( " 'connections' cannot be null " ) ; } for ( WebSocket c : this . arg0 ) { if ( ! arg0 . contains ( c ) ) {
private Predicate < PropertyDescriptor > function ( final RequestSetting arg0 ) { return new Predicate < PropertyDescriptor > ( ) { @Override
public void function ( Marker arg0 , String arg1 , Object [ ] arg2 ) { if ( ! logger . isWarnEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg1 , arg2 ) ;
static boolean function ( String arg0 ) { return arg0 . length ( ) > 1 & & arg0 . charAt ( 0 ) = = InternalPrefix ; }
protected Optional < String > function ( final HttpRequest arg0 ) { Optional < String > extractedUri = extractor . extract ( arg0 ) ; return extractedUri . flatMap ( target : : extract ) ; }
public void function ( ) { PingFrame frame = new PingFrame ( ) ; try { frame . isValid ( ) ; } catch ( InvalidDataException e ) { fail ( " InvalidDataException should not be thrown " ) ; } frame . setFin ( false ) ; try { frame . isValid ( ) ; fail ( " InvalidDataException should be thrown " ) ; } catch ( InvalidDataException e ) { } frame . setFin ( true ) ; frame . setRSV1 ( true ) ; try { frame . isValid ( ) ; fail ( " InvalidDataException should be thrown " ) ; } catch ( InvalidDataException e ) { } frame . setRSV1 ( false ) ; frame . setRSV2 ( true ) ; try { frame . isValid ( ) ; fail ( " InvalidDataException should be thrown " ) ; } catch ( InvalidDataException e ) { } frame . setRSV2 ( false ) ; frame . setRSV3 ( true ) ; try { frame . isValid ( ) ;
private void function ( byte [ ] arg0 , ByteArrayOutputStream arg1 ) throws DataFormatException { inflater . setInput ( arg0 ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesInflated ; while ( ( bytesInflated = inflater . inflate ( buffer ) ) > 0 ) { arg1 . write ( buffer , 0 , bytesInflated ) ;
public void function ( WebSocket arg0 , Framedata arg1 ) { FramedataImpl1 builder = ( FramedataImpl1 ) arg1 ; builder . setTransferemasked ( true ) ; getConnection ( ) . sendFrame ( arg1 ) ; }
public void function ( String arg0 , Throwable arg1 ) { log ( LOG_LEVEL_DEBUG , arg0 , arg1 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p><img src=foo.png id=1><img src=bar.jpg id=2><img src=qux.JPEG id=3><img src=old.gif><img></p> " ) ; Elements imgs = doc . select ( " img[src~=(?i) \\ .(png|jpe?g)] " ) ; assertEquals ( 3 , imgs . size ( ) ) ; assertEquals ( " 1 " , imgs . get ( 0 ) . id ( ) ) ; assertEquals ( " 2 " , imgs . get ( 1 ) . id ( ) ) ; assertEquals ( " 3 " , imgs . get ( 2 ) . id ( ) ) ; }
public void function ( ) throws Exception { server . request ( contain ( uri ( " foo " ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
final boolean function ( ) { if ( siblingIndex = = 0 ) return true ; if ( siblingIndex = = 1 ) { final Node prev = previousSibling ( ) ; return prev instanceof TextNode & & ( ( ( TextNode ) prev ) . isBlank ( ) ) ; } return false ; }
public ByteChannel function ( SelectionKey arg0 ) { return ( ByteChannel ) arg0 . channel ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 175 ) ; }
public DefaultHttpRequest function ( ) { return new DefaultHttpRequest ( version , content , method , this . uri , headers , this . queries ) ; }
public void function ( ) throws Exception { testHandshakeRejection ( 2 ) ; }
@Test public void function ( ) { String html = " <a /> " ; Element el = Jsoup . parse ( html ) . getElementsByTag ( " a " ) . get ( 0 ) ; Attributes attr = el . getAttributes ( ) ; assertEquals ( 0 , attr . size ( ) ) ; }
public void function ( String arg0 ) { console . setText ( console . getText ( ) + arg0 + " \ n " ) ; }
public static CookieOption function ( final long arg0 , final TimeUnit arg1 ) { return new MaxAgeCookieOption ( arg0 , arg1 ) ; }
public void function ( ) throws Exception { webSocketServer . request ( by ( binary ( new byte [ ] { 1 , 2 , 3 } ) ) ) . response ( binary ( new byte [ ] { 4 , 5 , 6 } ) ) ; webSocketServer . ping ( text ( " hello " ) ) . pong ( text ( " world " ) ) ; running ( server , ( ) - > { final Endpoint endpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws/ " ) ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 20 ) ; }
public int function ( Object arg0 ) { String oIndex = ( ( PatternWrapper ) arg0 ) . index ; return this . index . compareTo ( oIndex ) ; }
private Function < ? super GlobalSetting , Stream < ? extends File > > function ( ) { return input - > input . includes ( ) . stream ( ) . map ( File : : new ) ; }
public static RequestMatcher function ( Uri arg0 ) { return new UriRequestMatcher ( arg0 . getUri ( ) ) ; }
public void function ( ) { Document htmlDoc = Jsoup . parse ( " <br>one</br> " ) ; assertEquals ( " <br>one<br> " , htmlDoc . body ( ) . html ( ) ) ; Document xmlDoc = Jsoup . parse ( " <br>one</br> " , " " , Parser . xmlParser ( ) ) ; assertEquals ( " <br>one</br> " , xmlDoc . html ( ) ) ; }
final static public void function ( StringBuffer arg0 , String arg1 , int arg2 ) { int actualLen = 0 ; if ( arg1 ! = null ) { actualLen = arg1 . length ( ) ; } if ( actualLen < arg2 ) { spacePad ( arg0 , arg2 - actualLen ) ; } if ( arg1 ! = null ) { arg0 . append ( arg1 ) ;
final private void function ( String arg0 , LogRecord arg1 ) { StackTraceElement [ ] steArray = new Throwable ( ) . getStackTrace ( ) ; int selfIndex = - 1 ; for ( int i = 0 ; i < steArray . length ; i + + ) { final String className = steArray [ i ] . getClassName ( ) ; if ( className . equals ( arg0 ) | | className . equals ( SUPER ) ) { selfIndex = i ; break ; } } int found = - 1 ; for ( int i = selfIndex + 1 ; i < steArray . length ; i + + ) { final String className = steArray [ i ] . getClassName ( ) ; if ( ! ( className . equals ( arg0 ) | | className . equals ( SUPER ) ) ) { found = i ; break ; } } if ( found ! = - 1 ) { StackTraceElement ste = steArray [ found ] ;
@Test public void function ( ) { Document docA = Jsoup . parse ( " <div/>One " ) ; Document docB = Jsoup . parse ( " <div/>One " ) ; Document docC = Jsoup . parse ( " <div/>Two " ) ; assertNotEquals ( docA , docB ) ; assertEquals ( docA , docA ) ; assertEquals ( docA . hashCode ( ) , docA . hashCode ( ) ) ; assertNotEquals ( docA . hashCode ( ) , docC . hashCode ( ) ) ; }
public void function ( ) throws IOException { String shutdownMocoKey = " _SHUTDOWN_MOCO_KEY " ; int shutdownPort = 9527 ; RunnerFactory factory = new RunnerFactory ( shutdownPort , shutdownMocoKey ) ; runner = factory . createRunner ( new StartArgs ( port ( ) , shutdownPort , " src/test/resources/foo.json " , null ) ) ; runner . run ( ) ; try { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; } catch ( HttpHostConnectException e ) { fail ( e . getMessage ( ) ) ; } runner . stop ( ) ; shutdownMoco ( shutdownPort , shutdownMocoKey ) ; }
void function ( ) { pendingTableCharacters = new ArrayList < String > ( ) ; }
private void function ( ByteBuffer arg0 ) throws InterruptedException { if ( DEBUG ) System . out . println ( " write( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) ) ) + " } " ) ; synchronized ( bufferQueueTotalAmount ) { bufferQueueTotalAmount + = arg0 . remaining ( ) ; } if ( ! bufferQueue . offer ( arg0 ) ) { try { flush ( ) ; } catch ( IOException e ) { wsl . onWebsocketError ( this , e ) ; closeConnection ( CloseFrame . ABNROMAL_CLOSE , true ) ; return ; } bufferQueue . put ( arg0 ) ; } wsl . onWriteDemand ( this ) ; }
public void function ( ) { startArgsParser . parse ( new String [ ] { " start " , " -p " , " 12306 " } ) ; }
public void function ( ) throws Exception { testHandshakeRejection ( 3 ) ; }
public void function ( String arg0 , Throwable arg1 ) { if ( ! logger . isTraceEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( null , fqcn , LocationAwareLogger . TRACE_INT , arg0 , null , arg1 ) ;
public void function ( ) { parse ( ServerType . HTTP , " start " , " -p " , " 12306 " , " -c " , " foo.json " , " -e " , " foo " ) ; }
private boolean function ( final arg0 . arg1 . arg2 . HttpResponse arg3 ) { int statusCode = arg3 . getStatusLine ( ) . getStatusCode ( ) ; return statusCode = = HttpResponseStatus . BAD_REQUEST . code ( ) ; }
public void function ( ) { logger . error ( marker , message , param1 , param2 ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . ERROR , marker , twoParams , null ) ; }
public void function ( byte [ ] arg0 , int arg1 ) throws NotSupportedException { packFrame ( arg0 , arg1 ) ; }
public boolean function ( Element arg0 , Element arg1 ) { final Element parent = arg1 . parent ( ) ; if ( arg0 = = arg1 | | parent = = null ) return false ; final int size = arg1 . elementSiblingIndex ( ) ; for ( int i = 0 ; i < size ; i + + ) { final Element el = parent . child ( i ) ; Boolean matches = memo . get ( el ) ; if ( matches = = null ) { matches = evaluator . matches ( arg0 , el ) ; memo . put ( el , matches ) ; } if ( matches ) return true ; } return false ; }
void function ( ) { if ( pendingAttributeName ! = null ) {
public void function ( final int arg0 , final ChannelHandler arg1 ) { EventLoopGroup group = new NioEventLoopGroup ( ) ; Bootstrap bootstrap = new Bootstrap ( ) ; bootstrap . group ( group ) . channel ( NioSocketChannel . class ) . remoteAddress ( " 127.0.0.1 " , arg0 ) . option ( ChannelOption . TCP_NODELAY , true ) . handler ( arg1 ) ; try { Channel channel = bootstrap . connect ( ) . sync ( ) . channel ( ) ;
public void function ( final byte [ ] arg0 ) { this . arg0 . complete ( arg0 ) ; }
public XmlDeclaration function ( ) { String data = getData ( ) ; Document doc = Jsoup . parse ( " < " + data . substring ( 1 , data . length ( ) - 1 ) + " > " , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . childNodeSize ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( " ! " ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ; } return decl ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { server . response ( " foobar " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { String msg0 = " msg0 " ; String msg1 = " msg1 {} " ; String msg2 = " msg2 {} {} " ; String msg3 = " msg3 {} {} {} " ; Object [ ] args = null ; result = MessageFormatter . arrayFormat ( msg0 , args ) . getMessage ( ) ; assertEquals ( msg0 , result ) ; result = MessageFormatter . arrayFormat ( msg1 , args ) . getMessage ( ) ; assertEquals ( msg1 , result ) ; result = MessageFormatter . arrayFormat ( msg2 , args ) . getMessage ( ) ; assertEquals ( msg2 , result ) ; result = MessageFormatter . arrayFormat ( msg3 , args ) . getMessage ( ) ; assertEquals ( msg3 , result ) ; }
public void function ( Marker arg0 , String arg1 ) { delegate ( ) . warn ( arg0 , arg1 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <body><p><select><option>One<option>Two</p><p>Three</p> " ) ; Elements options = doc . select ( " option " ) ; assertEquals ( 2 , options . size ( ) ) ; assertEquals ( " One " , options . first ( ) . text ( ) ) ; assertEquals ( " TwoThree " , options . last ( ) . text ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.23.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private Plain function ( arg0 . arg1 . arg2 . HttpResponse arg3 ) throws IOException { assertThat ( arg3 . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; HttpEntity entity = arg3 . getEntity ( ) ; MediaType mediaType = MediaType . parse ( entity . getContentType ( ) . getValue ( ) ) ; assertThat ( mediaType . type ( ) , is ( " application " ) ) ; assertThat ( mediaType . subtype ( ) , is ( " json " ) ) ; return mapper . readValue ( entity . getContent ( ) , Plain . class ) ; }
public Optional < MocoConfig > function ( ) { if ( response . isPresent ( ) ) { return of ( Moco . response ( response . get ( ) . getResponseHandler ( ) ) ) ; } return absent ( ) ; }
public void function ( Node arg0 , int arg1 ) { if ( ! arg0 . nodeName ( ) . equals ( " #text " ) ) { try {
public void function ( ) { try { serverSocket = new ServerSocket ( port ) ;
public void function ( ) { if ( id3v2Tag ! = null ) { id3v2Tag . clearFrameSet ( AbstractID3v2Tag . ID_COPYRIGHT ) ;
public ShutdownRunner function ( final StartArgs arg0 ) { Runner dynamicRunner = createDynamicRunner ( arg0 ) ; ShutdownMocoRunnerWatcher watcher = factory . createShutdownWatcher ( dynamicRunner , arg0 . getShutdownPort ( ) , shutdownKey ) ; return new ShutdownRunner ( dynamicRunner , watcher ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.2.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 250 ) ;
public void function ( ) throws IOException { LoggerFinder finder = System . LoggerFinder . getLoggerFinder ( ) ; Logger systemLogger = finder . getLogger ( " smoke " , null ) ; systemLogger . log ( Level . INFO , " hello " ) ; systemLogger . log ( Level . INFO , " hello %s " , " world " ) ; List < String > results = SPS . stringList ; assertEquals ( 2 , results . size ( ) ) ; assertEquals ( " INFO smoke - hello " , results . get ( 0 ) ) ; assertEquals ( " INFO smoke - hello world " , results . get ( 1 ) ) ; }
public void function ( ) throws Exception { ID3v2PopmFrameData iD3v2PopmFrameData = new ID3v2PopmFrameData ( false , 0 ) ; assertFalse ( iD3v2PopmFrameData . equals ( " a String " ) ) ; }
public List < Framedata > function ( String arg0 , boolean arg1 ) { FrameBuilder curframe = new FramedataImpl1 ( ) ; byte [ ] pay = Charsetfunctions . utf8Bytes ( arg0 ) ; try { curframe . setPayload ( pay ) ; } catch ( InvalidDataException e ) { throw new NotSendableException ( e ) ; } curframe . setFin ( true ) ; curframe . setOptcode ( Opcode . TEXT ) ; curframe . setTransferemasked ( arg1 ) ; return Collections . singletonList ( ( Framedata ) curframe ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 70 ) ; }
public static HttpServer function ( final int arg0 , final MocoConfig . . . arg1 ) { return httpServer ( arg0 , arg1 ) ; }
@Test void function ( ) { String html = " <title>Test</title></head><div id=1>D1</div><div id=2>D2<p id=3><span>P One</p><p id=4>P Two</p></div><div id=5>D3<p id=6>P three</p> " ; StreamParser parser = new StreamParser ( Parser . htmlParser ( ) ) . parse ( html , " " ) ; StringBuilder seen = new StringBuilder ( ) ; Iterator < Element > it = parser . iterator ( ) ; while ( it . hasNext ( ) ) { trackSeen ( it . next ( ) , seen ) ; } assertEquals ( " title[Test];head+;div#1[D1]+;span[P One];p#3+;p#4[P Two];div#2[D2]+;p#6[P three];div#5[D3];body;html;#root; " , seen . toString ( ) ) ;
private Function < Map . Entry < String , String > , RequestMatcher > function ( final Method arg0 ) { return new Function < Map . Entry < String , String > , RequestMatcher > ( ) { @Override
public void function ( String arg0 , Throwable arg1 ) { logger . log ( Level . WARNING , arg0 . toString ( ) , arg1 ) ; }
public void function ( ) throws IOException { new FileWrapper ( MALFORMED_FILENAME ) ; }
public double function ( long arg0 ) { long start = System . nanoTime ( ) ; for ( int i = 0 ; i < arg0 ; i + + ) { final FormattingTuple tp = MessageFormatter . format ( " This is some rather short message {}  " , i1 ) ; tp . getMessage ( ) ; tp . getArgArray ( ) ; tp . getThrowable ( ) ; MessageFormatter . format ( " This is some rather short message {}  " , i1 ) ; } long end = System . nanoTime ( ) ; return ( end - start ) / ( 1000 * 1000.0 ) ; }
public Range . AttributeRange function ( String arg0 ) { if ( ! hasKey ( arg0 ) ) return UntrackedAttr ; Map < String , Range . AttributeRange > ranges = getRanges ( ) ; if ( ranges = = null ) return Range . AttributeRange . UntrackedAttr ; Range . AttributeRange range = ranges . get ( arg0 ) ; return range ! = null ? range : Range . AttributeRange . UntrackedAttr ; }
public void function ( Object . . . arg0 ) { getNonNullArguments ( ) . addAll ( Arrays . asList ( arg0 ) ) ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws ServletException , IOException { arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; String doc = " <p>Hello, World! " ; arg1 . getWriter ( ) . write ( doc ) ; }
@Test public void function ( ) throws IOException { Connection con = Jsoup . connect ( FileServlet . urlTo ( " /bomtests/bom_utf8.html " ) ) ; Document doc = con . execute ( ) . streamParser ( ) . complete ( ) ; assertEquals ( " UTF-8 " , con . response ( ) . charset ( ) ) ; assertEquals ( " OK " , doc . title ( ) ) ; }
@Test public void function ( ) { Parser parser = Parser . xmlParser ( ) . settings ( ParseSettings . htmlDefault ) ; Document document = Jsoup . parse ( " <div>test</DIV><p></p> " , " " , parser ) ; assertEquals ( " <div>test</div><p></p> " , document . html ( ) ) ;
protected boolean function ( WebSocket arg0 ) { boolean removed = false ; synchronized ( connections ) { if ( this . connections . contains ( arg0 ) ) { removed = this . connections . remove ( arg0 ) ; } else { log . trace ( " Removing connection which is not in the connections collection! Possible no handshake received! {} " , arg0 ) ; } } if ( isclosed . get ( ) & & connections . isEmpty ( ) ) { selectorthread . interrupt ( ) ; } return removed ; }
public void function ( ) { MocoHttpServer server = new MocoHttpServer ( new HttpServer ( 8080 ) ) ; server . start ( ) ; server . stop ( ) ; server . stop ( ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( group ( " foo " ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-record " ) ) ) . response ( record ( group ( " bar " ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( group ( " foo " ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-replay " ) ) ) . response ( replay ( group ( " bar " ) , identifier ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /foo-record?type=blah " ) , " foo " ) ;
public static Document function ( File arg0 , arg1 String arg2 , String arg3 ) throws IOException { return load ( arg0 . toPath ( ) , arg2 , arg3 ) ; }
private ResponseHandler function ( ProxyContainer arg0 ) { if ( arg0 . getFailover ( ) ! = null ) { return arg0 ( arg0 . getUrl ( ) , failover ( arg0 . getFailover ( ) ) ) ; } return arg0 ( arg0 . getUrl ( ) ) ; }
private static Options function ( ) { Options options = new Options ( ) ; Option option = shutdownPortOption ( ) ; option . setRequired ( true ) ; options . addOption ( option ) ; return options ; }
protected RequestMatcher function ( Resource arg0 , ContentRequestExtractor arg1 ) { return null ; }
protected Map < String , String > function ( Map < String , String > arg0 ) { if ( arg0 = = null ) { return null ; } return new HashMap < String , String > ( arg0 ) ; }
public void function ( WindowEvent arg0 ) { if ( cc ! = null ) { cc . close ( ) ; } dispose ( ) ; }
protected String function ( ) { return NamespaceHtml ; }
public void function ( ) throws UnsupportedEncodingException { String original = " 1234567890QWERTYUIOP " ; byte [ ] buffer = BufferTools . stringToByteBuffer ( original , 2 , original . length ( ) - 5 ) ; String converted = BufferTools . byteBufferToString ( buffer , 0 , buffer . length ) ; assertEquals ( " 34567890QWERTYU " , converted ) ; }
public void function ( ByteBuffer arg0 ) { assert ( arg0 . hasRemaining ( ) ) ; if ( flushandclosestate ) { return ; } if ( DEBUG ) System . out . println ( " process( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) , arg0 . position ( ) , arg0 . remaining ( ) ) ) + " } " ) ; if ( readystate = = READYSTATE . OPEN ) { decodeFrames ( arg0 ) ; } else { if ( decodeHandshake ( arg0 ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) ! = arg0 . hasRemaining ( ) | | ! arg0 . hasRemaining ( ) ) ; if ( arg0 . hasRemaining ( ) ) { decodeFrames ( arg0 ) ; } else if ( tmpHandshakeBytes . hasRemaining ( ) ) { decodeFrames ( tmpHandshakeBytes ) ; } } } assert ( isClosing ( ) | | isFlushAndClose ( ) | | ! arg0 . hasRemaining ( ) ) ; }
private String function ( String arg0 ) { return Jsoup . parse ( arg0 , " " , Parser . xmlParser ( ) ) . childNode ( 0 ) . outerHtml ( ) ; }
@Test public void function ( ) { String h = " <a href=1>#</a><base href='/2/'><a href='3'>#</a><base href='http://bar'><a href=/4>#</a> " ; Document doc = Jsoup . parse ( h , " http://foo/ " ) ; assertEquals ( " http://foo/2/ " , doc . baseUri ( ) ) ; Elements anchors = doc . getElementsByTag ( " a " ) ; assertEquals ( 3 , anchors . size ( ) ) ; assertEquals ( " http://foo/2/ " , anchors . get ( 0 ) . baseUri ( ) ) ; assertEquals ( " http://foo/2/ " , anchors . get ( 1 ) . baseUri ( ) ) ; assertEquals ( " http://foo/2/ " , anchors . get ( 2 ) . baseUri ( ) ) ; assertEquals ( " http://foo/2/1 " , anchors . get ( 0 ) . absUrl ( " href " ) ) ; assertEquals ( " http://foo/2/3 " , anchors . get ( 1 ) . absUrl ( " href " ) ) ; assertEquals ( " http://foo/4 " , anchors . get ( 2 ) . absUrl ( " href " ) ) ; }
public void function ( ) { byte b = - 0x36 ; assertEquals ( - 0x36 , BufferTools . setBit ( b , 7 , true ) ) ; assertEquals ( - 0x35 , BufferTools . setBit ( b , 0 , true ) ) ; assertEquals ( - 0x26 , BufferTools . setBit ( b , 4 , true ) ) ; assertEquals ( - 0x36 , BufferTools . setBit ( b , 0 , false ) ) ; assertEquals ( 0x4A , BufferTools . setBit ( b , 7 , false ) ) ; assertEquals ( - 0x3E , BufferTools . setBit ( b , 3 , false ) ) ; }
public Builder function ( final Integer arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) throws Exception { ID3v2PopmFrameData iD3v2PopmFrameData1 = new ID3v2PopmFrameData ( false , 0 ) ; ID3v2PopmFrameData iD3v2PopmFrameData2 = new ID3v2PopmFrameData ( false , 1 ) ; assertFalse ( iD3v2PopmFrameData1 . hashCode ( ) = = iD3v2PopmFrameData2 . hashCode ( ) ) ; }
private void function ( HttpRequest arg0 , MutableHttpResponse arg1 ) { String content = responseContent ( arg0 ) ; arg1 . setContent ( content ) ; arg1 . addHeader ( HttpHeaders . CONTENT_LENGTH , content . getBytes ( ) . length ) ; if ( ! detector . hasContentType ( arg1 ) ) { arg1 . addHeader ( HttpHeaders . CONTENT_TYPE , getContentType ( arg0 ) ) ;
public void function ( ) { final ID3v22Tag id3tag = new ID3v22Tag ( ) ; inputBytes [ ID3v22Tag . FLAGS_OFFSET ] = BufferTools . setBit ( ZERO , ID3v22Tag . UNSYNCHRONISATION_BIT , true ) ; id3tag . unpackFlags ( inputBytes ) ; id3tag . packFlags ( outputBytes , 0 ) ; assertTrue ( BufferTools . checkBit ( outputBytes [ ID3v22Tag . FLAGS_OFFSET ] , ID3v22Tag . UNSYNCHRONISATION_BIT ) ) ; }
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { if ( " json " . equalsIgnoreCase ( arg1 . id ( ) ) ) { return new JsonRequestMatcher ( arg1 , ( ContentRequestExtractor ) arg0 , JsonRequestMatcher . JsonMatchMode . STRUCT ) ; } return new EqRequestMatcher < > ( arg0 , arg1 ) ; }
public static ProxySettings function ( ) { synchronized ( Jetty ) { if ( ! Jetty . isStarted ( ) )
public static MocoEventAction function ( final Resource arg0 , final Object arg1 ) { return post ( checkNotNull ( arg0 , " URL should not be null " ) , Jsons . toJson ( checkNotNull ( arg1 , " Content should not be null " ) ) ) ;
public void function ( HttpProtocolVersion arg0 , JsonGenerator arg1 , SerializerProvider arg2 ) throws IOException { arg1 . writeString ( arg0 . text ( ) ) ; }
public void function ( final int arg0 , ChannelPipelineFactory arg1 ) { ChannelFactory factory = new NioServerSocketChannelFactory ( Executors . newCachedThreadPool ( ) , Executors . newCachedThreadPool ( ) ) ; bootstrap = new ServerBootstrap ( factory ) ; bootstrap . setPipelineFactory ( arg1 ) ; bootstrap . setOption ( " child.tcpNoDelay " , true ) ; bootstrap . setOption ( " child.keepAlive " , true ) ; allChannels = new DefaultChannelGroup ( ) ; allChannels . add ( bootstrap . bind ( new InetSocketAddress ( arg0 ) ) ) ; }
public static Response function ( HttpResponse arg0 ) { Response dumpedResponse = new Response ( ) ; dumpedResponse . setStatusCode ( arg0 . getStatus ( ) . code ( ) ) ; dumpedResponse . setVersion ( arg0 . getProtocolVersion ( ) . text ( ) ) ; for ( Map . Entry < String , String > entry : arg0 . headers ( ) ) { dumpedResponse . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } setContent ( arg0 , dumpedResponse ) ; return dumpedResponse ; }
final Tag function ( String arg0 ) { tagName = arg0 ; normalName = ParseSettings . normalName ( tagName ) ; return this ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <template \ u001E<select<input< " ) ; assertNotNull ( doc ) ; assertEquals ( " <template><select></select><input>&lt;</template> " , TextUtil . stripNewlines ( doc . head ( ) . html ( ) ) ) ;
public final void function ( WebSocket arg0 , Handshakedata arg1 ) { onOpen ( ( ServerHandshake ) arg1 ) ; connectLatch . countDown ( ) ; }
public static Collection < Integer [ ] > function ( ) { List < Integer [ ] > ret = new ArrayList < Integer [ ] > ( NUMBER_OF_TESTS ) ; for ( int i = 0 ; i < NUMBER_OF_TESTS ; i + + ) ret . add ( new Integer [ ] { 25 + i * 25 } ) ; return ret ; }
public @Nullable Element function ( ) { return isEmpty ( ) ? null : get ( size ( ) - 1 ) ; }
protected String function ( Exception arg0 ) { String message = " [ " + arg0 . getClass ( ) . getName ( ) ; if ( arg0 . getMessage ( ) ! = null ) message + = " :  " + arg0 . getMessage ( ) ; message + = " ] " ; return message ; }
private List < SessionSetting > function ( InputStream arg0 ) { try { return mapper . readValue ( arg0 , factory . constructCollectionType ( List . class , SessionSetting . class ) ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 100 ) ;
public void function ( String arg0 ) { loggingEvent . setMessage ( arg0 ) ; innerLog ( loggingEvent ) ; }
public String function ( ) { if ( a = = 0 ) return String . format ( " :%s(%d) " , getPseudoClass ( ) , b ) ; if ( b = = 0 ) return String . format ( " :%s(%dn) " , getPseudoClass ( ) , a ) ; return String . format ( " :%s(%dn%+d) " , getPseudoClass ( ) , a , b ) ; }
protected void function ( byte [ ] arg0 ) { try { url = BufferTools . byteBufferToString ( arg0 , 0 , arg0 . length ) ;
boolean function ( Object arg0 ) { if ( arg0 instanceof Priority ) { Priority r = ( Priority ) arg0 ;
public void function ( String arg0 ) throws InterruptedException { Set < WebSocket > con = connections ( ) ; synchronized ( con ) { for ( WebSocket c : con ) {
@Test public void function ( ) { AttributeParser ap = new AttributeParser ( ) ; Attributes attr = ap . parse ( " id=bar " ) ; assertEquals ( 1 , attr . size ( ) ) ; assertEquals ( " bar " , attr . get ( " id " ) ) ; attr = ap . parse ( " id=qux " ) ; assertEquals ( 1 , attr . size ( ) ) ; assertEquals ( " qux " , attr . get ( " id " ) ) ; }
public void function ( ) throws Exception { server . mount ( MOUNT_DIR , to ( " /dir " ) ) ; running ( server , new Runnable ( ) { @Override
private Element function ( Element arg0 ) { Element parent = popStackToSuitableContainer ( arg0 . getTag ( ) ) ; Tag childTag = arg0 . getTag ( ) ; boolean validAncestor = stackHasValidParent ( childTag ) ; if ( ! validAncestor ) { Tag parentTag = childTag . getImplicitParent ( ) ; StartTag parentStart = new StartTag ( parentTag , baseUri ) ; Element implicit = new Element ( parentStart ) ; if ( arg0 . getTag ( ) . equals ( bodyTag ) ) { Element head = new Element ( new StartTag ( headTag , baseUri ) ) ; implicit . addChild ( head ) ; } implicit . addChild ( arg0 ) ; Element root = addChildToParent ( implicit ) ; stack . addLast ( arg0 ) ; return root ; } parent . addChild ( arg0 ) ; if ( ! childTag . isEmpty ( ) ) stack . addLast ( arg0 ) ; return parent ; }
public TextContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return text ( arg0 ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; return textContainer ( arg0 , arg1 ) ; } return ( TextContainer ) arg1 . handleUnexpectedToken ( TextContainer . class , arg0 ) ; }
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { throw new RuntimeException ( " no failover response found " ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.17.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { AutobahnClient autobahnClient = new AutobahnClient ( this . draft , URI . create ( this . protocol + this . host + this . port + this . query ) ) ; Thread thread = new Thread ( autobahnClient ) ; thread . start ( ) ; }
public void function ( ) { Document document = Document . createShell ( " " ) ; document . outputSettings ( ) . syntax ( Syntax . xml ) ; document . charset ( StandardCharsets . UTF_8 ) ; assertEquals ( " <?xml version= \" 1.0 \"  encoding= \" UTF-8 \" ?> \ n " + " <html> \ n " +
public void function ( ) throws IOException { runWithConfiguration ( " template_with_extractor.json " ) ; String content = helper . postContent ( remoteUrl ( " /extractor_template " ) , " { \" book \" :[{ \" price \" : \" 1 \" }]} " ) ; assertThat ( content , is ( " 1 " ) ) ; }
public void function ( ) throws Exception { final String jsonContent = " { \" foo \" : \" bar \" } " ; server . request ( json ( text ( jsonContent ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { server . request ( contain ( uri ( " foo " ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( LoggingEvent arg0 ) { Object [ ] argArray = arg0 . getArgumentArray ( ) ; int argLen = argArray = = null ? 0 : argArray . length ; Throwable t = arg0 . getThrowable ( ) ; int tLen = t = = null ? 0 : 1 ; Object [ ] combinedArguments = new Object [ argLen + tLen ] ; if ( argArray ! = null ) { System . arraycopy ( argArray , 0 , combinedArguments , 0 , argLen ) ; } if ( t ! = null ) { combinedArguments [ argLen ] = t ; } String mergedMessage = mergeMarkersAndKeyValuePairsAndMessage ( arg0 ) ; switch ( arg0 . getLevel ( ) ) { case TRACE :
public void function ( ) { ImmutableList < String > glob = Globs . glob ( " *.json " ) ; assertThat ( glob . isEmpty ( ) , is ( true ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { debug ( arg1 , arg2 ) ; }
public static void function ( String arg0 ) throws IllegalArgumentException { if ( arg0 = = null ) { throw new IllegalArgumentException ( " key parameter cannot be null " ) ; } if ( mdcAdapter = = null ) { throw new IllegalStateException ( " MDCAdapter cannot be null. See also  " + NULL_MDCA_URL ) ; } mdcAdapter . remove ( arg0 ) ; }
public void function ( ) { Safelist safelist1 = Safelist . none ( ) . addEnforcedAttribute ( TEST_TAG , TEST_ATTRIBUTE , TEST_VALUE ) ; Safelist safelist2 = new Safelist ( safelist1 ) ; safelist1 . addEnforcedAttribute ( TEST_TAG , TEST_ATTRIBUTE , " invalidValue " ) ; for ( Attribute enforcedAttribute : safelist2 . getEnforcedAttributes ( TEST_TAG ) ) { assertNotEquals ( " invalidValue " , enforcedAttribute . getValue ( ) ) ;
private boolean function ( final Request arg0 , final byte [ ] arg1 ) { try { JsonNode requestNode = mapper . readTree ( new String ( arg1 ) ) ;
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { warn ( arg1 , arg2 ) ; }
protected final BaseActualServer function ( ) { return this . serverSetting ; }
public static ResponseHandler function ( final String arg0 , final Resource arg1 , final CookieAttribute . . . arg2 ) { return with ( asHeader ( SET_COOKIE , cookieResource ( checkNotNullOrEmpty ( arg0 , " Cookie key should not be null " ) ,
public void function ( ExtensionContext arg0 ) throws Exception { map = getThreadMap ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { delegate ( ) . info ( arg0 , arg1 , arg2 ) ; }
public Builder function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( SessionContext arg0 ) { this . handler . writeToResponse ( arg0 ) ; this . fireCompleteEvent ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " get_method.json " ) ; assertThat ( helper . get ( remoteUrl ( " /get " ) ) , is ( " response_for_get_method " ) ) ; }
private static String function ( Stream < Node > arg0 ) { return arg0 . map ( node - > { if ( node instanceof TextNode ) return ( ( TextNode ) node ) . getWholeText ( ) ;
private Mp3File function ( String arg0 , int arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { Mp3File mp3File = loadAndCheckTestMp3 ( arg0 , arg1 ) ; assertEquals ( 0x000 , mp3File . getXingOffset ( ) ) ; assertEquals ( 0x1A1 , mp3File . getStartOffset ( ) ) ; assertEquals ( 0xB34 , mp3File . getEndOffset ( ) ) ; assertFalse ( mp3File . hasId3v1Tag ( ) ) ; assertFalse ( mp3File . hasId3v2Tag ( ) ) ; assertFalse ( mp3File . hasCustomTag ( ) ) ; return mp3File ; }
private boolean function ( ) { HandshakeStatus status = sslEngine . getHandshakeStatus ( ) ; return status = = SSLEngineResult . HandshakeStatus . FINISHED | | status = = SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING ; }
public String function ( final Request arg0 ) { HttpRequest httpRequest = ( HttpRequest ) arg0 ; StringBuilder buf = new StringBuilder ( ) ; buf . append ( requestProtocolLine ( httpRequest ) ) . append ( StringUtil . NEWLINE ) . append ( headerJoiner . join ( asSimple ( httpRequest . getHeaders ( ) ) ) ) . append ( asContent ( httpRequest ) ) ; return buf . toString ( ) ; }
public String function ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Element element : this ) { if ( sb . length ( ) ! = 0 ) sb . append ( "   " ) ; sb . append ( element . text ( ) ) ; } return StringUtil . releaseBuilder ( sb ) ; }
public void function ( ) throws Exception { server . response ( " foo " ) ; running ( server , ( ) - > { Request request = Request . get ( root ( ) ) . addHeader ( " Connection " , " close " ) ;
public static String function ( byte [ ] arg0 ) throws CharacterCodingException { return stringAscii ( arg0 , 0 , arg0 . length ) ; }
private List < Plain > function ( HttpResponse arg0 ) throws IOException { HttpEntity entity = checkJsonResponse ( arg0 ) ; return Jsons . toObject ( entity . getContent ( ) , new TypeReference < List < Plain > > ( ) { } ) ;
public static RestSetting function ( final RequestMatcher arg0 , final ResponseHandler . . . arg1 ) { return new PostRestSetting ( of ( arg0 ) , and ( arg1 ) ) ; }
public static ContentResource function ( final String arg0 ) { checkNotNull ( arg0 , " Text should not be null " ) ; return arg0 ( ( ) - > arg0 ) ; }
public static RecorderTape function ( final String arg0 ) { return new RecorderTape ( arg0 ) ; }
static void function ( ) { if ( INITIALIZED ) { return ; } INITIALIZED = true ; init ( ) ; }
public final ResponseHandler function ( final MocoConfig arg0 ) { ResponseHandler handler = super . apply ( arg0 ) ; if ( handler ! = this ) { return handler ; } Resource appliedResource = this . resource . apply ( arg0 ) ; if ( appliedResource ! = this . resource ) { return new ContentHandler ( ( ContentResource ) appliedResource ) ; } return this ; }
public boolean function ( ) { return delegate ( ) . isWarnEnabled ( ) ; }
public void function ( ) throws Exception { server . get ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public String function ( ) { return searchUpForAttribute ( this , baseUriKey ) ; }
public static boolean function ( String arg0 , Whitelist arg1 ) { Document dirty = parseBodyFragment ( arg0 , " " ) ; Cleaner cleaner = new Cleaner ( arg1 ) ; return cleaner . isValid ( dirty ) ; }
public List < String > function ( ) { ArrayList < String > texts = new ArrayList < > ( size ( ) ) ; for ( Element el : this ) { if ( el . hasText ( ) ) texts . add ( el . text ( ) ) ; } return texts ; }
public static MocoEventAction function ( String arg0 , ContentResource arg1 ) { return new MocoRequestAction ( arg0 , " POST " , arg1 ) ; }
protected void function ( ) throws Exception { removeHandlers ( Logger . getLogger ( " TEST " ) ) ; super . tearDown ( ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { warn ( arg1 , arg2 ) ; }
public void function ( HandshakeBuilder arg0 ) throws IOException , InvalidHandshakeException { if ( handshakeComplete ) throw new IllegalStateException ( " Handshake has allready been sent. " ) ; this . handshakerequest = arg0 ; channelWrite ( draft . createHandshake ( draft . postProcessHandshakeRequestAsClient ( arg0 ) , role ) ) ; }
public static ResponseHandler function ( final ResponseElement arg0 , final ResponseElement . . . arg1 ) { return AndResponseHandler . and ( checkNotNull ( arg0 , " Handlers should not be null " ) ,
private JsonRunner function ( final String [ ] arg0 ) throws IOException { ImmutableList . Builder < InputStream > builder = ImmutableList . builder ( ) ; for ( String resourceName : arg0 ) { builder . add ( Resources . getResource ( resourceName ) . openStream ( ) ) ; } return newJsonRunnerWithStreams ( builder . build ( ) , httpArgs ( ) . withPort ( port ( ) ) . build ( ) ) ; }
public boolean function ( ) { return RECORD_ALL_EVENTS ; }
@Override public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null | | getClass ( ) ! = arg0 . getClass ( ) ) return false ; AttributeRange that = ( AttributeRange ) arg0 ; if ( ! nameRange . equals ( that . nameRange ) ) return false ; return valueRange . equals ( that . valueRange ) ; }
public static < T , U > Function < T , List < U > > function ( ) { return ( Function < T , List < U > > ) ListFunction ; }
public String function ( ) { return " Framedata{ opcode: " + getOpcode ( ) + " , fin: " + isFin ( ) + " , rsv1: " + isRSV1 ( ) + " , rsv2: " + isRSV2 ( ) + " , rsv3: " + isRSV3 ( ) + " , payloadlength:[pos: " + unmaskedpayload . position ( ) + " , len: " + unmaskedpayload . remaining ( ) + " ], payload: " + ( unmaskedpayload . remaining ( ) > 1000 ? " (too big to display) " : new String ( unmaskedpayload . array ( ) ) ) + '}' ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null ) return false ; if ( getClass ( ) ! = arg0 . getClass ( ) ) return false ; ID3v2Frame other = ( ID3v2Frame ) arg0 ; if ( compression ! = other . compression ) return false ; if ( ! Arrays . equals ( data , other . data ) ) return false ; if ( dataLength ! = other . dataLength ) return false ; if ( dataLengthIndicator ! = other . dataLengthIndicator ) return false ; if ( encryption ! = other . encryption ) return false ; if ( group ! = other . group ) return false ; if ( id = = null ) { if ( other . id ! = null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; if ( preserveFile ! = other . preserveFile ) return false ; if ( preserveTag ! = other . preserveTag ) return false ; if ( readOnly ! = other . readOnly ) return false ; if ( unsynchronisation ! = other . unsynchronisation ) return false ; return true ; }
public MessageContent function ( final Request arg0 ) { return MessageContent . content ( ) . withContent ( toJson ( pojo . get ( ) ) ) . build ( ) ; }
public Document function ( InputSource arg0 , XmlRequestMatcher arg1 ) throws SAXException { try { Document document = arg1 . documentBuilder . parse ( arg0 ) ;
public StreamParser function ( String arg0 , String arg1 ) { return parse ( new StringReader ( arg0 ) , arg1 ) ; }
public void function ( ) throws IOException { String response = Request . Delete ( remoteUrl ( " /foo " ) ) . execute ( ) . returnContent ( ) . asString ( ) ; assertThat ( response , is ( " bar " ) ) ; }
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; long x = 5 ; Throwable t = null ; try { @SuppressWarnings ( " unused " ) long y = x / 0 ; } catch ( Exception ex ) { t = ex ; logger . catching ( ex ) ; logger . catching ( XLogger . Level . DEBUG , ex ) ; } verifyWithException ( listAppender . list . get ( 0 ) , " catching " , t ) ; verifyWithLevelAndException ( listAppender . list . get ( 1 ) , XLogger . Level . DEBUG , " catching " , t ) ; }
public void function ( Marker arg0 , String arg1 ) { if ( isErrorEnabled ( arg0 ) ) { handle_0ArgsCall ( Level . ERROR , arg0 , arg1 , null ) ;
private static < E extends Element > int function ( Element arg0 , List < E > arg1 ) { final int size = arg1 . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { if ( arg1 . get ( i ) = = arg0 ) return i ; } return 0 ; }
@Override public Element function ( ) { maybeFindNext ( ) ; if ( next = = null ) throw new NoSuchElementException ( ) ; current = next ; next = null ; return current ; }
public void function ( ) throws IOException { File in = getFile ( " /htmltests/nyt-article-1.html.gz " ) ; Document doc = Jsoup . parse ( in , null , " http://www.nytimes.com/2010/07/26/business/global/26bp.html?hp " ) ; Element headline = doc . select ( " nyt_headline[version=1.0] " ) . first ( ) ; assertEquals ( " As BP Lays Out Future, It Will Not Include Hayward " , headline . text ( ) ) ; }
void function ( Connection . KeyVal arg0 ) throws UnsupportedEncodingException { if ( q = = null ) q = StringUtil . borrowBuilder ( ) ; else q . append ( '&' ) ; q . append ( URLEncoder . encode ( arg0 . key ( ) , UTF_8 . name ( ) ) )
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 3.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { ID3v2PopmFrameData iD3v2PopmFrameData1 = new ID3v2PopmFrameData ( false , 0 ) ; ID3v2PopmFrameData iD3v2PopmFrameData2 = new ID3v2PopmFrameData ( false , 0 ) ; assertEquals ( iD3v2PopmFrameData1 , iD3v2PopmFrameData2 ) ; }
Tag function ( ) { super . reset ( ) ; attributes = null ; return this ; }
public void function ( ) throws IOException { runWithConfiguration ( " cookie.json " ) ; Cookie decodeCookie = getCookie ( " /cookie-with-domain " ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; assertThat ( decodeCookie . domain ( ) , is ( " github.com " ) ) ; }
protected void function ( SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; if ( serverSetting . isSecure ( ) ) { pipeline . addFirst ( " ssl " , sslHandler ( ) . get ( ) ) ; } pipeline . addLast ( " codec " , new HttpServerCodec ( ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( 1048576 ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
public boolean function ( String arg0 ) { return arg0 . endsWith ( new String ( expected . readFor ( null ) ) ) ; }
private Iterable < RestSetting > function ( final List < RestSubResourceSetting > arg0 ) { if ( arg0 = = null | | arg0 . isEmpty ( ) ) { return ImmutableList . of ( ) ; } return from ( arg0 ) . transform ( toSubResourceSetting ( ) ) ; }
protected ChannelInitializer < SocketChannel > function ( ) { return new ChannelInitializer < SocketChannel > ( ) { @Override
Watcher function ( final FileRunner arg0 , final File . . . arg1 ) ; }
public void function ( ) throws IOException { runWithConiguration ( " foo.json " ) ; assertThat ( helper . postContent ( " http://localhost:8080 " , " text_request " ) , is ( " response_for_text_request " ) ) ; }
public void function ( ) throws Exception { String imageFilename = " src/test/resources/SomeArtist-SomeAlbum.png " ; tryAddImage ( TEST_FILE_WITH_IMAGE , imageFilename ) ; }
void function ( Element arg0 ) { this . checkActiveFormattingElements ( arg0 ) ; formattingElements . add ( arg0 ) ; }
public static ResponseHandler function ( final String arg0 , Failover arg1 ) { return new ProxyResponseHandler ( toUrl ( checkNotNull ( arg0 , " Null URL is not allowed " ) ) , checkNotNull ( arg1 , " Null failover is not allowed " ) ) ; }
public void function ( Object arg0 ) { logger . log ( null , FQCN , LocationAwareLogger . INFO_INT , String . valueOf ( arg0 ) , null , null ) ; }
public void function ( final Channel arg0 ) { if ( open ! = null ) { MessageContent messageContent = this . open . readFor ( null ) ;
public ResponseSetting function ( final MocoProcedure arg0 ) { this . response ( with ( checkNotNull ( arg0 , " Procedure should not be null " ) ) ) ; return this ; }
private static String function ( String arg0 , Document arg1 ) { return arg1 . selectFirst ( " th:contains( " + arg0 + " ) + td " ) . text ( ) ; }
@Test public void function ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( " <head><base href='https://jsoup.org/'> " ) ; for ( int i = 0 ; i < 100000 ; i + + ) { sb . append ( " <div> " ) ; } sb . append ( " <p>Hello <a href='/example.html'>there</a> " ) ; Document doc = Jsoup . parse ( sb . toString ( ) ) ; String expectedLink = " https://jsoup.org/example.html " ; assertEquals ( expectedLink , doc . selectFirst ( " a " ) . attr ( " abs:href " ) ) ; Document clone = doc . clone ( ) ; doc . hasSameValue ( clone ) ; assertEquals ( expectedLink , clone . selectFirst ( " a " ) . attr ( " abs:href " ) ) ; }
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( toJson ( ImmutableList . of ( resource1 , resource2 ) ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( Object arg0 , Throwable arg1 ) { logger . log ( null , FQCN , LocationAwareLogger . DEBUG_INT , String . valueOf ( arg0 ) , arg1 ) ;
public static RecorderIdentifier function ( final String arg0 ) { return new RecorderIdentifier ( template ( checkNotNullOrEmpty ( arg0 , " Identifier should not be empty " ) ) ) ; }
public boolean function ( Map . Entry < String , String > arg0 ) { return key . equalsIgnoreCase ( arg0 . getKey ( ) ) ; }
public void function ( ) { helper = new MocoTestHelper ( ) ; server = httpserver ( port ( ) , fileRoot ( " src/test/resources " ) ) ; }
final static public void function ( StringBuilder arg0 , String arg1 , int arg2 ) { int actualLen = 0 ; if ( arg1 ! = null ) { actualLen = arg1 . length ( ) ; } if ( actualLen < arg2 ) { spacePad ( arg0 , arg2 - actualLen ) ; } if ( arg1 ! = null ) { arg0 . append ( arg1 ) ;
public void function ( ) throws IOException { assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " proxy " ) ) ; assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " proxy " ) ) ; }
public void function ( ) throws Exception { byte [ ] bytes = createTestPictureFrameDataRequiringSynchronisation ( ) ; ID3v2PictureFrameData frameData = new ID3v2PictureFrameData ( true , bytes ) ; int headerLength = 4 ; assertEquals ( TEST_IMAGE_DATA_LENGTH - headerLength - 3 , frameData . getImageData ( ) . length ) ; }
public void function ( ) { ID3v2ChapterTOCFrameData frameData1 = new ID3v2ChapterTOCFrameData ( false , true , false , " toc1 " , new String [ ] { " ch1 " , " ch2 " } ) ; ID3v2ChapterTOCFrameData frameData2 = new ID3v2ChapterTOCFrameData ( false , true , false , " toc` " , new String [ ] { " ch3 " , " ch2 " } ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
private HttpRequestBase function ( final HttpRequest arg0 , final URL arg1 ) { FullHttpRequest httpRequest = ( ( DefaultHttpRequest ) arg0 ) . toFullHttpRequest ( ) ; return prepareRemoteRequest ( httpRequest , arg1 ) ; }
public void function ( Object arg0 ) { innerLog ( null , CATEGORY_FQCN , LocationAwareLogger . WARN_INT , arg0 , null ) ; }
public void function ( ) throws IOException , NoSuchTagException , UnsupportedTagException , InvalidDataException { byte [ ] buffer = loadFile ( " test-res/v1andv24tags.mp3 " ) ; ID3v2 id3v2tag = ID3v2TagFactory . createTag ( buffer ) ; assertEquals ( " 4.0 " , id3v2tag . getVersion ( ) ) ; assertEquals ( 0x44B , id3v2tag . getLength ( ) ) ; }
public void function ( ) { byte b = - 0x36 ; assertFalse ( BufferTools . checkBit ( b , 0 ) ) ; assertTrue ( BufferTools . checkBit ( b , 1 ) ) ; assertFalse ( BufferTools . checkBit ( b , 2 ) ) ; assertTrue ( BufferTools . checkBit ( b , 3 ) ) ; assertFalse ( BufferTools . checkBit ( b , 4 ) ) ; assertFalse ( BufferTools . checkBit ( b , 5 ) ) ; assertTrue ( BufferTools . checkBit ( b , 6 ) ) ; assertTrue ( BufferTools . checkBit ( b , 7 ) ) ; }
public ByteBuffer function ( Framedata arg0 ) { if ( arg0 . getOpcode ( ) ! = Opcode . TEXT ) { throw new RuntimeException ( " only text frames supported " ) ; } ByteBuffer pay = arg0 . getPayloadData ( ) ; ByteBuffer b = ByteBuffer . allocate ( pay . remaining ( ) + 2 ) ; b . put ( START_OF_FRAME ) ; pay . mark ( ) ; b . put ( pay ) ; pay . reset ( ) ; b . put ( END_OF_FRAME ) ; b . flip ( ) ; return b ; }
public void function ( ) throws Exception { Draft_6455 draft_6455 = new Draft_6455 ( Collections . < IExtension > singletonList ( new TestExtension ( ) ) , 100 ) ; draft_6455 . acceptHandshakeAsServer ( handshakedataProtocolExtension ) ; List < IExtension > extensionList = new ArrayList < IExtension > ( draft_6455 . getKnownExtensions ( ) ) ; List < IProtocol > protocolList = new ArrayList < IProtocol > ( draft_6455 . getKnownProtocols ( ) ) ; draft_6455 . reset ( ) ; assertEquals ( new DefaultExtension ( ) , draft_6455 . getExtension ( ) ) ; assertNull ( draft_6455 . getProtocol ( ) ) ; assertEquals ( extensionList , draft_6455 . getKnownExtensions ( ) ) ; assertEquals ( protocolList , draft_6455 . getKnownProtocols ( ) ) ; }
public T function ( final InputStream arg0 , final Optional < Integer > arg1 , final MocoConfig . . . arg2 ) { return createServer ( reader . read ( arg0 , SessionSetting . class ) , arg1 , arg2 ) ; }
@Test public void function ( ) { String styleContents = " foo < bar > qux {color:white;} " ; String html = " <head><style> " + styleContents + " </style></head> " ; Document doc = Jsoup . parse ( html ) ; Element head = doc . head ( ) ; Element style = head . selectFirst ( " style " ) ; assertNotNull ( style ) ; assertEquals ( styleContents , style . html ( ) ) ; style . html ( styleContents ) ; assertEquals ( styleContents , style . html ( ) ) ; assertEquals ( " " , style . text ( ) ) ; style . text ( styleContents ) ; assertEquals ( " " , style . text ( ) ) ; assertEquals ( styleContents , style . html ( ) ) ; }
public void function ( Level arg0 , ResourceBundle arg1 , String arg2 , Object . . . arg3 ) { switch ( arg0 ) { case ALL :
public int function ( int arg0 , int arg1 ) { return super . extractField ( arg0 , arg1 ) ; }
public void function ( ) { String h = " <ol><li id=1>One<li id=2>Two<li id=3>Three</ol> " ; Document doc = Jsoup . parse ( h ) ; Elements sibs = SelectMatch . match ( doc , new ElementSelector ( " li " , null , " 2 " ) , new PrevSiblingSelector ( new ElementSelector ( " li " , null , " 1 " ) ) ) ; assertEquals ( 1 , sibs . size ( ) ) ; assertEquals ( " Two " , sibs . get ( 0 ) . text ( ) ) ; }
private void function ( Throwable arg0 , int arg1 ) { LogRecord logRecord = listHandler . recordList . get ( arg1 ) ; Assert . assertNotNull ( logRecord ) ; assertEquals ( arg0 , logRecord . getThrown ( ) ) ; }
private void function ( ) throws IOException { try { engine . closeInbound ( ) ; } catch ( Exception e ) { log . error ( " This engine was forced to close inbound, without having received the proper SSL/TLS close notification message from the peer, due to end of stream. " ) ; } closeConnection ( ) ; }
public HttpResponseSetting function ( final ResponseHandler . . . arg0 ) { this . response ( new AndResponseHandler ( copyOf ( arg0 ) ) ) ; return this ; }
public void function ( ) throws Exception { server . request ( and ( by ( uri ( " /target " ) ) , by ( version ( VERSION_1_0 ) ) ) ) . response ( " 1.0 " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( version ( VERSION_1_1 ) ) ) ) . response ( " 1.1 " ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) ) ) ; running ( server , new Runnable ( ) { @Override
protected void function ( final SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; pipeline . addLast ( " aggregator " , new MocoAggregator ( ) ) ; pipeline . addLast ( " handler " , new MocoSocketHandler ( serverSetting ) ) ; }
public static ContentResource function ( final Resource arg0 ) { return jsonResource ( checkNotNull ( arg0 , " Json should not be null " ) ) ; }
private void function ( int arg0 , String arg1 , Object . . . arg2 ) { if ( isLoggable ( arg0 ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg1 , arg2 ) ;
public void function ( ) throws IOException { Connection session = Jsoup . newSession ( ) . parser ( Parser . xmlParser ( ) ) ; String xmlUrl = FileServlet . urlTo ( " /htmltests/xml-test.xml " ) ; String xmlVal = " <doc><val>One<val>Two</val>Three</val></doc> \ n " ; Document doc1 = session . newRequest ( ) . url ( xmlUrl ) . get ( ) ; assertEquals ( xmlVal , doc1 . html ( ) ) ; Document doc2 = session . newRequest ( ) . parser ( Parser . htmlParser ( ) ) . url ( xmlUrl ) . get ( ) ; assertTrue ( doc2 . html ( ) . startsWith ( " <html> " ) ) ; Document doc3 = session . newRequest ( ) . url ( xmlUrl ) . get ( ) ; assertEquals ( xmlVal , doc3 . html ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ) ; }
public void function ( ) { Logger log = LoggerFactory . getLogger ( NopBundleTest . class ) ; assertNotNull ( log ) ; BundleContext context = getBundleContext ( ) ; List symNames = new ArrayList ( ) ; Bundle [ ] bundles = context . getBundles ( ) ; log . info ( " Loaded bundles: " ) ; for ( int i = 0 ; i < bundles . length ; i + + ) { Bundle bundle = bundles [ i ] ; assertEquals ( " Bundle  " + bundle . getSymbolicName ( ) + "  is not active. " , Bundle . ACTIVE , bundle . getState ( ) ) ; symNames . add ( bundle . getSymbolicName ( ) ) ; if ( bundle . getHeaders ( ) . get ( Constants . BUNDLE_ACTIVATOR ) ! = null ) { log . info ( " Symbolic Name: " + bundle . getSymbolicName ( ) + " , Activator: " + bundle . getHeaders ( ) . get ( Constants . BUNDLE_ACTIVATOR ) ) ; } else { log . info ( " Symbolic Name: " + bundle . getSymbolicName ( ) ) ; } } assertTrue ( " Could not find  " + NOP_BINDING_BUNDLE_SYM_NAME , symNames . contains ( NOP_BINDING_BUNDLE_SYM_NAME ) ) ; assertTrue ( symNames . contains ( TEST_BUNDLE_SYM_NAME ) ) ;
public void function ( Object arg0 ) { logger . error ( String . valueOf ( arg0 ) ) ; }
protected Runner function ( ) { return new JsonRunner ( of ( toInputStream ( file ) ) , port ) ; }
public void function ( String arg0 , Throwable arg1 ) { delegate ( ) . error ( arg0 , arg1 ) ; }
public void function ( ) throws IOException { String xmlUrl = " http://direct.infohound.net/tools/jsoup-xml-test.xml " ; Document xmlDoc = Jsoup . connect ( xmlUrl ) . parser ( Parser . xmlParser ( ) ) . get ( ) ; Document htmlDoc = Jsoup . connect ( xmlUrl ) . parser ( Parser . htmlParser ( ) ) . get ( ) ; Document autoXmlDoc = Jsoup . connect ( xmlUrl ) . get ( ) ; assertEquals ( " <doc><val>One<val>Two</val>Three</val></doc> " , TextUtil . stripNewlines ( xmlDoc . html ( ) ) ) ; assertNotEquals ( htmlDoc , xmlDoc ) ; assertEquals ( xmlDoc , autoXmlDoc ) ; assertEquals ( 1 , htmlDoc . select ( " head " ) . size ( ) ) ; assertEquals ( 0 , xmlDoc . select ( " head " ) . size ( ) ) ; assertEquals ( 0 , autoXmlDoc . select ( " head " ) . size ( ) ) ; }
public boolean function ( HttpRequest arg0 ) { try { JsonNode requestNode = mapper . readTree ( extractor . extract ( arg0 ) ) ;
protected void function ( LocationAwareLogger arg0 , LogRecord arg1 ) { int julLevelValue = arg1 . getLevel ( ) . intValue ( ) ; int slf4jLevel ; if ( julLevelValue < = TRACE_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . TRACE_INT ; } else if ( julLevelValue < = DEBUG_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . DEBUG_INT ; } else if ( julLevelValue < = INFO_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . INFO_INT ; } else if ( julLevelValue < = WARN_LEVEL_THRESHOLD ) { slf4jLevel = LocationAwareLogger . WARN_INT ; } else { slf4jLevel = LocationAwareLogger . ERROR_INT ; } String i18nMessage = getMessageI18N ( arg1 ) ; arg0 . log ( null , FQCN , slf4jLevel , i18nMessage , null , arg1 . getThrown ( ) ) ; }
public HttpResponse function ( ) { return new DefaultHttpResponse ( HttpVersion . HTTP_1_1 , status ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.15.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
protected ID3v2Frame function ( byte [ ] arg0 , int arg1 ) throws InvalidDataException { if ( obseleteFormat ) return new ID3v2ObseleteFrame ( arg0 , arg1 ) ; return new ID3v2Frame ( arg0 , arg1 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.4.3 " ) ; assertEquals ( " NON-STRICT " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 2100 ) ; }
public Node function ( ) { Node thisClone = doClone ( null ) ; final LinkedList < Node > nodesToProcess = new LinkedList < > ( ) ; nodesToProcess . add ( thisClone ) ; while ( ! nodesToProcess . isEmpty ( ) ) { Node currParent = nodesToProcess . remove ( ) ; final int size = currParent . childNodeSize ( ) ; for ( int i = 0 ; i < size ; i + + ) { final List < Node > childNodes = currParent . ensureChildNodes ( ) ; Node childClone = childNodes . get ( i ) . doClone ( currParent ) ; childNodes . set ( i , childClone ) ; nodesToProcess . add ( childClone ) ; } } return thisClone ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { formatAndLog ( Log . DEBUG , arg0 , arg1 , arg2 ) ; }
public void function ( ) throws Exception { server . request ( and ( by ( uri ( " /target " ) ) , by ( version ( VERSION_1_0 ) ) ) ) . response ( version ( VERSION_1_0 ) ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( version ( VERSION_1_1 ) ) ) ) . response ( version ( VERSION_1_1 ) ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( version ( VERSION_0_9 ) ) ) ) . response ( version ( VERSION_1_0 ) ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) ) ) ; running ( server , ( ) - > { HttpResponse response10 = helper . execute ( Request . get ( remoteUrl ( " /proxy " ) )
private static void function ( Tokeniser arg0 , CharacterReader arg1 , TokeniserState arg2 , TokeniserState arg3 ) { if ( arg1 . matchesAsciiAlpha ( ) ) { arg0 . createTagPending ( false ) ;
public static Document function ( InputStream arg0 , arg1 String arg2 , String arg3 , Parser arg4 ) throws IOException { return DataUtil . load ( arg0 , arg2 , arg3 , arg4 ) ; }
private List < Plain > function ( HttpResponse arg0 ) throws IOException { HttpEntity entity = checkJsonResponse ( arg0 ) ; return mapper . readValue ( entity . getContent ( ) , new TypeReference < List < Plain > > ( ) { } ) ;
public void function ( ) throws Exception { server . response ( version ( VERSION_1_0 ) ) ; running ( server , ( ) - > { ProtocolVersion version = helper . getResponse ( root ( ) ) . getProtocolVersion ( ) ;
public void function ( ) throws IOException { String response = Request . Delete ( remoteUrl ( " /foo " ) ) . execute ( ) . returnContent ( ) . toString ( ) ; assertThat ( response , is ( " bar " ) ) ; }
public FileContainerBuilder function ( final TextContainer arg0 ) { this . arg0 = arg0 ; return this ; }
static SLF4JServiceProvider function ( ClassLoader arg0 ) { String explicitlySpecified = System . getProperty ( PROVIDER_PROPERTY_KEY ) ; if ( null = = explicitlySpecified | | explicitlySpecified . isEmpty ( ) ) { return null ; } try { String message = String . format ( " Attempting to load provider  \" %s \"  specified via  \" %s \"  system property " , explicitlySpecified , PROVIDER_PROPERTY_KEY ) ;
private static Map < String , Character > function ( String arg0 ) { Properties properties = new Properties ( ) ; Map < String , Character > entities = new HashMap < String , Character > ( ) ; try { InputStream in = Entities . class . getResourceAsStream ( arg0 ) ; properties . load ( in ) ; in . close ( ) ; } catch ( IOException e ) { throw new MissingResourceException ( " Error loading entities resource:  " + e . getMessage ( ) , " Entities " , arg0 ) ; } for ( Map . Entry entry : properties . entrySet ( ) ) { Character val = Character . valueOf ( ( char ) Integer . parseInt ( ( String ) entry . getValue ( ) , 16 ) ) ; String name = ( String ) entry . getKey ( ) ; entities . put ( name , val ) ; } return entities ; }
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeAttributeQuoted ( true ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; else arg0 . tagPending . setEmptyAttributeValue ( ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\'' :
public static void function ( final String arg0 , final HttpResponse arg1 ) { HttpEntity entity = arg1 . getEntity ( ) ; MediaType mediaType = MediaType . parse ( entity . getContentType ( ) . getValue ( ) ) ; assertThat ( mediaType . type ( ) , is ( " application " ) ) ; assertThat ( mediaType . subtype ( ) , is ( " json " ) ) ; try { JSONAssert . assertEquals ( arg0 ,
public final T function ( final HttpHeader arg0 ) { return this . response ( with ( checkNotNull ( arg0 , " Http header should not be null " ) ) ) ; }
public void function ( byte [ ] arg0 , Collection < WebSocket > arg1 ) { if ( arg0 = = null | | arg1 = = null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( arg0 ) , arg1 ) ; }
public boolean function ( ) { return inData . hasRemaining ( ) | | ( inCrypt . hasRemaining ( ) & & engineResult . getStatus ( ) ! = Status . BUFFER_UNDERFLOW ) ; }
public String function ( final String arg0 ) { return join ( context , arg0 ) ; }
public Connection . Response function ( ) { if ( res = = null ) { throw new IllegalArgumentException ( " You must execute the request before getting a response. " ) ; } return res ; }
public void function ( ) { { Abbreviator abb = new Abbreviator ( 0 , 100 , FS ) ;
public static boolean function ( final String arg0 , final String . . . arg1 ) { final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { if ( arg1 [ i ] . equals ( arg0 ) ) return true ; } return false ; }
private ActualSocketServer function ( final int arg0 ) { return createLogServer ( arg0 ) ; }
public final MessageContent function ( final Request arg0 ) { return reader . readFor ( arg0 ) ; }
public static ContentResource function ( final String arg0 ) { return textResource ( checkNotNull ( arg0 , " Null text is not allowed " ) ) ; }
public void function ( Exception arg0 ) { Assert . fail ( arg0 . toString ( ) + "  should not occur " ) ; }
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { handleDataDoubleEscapeTag ( arg0 , arg1 , ScriptDataDoubleEscaped , ScriptDataEscaped ) ; }
public void function ( String arg0 , Object [ ] arg1 ) { formatAndLog ( LOG_LEVEL_WARN , arg0 , arg1 ) ; }
public Optional < String [ ] > function ( FullHttpRequest arg0 ) { return of ( toStringArray ( jsonPath . read ( extractor . extract ( arg0 ) . get ( ) ) ) ) ; }
public HandshakeBuilder function ( HandshakeBuilder arg0 ) { arg0 . put ( " Upgrade " , " WebSocket " ) ; arg0 . put ( " Connection " , " Upgrade " ) ; arg0 . put ( " Sec-WebSocket-Key1 " , this . generateKey ( ) ) ; arg0 . put ( " Sec-WebSocket-Key2 " , this . generateKey ( ) ) ; byte [ ] key3 = new byte [ 8 ] ; ( new Random ( ) ) . nextBytes ( key3 ) ; arg0 . setContent ( key3 ) ; return arg0 ;
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; assertTrue ( deflateExtension . isServerNoContextTakeover ( ) ) ; }
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; assertEquals ( frameData , frameData ) ; }
public String function ( String arg0 ) { Validate . notEmpty ( arg0 ) ; String relUrl = attr ( arg0 ) ; if ( ! hasAttr ( arg0 ) ) { return " " ;
@Test public void function ( ) { String h = " <div><p class=foo><a href='http://evil.com'>Hello <b id=bar>there</b>!</a></div> " ; String cleanHtml = Jsoup . clean ( h , Whitelist . simpleText ( ) ) ; assertEquals ( " Hello <b>there</b>! " , cleanHtml ) ; }
public void function ( Object arg0 , Throwable arg1 ) { lbLogger . error ( FATAL_MARKER , convertToString ( arg0 ) , arg1 ) ; }
public String function ( ) { StringBuilder builder = new StringBuilder ( ) ; builder . append ( " ID3v2ChapterTOCFrameData [isRoot= " ) ; builder . append ( isRoot ) ; builder . append ( " , isOrdered= " ) ; builder . append ( isOrdered ) ; builder . append ( " , id= " ) ; builder . append ( id ) ; builder . append ( " , childs= " ) ; builder . append ( Arrays . toString ( childs ) ) ; builder . append ( " , subframes= " ) ; builder . append ( subframes ) ; builder . append ( " ] " ) ; return builder . toString ( ) ; }
public final void function ( Object arg0 ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_INFO ) ) { log ( SimpleLog . LOG_LEVEL_INFO , arg0 , null ) ;
private URL function ( HttpRequest arg0 ) throws MalformedURLException { QueryStringDecoder decoder = new QueryStringDecoder ( arg0 . getUri ( ) ) ; QueryStringEncoder encoder = new QueryStringEncoder ( this . url . getPath ( ) ) ; for ( Map . Entry < String , List < String > > entry : decoder . parameters ( ) . entrySet ( ) ) { encoder . addParam ( entry . getKey ( ) , entry . getValue ( ) . get ( 0 ) ) ; } return new URL ( this . url . getProtocol ( ) , this . url . getHost ( ) , this . url . getPort ( ) , encoder . toString ( ) ) ; }
public static Resource function ( final HttpProtocolVersion arg0 ) { return resource ( id ( " arg0 " ) , DO_NOTHING_APPLIER , new ResourceReader ( ) { @Override
public void function ( Framedata arg0 ) throws InvalidDataException { if ( arg0 . isRSV1 ( ) | | arg0 . isRSV2 ( ) | | arg0 . isRSV3 ( ) ) { throw new InvalidFrameException ( " bad rsv RSV1:  " + arg0 . isRSV1 ( ) + "  RSV2:  " + arg0 . isRSV2 ( ) + "  RSV3:  " + arg0 . isRSV3 ( ) ) ;
public void function ( final SocketServer arg0 ) { if ( isAnyResponse ( ) ) { arg0 . response ( getResponseHandler ( ) ) ; return ; } arg0 . request ( getRequestMatcher ( ) ) . response ( getResponseHandler ( ) ) ; }
public void function ( ) throws Exception { byte [ ] bytes = BufferTools . stringToByteBuffer ( " xxxxx " + T_FRAME , 0 , 5 + T_FRAME . length ( ) ) ; replaceNumbersWithBytes ( bytes , 8 ) ; ID3v2ObseleteFrame frame = new ID3v2ObseleteFrame ( bytes , 5 ) ; assertEquals ( 40 , frame . getLength ( ) ) ; assertEquals ( " TP1 " , frame . getId ( ) ) ; String s = " 0ARTISTABCDEFGHIJKLMNOPQRSTUVWXYZ0 " ; byte [ ] expectedBytes = BufferTools . stringToByteBuffer ( s , 0 , s . length ( ) ) ; replaceNumbersWithBytes ( expectedBytes , 0 ) ; assertTrue ( Arrays . equals ( expectedBytes , frame . getData ( ) ) ) ; }
public void function ( ) throws IOException , UnsupportedTagException , InvalidDataException { loadAndCheckTestMp3WithNoTags ( MP3_WITH_NO_TAGS , 41 ) ; loadAndCheckTestMp3WithNoTags ( MP3_WITH_NO_TAGS , 256 ) ; loadAndCheckTestMp3WithNoTags ( MP3_WITH_NO_TAGS , 1024 ) ; loadAndCheckTestMp3WithNoTags ( MP3_WITH_NO_TAGS , 5000 ) ; }
protected void function ( HttpRequest arg0 , MutableHttpResponse arg1 ) { MessageContent content = responseContent ( arg0 ) ; arg1 . setContent ( content ) ; arg1 . addHeader ( HttpHeaders . CONTENT_LENGTH , content . getContent ( ) . length ) ; if ( ! detector . hasContentType ( arg1 ) ) { arg1 . addHeader ( HttpHeaders . CONTENT_TYPE , getContentType ( arg0 ) ) ;
public void function ( ) { String html = " <script> var a= \" <? \" ; var b= \" ?> \" ; </script> " ; Document doc = Jsoup . parse ( html , " " , Parser . xmlParser ( ) ) ; assertEquals ( " <script> var a= \" <!--? \" ; var b= \" ?--> \" ; </script> " , doc . html ( ) ) ; }
public ShutdownRunner function ( final StartArgs arg0 ) { Runner dynamicRunner = createDynamicRunner ( arg0 ) ; ShutdownMocoRunnerWatcher watcher = factory . createShutdownWatcher ( dynamicRunner , arg0 . getShutdownPort ( ) . orElse ( 0 ) , shutdownKey ) ; return new ShutdownRunner ( dynamicRunner , watcher ) ; }
public MessageContent function ( final Object arg0 ) { throw new IllegalArgumentException ( " Unknown xml value: " + arg0 ) ; }
protected void function ( SSLSession arg0 ) { int netBufferMax = arg0 . getPacketBufferSize ( ) ; int appBufferMax = Math . max ( arg0 . getApplicationBufferSize ( ) , netBufferMax ) ; if ( inData = = null ) { inData = ByteBuffer . allocate ( appBufferMax ) ; outCrypt = ByteBuffer . allocate ( netBufferMax ) ; inCrypt = ByteBuffer . allocate ( netBufferMax ) ; } else { if ( inData . capacity ( ) ! = appBufferMax ) inData = ByteBuffer . allocate ( appBufferMax ) ; if ( outCrypt . capacity ( ) ! = netBufferMax ) outCrypt = ByteBuffer . allocate ( netBufferMax ) ; if ( inCrypt . capacity ( ) ! = netBufferMax ) inCrypt = ByteBuffer . allocate ( netBufferMax ) ; } inData . rewind ( ) ; inData . flip ( ) ; inCrypt . rewind ( ) ; inCrypt . flip ( ) ; outCrypt . rewind ( ) ; outCrypt . flip ( ) ; bufferallocations + + ; }
public void function ( String arg0 , Object [ ] arg1 ) { formatAndLog ( ERROR_STR , arg0 , arg1 ) ; }
static ByteBuffer function ( InputStream arg0 ) throws IOException { return readToByteBuffer ( arg0 , 0 ) ; }
public T function ( Method arg0 ) { this . arg0 = arg0 ; return ( T ) this ; }
StartTag function ( String arg0 , Attributes arg1 ) { this . tagName = arg0 ; this . arg1 = arg1 ; normalName = ParseSettings . normalName ( tagName ) ; return this ; }
private RequestMatcher function ( final String arg0 , final Map < String , Object > arg1 ) { List < RequestMatcher > matchers = arg1 . entrySet ( ) . stream ( ) . map ( toTargetMatcher ( getExtractorMethod ( arg0 ) ) ) . collect ( toList ( ) ) ; return wrapRequestMatcher ( null , matchers ) ; }
private static RequestMatcher function ( final RequestSetting arg0 , final List < RequestMatcher > arg1 ) { switch ( arg1 . size ( ) ) { case 0 :
public void function ( String [ ] arg0 ) { StartArgs startArgs = parse ( arg0 ) ; final Runner runner = factory . createRunner ( startArgs ) ; final Stopwatch stopwatch = Stopwatch . createStarted ( ) ; runner . run ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ) { @Override
public boolean function ( ) { boolean hasNext = ( buffer . hasRemaining ( ) | | ( fillBuffer ( ) > - 1 ) ) ; if ( ! hasNext & & autoCloseReader ) try { in . close ( ) ; } catch ( IOException e ) { throw new ParserRuntimeException ( " IO exception whilst auto-closing reader " , e , pos ) ; } return hasNext ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { delegate ( ) . trace ( arg0 , arg1 , arg2 , arg3 ) ; }
private String [ ] function ( Object arg0 ) { if ( arg0 instanceof List ) { @SuppressWarnings ( " unchecked " ) List < String > texts = ( List < String > ) arg0 ; return texts . toArray ( new String [ texts . size ( ) ] ) ; } return new String [ ] { arg0 . toString ( ) } ; }
@Test public void function ( ) { String bare = " <script>One</script> " ; String full = " <html><head><title>Check</title></head><body><p>One</p></body></html> " ; assertTrue ( didAddElements ( bare ) ) ; assertFalse ( didAddElements ( full ) ) ; }
public void function ( ) throws IOException { runWithConiguration ( " foo.json " ) ; String value = Request . Get ( " http://localhost:8080/response_header " ) . execute ( ) . returnResponse ( ) . getHeaders ( " content-type " ) [ 0 ] . getValue ( ) ; assertThat ( value , is ( " application/json " ) ) ; }
public Builder function ( int [ ] arg0 ) { this . arg0 = arg0 ; return this ; }
public Iterator < Attribute > function ( ) { return new Iterator < Attribute > ( ) { int expectedSize = size ;
public static String function ( byte [ ] arg0 ) { String encoded = null ; try { encoded = encodeBytes ( arg0 , 0 , arg0 . length , NO_OPTIONS ) ; } catch ( java . io . IOException ex ) { assert false : ex . getMessage ( ) ; } assert encoded ! = null ; return encoded ; }
public void function ( final SessionContext arg0 ) { HttpRequest request = arg0 . getRequest ( ) ; Optional < URL > url = remoteUrl ( request ) ; if ( ! url . isPresent ( ) ) { return ; } HttpResponse response = doProxy ( request , url . get ( ) ) ; writeHttpResponse ( arg0 , response ) ; writeResponse ( arg0 . getResponse ( ) , response ) ; }
public final RecorderIdentifier function ( final MocoConfig arg0 ) { Resource applied = resource . apply ( arg0 ) ; if ( applied ! = this . resource ) { return new RecorderIdentifier ( ( ContentResource ) applied ) ; } return this ; }
String function ( String arg0 ) { int offset = input . indexOf ( arg0 , pos ) ; if ( offset ! = - 1 ) { String consumed = input . substring ( pos , offset ) ;
private String function ( String arg0 ) { String contentType = contentTypeMap . get ( arg0 . toLowerCase ( ) ) ; return contentType ! = null ? contentType : " text/html; charset=UTF-8 " ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeToAnySorted ( attributeSingleValueCharsSorted ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; else arg0 . tagPending . setEmptyAttributeValue ( ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\'' :
public void function ( ) throws Exception { server . response ( with ( " foo " ) ) ; running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " put_method.json " ) ; Request request = Request . Put ( remoteUrl ( " /put " ) ) ; assertThat ( helper . executeAsString ( request ) , is ( " response_for_put_method " ) ) ; }
public ByteChannel function ( SocketChannel arg0 ) throws IOException { if ( sslContext = = null ) throw new IllegalArgumentException ( " sslContext not initialized " ) ; SSLEngine e = sslContext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; return new SSLSocketChannel ( arg0 , e ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <p>One</p><p>Two <span>Three</span> <span>Four</span> " ) ; Element span = doc . expectFirst ( " span " ) ; assertEquals ( " Three " , span . text ( ) ) ; assertNull ( doc . selectFirst ( " div " ) ) ; boolean threw = false ; try { Element div = doc . expectFirst ( " div " ) ; } catch ( IllegalArgumentException e ) { threw = true ; } assertTrue ( threw ) ; }
public void function ( ) throws Exception { assertFalse ( Mp3Retag . parseArgs ( new String [ ] { " -p " } ) ) ; }
public static HttpServer function ( final int arg0 , final MocoConfig . . . arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualHttpServer . createQuietServer ( arg0 , arg1 ) ; }
private void function ( WebSocket arg0 , long arg1 ) { if ( ! ( arg0 instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) arg0 ; if ( webSocketImpl . getLastPong ( ) < arg1 ) { log . trace ( " Closing connection due to no pong received: {} " , webSocketImpl ) ;
@Override boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isCharacter ( ) ) { arg1 . insertCharacterNode ( arg0 . asCharacter ( ) ) ; } else if ( arg0 . isEOF ( ) ) { arg1 . error ( this ) ; arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; } return true ; }
public void function ( ) throws IOException , InterruptedException { final File config = tempFolder . newFile ( ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foo \" " + " }}] " ) ; RunnerFactory factory = new RunnerFactory ( " SHUTDOWN " ) ; runner = factory . createRunner ( httpArgs ( ) . withPort ( port ( ) ) . withShutdownPort ( 9090 ) . withConfigurationFile ( config . getAbsolutePath ( ) ) . build ( ) ) ; runner . run ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; changeFileContent ( config , " [{ \" response \"  :{ " + " \" text \"  :  \" foobar \" " + " }}] " ) ; waitChangeHappens ( ) ; assertThat ( helper . get ( root ( ) ) , is ( " foobar " ) ) ; }
CookieManager function ( ) { return cookieManager ; }
@Test public void function ( ) { String html = " <a foo bar= \" \"  async=async qux=qux defer=deferring ismap inert= \" \" > " ; Element el = Jsoup . parse ( html ) . selectFirst ( " a " ) ; assertEquals ( "  foo bar= \" \"  async qux= \" qux \"  defer= \" deferring \"  ismap inert " , el . attributes ( ) . html ( ) ) ;
public void function ( StringBuilder arg0 ) { arg0 . append ( getWholeData ( ) ) ; }
public void function ( ) { assertTrue ( Arrays . equals ( new byte [ ] { BYTE_FF , BYTE_FB , BYTE_90 , BYTE_44 } , BufferTools . packInteger ( 0xFFFB9044 ) ) ) ; }
public void function ( ) throws Exception { runWithConfiguration ( " event.json " ) ; assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " post_foo " ) ) ; Idles . idle ( IDLE ) ; }
public String function ( ) { return StringUtil . normaliseWhitespace ( getWholeText ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " template_with_function.json " ) ; String response = helper . get ( remoteUrl ( " /random_template_with_range_and_format " ) ) ; double result = Double . parseDouble ( response ) ; assertThat ( result , lessThan ( 100 d ) ) ; assertThat ( result , greaterThan ( 0d ) ) ; String target = Splitter . on ( '.' ) . splitToList ( response ) . get ( 1 ) ; assertThat ( target . length ( ) , is ( 6 ) ) ; }
public void function ( ) { ByteBuffer source = ByteBufferUtils . getEmptyByteBuffer ( ) ; ByteBuffer dest = ByteBufferUtils . getEmptyByteBuffer ( ) ; ByteBufferUtils . transferByteBuffer ( source , null ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( ! logger . isErrorEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
public MessageContent function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { return content ( arg0 . getText ( ) ) ; }
public boolean function ( Document arg0 ) { Validate . notNull ( arg0 ) ; Document clean = Document . createShell ( arg0 . baseUri ( ) ) ; int numDiscarded = copySafeNodes ( arg0 . body ( ) , clean . body ( ) ) ; return numDiscarded = = 0 ; }
public HttpRequest function ( String arg0 ) { return getTapeContent ( ) . getRequest ( arg0 ) ; }
public ResponseHandler function ( ) { List < ResponseHandler > handlers = new ArrayList < > ( ) ; if ( text ! = null ) { handlers . add ( with ( this . text . asResource ( ) ) ) ; } if ( file ! = null ) { handlers . add ( with ( asFileResource ( " file " , this . file ) ) ) ; } if ( broadcast ! = null ) { handlers . add ( broadcast . asHandler ( ) ) ; } if ( group ! = null ) { handlers . add ( join ( Moco . group ( this . group ) ) ) ; } return AndResponseHandler . and ( handlers ) ; }
private Predicate < RestSingleSetting > function ( final HttpRequest arg0 ) { return new Predicate < RestSingleSetting > ( ) { @Override
public void function ( ) { assertNull ( mdc . get ( " testKey " ) ) ; mdc . put ( " testKey " , " testValue " ) ; mdc . put ( " testKey " , " differentTestValue " ) ; assertEquals ( mdc . get ( " testKey " ) , " differentTestValue " ) ; }
public void function ( ) { setTrialEnabled ( true ) ; LoggerFactory . getLogger ( String . class ) ; assertMismatchDetected ( true ) ; }
public boolean function ( Element arg0 , Element arg1 ) { return ( arg1 . tagName ( ) . equals ( tagName ) ) ; }
private void function ( ) throws InvalidDataException { if ( code = = CloseFrame . NOCODE ) { reason = Charsetfunctions . stringUtf8 ( super . getPayloadData ( ) ) ;
public void function ( ) throws Exception { String original = " 1234567890QWERTYUIOP " ; byte buffer [ ] = BufferTools . stringToByteBuffer ( original , 2 , original . length ( ) - 5 ) ; String converted = BufferTools . byteBufferToString ( buffer , 0 , buffer . length ) ; assertEquals ( " 34567890QWERTYU " , converted ) ; }
public static Identifiable function ( final String arg0 ) { return ( ) - > arg0 ; }
public void function ( ) { Map map = org . apache . log4j . MDC . getContext ( ) ; if ( map ! = null ) { map . clear ( ) ;
public boolean function ( String arg0 ) { return FILE_ID . equals ( arg0 ) ; }
@Test public void function ( ) throws IOException { Document doc = Jsoup . connect ( " http://infohound.net/tools/302-escaped.pl " ) . get ( ) ; assertEquals ( " http://infohound.net/tools/q.pl?q=one%20two " , doc . location ( ) ) ; doc = Jsoup . connect ( " http://infohound.net/tools/302-white.pl " ) . get ( ) ; assertEquals ( " http://infohound.net/tools/q.pl?q=one%20two " , doc . location ( ) ) ; }
public void function ( ) { ID3v2PictureFrameData frameData1 = new ID3v2PictureFrameData ( false , null , ( byte ) 3 , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; ID3v2PictureFrameData frameData2 = new ID3v2PictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 3 , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; new ID3v2ChapterFrameData ( false , " ch2 " , 1 , 380 , 3 , 400 ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object arg3 , Object arg4 ) { if ( arg4 instanceof Throwable ) { handleNormalizedLoggingCall ( arg0 , arg1 , arg2 , new Object [ ] { arg3 } , ( Throwable ) arg4 ) ;
private String function ( DurationUnit arg0 , String arg1 , String arg2 , String arg3 ) { StringBuffer buf = new StringBuffer ( ) ; buf . append ( arg1 ) ; buf . append ( "  Profiler [ " ) ; buf . append ( name ) ; buf . append ( " ] " ) ; buf . append ( SpacePadder . LINE_SEP ) ; for ( TimeInstrument child : childTimeInstrumentList ) { if ( child instanceof StopWatch ) { buildStopWatchString ( buf , arg0 , ELAPSED_TIME , arg3 , ( StopWatch ) child ) ; } else if ( child instanceof Profiler ) { Profiler profiler = ( Profiler ) child ; String subString = profiler . buildProfilerString ( arg0 , NESTED_PROFILER_FIRST_PREFIX , SUBTOTAL_ELAPSED , arg3 + "      " ) ; buf . append ( subString ) ; buildStopWatchString ( buf , arg0 , ELAPSED_TIME , arg3 , profiler . globalStopWatch ) ; } } buildStopWatchString ( buf , arg0 , arg2 , arg3 , globalStopWatch ) ; return buf . toString ( ) ; }
public Variable function ( String arg0 , String arg1 ) { return new PlainVariable ( arg1 ) ; }
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return ApiUtils . as ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
void function ( Evaluator arg0 ) { evaluators . set ( num - 1 , arg0 ) ; updateEvaluators ( ) ; }
public HttpResponseSetting function ( final MocoEventTrigger arg0 ) { this . eventTriggers . add ( checkNotNull ( arg0 , " Trigger should not be null " ) ) ; return this ; }
private Request function ( HttpRequest arg0 ) { Request dumpedRequest = new Request ( ) ; dumpedRequest . setVersion ( arg0 . getProtocolVersion ( ) . getText ( ) ) ; dumpedRequest . setContent ( arg0 . getContent ( ) . toString ( Charset . defaultCharset ( ) ) ) ; dumpedRequest . setMethod ( arg0 . getMethod ( ) . getName ( ) ) ; QueryStringDecoder decoder = new QueryStringDecoder ( arg0 . getUri ( ) ) ; for ( Map . Entry < String , List < String > > entry : decoder . getParameters ( ) . entrySet ( ) ) { dumpedRequest . addQuery ( entry . getKey ( ) , entry . getValue ( ) . get ( 0 ) ) ; } for ( Map . Entry < String , String > entry : arg0 . getHeaders ( ) ) { dumpedRequest . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } return dumpedRequest ; }
public void function ( ) throws IOException { DataNode node = new DataNode ( " script && <> data " ) ; node . parentNode = new Element ( " script " ) ; StringBuilder accum = new StringBuilder ( ) ; node . outerHtmlHead ( accum , 0 , new Document . OutputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml ) ) ; assertEquals ( " //<![CDATA[ \ nscript && <> data \ n//]]> " , accum . toString ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.7.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 500 ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { recordEvent2Args ( Level . INFO , null , arg0 , arg1 , arg2 ) ; }
public void function ( WebSocket arg0 , ByteBuffer arg1 ) { broadcast ( arg1 . array ( ) ) ; System . out . println ( arg0 + " :  " + arg1 ) ; }
public static RestSetting function ( final RestIdMatcher arg0 , final String arg1 , final RestSetting . . . arg2 ) { return new SubResourceSetting ( arg0 , checkNotNullOrEmpty ( arg1 , " Resource name should not be null or empty " ) ,
public void function ( LogRecord arg0 ) { if ( arg0 = = null ) { return ; } Logger slf4jLogger = getSLF4JLogger ( arg0 ) ; String message = arg0 . getMessage ( ) ; if ( message = = null ) { message = " " ; } if ( slf4jLogger instanceof LocationAwareLogger ) { callLocationAwareLogger ( ( LocationAwareLogger ) slf4jLogger , arg0 ) ;
public boolean function ( final String arg0 ) { return FILE_ID . equalsIgnoreCase ( arg0 ) ; }
public void function ( ) { String html = " <?a<U<P<A  " ; Document doc = Jsoup . parse ( html ) ; assertNotNull ( doc ) ; Document xmlDoc = Parser . xmlParser ( ) . parseInput ( html , " " ) ; assertNotNull ( xmlDoc ) ; }
private void function ( Tokeniser arg0 , CharacterReader arg1 ) { arg0 . emit ( " </ " + arg0 . dataBuffer . toString ( ) ) ; arg0 . transition ( Rawtext ) ; }
public RunnerWatcher function ( final File arg0 , final FileRunner arg1 ) { return factory . createWatcher ( arg1 , arg0 ) ; }
private void function ( WebSocketListener arg0 , Draft arg1 , SocketChannel arg2 ) { this . sockchannel = arg2 ; this . bufferQueue = new LinkedBlockingQueue < ByteBuffer > ( 10 ) ; this . socketBuffer = ByteBuffer . allocate ( 65558 ) ; socketBuffer . flip ( ) ; this . wsl = arg0 ; this . role = Role . CLIENT ; this . arg1 = arg1 ; }
public void function ( ) throws Exception { server . response ( cors ( allowMethods ( " PUT " ) ) ) ; running ( server , ( ) - > { ClassicHttpResponse response = helper . putForResponseWithHeaders ( root ( ) , " " , ImmutableMultimap . of ( " Origin " , " https://www.github.com/ " ) ) ;
@Test public void function ( ) { CharacterReader r = new CharacterReader ( " One Two Three " ) ; assertEquals ( " One  " , r . consumeTo ( 'T' ) ) ; assertEquals ( " " , r . consumeTo ( 'T' ) ) ; assertEquals ( 'T' , r . consume ( ) ) ; assertEquals ( " wo  " , r . consumeTo ( 'T' ) ) ; assertEquals ( 'T' , r . consume ( ) ) ; assertEquals ( " hree " , r . consumeTo ( 'T' ) ) ; }
public static Expectation function ( String arg0 ) { checkNotNull ( arg0 , " Null URI is not allowed " ) ; return new Expectation ( new UriRequestExtractor ( ) , arg0 ) ; }
public void function ( ) { if ( writethread = = null ) writethread = Thread . currentThread ( ) ; interruptableRun ( ) ; assert ( ! channel . isOpen ( ) ) ;
@Test public void function ( ) { String html = " <p>One</p href='no'> \ n<!DOCTYPE html> \ n&arrgh;<font /><br /><foo " ; Parser parser = Parser . htmlParser ( ) . setTrackErrors ( 3 ) ; Document doc = parser . parseInput ( html , " http://example.com " ) ; List < ParseError > errors = parser . getErrors ( ) ; assertEquals ( 3 , errors . size ( ) ) ; assertEquals ( " <1:21>: Attributes incorrectly present on end tag [/p] " , errors . get ( 0 ) . toString ( ) ) ; assertEquals ( " <2:16>: Unexpected token [Doctype] when in state [InBody] " , errors . get ( 1 ) . toString ( ) ) ; assertEquals ( " <3:2>: Invalid character reference: invalid named reference [arrgh] " , errors . get ( 2 ) . toString ( ) ) ; }
public static ClasspathFileResource function ( String arg0 ) { return new ClasspathFileResource ( checkNotNull ( arg0 , " Null filename is not allowed " ) ) ; }
void function ( StringBuilder arg0 ) { for ( Attribute attribute : this ) { arg0 . append ( "   " ) ;
public void function ( final String arg0 , final HttpRequest arg1 ) { content . put ( arg0 , arg1 ) ; }
public Element function ( String arg0 ) { Validate . notEmpty ( arg0 , " Tag name must not be empty. " ) ; tag = Tag . valueOf ( arg0 ) ; return this ; }
public boolean function ( Element arg0 ) { return arg0 . attributes ( ) . get ( name ) . equals ( value ) ; }
@Test public void function ( ) { String h = " <td>Hello<td><p>There<p>now " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <table><tr><td>Hello</td><td><p>There</p><p>now</p></td></tr></table> " , doc . body ( ) . html ( ) ) ; }
public void function ( ) throws Exception { runTestScenarioReconnect ( false ) ; }
private final static void function ( ) { try { Set < URL > staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet ( ) ;
@Test void function ( ) { HttpConnection . Response res = new HttpConnection . Response ( ) ; CookieUtil . parseCookie ( " foo=bar qux; Domain=.example.com; Path=/; Secure " , res ) ; CookieUtil . parseCookie ( " bar=foo qux " , res ) ; CookieUtil . parseCookie ( " =bar; Domain=.example.com; Path=/; Secure " , res ) ; CookieUtil . parseCookie ( " ; Domain=.example.com; Path=/ " , res ) ; CookieUtil . parseCookie ( " " , res ) ; CookieUtil . parseCookie ( null , res ) ; assertEquals ( 3 , res . cookies ( ) . size ( ) ) ; assertEquals ( " bar qux " , res . cookies . get ( " foo " ) ) ; assertEquals ( " foo qux " , res . cookies . get ( " bar " ) ) ; assertEquals ( " .example.com " , res . cookies . get ( " ; Domain " ) ) ; }
public Resource function ( final MocoConfig arg0 ) { return configApplier . apply ( arg0 , this ) ; }
public boolean function ( ) { return delegate ( ) . isInfoEnabled ( ) ; }
private static void function ( StringBuffer arg0 , Object arg1 ) { try { String oAsString = arg1 . toString ( ) ;
public synchronized void function ( ) throws IOException { ByteBuffer buffer = this . outQueue . peek ( ) ; while ( buffer ! = null ) { int written = sockchannel . write ( buffer ) ;
private Range function ( final List < ? > arg0 ) { final Object end = arg0 . get ( 0 ) ; if ( end instanceof SimpleNumber ) { return getSingleRange ( ( SimpleNumber ) end ) ; } return new Range ( Optional . empty ( ) , Optional . empty ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo " ) ) ) . response ( cycle ( " bar " , " blah " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { String html = " <html><head></head><body><img src=foo><!-- <table><tr><td></table> --!---!>--><p>Hello</p></body></html> " ; Document doc = Jsoup . parse ( html ) ; Element body = doc . body ( ) ; Comment comment = ( Comment ) body . childNode ( 1 ) ; assertEquals ( "  <table><tr><td></table> --!- " , comment . getData ( ) ) ; Element p = body . child ( 1 ) ; TextNode text = ( TextNode ) p . childNode ( 0 ) ; assertEquals ( " Hello " , text . getWholeText ( ) ) ; }
public static ActualHttpServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoMonitor arg2 , final MocoConfig < ? > . . . arg3 ) { return new ActualHttpServer ( arg0 , arg1 , arg2 , arg3 ) ; }
public static ContentResource function ( final Resource arg0 , final Optional < Charset > arg1 , final Optional < MocoConfig > arg2 ) { return contentResource ( id ( MocoConfig . FILE_ID ) , fileConfigApplier ( MocoConfig . FILE_ID , arg0 ) , new FileResourceReader ( arg0 , arg1 , arg2 ) ) ;
public void function ( ) { Document doc = Jsoup . parse ( " <div><p>One</p><p>Two</p></div> " ) ; Element div = doc . select ( " div " ) . first ( ) ; assertEquals ( 2 , div . children ( ) . size ( ) ) ; assertEquals ( " One " , div . child ( 0 ) . text ( ) ) ; try { div . child ( 3 ) ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( by ( uri ( " /path " ) ) ) ) ; final String jsonContent = " { \" foo \" : \" bar \" } " ; server . request ( json ( jsonContent ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( String arg0 , Object arg1 ) { recordEvent_1Args ( Level . WARN , null , arg0 , arg1 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 70 ) ;
public static CookieAttribute function ( final String arg0 ) { CookieHeaderNames . SameSite name = ofSameSite ( arg0 ) ; return new SameSiteAttribute ( name ) ; }
public static AndResponseHandler function ( final Iterable < ResponseHandler > arg0 ) { return new AndResponseHandler ( arg0 ) ; }
protected void function ( Reader arg0 , String arg1 , Parser arg2 ) { Validate . notNull ( arg0 , " String input must not be null " ) ; Validate . notNull ( arg1 , " BaseURI must not be null " ) ; Validate . notNull ( arg2 ) ; doc = new Document ( arg1 ) ; doc . arg2 ( arg2 ) ; this . arg2 = arg2 ; settings = arg2 . settings ( ) ; reader = new CharacterReader ( arg0 ) ; trackSourceRange = arg2 . isTrackPosition ( ) ; reader . trackNewlines ( arg2 . isTrackErrors ( ) | | trackSourceRange ) ; currentToken = null ; tokeniser = new Tokeniser ( reader , arg2 . getErrors ( ) ) ; stack = new ArrayList < > ( 32 ) ; seenTags = new HashMap < > ( ) ; this . arg1 = arg1 ; }
public static MocoEventAction function ( final String arg0 , final ContentResource arg1 ) { return new MocoRequestAction ( checkNotNullOrEmpty ( arg0 , " URL should not be null " ) , " POST " , of ( checkNotNull ( arg1 , " Content should not be null " ) ) ) ; }
public void function ( ) { Selector . SelectorParseException exception = assertThrows ( Selector . SelectorParseException . class , ( ) - > QueryParser . parse ( " p:contains(One  \"  One) " ) ) ; assertEquals ( " Did not find balanced marker at 'One ' " , exception . getMessage ( ) ) ;
@Test public void function ( ) { Map < String , List < String > > headers = new HashMap < String , List < String > > ( ) ; headers . put ( " Set-Cookie " , Collections . < String > emptyList ( ) ) ; HttpConnection . Response res = new HttpConnection . Response ( ) ; res . processResponseHeaders ( headers ) ; assertEquals ( 0 , res . cookies ( ) . size ( ) ) ; }
public String function ( String arg0 ) { os . print ( arg0 ) ; os . flush ( ) ; try { return reader . readLine ( ) ;
private Function < Map . Entry < String , Object > , RequestMatcher > function ( final Method arg0 ) { return pair - > { RequestExtractor extractor = createRequestExtractor ( arg0 , pair . getKey ( ) ) ;
public Whitelist function ( String arg0 , String arg1 ) { Validate . notEmpty ( arg0 ) ; Validate . notEmpty ( arg1 ) ; TagName tagName = TagName . valueOf ( arg0 ) ; if ( tagNames . contains ( tagName ) & & enforcedAttributes . containsKey ( tagName ) ) { AttributeKey attrKey = AttributeKey . valueOf ( arg1 ) ; Map < AttributeKey , AttributeValue > attrMap = enforcedAttributes . get ( tagName ) ; attrMap . remove ( attrKey ) ; if ( attrMap . isEmpty ( ) ) enforcedAttributes . remove ( tagName ) ; } return this ; }
public void function ( ) { String h = " <div class=foo><ol><li>One<li>Two<li>Three</ol></div> " ; Document doc = Jsoup . parse ( h ) ; Elements els = SelectMatch . match ( doc , Parser . parse ( " .foo > ol, ol > li + li " ) ) ; assertEquals ( 3 , els . size ( ) ) ; assertEquals ( " ol " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " Two " , els . get ( 1 ) . text ( ) ) ; assertEquals ( " Three " , els . get ( 2 ) . text ( ) ) ; }
public void function ( ) { boolean caught = false ; String url = " https://jsoup.org " ; try { Document doc = Jsoup . connect ( url ) . proxy ( " localhost " , 8889 ) . get ( ) ; } catch ( IOException e ) { caught = e instanceof ConnectException ; } assertTrue ( caught ) ; }
public void function ( ) { byte [ ] buffer = { BYTE_FF } ; byte [ ] expectedBuffer = { BYTE_FF , 0 } ; byte [ ] unsynchronised = BufferTools . unsynchroniseBuffer ( buffer ) ; byte [ ] synchronised = BufferTools . synchroniseBuffer ( unsynchronised ) ; assertTrue ( Arrays . equals ( expectedBuffer , unsynchronised ) ) ; assertTrue ( Arrays . equals ( buffer , synchronised ) ) ; }
public void function ( Object arg0 , Object arg1 ) { lbLogger . info ( convertToString ( arg0 ) , arg1 ) ; }
private RequestMatcher function ( final String arg0 , final Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return by ( json ( arg1 ) ) ; } if ( arg1 instanceof Map ) { return createCompositeMatcher ( arg0 , castToMap ( arg1 ) ) ; } if ( arg1 instanceof TextContainer ) { return createSingleTextMatcher ( arg0 , ( TextContainer ) arg1 ) ; } if ( arg1 instanceof StructSetting ) { final StructSetting struct = ( StructSetting ) arg1 ; if ( struct . isJson ( ) ) { return Moco . struct ( json ( struct . getJson ( ) ) ) ; } throw new IllegalArgumentException ( " Unknown struct configuration:  " + struct ) ; } throw new IllegalArgumentException ( " unknown configuration : " + arg1 ) ; }
public void function ( ) { String msg0 = " msg0 " ; String msg1 = " msg1 {} " ; String msg2 = " msg2 {} {} " ; String msg3 = " msg3 {} {} {} " ; Object [ ] args = null ; result = MessageFormatter . arrayFormat ( msg0 , args ) ; assertEquals ( msg0 , result ) ; result = MessageFormatter . arrayFormat ( msg1 , args ) ; assertEquals ( msg1 , result ) ; result = MessageFormatter . arrayFormat ( msg2 , args ) ; assertEquals ( msg2 , result ) ; result = MessageFormatter . arrayFormat ( msg3 , args ) ; assertEquals ( msg3 , result ) ; }
public void function ( ByteBuffer arg0 ) { assert ( arg0 . hasRemaining ( ) ) ; if ( DEBUG ) System . out . println ( " process( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) , arg0 . position ( ) , arg0 . remaining ( ) ) ) + " } " ) ; if ( readystate ! = READYSTATE . NOT_YET_CONNECTED ) { if ( readystate = = READYSTATE . OPEN ) { decodeFrames ( arg0 ) ; } } else { if ( decodeHandshake ( arg0 ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) ! = arg0 . hasRemaining ( ) | | ! arg0 . hasRemaining ( ) ) ; if ( arg0 . hasRemaining ( ) ) { decodeFrames ( arg0 ) ; } else if ( tmpHandshakeBytes . hasRemaining ( ) ) { decodeFrames ( tmpHandshakeBytes ) ; } } } assert ( isClosing ( ) | | isFlushAndClose ( ) | | ! arg0 . hasRemaining ( ) ) ; }
public void function ( ) throws Exception { assertThat ( helper . get ( remoteUrl ( " /bar/foo " ) ) , is ( " bar " ) ) ; assertThat ( helper . postContent ( remoteUrl ( " /blah/foo " ) , " content " ) , is ( " bar " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; ProtocolVersion version = helper . execute ( Request . Get ( remoteUrl ( " /version10 " ) ) ) . getProtocolVersion ( ) ; assertThat ( version . getProtocol ( ) , is ( " HTTP " ) ) ; assertThat ( version . getMajor ( ) , is ( 1 ) ) ; assertThat ( version . getMinor ( ) , is ( 0 ) ) ; }
public static ResourceConfigApplier function ( final String arg0 , final Resource arg1 ) { return new ResourceConfigApplier ( ) { @Override
private static DefaultFailoverExecutor function ( String arg0 ) { return new DefaultFailoverExecutor ( new File ( checkNotNull ( arg0 , " Filename should not be null " ) ) ) ; }
public void function ( ) throws Exception { sameSite ( " Unknown " ) ; }
public StreamParser function ( String arg0 , arg1 Element arg2 , String arg3 ) { return parseFragment ( new StringReader ( arg0 ) , arg2 , arg3 ) ; }
public void function ( ) throws Exception { server . response ( proxy ( " https://github.com/ " ) ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null | | getClass ( ) ! = arg0 . getClass ( ) ) return false ; FramedataImpl1 that = ( FramedataImpl1 ) arg0 ; if ( fin ! = that . fin ) return false ; if ( transferemasked ! = that . transferemasked ) return false ; if ( rsv1 ! = that . rsv1 ) return false ; if ( rsv2 ! = that . rsv2 ) return false ; if ( rsv3 ! = that . rsv3 ) return false ; if ( optcode ! = that . optcode ) return false ; return unmaskedpayload ! = null ? unmaskedpayload . equals ( that . unmaskedpayload ) : that . unmaskedpayload = = null ; }
protected boolean function ( final HttpMethod arg0 , final HttpMethod arg1 ) { return arg0 = = null | | arg0 = = arg1 ; }
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { if ( arg0 . length ( ) > 0 & & arg2 . prettyPrint ( ) & & ( tag . formatAsBlock ( ) | | ( parent ( ) ! = null & & parent ( ) . tag ( ) . formatAsBlock ( ) ) ) ) indent ( arg0 , arg1 , arg2 ) ; arg0 . append ( " < " ) . append ( tagName ( ) ) ; attributes . html ( arg0 , arg2 ) ; if ( childNodes . isEmpty ( ) & & tag . isSelfClosing ( ) ) arg0 . append ( "  /> " ) ;
public boolean function ( Priority arg0 ) { switch ( arg0 . level ) { case Level . TRACE_INT : return slf4jLogger . isTraceEnabled ( ) ; case Level . DEBUG_INT : return slf4jLogger . isDebugEnabled ( ) ; case Level . INFO_INT : return slf4jLogger . isInfoEnabled ( ) ; case Level . WARN_INT : return slf4jLogger . isWarnEnabled ( ) ; case Level . ERROR_INT : return slf4jLogger . isErrorEnabled ( ) ; case Priority . FATAL_INT : return slf4jLogger . isErrorEnabled ( ) ; } return false ; }
private void function ( final ObjectInputStream arg0 ) throws IOException , ClassNotFoundException { arg0 . defaultReadObject ( ) ; level = arg0 . readInt ( ) ; syslogEquivalent = arg0 . readInt ( ) ; levelStr = arg0 . readUTF ( ) ; if ( levelStr = = null ) { levelStr = " " ;
public void function ( ) throws Exception { String filename = MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ; String saveFilename = filename + " .copy " ; try { Mp3File mp3File = new Mp3File ( filename ) ;
final boolean function ( ) { return selfClosing ; }
public boolean function ( Field arg0 ) { try { return arg0 . get ( request ) ! = null ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , log ( ) , fileRoot ( " src/test/resources " ) ) ; server . response ( asHeader ( " foo " , file ( " foo.response " ) ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( WebSocketImpl arg0 , Framedata arg1 ) throws InvalidDataException { try { arg0 . getWebSocketListener ( )
private String function ( byte arg0 ) { try { return characterSets [ arg0 ] ;
HtmlTreeBuilder function ( ) { return new HtmlTreeBuilder ( ) ; }
public void function ( String arg0 ) throws IOException , NotSupportedException { if ( filename . compareToIgnoreCase ( arg0 ) = = 0 ) { throw new IllegalArgumentException ( " Save filename same as source filename " ) ; } RandomAccessFile saveFile = new RandomAccessFile ( arg0 , " rw " ) ; try { if ( hasId3v2Tag ( ) ) {
private Optional < Response > function ( final SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; for ( Setting < T > setting : this . getSettings ( ) ) { if ( setting . match ( request ) ) { setting . writeToResponse ( arg0 ) ; return Optional . of ( arg0 . getResponse ( ) ) ; } } Setting < T > anySetting = this . getAnySetting ( ) ; if ( anySetting . match ( request ) ) { anySetting . writeToResponse ( arg0 ) ; return Optional . of ( arg0 . getResponse ( ) ) ; } monitor . onUnexpectedMessage ( request ) ; return Optional . empty ( ) ; }
public void function ( ) { final Document doc = createHtmlDocument ( " dontTouch " ) ; final String htmlCharset = " <html> \ n " + "  <head> \ n " + "   <meta charset= \" dontTouch \" > \ n " + "   <meta name= \" charset \"  content= \" dontTouch \" > \ n " + "  </head> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( htmlCharset , doc . toString ( ) ) ; Element selectedElement = doc . select ( " meta[charset] " ) . first ( ) ; assertNotNull ( selectedElement ) ; assertEquals ( " dontTouch " , selectedElement . attr ( " charset " ) ) ; selectedElement = doc . select ( " meta[name=charset] " ) . first ( ) ; assertNotNull ( selectedElement ) ; assertEquals ( " dontTouch " , selectedElement . attr ( " content " ) ) ; }
private void function ( ) { layoutManager . putConstraint ( SpringLayout . WEST , migrationLabel , BASIC_PADDING , SpringLayout . EAST , this ) ; layoutManager . putConstraint ( SpringLayout . NORTH , migrationLabel , BASIC_PADDING , SpringLayout . NORTH , this ) ; slh . placeToTheRight ( migrationLabel , radioJCL , BASIC_PADDING , - BASIC_PADDING / 2 ) ; slh . placeBelow ( radioJCL , radioLog4j , 0 , 0 ) ; slh . placeBelow ( migrationLabel , folderLabel , 0 , BASIC_PADDING * 5 ) ; slh . placeToTheRight ( folderLabel , folderTextField ) ; slh . placeToTheRight ( folderTextField , browseButton ) ; slh . placeBelow ( folderLabel , warningLabel , 0 , BASIC_PADDING * 3 ) ; slh . placeBelow ( warningLabel , awareCheckBox , 0 , ( int ) ( BASIC_PADDING * 1.5 ) ) ; slh . placeToTheRight ( awareCheckBox , awareLabel ) ; slh . placeBelow ( awareCheckBox , migrateButton , 0 , BASIC_PADDING * 3 ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <table> <td>One <td><table><td>Two</table> <table><td>Three " ) ; assertEquals ( " <table><tbody><tr><td>One </td><td><table><tbody><tr><td>Two</td></tr></tbody></table><table><tbody><tr><td>Three</td></tr></tbody></table></td></tr></tbody></table> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ;
public ResponseHandler function ( final MocoConfig arg0 ) { return and ( from ( handlers ) . transform ( applyConfig ( arg0 ) ) ) ; }
public void function ( Throwable arg0 ) { if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( THROWING_MARKER , FQCN ,
public void function ( ) { Document doc = Jsoup . parse ( " <div><p>Hello</p></div> " ) ; Node p = doc . select ( " p " ) . first ( ) ; Node wrapped = p . wrap ( " Some junk " ) ; assertSame ( p , wrapped ) ; assertEquals ( " <div><p>Hello</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ;
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( " 1 " ) . response ( json ( resource1 ) ) , get ( " 2 " ) . response ( json ( resource2 ) ) ) ; server . response ( " hello " ) ; running ( server , new Runnable ( ) { @Override
public void function ( boolean arg0 , String arg1 ) { if ( ! arg0 ) error ( arg1 ) ;
public void function ( ) throws Exception { HttpResponse httpResponse1 = helper . deleteForResponse ( remoteUrl ( " /targets/1 " ) ) ; assertThat ( httpResponse1 . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; HttpResponse httpResponse2 = helper . deleteForResponse ( remoteUrl ( " /targets/2 " ) ) ; assertThat ( httpResponse2 . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; }
public static RestSetting function ( final String arg0 , final RequestMatcher arg1 , final ResponseHandler arg2 , final ResponseHandler . . . arg3 ) { return new HeadSingleRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , of ( checkNotNull ( arg1 , " Head request matcher should be not null " ) ) ,
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( file ( " src/test/resources/two_vars.template " ) , " foo " , " ANOTHER " , " bar " , " TEMPLATE " ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /template " ) ) , is ( " ANOTHER TEMPLATE " ) ) ) ; }
public void function ( FullHttpRequest arg0 , FullHttpResponse arg1 ) { Idles . idle ( millis ) ; }
public String function ( ) { return contentType ; }
@Test public void function ( ) { assertEquals ( " UTF-8 " , DataUtil . getCharsetFromContentType ( " text/html; charset= \" utf-8 \" " ) ) ; assertEquals ( " UTF-8 " , DataUtil . getCharsetFromContentType ( " text/html;charset= \" utf-8 \" " ) ) ; assertEquals ( " ISO-8859-1 " , DataUtil . getCharsetFromContentType ( " text/html; charset= \" ISO-8859-1 \" " ) ) ; }
private RequestMatcher function ( String arg0 , Map < String , Object > arg1 ) { ImmutableList < RequestMatcher > matchers = from ( arg1 . entrySet ( ) ) . transform ( toTargetMatcher ( getExtractorMethod ( arg0 ) ) ) . toList ( ) ; return wrapRequestMatcher ( null , matchers ) ; }
public void function ( ) throws Exception { assertEquals ( 75 , ID3v1Genres . matchGenreDescription ( " Polka " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; org . apache . http . HttpResponse response = helper . getResponseWithHeader ( remoteUrl ( " /all-resources " ) , of ( HttpHeaders . CONTENT_TYPE , " application/json " ) ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; HttpEntity entity = response . getEntity ( ) ; List < Plain > plains = Jsons . toObject ( entity . getContent ( ) , new TypeReference < List < Plain > > ( ) { } ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; }
public void function ( Marker arg0 , String arg1 , int arg2 , String arg3 , Object [ ] arg4 , Throwable arg5 ) { Level log4jLevel = toLog4jLevel ( arg2 ) ; logger . log ( arg1 , log4jLevel , arg3 , arg5 ) ; }
public final MessageContent function ( final Request arg0 ) { String text = HttpProtocolVersion . versionOf ( version . readFor ( arg0 ) . toString ( ) ) . text ( ) ; return content ( text ) ; }
public Whitelist function ( String arg0 , String arg1 , String arg2 ) { super . addEnforcedAttribute ( arg0 , arg1 , arg2 ) ; return this ; }
public HttpResponseSetting function ( final HttpResponseSetting arg0 , final Resource arg1 ) { return arg0 . response ( status ( HttpResponseStatus . FOUND . code ( ) ) , with ( new HttpHeader ( checkNotNullOrEmpty ( HttpHeaders . LOCATION , " Header name should not be null " ) ,
public static String function ( final String arg0 ) { return SEPARATOR + arg0 ; }
public void function ( Object arg0 , Throwable arg1 ) { logger . debug ( arg0 . toString ( ) , arg1 ) ; }
@Test public void function ( ) { assertEquals ( " one \\ #two \\ .three \\ /four \\ \\ five " , TokenQueue . escapeCssIdentifier ( " one#two.three/four \\ five " ) ) ; }
public void function ( ) throws IOException { InputStream stream = null ; try { stream = getResourceAsStream ( " settings/response-settings.json " ) ;
public static Resource function ( final ContentResource arg0 , final String arg1 , final String arg2 , final String arg3 , final String arg4 ) { return arg0 ( checkNotNull ( arg0 , " Template should not be null " ) , ImmutableMap . of ( checkNotNull ( arg1 , " Template variable name should not be null " ) ,
public void function ( ) throws IOException { runWithConfiguration ( " put_method.json " ) ; String response = Request . Put ( remoteUrl ( " /put " ) ) . execute ( ) . returnContent ( ) . toString ( ) ; assertThat ( response , is ( " response_for_put_method " ) ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { arg1 . error ( this ) ; boolean processed ; if ( StringUtil . in ( arg1 . currentElement ( ) . nodeName ( ) , " table " , " tbody " , " tfoot " , " thead " , " tr " ) ) { arg1 . setFosterInserts ( true ) ; processed = arg1 . process ( arg0 , InBody ) ; arg1 . setFosterInserts ( false ) ; } else { processed = arg1 . process ( arg0 , InBody ) ; } return processed ; }
@Test @MultiLocaleTest public void function ( ) { ParseSettings parseSettings = new ParseSettings ( false , false ) ; String normalizedAttribute = parseSettings . normalizeAttribute ( " HIDDEN " ) ; assertEquals ( " hidden " , normalizedAttribute ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div hidden> " ) ; Attributes attributes = doc . body ( ) . child ( 0 ) . attributes ( ) ; assertEquals ( " " , attributes . get ( " hidden " ) ) ; Attribute first = attributes . iterator ( ) . next ( ) ; assertEquals ( " hidden " , first . getKey ( ) ) ; assertEquals ( " " , first . getValue ( ) ) ; assertFalse ( first . hasValue ( ) ) ; assertTrue ( Attribute . isBooleanAttribute ( first . getKey ( ) ) ) ; }
public void function ( ) throws Exception { server . response ( text ( ( request ) - > " foo " ) ) ; running ( server , ( ) - > { String response = helper . get ( root ( ) ) ;
public void function ( ) throws IOException { runWithConfiguration ( " template_with_function.json " ) ; String response = helper . get ( remoteUrl ( " /random_template_with_range_and_format " ) ) ; double result = Double . parseDouble ( response ) ; assertThat ( result , lessThan ( 100 d ) ) ; assertThat ( result , greaterThanOrEqualTo ( 0d ) ) ; String target = response . split ( " \\ . " ) [ 1 ] ; assertThat ( target . length ( ) , lessThanOrEqualTo ( 6 ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " , PORT ) ; helper . get ( " http://localhost:9090/mount-exclude/mount.response " ) ; }
public void function ( ) throws Exception { testHandshakeRejection ( 8 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.20.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { byte [ ] bytes = { 0x01 , 'P' , 'N' , 'G' , 0x01 , ( byte ) 0xff , ( byte ) 0xfe , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac , 0x03 , 0 , 0 , 1 , 2 , 3 , 4 , 5 } ; ID3v2ObseletePictureFrameData frameData = new ID3v2ObseletePictureFrameData ( false , bytes ) ; assertEquals ( TEST_MIME_TYPE , frameData . getMimeType ( ) ) ; assertEquals ( ( byte ) 1 , frameData . getPictureType ( ) ) ; assertEquals ( new EncodedText ( EncodedText . TEXT_ENCODING_UTF_16 , TEST_DESCRIPTION_UNICODE ) , frameData . getDescription ( ) ) ; assertTrue ( Arrays . equals ( DUMMY_IMAGE_DATA , frameData . getImageData ( ) ) ) ; }
public Integer function ( ) { if ( parent ( ) = = null ) return 0 ; return indexInList ( this , parent ( ) . children ( ) ) ; }
public void function ( ) throws IOException { assertThat ( helper . postContent ( root ( ) , " { \ n \ t \" code \" :1, \ n \ t \" message \" : \" message \" \ n} " ) , is ( " foo " ) ) ; }
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final String arg1 ) { return eq ( arg0 , text ( arg1 ) ) ; }
private void function ( final CloseableHttpResponse arg0 ) throws IOException { final DefaultHttpResponse dumped = DefaultHttpResponse . builder ( ) . withVersion ( HttpProtocolVersion . versionOf ( arg0 . getProtocolVersion ( ) . toString ( ) ) ) . withStatus ( arg0 . getStatusLine ( ) . getStatusCode ( ) ) . withHeaders ( asHeaders ( arg0 . getAllHeaders ( ) ) ) . withContent ( MessageContent . content ( ) . withContent ( arg0 . getEntity ( ) . getContent ( ) ) . build ( ) ) . build ( ) ; logger . info ( " Action Response: {} \ n " , responseDumper . dump ( dumped ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.20.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
protected void function ( ) { ConversionRule cr = new ConversionRule ( Pattern . compile ( " import org.slf4j.converter " ) ) ; cr . addReplacement ( Constant . INDEX_0 , " simple replacement with an unique capturing group " ) ; ConversionRule cr1 = new ConversionRule ( Pattern . compile ( " (first group)( second group)( third group)( 4th group) " ) ) ; cr1 . addReplacement ( Constant . INDEX_1 , " 1st group " ) ; cr1 . addReplacement ( Constant . INDEX_3 , " " ) ; rules = new ArrayList < ConversionRule > ( ) ; rules . add ( cr ) ; rules . add ( cr1 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.2.4 " ) ; assertEquals ( " NON-STRICT " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { System . out . println ( " running bTest in  " + Thread . currentThread ( ) . getName ( ) ) ; }
public void function ( String arg0 ) { Assert . assertTrue ( autobahnClient . openHandShakeFields . containsKey ( arg0 ) ) ;
public static ResponseHandler function ( final String arg0 , final String arg1 , final CookieOption . . . arg2 ) { return cookie ( checkNotNullOrEmpty ( arg0 , " Cookie key should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Cookie value should not be null " ) ) ,
public void function ( final String arg0 , final Map < String , ? extends ResponseHandler > arg1 ) { for ( Map . Entry < String , ? extends ResponseHandler > entry : arg1 . entrySet ( ) ) { this . get ( by ( uri ( " / " + arg0 + " / " + entry . getKey ( ) ) ) ) . response ( entry . getValue ( ) ) ; } Collection < ? extends ResponseHandler > values = arg1 . values ( ) ; FluentIterable < ? extends ResponseHandler > handlers = from ( values ) ; if ( handlers . allMatch ( isJsonHandlers ( ) ) ) { ImmutableList < Object > objects = handlers . transform ( toJsonHandler ( ) ) . transform ( toPojo ( ) ) . toList ( ) ;
public void function ( ) { String xml = " <?xml version='1' encoding='UTF-8' something='else'?><val>One</val> " ; Document doc = Jsoup . parse ( xml , " " , Parser . xmlParser ( ) ) ; XmlDeclaration decl = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( " 1 " , decl . attr ( " version " ) ) ; assertEquals ( " UTF-8 " , decl . attr ( " encoding " ) ) ; assertEquals ( " else " , decl . attr ( " something " ) ) ; assertEquals ( " version= \" 1 \"  encoding= \" UTF-8 \"  something= \" else \" " , decl . getWholeDeclaration ( ) ) ; assertEquals ( " <?xml version= \" 1 \"  encoding= \" UTF-8 \"  something= \" else \" ?> " , decl . outerHtml ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.30 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { assertTrue ( comp . contains ( comp ) ) ; assertTrue ( comp . contains ( blue ) ) ; }
public boolean function ( Element arg0 , Element arg1 ) { if ( arg0 = = arg1 ) return false ; Element sibling = arg1 . firstElementSibling ( ) ; while ( sibling ! = null ) { if ( sibling = = arg1 ) break ; if ( memoMatches ( arg0 , sibling ) ) return true ; sibling = sibling . nextElementSibling ( ) ; } return false ; }
protected StartArgs function ( final CommandLine arg0 ) { String port = arg0 . getOptionValue ( " p " ) ; String config = arg0 . getOptionValue ( " c " ) ; String globalSettings = arg0 . getOptionValue ( " g " ) ; String shutdownPort = arg0 . getOptionValue ( " s " ) ; String env = arg0 . getOptionValue ( " e " ) ; if ( config = = null & & globalSettings = = null ) { throw new ParseArgException ( " config or global setting is required " ) ; } if ( config ! = null & & globalSettings ! = null ) { throw new ParseArgException ( " config and global settings can not be set at the same time " ) ; } if ( globalSettings = = null & & env ! = null ) { throw new ParseArgException ( " environment must be configured with global settings " ) ; } if ( arg0 . getArgs ( ) . length ! = 1 ) { throw new ParseArgException ( " only one args allowed " ) ; } return httpArgs ( ) . withPort ( getPort ( port ) ) . withShutdownPort ( getPort ( shutdownPort ) ) . withConfigurationFile ( config ) . withSettings ( globalSettings ) . withEnv ( env ) . build ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>One <span>two &amp;</span> three &amp;</p> " ) ; Element p = doc . select ( " p " ) . first ( ) ; Element span = doc . select ( " span " ) . first ( ) ; assertEquals ( " two & " , span . text ( ) ) ; TextNode spanText = ( TextNode ) span . childNode ( 0 ) ; assertEquals ( " two & " , spanText . text ( ) ) ; TextNode tn = ( TextNode ) p . childNode ( 2 ) ; assertEquals ( "  three & " , tn . text ( ) ) ; tn . text ( "  POW! " ) ; assertEquals ( " One <span>two &amp;</span> POW! " , TextUtil . stripNewlines ( p . html ( ) ) ) ; tn . attr ( tn . nodeName ( ) , " kablam & " ) ; assertEquals ( " kablam & " , tn . text ( ) ) ; assertEquals ( " One <span>two &amp;</span>kablam &amp; " , TextUtil . stripNewlines ( p . html ( ) ) ) ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( message , param1 ) ; break ; case DEBUG : logger . debug ( message , param1 ) ; break ; case INFO : logger . info ( message , param1 ) ; break ; case WARN : logger . warn ( message , param1 ) ; break ; case ERROR : logger . error ( message , param1 ) ; break ; } verifyMessageWithoutMarker ( arg0 , oneParam , null ) ; }
public int function ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( description = = null ) ? 0 : description . hashCode ( ) ) ; result = prime * result + ( ( url = = null ) ? 0 : url . hashCode ( ) ) ; return result ; }
public Object function ( final List arg0 ) { if ( arg0 . size ( ) < 1 ) { throw new IllegalArgumentException ( " Date format is required " ) ; } Date date = new Date ( ) ; SimpleDateFormat format = new SimpleDateFormat ( arg0 . get ( 0 ) . toString ( ) ) ; return format . format ( date ) ; }
public void function ( ) { check ( html . select ( " #pseudo :nth-child(-5) " ) ) ; check ( html . select ( " #pseudo :nth-child(odd) " ) , " 1 " , " 3 " , " 5 " , " 7 " , " 9 " ) ; check ( html . select ( " #pseudo :nth-child(2n-1) " ) , " 1 " , " 3 " , " 5 " , " 7 " , " 9 " ) ; check ( html . select ( " #pseudo :nth-child(2n+1) " ) , " 1 " , " 3 " , " 5 " , " 7 " , " 9 " ) ; check ( html . select ( " #pseudo :nth-child(2n+3) " ) , " 3 " , " 5 " , " 7 " , " 9 " ) ; check ( html . select ( " #pseudo :nth-child(even) " ) , " 2 " , " 4 " , " 6 " , " 8 " , " 10 " ) ; check ( html . select ( " #pseudo :nth-child(2n) " ) , " 2 " , " 4 " , " 6 " , " 8 " , " 10 " ) ; check ( html . select ( " #pseudo :nth-child(3n-1) " ) , " 2 " , " 5 " , " 8 " ) ; check ( html . select ( " #pseudo :nth-child(-2n+5) " ) , " 1 " , " 3 " , " 5 " ) ; check ( html . select ( " #pseudo :nth-child(+5) " ) , " 5 " ) ; }
void function ( HtmlTreeBuilderState arg0 ) { tmplInsertMode . add ( arg0 ) ; }
public Elements function ( String arg0 ) { return new Elements ( NodeUtils . selectXpath ( arg0 , this , Element . class ) ) ; }
private Resource function ( String arg0 , String arg1 ) { return invokeTarget ( arg0 , arg1 , Resource . class ) ; }
public LatencyContainer function ( JsonParser arg0 , DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_NUMBER_INT ) { return LatencyContainer . latency ( arg0 . getLongValue ( ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; InternalLatencyContainer container = get ( arg0 . readValuesAs ( InternalLatencyContainer . class ) , 0 ) ; return LatencyContainer . latencyWithUnit ( container . duration , TimeUnit . valueOf ( container . unit . toUpperCase ( ) + 'S' ) ) ; } throw arg1 . mappingException ( TextContainer . class , currentToken ) ; }
public Setting function ( RequestMatcher arg0 ) { return this . onRequestAttached ( arg0 ) ; }
private static void function ( Thread arg0 , StringBuilder arg1 ) { StackTraceElement [ ] st = arg0 . getStackTrace ( ) ; for ( int i = 0 ; i < st . length ; i + + ) { arg1 . append ( " \ n    at  " ) ;
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( file ( " src/test/resources/var.template " ) , ImmutableMap . of ( " var " , " TEMPLATE " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { arg1 . error ( this ) ; return false ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . normalName ( ) . equals ( " html " ) ) { return InBody . process ( arg0 , arg1 ) ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . normalName ( ) . equals ( " head " ) ) { Element head = arg1 . insert ( arg0 . asStartTag ( ) ) ; arg1 . setHeadElement ( head ) ; arg1 . transition ( InHead ) ; } else if ( arg0 . isEndTag ( ) & & ( StringUtil . in ( arg0 . asEndTag ( ) . normalName ( ) , " head " , " body " , " html " , " br " ) ) ) { arg1 . processStartTag ( " head " ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . error ( this ) ; return false ; } else { arg1 . processStartTag ( " head " ) ; return arg1 . process ( arg0 ) ; } return true ; }
public static HttpRequest function ( FullHttpRequest arg0 ) { return builder ( ) . withVersion ( arg0 . getProtocolVersion ( ) . text ( ) )
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { handleDataEndTag ( arg0 , arg1 , ScriptDataEscaped ) ; }
public void function ( String arg0 , Throwable arg1 ) { recordEventwithoutMarkerArgArray ( Level . INFO , arg0 , null , arg1 ) ; }
protected byte [ ] function ( final Request arg0 ) { String actualFilename = this . filename ( arg0 ) ; URL resource = Resources . getResource ( actualFilename ) ; if ( resource = = null ) { throw new IllegalArgumentException ( format ( " %s does not exist " , actualFilename ) ) ; } try { return toByteArray ( resource . openStream ( ) ) ;
@Test public void function ( ) { String h = " <!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven  " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <!doctype html><html><head><link /></head><body>One Two Four Three Five Six Seven </body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
public void function ( ) throws IOException , NoSuchTagException , UnsupportedTagException , InvalidDataException { byte [ ] buffer = TestHelper . loadFile ( " src/test/resources/v1andv24tags.mp3 " ) ; ID3v2 id3v2tag = ID3v2TagFactory . createTag ( buffer ) ; assertEquals ( " 4.0 " , id3v2tag . getVersion ( ) ) ; assertEquals ( 0x44B , id3v2tag . getLength ( ) ) ; }
public void function ( ) throws UnsupportedEncodingException { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " TAG- " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 0 ) ; byte [ ] expectedBuffer = { BYTE_T , BYTE_A , BYTE_G , BYTE_DASH , 0 , 0 , 0 , 0 , 0 , 0 } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
@Test public void function ( ) { String h = " <h1>Head</h1><td>One<td>Two</td> " ; String cleanHtml = Jsoup . clean ( h , Whitelist . relaxed ( ) ) ; assertEquals ( " <h1>Head</h1><table><tr><td>One</td><td>Two</td></tr></table> " , cleanHtml ) ; }
public void function ( String arg0 , Throwable arg1 ) { log ( LOG_LEVEL_INFO , arg0 , arg1 ) ; }
protected void function ( Reader arg0 , String arg1 , Parser arg2 ) { Validate . notNullParam ( arg0 , " arg0 " ) ; Validate . notNullParam ( arg1 , " arg1 " ) ; Validate . notNull ( arg2 ) ; doc = new Document ( arg2 . defaultNamespace ( ) , arg1 ) ; doc . arg2 ( arg2 ) ; this . arg2 = arg2 ; settings = arg2 . settings ( ) ; reader = new CharacterReader ( arg0 ) ; trackSourceRange = arg2 . isTrackPosition ( ) ; reader . trackNewlines ( arg2 . isTrackErrors ( ) | | trackSourceRange ) ; currentToken = null ; tokeniser = new Tokeniser ( reader , arg2 . getErrors ( ) ) ; stack = new ArrayList < > ( 32 ) ; seenTags = new HashMap < > ( ) ; this . arg1 = arg1 ; }
public boolean function ( ) { return request ! = null | | response ! = null
public static void function ( String [ ] arg0 ) { new Bootstrap ( ) . run ( arg0 ) ; }
public Elements function ( ) { HashSet < Element > combo = new LinkedHashSet < > ( ) ; for ( Element e : this ) { combo . addAll ( e . parents ( ) ) ; } return new Elements ( combo ) ; }
public static ContentResource function ( final File arg0 , final Optional < Charset > arg1 ) { String fileId = " arg0 " ; return contentResource ( id ( fileId ) , fileConfigApplier ( fileId , arg0 ) , new FileResourceReader ( arg0 , arg1 ) ) ; }
public boolean function ( String arg0 , int arg1 ) { matcher = AbstractMatcher . getMatcherImpl ( arg1 ) ; if ( matcher = = null ) { return false ; } writer = new Writer ( ) ; fileSource = new File ( arg0 ) ; if ( ! fileSource . isDirectory ( ) ) { return false ;
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , put ( " 1 " ) . response ( status ( 409 ) ) ) ; running ( server , ( ) - > { HttpResponse httpResponse = helper . putForResponse ( remoteUrl ( " /targets/1 " ) ,
@Test public void function ( ) { String h = " <A HREF= \" javascript:document.location='http://www.google.com/' \" >XSS</A> " ; String cleanHtml = Jsoup . clean ( h , Whitelist . relaxed ( ) ) ; assertEquals ( " <a>XSS</a> " , cleanHtml ) ; }
private static boolean function ( Set < URL > arg0 ) { return arg0 . size ( ) > 1 ; }
private static boolean function ( String arg0 ) { if ( arg0 = = null ) return false ; if ( arg0 . indexOf ( " org/slf4j/impl/StaticLoggerBinder " ) ! = - 1 ) return true ; if ( arg0 . indexOf ( " org.slf4j.impl.StaticLoggerBinder " ) ! = - 1 ) return true ; return false ; }
private void function ( Handshakedata arg0 ) { log . trace ( " open using draft: {} " , draft ) ; readyState = ReadyState . OPEN ; try { wsl . onWebsocketOpen ( this , arg0 ) ;
public static boolean function ( int arg0 ) throws InterruptedException { Socket socket = null ; for ( int i = 0 ; i < 50 ; i + + ) { try { socket = new Socket ( " localhost " , arg0 ) ; if ( socket . isConnected ( ) ) { return true ; } } catch ( IOException ignore ) { } finally { if ( socket ! = null ) { try { socket . close ( ) ; } catch ( IOException ignore ) { } } } Thread . sleep ( 10 ) ; } return false ; }
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( HttpMethod . POST ) . withContent ( " proxy " ) . withUri ( " /foo " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest another = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( HttpMethod . POST ) . withContent ( " proxy " ) . withUri ( " /bar " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( request ) . match ( another ) , is ( false ) ) ; }
String function ( ) { int start = pos ; while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( ( c > = '0' & & c < = '9' ) | | ( c > = 'A' & & c < = 'F' ) | | ( c > = 'a' & & c < = 'f' ) ) pos + + ; else break ; } return new String ( input . substring ( start , pos ) ) ; }
public void function ( ) throws Throwable { WithException withException = new WithException ( ) ; Other other = new Other ( ) ; threads [ 0 ] = new Thread ( withException ) ; threads [ 1 ] = new Thread ( other ) ; threads [ 0 ] . start ( ) ; threads [ 1 ] . start ( ) ; Thread . sleep ( TEST_DURATION_IN_MILLIS ) ; signal = true ; threads [ 0 ] . join ( ) ; threads [ 1 ] . join ( ) ; if ( withException . throwable ! = null ) { throw withException . throwable ; } if ( other . throwable ! = null ) { throw other . throwable ;
public Attributes function ( Attribute arg0 ) { Validate . notNull ( arg0 ) ; if ( attributes = = null ) attributes = new LinkedHashMap < > ( 2 ) ; attributes . put ( arg0 . getKey ( ) , arg0 ) ; return this ; }
public Element function ( String arg0 , String arg1 ) { Validate . notEmptyParam ( arg0 , " arg0 " ) ; Validate . notEmptyParam ( arg1 , " arg1 " ) ; tag = Tag . valueOf ( arg0 , arg1 , NodeUtils . parser ( this ) . settings ( ) ) ; return this ; }
protected byte [ ] function ( final Optional < ? extends Request > arg0 ) { ClassLoader classLoader = this . getClass ( ) . getClassLoader ( ) ; URL resource = classLoader . getResource ( filename . readFor ( arg0 ) . toString ( ) ) ; if ( resource = = null ) { throw new IllegalArgumentException ( format ( " %s does not exist " , filename ) ) ; } try { return toByteArray ( resource . openStream ( ) ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isErrorEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 ) . getMessage ( ) ;
protected void function ( final ChannelHandlerContext arg0 , final String arg1 ) throws Exception { try { MessageContent content = content ( arg1 ) ;
public void function ( ) throws Exception { final PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; String text = Jsons . toJson ( pojo ) ; server . response ( Moco . json ( text ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { for ( FileMonitor monitor : monitors ) { monitor . stopMonitor ( ) ;
public void function ( ) { String s = Parser . unescapeEntities ( " One &amp; Two " , false ) ; assertEquals ( " One & Two " , s ) ; }
public int function ( ByteBuffer arg0 ) throws SSLException { return channel instanceof WrappedByteChannel ? ( ( WrappedByteChannel ) channel ) . readMore ( arg0 ) : 0 ; }
@Test void function ( ) { String html = " <ruby><rp>(<rt>Hello<rt>Hello<rp>)</ruby> \ n " ; Parser parser = Parser . htmlParser ( ) ; parser . setTrackErrors ( 10 ) ; Document doc = Jsoup . parse ( html , parser ) ; assertEquals ( 0 , parser . getErrors ( ) . size ( ) ) ; Element ruby = doc . expectFirst ( " ruby " ) ; assertEquals ( " <ruby><rp>(</rp><rt>Hello</rt><rt>Hello</rt><rp>)</rp></ruby> " ,
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false ) ; frameData . setStartTime ( 9 ) ; assertEquals ( 9 , frameData . getStartTime ( ) ) ; }
public Connection function ( String arg0 ) { Validate . notEmptyParam ( arg0 , " arg0 " ) ; try { req . arg0 ( new URL ( encodeUrl ( arg0 ) ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( String . format ( " The supplied URL, '%s', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. " , arg0 ) , e ) ; } return this ; }
public void function ( ) throws Exception { SocketServer server = socketServer ( 12306 ) ; SocketServer secondServer = socketServer ( ) ; final SocketServer newServer = ( ( ActualSocketServer ) server ) . mergeServer ( ( ActualSocketServer ) secondServer ) ; running ( newServer , new Runnable ( ) { @Override
static void function ( StringBuilder arg0 , String arg1 , Document . OutputSettings arg2 , boolean arg3 , boolean arg4 , boolean arg5 ) { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = arg2 . escapeMode ( ) ; final CharsetEncoder encoder = arg2 . encoder ( ) ; final CoreCharset coreCharset = CoreCharset . byName ( encoder . charset ( ) . name ( ) ) ; final Map < Character , String > map = escapeMode . getMap ( ) ; final int length = arg1 . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset + = Character . charCount ( codePoint ) ) { codePoint = arg1 . codePointAt ( offset ) ;
public static String function ( String arg0 ) { arg0 = stripLines . matcher ( arg0 ) . replaceAll ( " " ) ; arg0 = stripper . matcher ( arg0 ) . replaceAll ( " " ) ; arg0 = spaceCollapse . matcher ( arg0 ) . replaceAll ( "   " ) ; arg0 = tagSpaceCollapse . matcher ( arg0 ) . replaceAll ( " >< " ) ; return arg0 ; }
public void function ( ) { Connection con = Jsoup . connect ( FileServlet . urlTo ( " /htmltests/thumb.jpg " ) ) ; con . data ( FileServlet . ContentTypeParam , " image/jpeg " ) ; con . ignoreContentType ( true ) ; boolean threw = false ; try { con . execute ( ) ; Document doc = con . response ( ) . parse ( ) ; } catch ( IOException e ) { threw = true ; assertEquals ( " Input is binary and unsupported " , e . getMessage ( ) ) ; } assertTrue ( threw ) ; }
private static String function ( String arg0 ) { if ( arg0 = = null ) return null ; return arg0 . replaceAll ( " \" " , " %22 " ) ; }
public LoggingEventBuilder function ( String arg0 , Object arg1 ) { loggingEvent . addKeyValue ( arg0 , arg1 ) ; return this ; }
public static void function ( String [ ] arg0 ) throws Exception { if ( arg0 . length < 1 ) { usage ( ) ;
public InputSource function ( FullHttpRequest arg0 , RequestExtractor < String > arg1 ) { return new InputSource ( new StringReader ( arg1 . extract ( arg0 ) ) ) ; }
private Elements function ( ) { String key = tq . consumeToAny ( " = " , " != " , " ^= " , " $= " , " *= " , " ~= " , " ] " ) ; Validate . notEmpty ( key ) ; if ( tq . matchChomp ( " ] " ) ) { return key . startsWith ( " ^ " ) ? root . getElementsByAttributeStarting ( key . substring ( 1 ) ) : root . getElementsByAttribute ( key ) ;
public void function ( ) { for ( MocoRunnerWatcher watcher : watchers ) { watcher . start ( ) ;
protected void function ( ChannelBuffer arg0 ) { arg0 . writeBytes ( contents [ current ( ) ] . getBytes ( ) ) ; }
default Connection function ( arg0 RequestAuthenticator arg1 ) { throw new UnsupportedOperationException ( ) ; }
public void function ( ) { assertThat ( Iterables . head ( new Integer [ ] { 1 , 2 } ) , is ( 1 ) ) ; assertThat ( Iterables . head ( new Integer [ ] { 1 } ) , is ( 1 ) ) ; assertThat ( Iterables . head ( new Integer [ 0 ] ) , nullValue ( ) ) ; }
public boolean function ( HttpRequest arg0 ) { return ! matcher . match ( arg0 ) ; }
@Test public void function ( ) { Parser parser = Parser . htmlParser ( ) . settings ( ParseSettings . preserveCase ) ; Document doc = parser . parseInput ( " <!DOCTYPE html><HTML><HEAD><TITLE>SHOUTY</TITLE></HEAD><BODY>HELLO</BODY></HTML> " , " " ) ; Element body = doc . body ( ) ; assertEquals ( " BODY " , body . tagName ( ) ) ; assertEquals ( " body " , body . normalName ( ) ) ; Element head = doc . head ( ) ; assertEquals ( " HEAD " , head . tagName ( ) ) ; assertEquals ( " body " , body . normalName ( ) ) ; Element root = doc . selectFirst ( " html " ) ; assertEquals ( " HTML " , root . tagName ( ) ) ; assertEquals ( " html " , root . normalName ( ) ) ; assertEquals ( " SHOUTY " , doc . title ( ) ) ; }
public void function ( ) { InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " foo.request " ) ; server . request ( eq ( stream ( is ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public void function ( Object arg0 , Throwable arg1 ) { differentiatedLog ( null , CATEGORY_FQCN , LocationAwareLogger . WARN_INT , arg0 , arg1 ) ; }
final static boolean function ( String arg0 , int arg1 ) { if ( arg1 = = 0 ) { return false ; } char potentialEscape = arg0 . charAt ( arg1 - 1 ) ; if ( potentialEscape = = ESCAPE_CHAR ) { return true ;
public void function ( String arg0 ) { Map map = ( Map ) inheritableThreadLocal . get ( ) ; if ( map ! = null ) { map . remove ( arg0 ) ;
public final boolean function ( ) { return hasBody ; }
public void function ( ) { Supplier < String > stringSupplier = ( ) - > " String " ; logger . atDebug ( ) . addArgument ( stringSupplier ) . log ( " hello " ) ;
protected final HttpResponseSetting function ( final RequestMatcher arg0 ) { HttpSetting baseSetting = new HttpSetting ( arg0 ) ; addSetting ( baseSetting ) ; return baseSetting ; }
public void function ( ) throws Exception { Mp3File mp3File = new Mp3File ( new File ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ) ) ; testShouldThrowExceptionIfSavingMp3WithSameNameAsSourceFile ( mp3File ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeToAny ( attributeDoubleValueCharsSorted ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; else arg0 . tagPending . setEmptyAttributeValue ( ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '"' :
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 3.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private static ImmutableMap < String , String [ ] > function ( final Iterable < Map . Entry < String , String > > arg0 ) { Map < String , List < String > > headers = new HashMap < > ( ) ; for ( Map . Entry < String , String > entry : arg0 ) { String key = entry . getKey ( ) ; List < String > values = getValues ( headers , key ) ; values . add ( entry . getValue ( ) ) ; headers . put ( key , values ) ; } Map < String , String [ ] > results = new HashMap < > ( ) ; for ( Map . Entry < String , List < String > > entry : headers . entrySet ( ) ) { List < String > value = entry . getValue ( ) ; results . put ( entry . getKey ( ) , value . toArray ( new String [ value . size ( ) ] ) ) ; } return copyOf ( results ) ; }
@Override public void function ( RequestAuthenticator arg0 , HttpURLConnection arg1 ) { authenticators . set ( new AuthenticationHandler ( arg0 ) ) ; }
public String function ( ) { prepareByteData ( ) ; String body = ( charset = = null ? DataUtil . UTF_8 : Charset . forName ( charset ) ) . decode ( byteData ) . toString ( ) ; ( ( Buffer ) byteData ) . rewind ( ) ; return body ; }
private Map < String , Object > function ( final Object arg0 ) { return ( Map < String , Object > ) arg0 ; }
public Watcher function ( final Iterable < File > arg0 , final FileRunner arg1 ) { return factory . createWatcher ( listener ( arg1 ) , Iterators . toArray ( arg0 . iterator ( ) , File . class ) ) ; }
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { if ( arg2 . syntax ( ) = = Syntax . html & & ! has ( PUBLIC_ID ) & & ! has ( SYSTEM_ID ) ) { arg0 . append ( " <!doctype " ) ; } else { arg0 . append ( " <!DOCTYPE " ) ; } if ( has ( NAME ) ) arg0 . append ( "   " ) . append ( attr ( NAME ) ) ; if ( has ( PUBLIC_ID ) ) arg0 . append ( "  PUBLIC  \" " ) . append ( attr ( PUBLIC_ID ) ) . append ( '"' ) ; if ( has ( SYSTEM_ID ) ) arg0 . append ( "   \" " ) . append ( attr ( SYSTEM_ID ) ) . append ( '"' ) ; arg0 . append ( '>' ) ; }
private int function ( ) { int current = this . index ; if ( + + index > = handlers . size ( ) ) { index = 0 ; } return current ; }
public void function ( String arg0 ) { Map < String , String > map = ( Map < String , String > ) inheritableThreadLocal . get ( ) ; if ( map ! = null ) { map . remove ( arg0 ) ;
public void function ( ) { try { barrier . await ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } logger = LoggerFactory . getLogger ( this . getClass ( ) . getName ( ) + " - " + count ) ; logger . info ( " in run method " ) ; EVENT_COUNT . getAndIncrement ( ) ; }
public boolean function ( SocketAddress arg0 ) throws IOException { return sc . connect ( arg0 ) ; }
public static VerificationMode function ( int arg0 ) { checkArgument ( arg0 > = 0 , " Times count must not be less than zero " ) ; return new TimesVerification ( arg0 ) ; }
public ByteChannel function ( SelectionKey arg0 , String arg1 , int arg2 ) throws IOException ; } }
public boolean function ( Marker arg0 ) { return referenceList . remove ( arg0 ) ; }
private Document function ( final Request arg0 , final RequestExtractor < byte [ ] > arg1 ) throws SAXException { return extractDocument ( helper . extractAsInputSource ( arg0 , arg1 ) , this ) ; }
public Builder function ( String arg0 ) { arg0 = arg0 . toLowerCase ( ) ; if ( arg0 . equals ( " info " ) | | arg0 . equals ( " debug " ) | | arg0 . equals ( " trace " ) ) { this . arg0 = arg0 ; } else { if ( verbose ) { System . err . println ( " level not info/debug/trace :  " + arg0 ) ; } } return this ; }
public void function ( ) { hit = requestHit ( ) ; server = httpserver ( 2587 , hit ) ; server . request ( by ( uri ( " /target " ) ) ) . response ( " 0XCAFEBABE " ) ; }
protected String function ( String arg0 ) throws NumberFormatException { String value = arg0 . trim ( ) ; if ( value . length ( ) > 0 ) { if ( value . charAt ( 0 ) = = '(' ) { int pos = value . indexOf ( ')' ) ; if ( pos > 0 ) { return value . substring ( pos + 1 ) ; } } return value ; } return null ; }
public void function ( int arg0 , String arg1 , boolean arg2 ) { System . out . println ( " Disconnected " ) ; System . exit ( 0 ) ;
public void function ( ) { String t = " <textarea>one < two </TEXTarea> third </TEXTarea> " ; TokenQueue tq = new TokenQueue ( t ) ; String data = tq . chompToIgnoreCase ( " </textarea> " ) ; assertEquals ( " <textarea>one < two  " , data ) ; data = tq . chompToIgnoreCase ( " </textarea> " ) ; assertEquals ( "  third  " , data ) ; }
Element function ( String arg0 ) { Element el = new Element ( Tag . valueOf ( arg0 ) , baseUri ) ; insert ( el ) ; return el ; }
public void function ( ) throws Exception { httpServer = httpServer ( 12306 , fileRoot ( " src/test/resources " ) ) ; httpServer . response ( file ( " foo.response " ) ) ; HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeHttpServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public static MountTo function ( final String arg0 ) { return new MountTo ( checkNotNullOrEmpty ( arg0 , " Target should not be null " ) ) ; }
public void function ( ) throws Exception { final ID3v22Tag id3tag = new ID3v22Tag ( ) ; final String grouping = " GROUPING " ; id3tag . setGrouping ( grouping ) ; final byte [ ] bytes = id3tag . toBytes ( ) ; final ID3v22Tag newId3tag = new ID3v22Tag ( bytes ) ; assertEquals ( grouping , newId3tag . getGrouping ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /target " ) ) ) . response ( seq ( status ( 500 ) , status ( 400 ) ) ) ; server . request ( match ( uri ( " /proxy/.* " ) ) ) . response ( proxy ( from ( " /proxy " ) . to ( remoteUrl ( " /target " ) ) , failover ( " src/test/resources/failover.response " ) , 500 , 400 ) ) ; running ( server , new Runnable ( ) { @Override
private ByteBuffer function ( int arg0 ) { String errorCodeDescription ; switch ( arg0 ) { case 404 : errorCodeDescription = " 404 WebSocket Upgrade Failure " ; break ; case 500 : default : errorCodeDescription = " 500 Internal Server Error " ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( " HTTP/1.1  " + errorCodeDescription + " \ r \ nContent-Type: text/html \ r \ nServer: TooTallNate Java-WebSocket \ r \ nContent-Length:  " + ( 48 + errorCodeDescription . length ( ) ) + " \ r \ n \ r \ n<html><head></head><body><h1> " + errorCodeDescription + " </h1></body></html> " ) ) ; }
public void function ( ) { runner . stop ( ) ; monitor . stopMonitor ( ) ; }
public static void function ( String arg0 , String arg1 ) throws IllegalArgumentException { if ( arg0 = = null ) { throw new IllegalArgumentException ( " key parameter cannot be null " ) ; } if ( mdcAdapter = = null ) { throw new IllegalStateException ( " MDCAdapter cannot be null. See also  " + NULL_MDCA_URL ) ; } mdcAdapter . put ( arg0 , arg1 ) ; }
private static boolean function ( String arg0 ) { return arg0 = = null | | arg0 . startsWith ( " text " ) | | arg0 . endsWith ( " javascript " ) | | arg0 . endsWith ( " json " ) | | arg0 . endsWith ( " xml " ) ; }
public boolean function ( ) { return inData . hasRemaining ( ) | | ( inCrypt . hasRemaining ( ) & & readEngineResult . getStatus ( ) ! = Status . BUFFER_UNDERFLOW & & readEngineResult . getStatus ( ) ! = Status . CLOSED ) ; }
void function ( String arg0 ) { if ( errors . canAddError ( ) ) errors . add ( new ParseError ( reader . pos ( ) , arg0 ) ) ;
public WebSocketImpl function ( WebSocketAdapter arg0 , List < Draft > arg1 , SocketChannel arg2 ) { if ( sslContext ! = null ) try { SSLEngine e = sslContext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; return new WebSocketImpl ( arg0 , arg1 , new SSLSocketChannel ( arg2 , e ) ) ; } catch ( Exception e1 ) { } return new WebSocketImpl ( arg0 , arg1 , arg2 ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 25 , new Draft_6455 ( ) ) ; }
public FileContainer function ( ) { FileContainer container = new FileContainer ( name ) ; container . charset = toCharset ( charset ) . orElse ( null ) ; if ( charset = = null ) { container . content = null ; } return container ; }
public void function ( ) { ta . append ( " You are connected to ChatServer:  " + getURI ( ) + " \ n " ) ; ta . setCaretPosition ( ta . getDocument ( ) . getLength ( ) ) ; }
public void function ( ) throws Exception { final SocketServer server = jsonSocketServer ( file ( " src/test/resources/base.json " ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( File arg0 , String arg1 ) throws FileNotFoundException { PrintStream stream = null ; try { stream = new PrintStream ( new FileOutputStream ( arg0 ) ) ;
void function ( Appendable arg0 , int arg1 , Document . OutputSettings arg2 ) throws IOException { final boolean prettyPrint = arg2 . prettyPrint ( ) ; final Element parent = parentNode instanceof Element ? ( ( Element ) parentNode ) : null ; final boolean parentIndent = parent ! = null & & parent . shouldIndent ( arg2 ) ; final boolean blank = isBlank ( ) ; if ( parentIndent & & StringUtil . startsWithNewline ( coreValue ( ) ) & & blank ) return ; if ( prettyPrint & & ( ( siblingIndex = = 0 & & parent ! = null & & parent . tag ( ) . formatAsBlock ( ) & & ! blank ) | | ( arg2 . outline ( ) & & siblingNodes ( ) . size ( ) > 0 & & ! blank ) ) ) indent ( arg0 , arg1 , arg2 ) ; final boolean normaliseWhite = prettyPrint & & ! Element . preserveWhitespace ( parentNode ) ; final boolean stripWhite = prettyPrint & & parentNode instanceof Document ; Entities . escape ( arg0 , coreValue ( ) , arg2 , false , normaliseWhite , stripWhite ) ; }
protected void function ( byte [ ] arg0 ) throws InvalidDataException { String filetype ; try { filetype = BufferTools . byteBufferToString ( arg0 , 1 , 3 ) ; } catch ( UnsupportedEncodingException e ) { filetype = " unknown " ; } mimeType = " image/ " + filetype . toLowerCase ( ) ; pictureType = arg0 [ 4 ] ; int marker = BufferTools . indexOfTerminatorForEncoding ( arg0 , 5 , arg0 [ 0 ] ) ; if ( marker > = 0 ) { description = new EncodedText ( arg0 [ 0 ] , BufferTools . copyBuffer ( arg0 , 5 , marker - 5 ) ) ; marker + = description . getTerminator ( ) . length ; } else { description = new EncodedText ( arg0 [ 0 ] , " " ) ; marker = 1 ; } imageData = BufferTools . copyBuffer ( arg0 , marker , arg0 . length - marker ) ; }
public void function ( ) { if ( getReadyState ( ) = = READYSTATE . NOT_YET_CONNECTED ) { closeConnection ( CloseFrame . NEVER_CONNECTED , true ) ; } if ( draft = = null ) { closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ;
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " ) ; assertThat ( helper . get ( remoteUrl ( " /mount/mount.response " ) ) , is ( " response from mount " ) ) ; }
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { String html = Entities . escape ( getWholeText ( ) , arg2 ) ; if ( arg2 . prettyPrint ( ) & & parent ( ) instanceof Element & & ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( arg2 . prettyPrint ( ) & & siblingIndex ( ) = = 0 & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) & & ! isBlank ( ) ) indent ( arg0 , arg1 , arg2 ) ; arg0 . append ( html ) ; }
protected void function ( ChannelHandlerContext arg0 , FullHttpRequest arg1 ) throws Exception { eventBus . post ( arg1 ) ; httpRequestReceived ( arg0 , arg1 ) ; }
public void function ( ) { { Object [ ] cyclicA = new Object [ 1 ] ; cyclicA [ 0 ] = cyclicA ; assertEquals ( " [[...]] " , MessageFormatter . arrayFormat ( " {} " , cyclicA ) ) ; } { Object [ ] a = new Object [ 2 ] ;
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) | | isWhitespace ( arg0 ) | | ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " html " ) ) ) { return arg1 . process ( arg0 , InBody ) ; } else if ( arg0 . isEOF ( ) ) { } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " nofrmes " ) ) { return arg1 . process ( arg0 , InHead ) ; } else { arg1 . error ( this ) ; arg1 . transition ( InBody ) ; return arg1 . process ( arg0 ) ; } return true ; }
public void function ( ) { JsonPathRequestExtractor unitUnderTest = new JsonPathRequestExtractor ( " $.detail_item_list[*].number " ) ; HttpRequest request = DefaultHttpRequest . builder ( ) . withStringContent ( " { \ n " + "      \" detail_item_list \" :[ \ n " + "     { \ n " + "          \" number \" : 100 \ n " + "      }] \ n " + " } " + " \" number \" : 100 " + " }]} " ) . build ( ) ; Optional < Object > result = unitUnderTest . extract ( request ) ; assertThat ( result . isPresent ( ) , is ( true ) ) ; String [ ] texts = ( String [ ] ) result . get ( ) ; assertThat ( texts [ 0 ] , is ( " 100 " ) ) ; }
@Test public void function ( ) { String h = " <p>Hello<p>there<p>world " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " there " , doc . select ( " p " ) . eq ( 1 ) . text ( ) ) ; assertEquals ( " there " , doc . select ( " p " ) . get ( 1 ) . text ( ) ) ; }
public static RequestMatcher function ( final RequestMatcher arg0 ) { return new NotRequestMatcher ( arg0 ) ; }
@Test void function ( ) { String html = " <table>foo<tr>bar<td>baz</td>qux</tr>coo</table> " ; Document doc = Jsoup . parse ( html , TrackingParser ) ; List < TextNode > textNodes = doc . nodeStream ( TextNode . class ) . collect ( Collectors . toList ( ) ) ; assertEquals ( 5 , textNodes . size ( ) ) ; assertEquals ( " 1,8:7-1,11:10 " , textNodes . get ( 0 ) . sourceRange ( ) . toString ( ) ) ; assertEquals ( " 1,15:14-1,18:17 " , textNodes . get ( 1 ) . sourceRange ( ) . toString ( ) ) ; assertEquals ( " 1,22:21-1,25:24 " , textNodes . get ( 2 ) . sourceRange ( ) . toString ( ) ) ; assertEquals ( " 1,30:29-1,33:32 " , textNodes . get ( 3 ) . sourceRange ( ) . toString ( ) ) ; assertEquals ( " 1,38:37-1,41:40 " , textNodes . get ( 4 ) . sourceRange ( ) . toString ( ) ) ; }
public boolean function ( Marker arg0 ) { return isErrorEnabled ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.7.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
void function ( ) { if ( stack . size ( ) > maxQueueDepth ) return ; Element last = lastFormattingElement ( ) ; if ( last = = null | | onStack ( last ) ) return ; Element entry = last ; int size = formattingElements . size ( ) ; int ceil = size - maxUsedFormattingElements ; if ( ceil < 0 ) ceil = 0 ; int pos = size - 1 ; boolean skip = false ; while ( true ) { if ( pos = = ceil ) { skip = true ; break ; } entry = formattingElements . get ( - - pos ) ; if ( entry = = null | | onStack ( entry ) ) break ; } while ( true ) { if ( ! skip )
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.18 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( String [ ] arg0 ) { ShutdownArgs shutdownArgs = parse ( arg0 ) ; socketShutdown ( shutdownArgs . getShutdownPort ( defaultShutdownPort ) , defaultShutdownKey ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { error ( arg1 , arg2 ) ; }
private boolean function ( final TextContainer arg0 ) { return " exist " . equals ( arg0 . getOperation ( ) ) ; }
public void function ( ) throws Exception { server . request ( path ( uri ( " /{path} " ) ) ) . response ( " bar " ) ; server . request ( path ( uri ( " /path/{path} " ) ) ) . response ( " path " ) ; server . request ( path ( uri ( " /path/{path}/sub/{sub} " ) ) ) . response ( " sub " ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ;
public void function ( ) { FileResourceReader reader = new FileResourceReader ( text ( new File ( " src/test/resources/unknown.response " ) . getPath ( ) ) ) ; assertThrows ( IllegalArgumentException . class , ( ) - > reader . readFor ( ( Request ) null ) ) ;
public void function ( ) throws IOException { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; assertThat ( Files . toString ( cacheFile , Charset . defaultCharset ( ) ) , is ( " foo " ) ) ; }
public static String function ( String arg0 , String arg1 , Safelist arg2 , Document . OutputSettings arg3 ) { Document dirty = parseBodyFragment ( arg0 , arg1 ) ; Cleaner cleaner = new Cleaner ( arg2 ) ; Document clean = cleaner . clean ( dirty ) ; clean . arg3 ( arg3 ) ; return clean . body ( ) . html ( ) ; }
private void function ( RandomAccessFile arg0 ) throws IOException , UnsupportedTagException , InvalidDataException { if ( xingOffset = = 0 | | startOffset = = 0 ) { id3v2Tag = null ;
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; assertFalse ( frameData . equals ( " 8 " ) ) ; }
public void function ( ) throws Exception { EncodedText encodedText = new EncodedText ( fromHex ( " ff fe  " + UNICODE_TEST_STRING_HEX_UTF16LE ) ) ; assertEquals ( EncodedText . TEXT_ENCODING_UTF_16 , encodedText . getTextEncoding ( ) ) ; }
private ID3v2TextFrameData function ( ) { ID3v2TextFrameData frameData = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_TEXT ) ) ; return frameData ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { arg0 . setAttachment ( index ) ; index + + ; System . out . println ( arg0 . getRemoteSocketAddress ( ) . getAddress ( ) . getHostAddress ( ) + "  entered the room! ID:  "
@Test public void function ( ) throws IOException { Connection con = Jsoup . connect ( FileServlet . urlTo ( " /htmltests/test-rss.xml " ) ) ; con . data ( FileServlet . ContentTypeParam , " application/rss+xml " ) ; Document doc = con . get ( ) ; Element title = doc . selectFirst ( " title " ) ; assertEquals ( " jsoup RSS news " , title . text ( ) ) ; assertEquals ( " channel " , title . parent ( ) . nodeName ( ) ) ; assertEquals ( " jsoup RSS news " , doc . title ( ) ) ; assertEquals ( 3 , doc . select ( " link " ) . size ( ) ) ; assertEquals ( " application/rss+xml " , con . response ( ) . contentType ( ) ) ; assertEquals ( Document . OutputSettings . Syntax . xml , doc . outputSettings ( ) . syntax ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " proxy.json " ) ; String content = helper . get ( remoteUrl ( " /failover-with-status " ) ) ; assertThat ( content , is ( " proxy " ) ) ; content = helper . get ( remoteUrl ( " /failover-with-status " ) ) ; assertThat ( content , is ( " proxy " ) ) ; }
public String function ( ) { int start = pos ; while ( ! isEmpty ( ) & & ( matchesWord ( ) | | matchesAny ( " | " ) ) ) pos + + ; return queue . substring ( start , pos ) ; }
private TextContainer function ( final TextContainer arg0 ) { String name = names . get ( arg0 . getOperation ( ) ) ; if ( name = = null ) { return arg0 ; } return builder ( ) . withOperation ( name ) . withText ( arg0 . getText ( ) ) . withProps ( arg0 . getProps ( ) ) . build ( ) ; }
public static RestSettingBuilder function ( final RestIdMatcher arg0 ) { return RestSettingBuilders . single ( HttpMethod . HEAD , checkNotNull ( arg0 , " ID Matcher should not be null " ) ) ; }
public RequestMatcher function ( final String arg0 ) { return match ( uri ( join ( resourceRoot ( arg0 ) , " [^/]* " ) ) ) ; }
public static RequestMatcher function ( ContentStream arg0 ) { return new ContentMatcher ( arg0 . asByteArray ( ) ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 10 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ) ;
private static void function ( String arg0 , ArrayList < CharacterRef > arg1 ) throws IOException { String base = projectDir + " /src/main/java/org/jsoup/nodes " ; File file = new File ( base , arg0 ) ; FileWriter writer = new FileWriter ( file , false ) ; for ( CharacterRef ref : arg1 ) { writer . append ( ref . toString ( ) ) . append ( " \ n " ) ; } writer . close ( ) ; }
public void function ( ) throws Exception { httpServer = httpServer ( 12306 , context ( " /foo " ) ) ; anotherServer = httpServer ( 12306 , context ( " /bar " ) ) ; final HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeHttpServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
protected HttpResponse function ( HttpRequest arg0 , arg1 . arg2 . arg3 . HttpResponse arg4 ) throws IOException { int statusCode = arg4 . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode = = HttpResponseStatus . BAD_REQUEST . code ( ) ) { return failover . failover ( arg0 ) ; } HttpResponse httpResponse = setupNormalResponse ( arg4 ) ; failover . onCompleteResponse ( arg0 , httpResponse ) ; return httpResponse ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.10 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { Thread . currentThread ( ) . setName ( " WebSocketWriteThread- " + Thread . currentThread ( ) . getId ( ) ) ; try { runWriteData ( ) ;
private void function ( HttpURLConnection arg0 , Connection . Response arg1 ) throws IOException { method = Method . valueOf ( arg0 . getRequestMethod ( ) ) ; url = arg0 . getURL ( ) ; statusCode = arg0 . getResponseCode ( ) ; statusMessage = arg0 . getResponseMessage ( ) ; contentType = arg0 . getContentType ( ) ; Map < String , List < String > > resHeaders = arg0 . getHeaderFields ( ) ; processResponseHeaders ( resHeaders ) ; if ( arg1 ! = null ) { for ( Map . Entry < String , String > prevCookie : arg1 . cookies ( ) . entrySet ( ) ) {
public static ByteBuffer function ( ByteBuffer arg0 ) { ByteBuffer sbuf = ByteBuffer . allocate ( arg0 . remaining ( ) ) ; byte prev ; byte cur = '0' ; while ( arg0 . hasRemaining ( ) ) { prev = cur ; cur = arg0 . get ( ) ; sbuf . put ( cur ) ; if ( prev = = ( byte ) '\r' & & cur = = ( byte ) '\n' ) { sbuf . limit ( sbuf . position ( ) - 2 ) ; sbuf . position ( 0 ) ; return sbuf ; } } arg0 . position ( arg0 . position ( ) - sbuf . position ( ) ) ; return null ; }
public void function ( ) throws Exception { server = httpserver ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . request ( by ( uri ( " /global-request " ) ) ) . response ( text ( " blah " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws NoSuchFieldException , IllegalAccessException { Document doc = Jsoup . parse ( " <div><p><a href=foo>One</a> " ) ; Element div = doc . selectFirst ( " div " ) ; Element p = doc . selectFirst ( " p " ) ; Element a = doc . selectFirst ( " a " ) ; assertEquals ( " " , div . attr ( " href " ) ) ; p . removeAttr ( " href " ) ; Elements hrefs = doc . select ( " [href] " ) ; assertEquals ( 1 , hrefs . size ( ) ) ; assertFalse ( div . hasAttributes ( ) ) ; assertFalse ( p . hasAttributes ( ) ) ; assertTrue ( a . hasAttributes ( ) ) ; }
private String function ( ServiceReference arg0 , String arg1 ) { StringBuilder output = new StringBuilder ( ) ; if ( arg0 ! = null ) { output . append ( '[' ) . append ( arg0 . toString ( ) ) . append ( ']' ) ; } else { output . append ( UNKNOWN ) ; } output . append ( arg1 ) ; return output . toString ( ) ; }
protected MessageContent function ( final HttpRequest arg0 ) { return recorder . getContent ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " settings/details/foo.json " , " settings/details/bar.json " ) ; assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " foo " ) ) ; assertThat ( helper . get ( remoteUrl ( " /bar " ) ) , is ( " bar " ) ) ; }
public void function ( ) { for ( ThreadSafeRunnerWatcher monitor : monitors ) { monitor . stop ( ) ;
private Function < ResponseHandler , ResponseHandler > function ( final MocoConfig arg0 ) { return new Function < ResponseHandler , ResponseHandler > ( ) { @Override
public void function ( ) { if ( runner ! = null ) { runner . stop ( ) ;
protected Options function ( ) { Options options = new Options ( ) ; options . addOption ( configOption ( ) ) ; options . addOption ( portOption ( ) ) ; options . addOption ( ShutdownPortOption . shutdownPortOption ( ) ) ; options . addOption ( settingsOption ( ) ) ; options . addOption ( envOption ( ) ) ; options . addOption ( httpsCertificate ( ) ) ; options . addOption ( keyStore ( ) ) ; options . addOption ( cert ( ) ) ; return options ; }
public void function ( ) throws Exception { server . request ( xml ( text ( " <request><parameters><id>1</id></parameters></request> " ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
protected boolean function ( ) { return key . startsWith ( Attributes . dataPrefix ) & & key . length ( ) > Attributes . dataPrefix . length ( ) ; }
public void function ( String arg0 , Throwable arg1 ) { log ( LOG_LEVEL_WARN , arg0 , arg1 ) ; }
public static Resource function ( final String arg0 , final Resource arg1 , final CookieOption . . . arg2 ) { return arg1 ( id ( " cookie " ) , cookieConfigApplier ( arg0 , arg1 ) , new ResourceReader ( ) { @Override
public WebSocketImpl function ( WebSocketAdapter arg0 , List < Draft > arg1 , SocketChannel arg2 ) ; } }
protected synchronized void function ( int arg0 , String arg1 , boolean arg2 ) { if ( flushandclosestate ) { return ; } closecode = arg0 ; closemessage = arg1 ; closedremotely = arg2 ; flushandclosestate = true ; wsl . onWriteDemand ( this ) ; try { wsl . onWebsocketClosing ( this , arg0 , arg1 , arg2 ) ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; } if ( draft ! = null ) draft . reset ( ) ; handshakerequest = null ; }
public static ResponseHandler function ( final Resource arg0 , final Resource . . . arg1 ) { checkNotNull ( arg0 , " Sequence content should not be null " ) ; checkArgument ( arg1 . length > 0 , " Sequence contents should not be null " ) ; return newCycle ( FluentIterable . from ( asIterable ( arg0 , arg1 ) ) . transform ( resourceToResourceHandler ( ) ) ) ; }
public ProxyContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return builder ( ) . withUrl ( arg0 . getText ( ) . trim ( ) ) . build ( ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { InternalProxyContainer container = get ( arg0 . readValuesAs ( InternalProxyContainer . class ) , 0 ) ; return container . toProxyContainer ( ) ; } return ( ProxyContainer ) arg1 . handleUnexpectedToken ( ProxyContainer . class , arg0 ) ; }
boolean function ( String arg0 ) { if ( arg0 = = null ) { return false ; } File file = new File ( arg0 ) ; if ( file . exists ( ) & & file . isDirectory ( ) ) { return true ;
public Whitelist function ( String arg0 , String arg1 , String . . . arg2 ) { super . arg2 ( arg0 , arg1 , arg2 ) ; return this ; }
public void function ( ) { final ID3v22Tag id3tag = new ID3v22Tag ( ) ; inputBytes [ ID3v22Tag . FLAGS_OFFSET ] = BufferTools . setBit ( ZERO , ID3v22Tag . COMPRESSION_BIT , false ) ; id3tag . unpackFlags ( inputBytes ) ; id3tag . packFlags ( outputBytes , 0 ) ; assertFalse ( BufferTools . checkBit ( outputBytes [ ID3v22Tag . FLAGS_OFFSET ] , ID3v22Tag . COMPRESSION_BIT ) ) ; }
static RequestExecutor function ( Request arg0 , arg1 Response arg2 ) { if ( Boolean . getBoolean ( SharedConstants . UseHttpClient ) & & clientConstructor ! = null ) { try {
public void function ( ) { org . slf4j . Logger logger = LoggerFactory . getLogger ( " aa " ) ; logger . atTrace ( ) . addKeyValue ( " a " , " n " ) . setCause ( new Throwable ( ) ) . log ( " aa " ) ; }
@Test public void function ( ) { String html = " <table><tr><form><input type=hidden id=1><td><input type=text id=2></td><tr></table> " ; Document doc = Jsoup . parse ( html ) ; Element el = doc . select ( " form " ) . first ( ) ; assertTrue ( " Is form element " , el instanceof FormElement ) ; FormElement form = ( FormElement ) el ; Elements controls = form . elements ( ) ; assertEquals ( 2 , controls . size ( ) ) ; assertEquals ( " 1 " , controls . get ( 0 ) . id ( ) ) ; assertEquals ( " 2 " , controls . get ( 1 ) . id ( ) ) ; assertEquals ( " <table><tbody><tr><form></form><input type= \" hidden \"  id= \" 1 \" ><td><input type= \" text \"  id= \" 2 \" ></td></tr><tr></tr></tbody></table> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
static URL function ( URL arg0 ) { arg0 = punyUrl ( arg0 ) ; try {
public void function ( ) throws IOException { LoggerFinder finder = System . LoggerFinder . getLoggerFinder ( ) ; assertEquals ( EXPECTED_FINDER_CLASS , finder . getClass ( ) . getName ( ) ) ; Logger systemLogger = finder . getLogger ( " smoke " , null ) ; systemLogger . log ( Level . INFO , " hello " ) ; systemLogger . log ( Level . INFO , " hello {0} " , " world " ) ; List < String > results = SPS . stringList ; assertEquals ( 2 , results . size ( ) ) ; assertEquals ( " INFO smoke - hello " , results . get ( 0 ) ) ; assertEquals ( " INFO smoke - hello world " , results . get ( 1 ) ) ; }
public static ContentResource function ( final byte [ ] arg0 ) { checkNotNull ( arg0 , " Binary should not be null " ) ; try { return arg0 ( ByteSource . wrap ( arg0 ) . openStream ( ) ) ;
public void function ( ) { MocoHttpsServer server = new MocoHttpsServer ( createLogServer ( of ( port ( ) ) ) , MocoTestHelper . CERTIFICATE ) ; server . stop ( ) ; }
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return ApiUtils . endsWith ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
protected MoreObjects . ToStringHelper function ( ) { return super . toStringHelper ( ) . add ( " version " , version )
public static Object function ( String arg0 ) { return org . slf4j . MDC . get ( arg0 ) ; }
public static String function ( CtBehavior arg0 ) throws NotFoundException { String returnValue = " " ; if ( methodReturnsValue ( arg0 ) ) { returnValue = "  returns:  \"  + $_ +  \" . " ; } return returnValue ; }
public static ResponseHandler function ( final String . . . arg0 ) { return seq ( from ( copyOf ( arg0 ) ) . transform ( textToResource ( ) ) . toArray ( Resource . class ) ) ; }
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { if ( arg1 . isEmpty ( ) ) { arg0 . eofError ( this ) ; arg0 . transition ( Data ) ; return ; } char c = arg1 . consume ( ) ; switch ( c ) { case '-' :
public static WritableResource function ( String arg0 ) { checkNotNull ( arg0 , " Null filename is not allowed " ) ; File file = new File ( arg0 ) ; return new FileResource ( file ) ; }
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( request ) . match ( request ) , is ( true ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>One<p>Two<p>Three " ) ; String origHtml = doc . html ( ) ; Element newP = doc . createElement ( " p " ) . text ( " New " ) ; Elements ps = doc . select ( " p " ) ; int size = ps . size ( ) ; assertFalse ( ps . remove ( newP ) ) ; assertFalse ( ps . remove ( newP . childNodes ( ) ) ) ; assertEquals ( origHtml , doc . html ( ) ) ; assertEquals ( size , ps . size ( ) ) ; }
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( HttpMethod . POST ) . withTextContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest failover = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withMethod ( HttpMethod . POST ) . withTextContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( failover ) . match ( request ) , is ( true ) ) ; }
public static void function ( byte [ ] arg0 , int arg1 , int arg2 , byte [ ] arg3 , int arg4 ) { if ( arg2 > 0 ) { System . arraycopy ( arg0 , arg1 , arg3 , arg4 , arg2 ) ;
protected byte [ ] function ( ) { ByteBuffer bb = ByteBuffer . allocate ( getLength ( ) ) ; bb . put ( id . getBytes ( ) ) ; bb . put ( ( byte ) 0 ) ; bb . put ( getFlags ( ) ) ; bb . put ( ( byte ) children . length ) ; for ( String child : children ) { bb . put ( child . getBytes ( ) ) ; bb . put ( ( byte ) 0 ) ; } for ( ID3v2Frame frame : subframes ) { try { bb . put ( frame . toBytes ( ) ) ; } catch ( NotSupportedException e ) { e . printStackTrace ( ) ; } } return bb . array ( ) ; }
public void function ( ) { running = tryToConnect ( new InetSocketAddress ( uri . getHost ( ) , getPort ( ) ) ) ; while ( this . running ) { try {
public void function ( ) throws IOException { new FileWrapper ( NON_EXISTENT_FILENAME ) ; }
public void function ( ) { UnsupportedTagException exception = new UnsupportedTagException ( ) ; assertNull ( exception . getMessage ( ) ) ; assertNull ( exception . getCause ( ) ) ; }
public String function ( Character arg0 , Character arg1 ) { StringBuilder accum = new StringBuilder ( ) ; int depth = 0 ; Character last = null ; do { if ( isEmpty ( ) ) break ; Character c = consume ( ) ; if ( last = = null | | ! last . equals ( ESC ) ) { if ( c . equals ( arg0 ) ) depth + + ; else if ( c . equals ( arg1 ) ) depth - - ; } if ( depth > 0 & & last ! = null ) accum . append ( c ) ; last = c ; } while ( depth > 0 ) ; return accum . toString ( ) ; }
private void function ( ) { InputStream in = AccessController . doPrivileged ( ( PrivilegedAction < InputStream > ) ( ) - > { ClassLoader threadCL = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( threadCL ! = null ) { return threadCL . getResourceAsStream ( CONFIGURATION_FILE ) ; } else { return ClassLoader . getSystemResourceAsStream ( CONFIGURATION_FILE ) ; } } ) ; if ( null ! = in ) { try {
private void function ( char arg0 ) { tq . consumeWhitespace ( ) ; String subQuery = consumeSubQuery ( ) ; Elements output ; if ( arg0 = = '>' ) output = filterForChildren ( elements , select ( subQuery , elements ) ) ; else if ( arg0 = = ' ' ) output = filterForDescendants ( elements , select ( subQuery , elements ) ) ; else if ( arg0 = = '+' ) output = filterForAdjacentSiblings ( elements , select ( subQuery , root ) ) ; else if ( arg0 = = '~' ) output = filterForGeneralSiblings ( elements , select ( subQuery , root ) ) ; else throw new IllegalStateException ( " Unknown combinator:  " + arg0 ) ; elements . clear ( ) ; elements . addAll ( output ) ; }
public void function ( String arg0 , Throwable arg1 ) { log . trace ( arg0 , arg1 ) ; }
public String function ( String arg0 ) throws IOException { Content content = Request . Get ( arg0 ) . execute ( ) . returnContent ( ) ; return content . asString ( ) ; }
public PongWebSocketFrame function ( PingWebSocketFrame arg0 ) { ByteBuf content = arg0 . content ( ) ; byte [ ] bytes = toByteArray ( content ) ; for ( PingPongSetting setting : settings ) { if ( Arrays . equals ( bytes , setting . getPing ( ) . getBytes ( ) ) ) { ByteBuf buf = Unpooled . wrappedBuffer ( setting . getPong ( ) . getBytes ( ) ) ; return new PongWebSocketFrame ( buf ) ; } } throw new IllegalArgumentException ( ) ; }
private void function ( ) { String tagName = tq . consumeElementSelector ( ) ; Validate . notEmpty ( tagName ) ; if ( tagName . contains ( " | " ) ) tagName = tagName . replace ( " | " , " : " ) ; evals . add ( new Evaluator . Tag ( tagName . trim ( ) ) ) ; }
public String [ ] function ( FullHttpRequest arg0 ) { try { NodeList list = ( NodeList ) xPathExpression . evaluate ( helper . extractAsInputSource ( arg0 , extractor ) , XPathConstants . NODESET ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 ) { recordEvent ( Level . INFO , arg0 , arg1 , new Object [ ] { arg2 } , null ) ; }
@Test public void function ( ) { String html = " <p One=One One=Two one=Three two=Four two=Five Two=Six>Text</p> " ; Parser parser = Parser . htmlParser ( ) . settings ( ParseSettings . preserveCase ) ; Document doc = parser . parseInput ( html , " " ) ; assertEquals ( " <p One= \" One \"  one= \" Three \"  two= \" Four \"  Two= \" Six \" >Text</p> " , doc . selectFirst ( " p " ) . outerHtml ( ) ) ; }
public void function ( ) throws UnsupportedEncodingException { byte [ ] buffer = { BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_T , BYTE_A , BYTE_G } ; try { BufferTools . byteBufferToString ( buffer , - 1 , 4 ) ;
public void function ( WebSocket arg0 , Handshakedata arg1 ) { counter + + ; System . out . println ( " ///////////Opened connection number " + counter ) ; }
@Test public void function ( ) throws IOException { File in = ParseTest . getFile ( " /htmltests/comments.html " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertEquals ( " <!--?xml version= \" 1.0 \"  encoding= \" utf-8 \" ?--> <!-- so --><!DOCTYPE html PUBLIC  \" -//W3C//DTD XHTML 1.0 Transitional//EN \"   \" http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd \" > <!-- what --> <html xml:lang= \" en \"  lang= \" en \"  xmlns= \" http://www.w3.org/1999/xhtml \" > <!-- now --> <head> <!-- then --> <meta http-equiv= \" Content-type \"  content= \" text/html; charset=utf-8 \" > <title>A Certain Kind of Test</title> </head> <body> <h1>Hello</h1>h1&gt; (There is a UTF8 hidden BOM at the top of this file.) </body> </html> " , StringUtil . normaliseWhitespace ( doc . html ( ) ) ) ; assertEquals ( " A Certain Kind of Test " , doc . head ( ) . select ( " title " ) . text ( ) ) ; }
public void function ( ) throws Exception { HttpResponse response = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) ; Header header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; response = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) ; header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; }
public void function ( Node arg0 , int arg1 ) { String name = arg0 . nodeName ( ) ; if ( arg0 instanceof TextNode ) append ( ( ( TextNode ) arg0 ) . text ( ) ) ;
@Test void function ( ) { assertEquals ( " foo:bar " , resolve ( " \ nhttps:// \ texample.com/ " , " \ r \ nfo \ to:ba \ br " ) ) ; }
@Test public void function ( ) { String h = " <td>Hello<td><p>There<p>now " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <table><tr><td>Hello</td><td><p>There</p><p>now</p></td></tr></table> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
private HttpMessage function ( final Map < String , String > arg0 ) { return DefaultHttpResponse . builder ( ) . forHeaders ( arg0 )
public ContentResource function ( final String arg0 ) { ensureTemplate ( ) ; if ( hasProperties ( ) ) { return template ( invokeTarget ( arg0 , this . text , ContentResource . class ) , toVariables ( this . props ) ) ; } return template ( invokeTarget ( arg0 , this . text , ContentResource . class ) ) ; }
public void function ( boolean arg0 ) { this . arg0 = arg0 ; }
public void function ( ) throws Exception { server . resource ( " targets " , patch ( " 1 " ) . response ( with ( text ( " patch result " ) ) ) ) ; running ( server , ( ) - > assertThat ( helper . patchForResponse ( remoteUrl ( " /targets/1 " ) , " result " ) , is ( " patch result " ) ) ) ; }
private FullHttpResponse function ( FullHttpRequest arg0 ) { HttpRequest request = DefaultHttpRequest . newRequest ( arg0 ) ; FullHttpResponse response = getHttpResponse ( request ) . toFullResponse ( ) ; prepareForKeepAlive ( arg0 , response ) ; monitor . onMessageLeave ( response ) ; return response ; }
public void function ( final SessionContext arg0 ) { HttpRequest request = arg0 . getRequest ( ) ; Optional < URL > url = remoteUrl ( request ) ; if ( ! url . isPresent ( ) ) { return ; } HttpResponse response = doProxy ( request , url . get ( ) ) ; writeHttpResponse ( arg0 , response ) ; }
private HttpsCertificate function ( final MocoCertificate arg0 ) { return HttpsCertificate . arg0 ( getResource ( arg0 ) , arg0 . keyStorePassword ( ) , arg0 . certPassword ( ) ) ; }
private void function ( int arg0 , int arg1 ) { hasAttrName = true ; if ( attrName ! = null ) { attrNameSb . append ( attrName ) ; attrName = null ; } if ( trackSource ) { attrNameStart = attrNameStart > Unset ? attrNameStart : arg0 ;
String function ( String arg0 ) { arg0 = arg0 . trim ( ) ; if ( ! preserveTagCase ) arg0 = arg0 . toLowerCase ( ) ; return arg0 ; }
public static RequestMatcher function ( final Resource arg0 ) { return match ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { error ( arg1 , arg2 , arg3 ) ; }
public void function ( ) { while ( ! queue . isEmpty ( ) & & Character . isWhitespace ( queue . peekFirst ( ) ) ) { consume ( ) ;
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , put ( " 1 " ) ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( Element arg0 ) { return arg0 . elementSiblingIndex ( ) < index ; }
protected final RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { return new PathMatcher < > ( arg0 , arg1 ) ; }
public String function ( String arg0 , String arg1 ) { if ( arg0 = = null ) { return null ; } Set < Cookie > cookies = decoder . decode ( arg0 ) ; Cookie cookie = find ( cookies , byCookieName ( arg1 ) , null ) ; return cookie = = null ? null : cookie . getValue ( ) ; }
public void function ( WebSocket arg0 , String arg1 ) { onClientMessage ( arg0 , arg1 ) ; }
private Attribute function ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeAttributeKey ( ) ; String value = " " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( " = " ) ) { tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ; while ( ! tq . matchesAny ( " < " , " /> " , " > " ) & & ! tq . matchesWhitespace ( ) & & ! tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( ! key . isEmpty ( ) ) return Attribute . createFromEncoded ( key , value ) ;
protected Node function ( Node arg0 ) { Node clone ; try { clone = ( Node ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } clone . parentNode = arg0 ; clone . siblingIndex = arg0 = = null ? 0 : siblingIndex ; return clone ; }
public void function ( ) throws Exception { server . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public int function ( ) { return timeoutMilliseconds ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.5.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( String arg0 ) { if ( logger . isLoggable ( Level . FINEST ) ) { log ( SELF , Level . FINEST , arg0 , null ) ;
CharsetEncoder function ( ) { CharsetEncoder ce = encoder . get ( ) ; if ( ! ce . charset ( ) . equals ( charset ) ) { encoder . remove ( ) ; ce = encoder . get ( ) ; } return ce ; }
private Runner function ( StartArgs arg0 ) { if ( arg0 . hasConfigurationFile ( ) ) { return createDynamicConfigurationRunner ( arg0 ) ; } return createDynamicSettingRunner ( arg0 ) ; }
public void function ( ) { Profiler profiler = new Profiler ( " BAS " ) ; profiler . start ( " doX " ) ; doX ( 1 ) ; profiler . start ( " doY " ) ; doY ( 10 ) ; profiler . start ( " doZ " ) ; doZ ( 2 ) ; profiler . stop ( ) ; profiler . sanityCheck ( ) ; StopWatch gSW = profiler . globalStopWatch ; assertEquals ( TimeInstrumentStatus . STOPPED , gSW . status ) ; assertEquals ( 3 , profiler . childTimeInstrumentList . size ( ) ) ; assertNotNull ( profiler . getLastTimeInstrument ( ) ) ; assertEquals ( " doZ " , profiler . getLastTimeInstrument ( ) . getName ( ) ) ; }
public static MocoConfig function ( final String arg0 ) { return new MocoContextConfig ( checkNotNull ( arg0 , " Context should not be null " ) ) ; }
public ResponseHandler function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . URI_ID ) ) { return new RestHandler ( ( String ) arg0 . apply ( name ) , settings ) ; } return this ; }
public void function ( ) { ID3v2TextFrameData frameData1 = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_TEXT ) ) ; ID3v2TextFrameData frameData2 = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_TEXT ) ) ; assertEquals ( frameData1 , frameData2 ) ; }
public void function ( ) throws Exception { ID3v2PopmFrameData iD3v2PopmFrameData1 = new ID3v2PopmFrameData ( false , 1 ) ; iD3v2PopmFrameData1 . setAddress ( " Address1 " ) ; ID3v2PopmFrameData iD3v2PopmFrameData2 = new ID3v2PopmFrameData ( false , 1 ) ; iD3v2PopmFrameData1 . setAddress ( " Address2 " ) ; assertFalse ( iD3v2PopmFrameData1 . equals ( iD3v2PopmFrameData2 ) ) ; }
void function ( StringBuilder arg0 , Throwable arg1 ) { PrintStream targetStream = OUTPUT_CHOICE . getTargetPrintStream ( ) ; targetStream . println ( arg0 . toString ( ) ) ; writeThrowable ( arg1 , targetStream ) ; targetStream . flush ( ) ; }
final String function ( ) { return tagName ! = null ? tagName : " [unset] " ; }
protected final MessageContent function ( final HttpRequest arg0 ) { HttpRequest recordedRequest = getRequiredRecordedRequest ( arg0 ) ; return modifier . getMessageContent ( recordedRequest ) ; }
public final void function ( WebSocket arg0 , byte [ ] arg1 ) { onMessage ( arg1 ) ; }
private void function ( File arg0 ) { try { InplaceFileConverter fc = new InplaceFileConverter ( ruleSet ,
public void function ( ) throws Exception { ID3v2ChapterFrameData frameData1 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2ChapterFrameData frameData2 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2TextFrameData subFrameData2 = new ID3v2TextFrameData ( false , new EncodedText ( " Hello there " ) ) ; frameData2 . addSubframe ( " TIT2 " , subFrameData2 ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
@Test void function ( ) { String h = "         <table> \ n " + "             <tr> \ n " + "                 <td> \ n " + "                     <p style= \" display:inline; \" >A</p> \ n " + "                     <p style= \" display:inline; \" >B</p> \ n " + "                 </td> \ n " + "             </tr> \ n " + "         </table> " ; Document doc = Jsoup . parse ( h ) ; String out = doc . body ( ) . html ( ) ; assertEquals ( " <table> \ n " + "  <tbody> \ n " +
static DurationUnit function ( StopWatch arg0 ) { return selectDurationUnitForDisplay ( arg0 . elapsedTime ( ) ) ; }
public void function ( ) throws Exception { String imageFilename = " test-res/Some Artist - Some Album.png " ; tryAddImage ( TEST_FILE_WITH_IMAGE_WITH_ARTIST_AND , imageFilename ) ; }
public static Runner function ( final SocketServer arg0 ) { return new MocoSocketServer ( ( ActualSocketServer ) checkNotNull ( arg0 , " Server should not be null " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public boolean function ( PropertyDescriptor arg0 ) { try { return arg0 . getReadMethod ( ) . invoke ( request ) ! = null ;
protected void function ( HttpRequest arg0 , MutableHttpResponse arg1 ) { arg1 . setStatus ( status . code ( ) ) ; }
void function ( String arg0 ) throws IOException { String password = AuthFilter . newServerPassword ( ) ; Connection . Response res = Jsoup . connect ( arg0 ) . header ( AuthFilter . WantsServerAuthentication , " 1 " ) . ignoreHttpErrors ( true ) . execute ( ) ; assertEquals ( 401 , res . statusCode ( ) ) ; }
final static public void function ( StringBuffer arg0 , int arg1 ) { while ( arg1 > = 32 ) { arg0 . append ( SPACES [ 5 ] ) ; arg1 - = 32 ; } for ( int i = 4 ; i > = 0 ; i - - ) { if ( ( arg1 & ( 1 < < i ) ) ! = 0 ) {
private File function ( ) { System . out . println ( " dest  " + destination ) ; File fileDest = new File ( destination ) ; if ( ! fileDest . isDirectory ( ) ) { System . out . println ( " dest path is not a valid source directory " ) ; return null ; } if ( fileDest . exists ( ) ) { if ( delDestination ) { delete ( fileDest ) ; } else { System . out . println ( " Destination file already exists " ) ; } } return fileDest ; }
public void function ( ) { DocumentType fail = new DocumentType ( " html " , null , null ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.1.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 2.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( FullHttpRequest arg0 , FullHttpResponse arg1 ) { try { URL url = remoteUrl ( arg0 ) ;
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_FF , BYTE_FB , 2 , 3 , 4 , BYTE_FF , BYTE_E0 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , BYTE_FF , BYTE_F0 } ; byte [ ] expectedBuffer = { BYTE_FF , 0 , BYTE_FB , 2 , 3 , 4 , BYTE_FF , 0 , BYTE_E0 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , BYTE_FF , 0 , BYTE_F0 } ; byte [ ] unsynchronised = BufferTools . unsynchroniseBuffer ( buffer ) ; byte [ ] synchronised = BufferTools . synchroniseBuffer ( unsynchronised ) ; assertTrue ( Arrays . equals ( expectedBuffer , unsynchronised ) ) ; assertTrue ( Arrays . equals ( buffer , synchronised ) ) ; }
public void function ( File arg0 ) { logger . info ( " {} change detected. " , arg0 . getName ( ) ) ; try { jsonRunner . stop ( ) ;
public HttpResponseSetting function ( String arg0 ) { return this . response ( status ( HttpResponseStatus . FOUND . code ( ) ) , header ( " Location " , checkNotNullOrEmpty ( arg0 , " URL should not be null " ) ) ) ; }
public HandshakeBuilder function ( Handshakedata arg0 , HandshakeBuilder arg1 ) throws InvalidHandshakeException { arg1 . setHttpStatusMessage ( " Web Socket Protocol Handshake " ) ; arg1 . put ( " Upgrade " , " WebSocket " ) ; arg1 . put ( " Connection " , arg0 . getFieldValue ( " Connection " ) ) ; arg1 . put ( " WebSocket-Origin " , arg0 . getFieldValue ( " Origin " ) ) ; String location = " ws:// " + arg0 . getFieldValue ( " Host " ) + arg0 . getResourceDescriptor ( ) ; arg1 . put ( " WebSocket-Location " , location ) ; return arg1 ; }
public void function ( ) { ID3v2PictureFrameData frameData = new ID3v2PictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 3 , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , DUMMY_IMAGE_DATA ) ; assertFalse ( frameData . equals ( " 8 " ) ) ; }
public void function ( String arg0 ) { this . arg0 = arg0 ; startTime = System . nanoTime ( ) ; status = TimeInstrumentStatus . STARTED ; }
public String function ( ) { final String remainder = queue . substring ( pos ) ; pos = queue . length ( ) ; return remainder ; }
public void function ( ) { assertEquals ( 9 , Util . getJavaMajorVersion ( " 9ea " ) ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <p>Hello " ) ; Element p = doc . selectFirst ( " p " ) ; Element body = p . parent ( ) ; assertNotNull ( body ) ; assertEquals ( " body " , body . tagName ( ) ) ; p . wrap ( " <div></div> There " ) ; Element div = p . parent ( ) ; assertNotNull ( div ) ; assertEquals ( " div " , div . tagName ( ) ) ; assertSame ( div , p . parent ( ) ) ; assertSame ( body , div . parent ( ) ) ; assertEquals ( " <div><p>Hello</p></div> There " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public static ContentResource function ( final Resource arg0 , final Optional < Charset > arg1 , final Optional < MocoConfig > arg2 ) { return contentResource ( id ( MocoConfig . FILE_ID ) , fileConfigApplier ( MocoConfig . FILE_ID , arg0 ) , new FileResourceReader ( arg0 , arg1 , arg2 ) ) ; }
public boolean function ( Element arg0 ) { return arg0 . attributes ( ) . get ( name ) . matches ( value ) ; }
private synchronized ByteBuffer function ( ByteBuffer arg0 ) throws SSLException { outCrypt . compact ( ) ; engineResult = sslEngine . wrap ( arg0 , outCrypt ) ; outCrypt . flip ( ) ; return outCrypt ; }
public String function ( final String arg0 , final String arg1 ) throws IOException { return postBytes ( arg0 , arg1 . getBytes ( ) ) ; }
@Test public void function ( ) { String html = " <a normal= \" 123 \"  boolean empty= \" \" ></a> " ; Element el = Jsoup . parse ( html ) . select ( " a " ) . first ( ) ; assertEquals ( " 123 " , el . attr ( " normal " ) ) ; assertEquals ( " " , el . attr ( " boolean " ) ) ; assertEquals ( " " , el . attr ( " empty " ) ) ; List < Attribute > attributes = el . attributes ( ) . asList ( ) ; assertEquals ( " There should be 3 attribute present " , 3 , attributes . size ( ) ) ; assertFalse ( " 'normal' attribute should not be boolean " , attributes . get ( 0 ) instanceof BooleanAttribute ) ; assertTrue ( " 'boolean' attribute should be boolean " , attributes . get ( 1 ) instanceof BooleanAttribute ) ; assertFalse ( " 'empty' attribute should not be boolean " , attributes . get ( 2 ) instanceof BooleanAttribute ) ; assertEquals ( html , el . outerHtml ( ) ) ; }
protected BaseSetting < SocketResponseSetting > function ( final RequestMatcher arg0 ) { return new SocketSetting ( arg0 ) ; }
private RequestMatcher function ( String arg0 , Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return json ( arg1 ) ; } if ( Map . class . isInstance ( arg1 ) ) { return createCompositeMatcher ( arg0 , castToMap ( arg1 ) ) ; } if ( TextContainer . class . isInstance ( arg1 ) ) { return createSingleTextMatcher ( arg0 , TextContainer . class . cast ( arg1 ) ) ; } throw new IllegalArgumentException ( " unknown configuration : " + arg1 ) ; }
public static String function ( final Map arg0 ) { try { return DEFAULT_MAPPER . writeValueAsString ( arg0 ) ;
public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( echoUrl ) . method ( Method . DELETE ) . execute ( ) ; Document doc = res . parse ( ) ; assertEquals ( " DELETE " , ihVal ( " Method " , doc ) ) ; assertEquals ( null , ihVal ( " Post Data " , doc ) ) ; }
public void function ( ) throws Exception { final HttpServer server = jsonHttpServer ( port ( ) , pathResource ( " foo.json " ) ) ; running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ) ; }
public void function ( Exception arg0 ) { } } ; webSocket . connectBlocking ( ) ; assertTrue ( " webSocket.isOpen() " , webSocket . isOpen ( ) ) ; webSocket . getSocket ( ) . close ( ) ; countDownLatch . await ( ) ; assertTrue ( " !webSocket.isOpen() " , ! webSocket . isOpen ( ) ) ; assertTrue ( " !wasOpenClient " , ! wasOpenClient ) ; assertTrue ( " !wasOpenServer " , ! wasOpenServer ) ; server . stop ( ) ; } }
private Predicate < Field > function ( ) { return new Predicate < Field > ( ) { @Override
@Test public void function ( ) throws Exception { Document docA = Jsoup . parse ( " <div/>One " ) ; Document docB = Jsoup . parse ( " <div/>One " ) ; Document docC = Jsoup . parse ( " <div/>Two " ) ; assertFalse ( docA . equals ( docB ) ) ; assertTrue ( docA . equals ( docA ) ) ; assertEquals ( docA . hashCode ( ) , docA . hashCode ( ) ) ; assertFalse ( docA . hashCode ( ) = = docC . hashCode ( ) ) ; }
public void function ( Marker arg0 ) { if ( arg0 = = null ) return ; if ( markers = = null ) { markers = new ArrayList < > ( 2 ) ; } markers . add ( arg0 ) ; }
protected HttpResponse function ( final HttpRequest arg0 , final arg1 . arg2 . arg3 . HttpResponse arg4 ) throws IOException { int statusCode = arg4 . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode = = HttpResponseStatus . BAD_REQUEST . code ( ) ) { return failover . failover ( arg0 ) ; } HttpResponse httpResponse = setupNormalResponse ( arg4 ) ; failover . onCompleteResponse ( arg0 , httpResponse ) ; return httpResponse ; }
private Predicate < ResponseHandler > function ( ) { return new Predicate < ResponseHandler > ( ) { @Override
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
Element function ( Token . StartTag arg0 ) { if ( arg0 . isSelfClosing ( ) ) { Element el = insertEmpty ( arg0 ) ; stack . add ( el ) ; tokeniser . transition ( TokeniserState . Data ) ; tokeniser . emit ( emptyEnd . reset ( ) . name ( el . tagName ( ) ) ) ; return el ; } Element el = new Element ( Tag . valueOf ( arg0 . name ( ) , settings ) , baseUri , settings . normalizeAttributes ( arg0 . attributes ) ) ; insert ( el ) ; return el ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.16.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public OutputSettings function ( boolean arg0 ) { forceAllElementAsBlock = arg0 ; return this ; }
public void function ( ) { try { assertThat ( MocoTestHelper . get ( " http://localhost:8080 " ) , is ( " bar " ) ) ;
@Test public void function ( ) { CharacterReader r = new CharacterReader ( " one " ) ; assertEquals ( 'o' , r . consume ( ) ) ; assertEquals ( 'n' , r . current ( ) ) ; r . unconsume ( ) ; assertEquals ( 'o' , r . current ( ) ) ; assertEquals ( 'o' , r . consume ( ) ) ; assertEquals ( 'n' , r . consume ( ) ) ; assertEquals ( 'e' , r . consume ( ) ) ; assertTrue ( r . isEmpty ( ) ) ; r . unconsume ( ) ; assertFalse ( r . isEmpty ( ) ) ; assertEquals ( 'e' , r . current ( ) ) ; assertEquals ( 'e' , r . consume ( ) ) ; assertTrue ( r . isEmpty ( ) ) ; assertEquals ( CharacterReader . EOF , r . consume ( ) ) ; r . unconsume ( ) ; assertTrue ( r . isEmpty ( ) ) ; r . unconsume ( ) ; assertFalse ( r . isEmpty ( ) ) ; assertEquals ( 'e' , r . consume ( ) ) ; assertTrue ( r . isEmpty ( ) ) ; assertEquals ( CharacterReader . EOF , r . consume ( ) ) ; assertTrue ( r . isEmpty ( ) ) ; for ( int i = 0 ; i < 4 ; i + + ) { r . unconsume ( ) ; } assertThrows ( UncheckedIOException . class , r : : unconsume ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeToAnySorted ( attributeSingleValueCharsSorted ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\'' :
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( final Channel arg0 ) { this . group . remove ( arg0 ) ; final MocoGroup group = this . channelGroups . get ( arg0 ) ; if ( group ! = null ) { this . channelGroups . remove ( arg0 ) ;
public static ContentResource function ( final String arg0 , final Optional < Charset > arg1 ) { return file ( text ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , checkNotNull ( arg1 , " Charset should not be null " ) ) ; }
public void function ( ) { locLogger . info ( Production . APPLICATION_STARTED ) ;
@Test void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element p = doc . expectFirst ( " p " ) ; p . prepend ( " Text <!-- comment -->  " ) ; assertEquals ( " Text <!-- comment --> Hello " , TextUtil . stripNewlines ( p . html ( ) ) ) ; }
public String function ( String arg0 , String arg1 ) { Cookie cookie = new DefaultCookie ( arg0 , arg1 ) ; cookie . setPath ( " / " ) ; return ServerCookieEncoder . encode ( cookie ) ; }
private void function ( InetSocketAddress arg0 ) throws IOException { client = SocketChannel . open ( ) ; client . configureBlocking ( false ) ; client . connect ( arg0 ) ; selector = Selector . open ( ) ; client . register ( selector , SelectionKey . OP_CONNECT ) ; }
public void function ( ) { LoggerFinder finder = System . LoggerFinder . getLoggerFinder ( ) ; Logger systemLogger = finder . getLogger ( " x " , null ) ; systemLogger . log ( Level . INFO , " hello " ) ; }
public void function ( final MessageContent arg0 , final JsonGenerator arg1 , final SerializerProvider arg2 ) throws IOException { if ( arg0 . hasCharset ( ) ) { arg1 . writeObject ( new InternalMessageContent ( arg0 . getContent ( ) , arg0 . getCharset ( ) ) ) ; return ; } arg1 . writeString ( new String ( arg0 . getContent ( ) ) ) ; }
@Test void function ( ) { String html = " <div>One</div><div>DESTROY</div><div>Two</div> " ; StreamParser parser = new StreamParser ( Parser . htmlParser ( ) ) . parse ( html , " " ) ; parser . parse ( html , " " ) ; parser . stream ( ) . forEach ( el - > { if ( el . ownText ( ) . equals ( " DESTROY " ) ) el . remove ( ) ; } ) ; Document doc = parser . document ( ) ; Elements divs = doc . select ( " div " ) ; assertEquals ( 2 , divs . size ( ) ) ; assertEquals ( " One Two " , divs . text ( ) ) ; }
@Test public void function ( ) { String html = " <p>test</p><div /><div>Two</div> " ; Parser parser = Parser . htmlParser ( ) . setTrackErrors ( 5 ) ; parser . parseInput ( html , " " ) ; assertEquals ( 1 , parser . getErrors ( ) . size ( ) ) ; assertEquals ( " 18: Tag cannot be self closing; not a void tag " , parser . getErrors ( ) . get ( 0 ) . toString ( ) ) ; assertFalse ( Jsoup . isValid ( html , Safelist . relaxed ( ) ) ) ; String clean = Jsoup . clean ( html , Safelist . relaxed ( ) ) ; assertEquals ( " <p>test</p> <div></div> <div> Two </div> " , StringUtil . normaliseWhitespace ( clean ) ) ; }
public static Document function ( InputStream arg0 , String arg1 , String arg2 ) throws IOException { return DataUtil . load ( arg0 , arg1 , arg2 ) ; }
public ResponseSetting function ( MocoEventTrigger arg0 ) { this . eventTriggers . add ( checkNotNull ( arg0 , " Trigger should not be null " ) ) ; return this ; }
public void function ( ) { FramedataImpl1 binary = FramedataImpl1 . get ( Opcode . BINARY ) ; assertEquals ( " Opcode must be equal " , Opcode . BINARY , binary . getOpcode ( ) ) ; assertEquals ( " Fin must be set " , true , binary . isFin ( ) ) ; assertEquals ( " transferredMask must not be set " , false , binary . getTransfereMasked ( ) ) ; assertEquals ( " Payload must be empty " , 0 , binary . getPayloadData ( ) . capacity ( ) ) ; assertEquals ( " RSV1 must be false " , false , binary . isRSV1 ( ) ) ; assertEquals ( " RSV2 must be false " , false , binary . isRSV2 ( ) ) ; assertEquals ( " RSV3 must be false " , false , binary . isRSV3 ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isDebugEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 )
public Optional < String > function ( final HttpRequest arg0 ) { return of ( arg0 . getUri ( ) ) ; }
private void function ( Mp3File arg0 ) throws Exception { assertTrue ( arg0 . hasId3v1Tag ( ) ) ; assertTrue ( arg0 . hasId3v2Tag ( ) ) ; }
public void function ( ) { setTrialEnabled ( true ) ; Square square = new Square ( ) ; assertEquals ( " org.slf4j.Square " , square . logger . getName ( ) ) ; assertMismatchDetected ( false ) ; }
public void function ( ) throws Exception { ID3v1Tag id3v1tag = new ID3v1Tag ( ) ; id3v1tag . setTitle ( " TITLE " ) ; id3v1tag . setArtist ( " ARTIST " ) ; id3v1tag . setAlbum ( " ALBUM " ) ; id3v1tag . setYear ( " 2001 " ) ; id3v1tag . setComment ( " COMMENT " ) ; id3v1tag . setTrack ( " 1 " ) ; id3v1tag . setGenre ( 0x0d ) ; byte [ ] expectedBuffer = BufferTools . stringToByteBuffer ( VALID_TAG_WITH_WHITESPACE , 0 , VALID_TAG_WITH_WHITESPACE . length ( ) ) ; TestHelper . replaceSpacesWithNulls ( expectedBuffer ) ; expectedBuffer [ expectedBuffer . length - 3 ] = 0x00 ; expectedBuffer [ expectedBuffer . length - 2 ] = 0x01 ; expectedBuffer [ expectedBuffer . length - 1 ] = 0x0D ; assertTrue ( Arrays . equals ( expectedBuffer , id3v1tag . toBytes ( ) ) ) ; }
public static MountPredicate function ( final String arg0 ) { return not ( include ( arg0 ) ) ; }
public < T > ImmutableList < T > function ( final InputStream arg0 , final Class < T > arg1 ) { try { CollectionType type = factory . constructCollectionType ( List . class , arg1 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.7.13 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public static void function ( arg0 final String arg1 , final String arg2 ) { if ( arg1 = = null | | arg1 . length ( ) = = 0 ) throw new ValidationException ( String . format ( " The '%s' parameter must not be empty. " , arg2 ) ) ;
private static Map < Character , String > function ( Map < String , Character > arg0 ) { Map < Character , String > outMap = new HashMap < Character , String > ( ) ; for ( Map . Entry < String , Character > entry : arg0 . entrySet ( ) ) { Character character = entry . getValue ( ) ; String name = entry . getKey ( ) ; if ( outMap . containsKey ( character ) ) { if ( name . toLowerCase ( ) . equals ( name ) ) outMap . put ( character , name ) ; } else { outMap . put ( character , name ) ; } } return outMap ; }
protected void function ( int arg0 , boolean arg1 ) { closeConnection ( arg0 , " " , arg1 ) ; }
final public static String function ( final String arg0 , final Object [ ] arg1 ) { FormattingTuple ft = arrayFormat ( arg0 , arg1 , null ) ; return ft . getMessage ( ) ; }
public static RequestMatcher function ( ContentStream arg0 ) { return new ContentMatcher ( arg0 . asByteArray ( ) ) ; }
final static boolean function ( String arg0 , int arg1 ) { if ( arg1 > = 2 & & arg0 . charAt ( arg1 - 2 ) = = ESCAPE_CHAR ) {
public final SocketArgs function ( ) { return new SocketArgs ( port , shutdownPort , configurationFile , quiet ) ; }
public static CorsConfig function ( final String . . . arg0 ) { return new CorsHeadersConfig ( arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.1.5 " ) ; assertEquals ( " NON-STRICT " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( HttpResponse arg0 ) { for ( ResponseHandler handler : handlers ) { handler . writeToResponse ( arg0 ) ;
public String function ( final Response arg0 ) { HttpResponse httpResponse = ( HttpResponse ) arg0 ; StringBuilder buf = new StringBuilder ( ) ; buf . append ( responseProtocolLine ( httpResponse ) ) . append ( StringUtil . NEWLINE ) . append ( headerJoiner . join ( httpResponse . getHeaders ( ) ) ) . append ( asContent ( httpResponse ) ) ; return buf . toString ( ) ; }
public static Resource function ( final HttpMethod arg0 ) { return methodResource ( checkNotNull ( arg0 , " HTTP method should not be null " ) . toString ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.3.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public T function ( ) { ArrayDeque < T > stack = getStack ( ) ; if ( ! stack . isEmpty ( ) ) { return stack . pop ( ) ; } return initializer . get ( ) ; }
public void function ( ) throws Exception { final ID3v22Tag id3tag = new ID3v22Tag ( ) ; inputBytes [ ID3v22Tag . FLAGS_OFFSET ] = BufferTools . setBit ( ZERO , ID3v22Tag . UNSYNCHRONISATION_BIT , true ) ; id3tag . unpackFlags ( inputBytes ) ; id3tag . packFlags ( outputBytes , 0 ) ; assertTrue ( BufferTools . checkBit ( outputBytes [ ID3v22Tag . FLAGS_OFFSET ] , ID3v22Tag . UNSYNCHRONISATION_BIT ) ) ; }
public void function ( ) throws UnsupportedEncodingException { byte [ ] buffer = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " TAG- " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 0 ) ; byte [ ] expectedBuffer = { BYTE_T , BYTE_A , BYTE_G , BYTE_DASH , 0 , 0 , 0 , 0 , 0 , 0 } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <a abs:href='odd'>One</a> " ) ; Element el = doc . select ( " a " ) . first ( ) ; assertTrue ( el . hasAttr ( " abs:href " ) ) ; assertEquals ( " odd " , el . attr ( " abs:href " ) ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div><p>Hello</p><p></p></div> " ) ; Element div = doc . select ( " div " ) . first ( ) ; Elements ps = doc . select ( " p " ) ; assertTrue ( div . hasText ( ) ) ; assertTrue ( ps . first ( ) . hasText ( ) ) ; assertFalse ( ps . last ( ) . hasText ( ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { recordEvent ( Level . ERROR , arg0 , null , arg1 ) ; }
public T function ( String arg0 ) { Validate . notEmpty ( arg0 , " Cookie name must not be empty " ) ; cookies . remove ( arg0 ) ; return ( T ) this ; }
public void function ( final String arg0 , final Object arg1 ) { if ( this . headers . containsKey ( arg0 ) & & isSingleValueHeader ( arg0 ) ) { this . headers . remove ( arg0 ) ; } doAddHeader ( arg0 , arg1 ) ; }
@Test void function ( ) { String html = " <style><img></style><math><svg><style><img></img></style></svg></math> " ; Document doc = Jsoup . parse ( html ) ; Element htmlStyle = doc . expectFirst ( " style " ) ; assertHtmlNamespace ( htmlStyle ) ; assertEquals ( " <img> " , htmlStyle . data ( ) ) ; Element svgStyle = doc . expectFirst ( " svg style " ) ; assertMathNamespace ( svgStyle ) ; Element styleImg = svgStyle . expectFirst ( " img " ) ; assertHtmlNamespace ( styleImg ) ; assertMathNamespace ( doc . expectFirst ( " svg " ) ) ; assertMathNamespace ( doc . expectFirst ( " math " ) ) ; }
public void function ( ) { this . mocoRunnerMonitor . stopMonitor ( ) ; this . runner . stop ( ) ; }
public void function ( ) throws Exception { HttpsServer server = httpsServer ( port ( ) , pathCertificate ( " /cert.jks " , " mocohttps " , " mocohttps " ) ) ; server . request ( by ( " foo " ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( Level arg0 ) { switch ( arg0 . levelInt ) { case Level . TRACE_INT : return lbLogger . isTraceEnabled ( ) ; case Level . DEBUG_INT : return lbLogger . isDebugEnabled ( ) ; case Level . INFO_INT : return lbLogger . isInfoEnabled ( ) ; case Level . WARN_INT : return lbLogger . isWarnEnabled ( ) ; case Level . ERROR_INT : return lbLogger . isErrorEnabled ( ) ; case Priority . FATAL_INT : return lbLogger . isErrorEnabled ( ) ; } return false ; }
public ResponseHandler function ( final MocoConfig arg0 ) { FluentIterable < Resource > transformedResources = from ( copyOf ( resources ) ) . transform ( applyConfig ( arg0 ) ) ; return new SequenceContentHandler ( transformedResources . toArray ( Resource . class ) ) ; }
boolean function ( Token arg0 , TreeBuilder arg1 ) { arg1 . error ( this ) ; boolean processed = true ; if ( StringUtil . in ( arg1 . currentElement ( ) . nodeName ( ) , " table " , " tbody " , " tfoot " , " thead " , " tr " ) ) { arg1 . setFosterInserts ( true ) ; processed = arg1 . process ( arg0 , InBody ) ; arg1 . setFosterInserts ( false ) ; } else { processed = arg1 . process ( arg0 , InBody ) ; } return processed ; }
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " none " , false ) ; doc . updateMetaCharsetElement ( true ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; final String xmlCharsetUTF8 = " <?xml version= \" 1.0 \"  encoding= \" " + charsetUtf8 + " \" ?> \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetUTF8 , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetUtf8 , selectedNode . attr ( " encoding " ) ) ; }
final private void function ( String arg0 , LogRecord arg1 ) { StackTraceElement [ ] steArray = new Throwable ( ) . getStackTrace ( ) ; int selfIndex = - 1 ; for ( int i = 0 ; i < steArray . length ; i + + ) { final String className = steArray [ i ] . getClassName ( ) ; if ( barrierMatch ( arg0 , className ) ) { selfIndex = i ; break ; } } int found = - 1 ; for ( int i = selfIndex + 1 ; i < steArray . length ; i + + ) { final String className = steArray [ i ] . getClassName ( ) ; if ( ! ( barrierMatch ( arg0 , className ) ) ) { found = i ; break ; } } if ( found ! = - 1 ) { StackTraceElement ste = steArray [ found ] ;
public void function ( Object arg0 ) { logger . info ( arg0 . toString ( ) ) ; }
public void function ( ) { String xml = " <doc><val>One<val>Two</val></bar>Three</doc> " ; Document doc = Jsoup . parse ( xml , " http://foo.com/ " , Parser . xmlParser ( ) ) ; assertEquals ( " <doc><val>One<val>Two</val>Three</val></doc> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
protected int function ( Element arg0 , Element arg1 ) { return arg1 . elementSiblingIndex ( ) + 1 ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.23.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private SslHandler function ( HttpsCertificate arg0 ) { SSLEngine sslEngine = arg0 . createSSLEngine ( ) ; sslEngine . setUseClientMode ( false ) ; return new SslHandler ( sslEngine ) ; }
@Test public void function ( ) { String test71540chars = " \ ud869 \ udeb2 \ u304b \ u309a  1 " ; String test71540charsExpectedSingleWhitespace = " \ ud869 \ udeb2 \ u304b \ u309a 1 " ; assertEquals ( test71540charsExpectedSingleWhitespace , normaliseWhitespace ( test71540chars ) ) ; String extractedText = Jsoup . parse ( test71540chars ) . text ( ) ; assertEquals ( test71540charsExpectedSingleWhitespace , extractedText ) ; }
public void function ( ) throws IOException { assertThat ( helper . postContent ( root ( ) , " foo " ) , is ( " bar " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withVersion ( " HTTP/1.1 " ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest failover = DefaultHttpRequest . builder ( ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( failover ) . match ( request ) , is ( true ) ) ; }
public void function ( ) { logger . warn ( message , param1 , param2 ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . WARN , twoParams , null ) ; }
public void function ( ) throws Exception { server . post ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public void function ( String arg0 , Throwable arg1 ) { if ( ! logger . isErrorEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( null , fqcn ,
private Map < String , String [ ] > function ( final List < NameValuePair > arg0 ) { final Multimap < String , String > multimap = ArrayListMultimap . create ( ) ; for ( NameValuePair query : arg0 ) { multimap . put ( query . getName ( ) , query . getValue ( ) ) ; } Map < String , String [ ] > result = new HashMap < > ( ) ; for ( String key : multimap . keys ( ) ) { final Collection < String > strings = multimap . get ( key ) ; result . put ( key , strings . toArray ( new String [ 0 ] ) ) ; } return result ; }
public void function ( ) { this . mocoRunnerWatcher . stop ( ) ; this . runner . stop ( ) ; }
public void function ( WebSocket arg0 , Framedata arg1 ) { pongBuffer = arg1 . getPayloadData ( ) . array ( ) ; pongLatch . countDown ( ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { recordEvent_0Args ( Level . WARN , arg0 , arg1 , arg2 ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) | | isWhitespace ( arg0 ) | | ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " html " ) ) ) { return arg1 . process ( arg0 , InBody ) ; } else if ( arg0 . isEOF ( ) ) { } else { arg1 . error ( this ) ; arg1 . transition ( InBody ) ; return arg1 . process ( arg0 ) ; } return true ; }
public static ActualHttpServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoMonitor arg2 , final MocoConfig . . . arg3 ) { return new ActualHttpServer ( arg0 , arg1 , arg2 , arg3 ) ; }
public boolean function ( Collection < ? > arg0 ) { return contents . retainAll ( arg0 ) ; }
private ID3v2CommentFrameData function ( String arg0 , boolean arg1 ) { ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { Iterator < ID3v2Frame > iterator = frameSet . getFrames ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) iterator . next ( ) ; ID3v2CommentFrameData frameData ; try { frameData = new ID3v2CommentFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; if ( arg1 & & ITUNES_COMMENT_DESCRIPTION . equals ( frameData . getDescription ( ) . toString ( ) ) ) { return frameData ; } else if ( ! arg1 ) { return frameData ; } } catch ( InvalidDataException e ) { } } } return null ; }
public void function ( ) { HttpServer server = httpserver ( port ( ) ) ; server . response ( " foo " ) ; runner = httpsRunner ( server ) ; runner . start ( ) ; helper = new MocoTestHelper ( ) ; }
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false ) ; frameData . setStartOffset ( 9 ) ; assertEquals ( 9 , frameData . getStartOffset ( ) ) ; }
private InputStream function ( String arg0 ) { try { return new ByteArrayInputStream ( arg0 . getBytes ( " UTF-8 " ) ) ;
public void function ( ) throws InterruptedException { final String [ ] body = new String [ 1 ] ; Thread runner = new Thread ( ( ) - > { try { Connection . Response res = Jsoup . connect ( SlowRider . Url ) . timeout ( 15 * 1000 ) . execute ( ) ; body [ 0 ] = res . body ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } ) ; runner . start ( ) ; Thread . sleep ( 1000 * 3 ) ; runner . interrupt ( ) ; assertTrue ( runner . isInterrupted ( ) ) ; runner . join ( ) ; assertTrue ( body [ 0 ] . length ( ) > 0 ) ; assertTrue ( body [ 0 ] . contains ( " <p>Are you still there? " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " xml_struct.json " ) ; assertThat ( helper . postFile ( remoteUrl ( " /struct-xml " ) , " foo.xml " ) , is ( " response_for_xml_struct_request " ) ) ; assertThat ( helper . postContent ( remoteUrl ( " /struct-xml " ) , " <request><parameters><id>2</id></parameters></request> " ) , is ( " response_for_xml_struct_request " ) ) ; assertThat ( helper . postForResponse ( remoteUrl ( " /struct-xml " ) , " <request><parameters><foo>2</foo></parameters></request> " ) . getCode ( ) , is ( 400 ) ) ; }
public static void function ( String arg0 , String arg1 ) throws java . io . IOException { Base64 . OutputStream bos = null ; try { bos = new Base64 . OutputStream (
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . response ( text ( " blah " ) ) ; running ( server , new Runnable ( ) { @Override
public LoggingEventBuilder function ( Object arg0 ) { logggingEvent . addParameter ( arg0 ) ; return this ; }
public List < Element > function ( int arg0 , int arg1 ) { return contents . subList ( arg0 , arg1 ) ; } }
private JsonRunner function ( String [ ] arg0 ) throws IOException { ImmutableList . Builder < InputStream > builder = ImmutableList . builder ( ) ; for ( String resourceName : arg0 ) { builder . add ( Resources . getResource ( resourceName ) . openStream ( ) ) ; } return newJsonRunnerWithStreams ( builder . build ( ) , new StartArgs ( ServerType . HTTP , port ( ) , null , null , null , null , null ) ) ; }
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /fuzztests/1593.html.gz " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertNotNull ( doc ) ; Document docXml = Jsoup . parse ( new FileInputStream ( in ) , " UTF-8 " , " https://example.com " , Parser . xmlParser ( ) ) ; assertNotNull ( docXml ) ; }
public void function ( ) throws Exception { server . request ( and ( by ( uri ( " /foo " ) ) , by ( method ( HttpMethod . GET ) ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
@Override public Element function ( int arg0 , Element arg1 ) { Validate . notNull ( arg1 ) ; Element old = super . set ( arg0 , arg1 ) ; old . replaceWith ( arg1 ) ; return old ; }
private File function ( FullHttpRequest arg0 ) { String relativePath = extractor . extract ( arg0 ) ; return new File ( dir , relativePath ) ; }
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return new XmlRequestMatcher ( ( RequestExtractor < byte [ ] > ) extractor ( arg0 . id ( ) ) , arg0 ) ; }
public static RestSettingBuilder function ( final RestIdMatcher arg0 ) { return new PutRestSettingBuilder ( arg0 ) ; }
public void function ( ServerHandshake arg0 ) { switch ( finalI ) { case 0 :
public static ContentResource function ( final Object arg0 ) { return jsonResource ( checkNotNull ( arg0 , " Json object should not be null " ) ) ; }
public void function ( ) throws Exception { copyAndCheckTestMp3WithCustomTag ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS , 41 ) ; copyAndCheckTestMp3WithCustomTag ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS , 256 ) ; copyAndCheckTestMp3WithCustomTag ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS , 1024 ) ; copyAndCheckTestMp3WithCustomTag ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS , 5000 ) ; copyAndCheckTestMp3WithCustomTag ( new File ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ) , 41 ) ; copyAndCheckTestMp3WithCustomTag ( new File ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ) , 256 ) ; copyAndCheckTestMp3WithCustomTag ( new File ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ) , 1024 ) ; copyAndCheckTestMp3WithCustomTag ( new File ( MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ) , 5000 ) ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws IOException { arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; arg1 . setHeader ( " Content-Encoding " , " deflate " ) ; String doc = " <p>Hello, World!<p>That should be enough, right?<p>Hello, World!<p>That should be enough, right? " ; DeflaterOutputStream stream = new DeflaterOutputStream ( arg1 . getOutputStream ( ) , new Deflater ( Deflater . BEST_COMPRESSION , true ) ) ; stream . write ( doc . getBytes ( StandardCharsets . UTF_8 ) ) ; stream . close ( ) ; }
public void function ( ) throws Exception { ResponseHandler handler = mock ( ResponseHandler . class ) ; server . request ( by ( uri ( " /target " ) ) ) . response ( handler ) ; server . request ( by ( uri ( " /event " ) ) ) . response ( " event " ) . on ( complete ( get ( pathResource ( " template.url " ) ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " event " ) ) ) ; verify ( handler ) . writeToResponse ( any ( SessionContext . class ) ) ; }
public Map < String , String > function ( ) { return new Dataset ( ) ; }
public void function ( ) { testHandshakeRejection ( 9 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.33 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <img src='foo'> " ) ; Element img = doc . select ( " img " ) . first ( ) ; assertEquals ( " <img src= \" foo \" > " , img . toString ( ) ) ; img . remove ( ) ; assertEquals ( " <img src= \" foo \" > " , img . toString ( ) ) ; }
private HttpServer function ( List < SessionSetting > arg0 , int arg1 ) { HttpServer server = new HttpServer ( arg1 ) ; for ( SessionSetting session : arg0 ) { logger . debug ( " Parse session: {} " , session ) ; if ( session . isMount ( ) ) { MountSetting mount = session . getMount ( ) ; server . mount ( mount . getDir ( ) , to ( mount . getUri ( ) ) , mount . getMountPredicates ( ) ) ; } else if ( session . isAnyResponse ( ) ) { server . response ( session . getResponseHandler ( ) ) ; } else if ( session . isRedirectResponse ( ) ) { server . request ( requestMatcherParser . createRequestMatcher ( session . getRequest ( ) ) ) . redirectTo ( session . getRedirectTo ( ) ) ; } else { server . request ( requestMatcherParser . createRequestMatcher ( session . getRequest ( ) ) ) . response ( session . getResponseHandler ( ) ) ; } } return server ; }
public void function ( ) throws Exception { server . request ( eq ( jsonPath ( " $.book.price " ) , " 1 " ) ) . response ( " jsonpath match success " ) ; running ( server , new Runnable ( ) { @Override
void function ( Tokeniser arg0 , CharacterReader arg1 ) { switch ( arg1 . current ( ) ) { case '&' :
public static MocoEventAction function ( final Resource arg0 , final HttpHeader . . . arg1 ) { return new MocoGetRequestAction ( checkNotNull ( arg0 , " URL should not be null " ) , toHeaders ( checkNotNull ( arg1 , " Headers should not be null " ) ) ) ;
public RequestRecorder function ( ) { return new FileRequestRecorder ( tape ) ; }
public void function ( String arg0 , Object . . . arg1 ) { recordEventwithoutMarkerArgArray ( Level . DEBUG , arg0 , arg1 , null ) ; }
public static < T > Resource function ( final String arg0 , final String arg1 , final RequestExtractor < T > arg2 ) { return templateResource ( text ( checkNotNullOrEmpty ( arg0 , " Template should not be null " ) ) , ImmutableMap . of ( checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
public void function ( ) throws IOException { runWithConfiguration ( " proxy.json " ) ; String content = helper . get ( remoteUrl ( " /proxy " ) ) ; assertThat ( content , is ( " proxy_target " ) ) ; }
public void function ( ) { Pattern pattern = Pattern . compile ( " example " ) ; Evaluator . MatchesWholeOwnText evaluator = new Evaluator . MatchesWholeOwnText ( pattern ) ; assertEquals ( " :matchesWholeOwnText(example) " , evaluator . toString ( ) ) ; }
private void function ( InvalidDataException arg0 ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( arg0 . getCloseCode ( ) , arg0 . getMessage ( ) , false ) ; }
public void function ( ) { MocoHttpServer server = new MocoHttpServer ( ActualHttpServer . createLogServer ( 8080 ) ) ; server . start ( ) ; server . stop ( ) ; server . stop ( ) ; }
public static RestSettingBuilder function ( final String arg0 ) { return DeleteRestSetting . builder ( eq ( arg0 ) ) ; }
public HttpArgs function ( ) { return new HttpArgs ( port , shutdownPort , configurationFile , settings , env ) ; }
boolean function ( char [ ] arg0 ) { bufferUp ( ) ; return ! isEmpty ( ) & & Arrays . binarySearch ( arg0 , charBuf [ bufPos ] ) > = 0 ; }
public static ContentResource function ( final ContentResource arg0 ) { return new DefaultContentResource ( id ( " arg0 " ) , ResourceConfigApplierFactory . templateConfigApplier ( arg0 ) , new TemplateResourceReader ( arg0 ) ) ; }
public void function ( ) { ID3v2ChapterFrameData frameData1 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2ChapterFrameData frameData2 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 2 , 400 ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
void function ( TokeniserState arg0 ) { if ( trackErrors ) errors . add ( new ParseError ( reader . pos ( ) , " Unexpected character '%s' in input state [%s] " , reader . current ( ) , arg0 ) ) ;
public Document function ( ) { if ( select ( " html " ) . isEmpty ( ) ) appendElement ( " html " ) ; if ( head ( ) = = null ) select ( " html " ) . first ( ) . prependElement ( " head " ) ; if ( body ( ) = = null ) select ( " html " ) . first ( ) . appendElement ( " body " ) ; normalise ( this ) ; normalise ( select ( " html " ) . first ( ) ) ; normalise ( head ( ) ) ; return this ; }
public void function ( ByteBuffer arg0 ) { assert ( arg0 . hasRemaining ( ) ) ; if ( DEBUG ) System . out . println ( " process( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) , arg0 . position ( ) , arg0 . remaining ( ) ) ) + " } " ) ; if ( readystate ! = READYSTATE . NOT_YET_CONNECTED ) { decodeFrames ( arg0 ) ; ; } else { if ( decodeHandshake ( arg0 ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) ! = arg0 . hasRemaining ( ) | | ! arg0 . hasRemaining ( ) ) ; if ( arg0 . hasRemaining ( ) ) { decodeFrames ( arg0 ) ; } else if ( tmpHandshakeBytes . hasRemaining ( ) ) { decodeFrames ( tmpHandshakeBytes ) ; } } } assert ( isClosing ( ) | | isFlushAndClose ( ) | | ! arg0 . hasRemaining ( ) ) ; }
@Test public void function ( ) { Parser parser = Parser . xmlParser ( ) . settings ( ParseSettings . htmlDefault ) ; Document document = Jsoup . parse ( " <div>test</DIV><p></p> " , " " , parser ) ; assertEquals ( " <div> \ n test \ n</div> \ n<p></p> " , document . html ( ) ) ;
private MessageContent function ( final byte [ ] arg0 ) { MessageContent . Builder builder = arg0 ( ) . withContent ( arg0 ) ; if ( charset . isPresent ( ) ) { builder . withCharset ( charset . get ( ) ) ; } return builder . build ( ) ; }
@Test void function ( ) { Document doc = new Document ( " https://example.com/ " ) ; Element el = doc . body ( ) ; for ( int i = 0 ; i < = 50000 ; i + + ) { el = el . appendElement ( " p " ) ; } Element script = el . appendElement ( " script " ) ; script . text ( " script " ) ; assertFalse ( script . hasText ( ) ) ; assertEquals ( " script " , script . data ( ) ) ; assertEquals ( el . data ( ) , doc . data ( ) ) ; }
public void function ( ) throws Exception { HttpResponse httpResponse = helper . putForResponseWithHeaders ( remoteUrl ( " /targets/1 " ) , Jsons . toJson ( resource1 ) , of ( HttpHeaders . IF_MATCH , " moco " ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; }
public void function ( ) throws Exception { server . response ( binary ( ByteBuffer . wrap ( new byte [ ] { 1 , 2 , 3 } ) ) ) ; running ( server , ( ) - > { byte [ ] asBytes = helper . getAsBytes ( root ( ) ) ;
public void function ( ) { byte [ ] buffer = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; try { BufferTools . copyBuffer ( buffer , - 1 , buffer . length ) ; fail ( " ArrayIndexOutOfBoundsException expected but not thrown " ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { BufferTools . copyBuffer ( buffer , buffer . length , 1 ) ; fail ( " ArrayIndexOutOfBoundsException expected but not thrown " ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { BufferTools . copyBuffer ( buffer , 1 , buffer . length ) ;
public void function ( ) { long timePassed = System . currentTimeMillis ( ) - start ; System . err . println ( " Stop at  " + new Date ( ) + " , execution time =  " + timePassed + "  ms " ) ;
private Resource function ( final String arg0 , final TextContainer arg1 ) { if ( arg1 . isRawText ( ) ) { return invokeTarget ( arg0 , arg1 . getText ( ) , Resource . class ) ; } if ( arg1 . isForTemplate ( ) ) { if ( " version " . equalsIgnoreCase ( arg0 ) ) { return version ( arg1 . asTemplateResource ( ) ) ; } return arg1 . asTemplateResource ( arg0 ) ; } if ( arg1 . isFileContainer ( ) ) { Optional < Resource > resource = fileResource ( arg0 , FileContainer . class . cast ( arg1 ) ) ; if ( resource . isPresent ( ) ) { return resource . get ( ) ; } } throw new IllegalArgumentException ( format ( " unknown operation [%s] " , arg1 . getOperation ( ) ) ) ; }
public void function ( byte [ ] arg0 , int arg1 ) throws NotSupportedException { throw ( new NotSupportedException ( " Packing Obselete frames is not supported " ) ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div id=1 data-name=jsoup>Hello</div><p data-val=5 id=2>There</p><p id=3>No</p> " ) ; Elements withData = SelectMatch . match ( doc , Parser . parse ( " [^data-] " ) ) ; assertEquals ( 2 , withData . size ( ) ) ; assertEquals ( " 1 " , withData . first ( ) . id ( ) ) ; assertEquals ( " 2 " , withData . last ( ) . id ( ) ) ; withData = SelectMatch . match ( doc , Parser . parse ( " p[^data-] " ) ) ; assertEquals ( 1 , withData . size ( ) ) ; assertEquals ( " 2 " , withData . first ( ) . id ( ) ) ; }
protected Optional < String [ ] > function ( final HttpRequest arg0 ) { String [ ] extractedValues = from ( arg0 . getHeaders ( ) . entrySet ( ) ) . filter ( isForHeaderName ( name ) ) . transform ( toValue ( ) ) . transformAndConcat ( arrayAsIterable ( ) ) . toArray ( String . class ) ; if ( extractedValues . length > 0 ) { return of ( extractedValues ) ; } return empty ( ) ; }
void function ( Marker arg0 , String arg1 , int arg2 , Object arg3 , Throwable arg4 ) { String m = convertToString ( arg3 ) ; if ( locationAwareLogger ! = null ) { locationAwareLogger . log ( arg0 , arg1 , arg2 , m , null , arg4 ) ;
public Builder function ( final HttpMethod arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( LogRecord arg0 ) { recordList . add ( arg0 ) ; }
public void function ( FullHttpResponse arg0 ) { logger . info ( " Response return: \ n \ n{} \ n " , responseDumper . dump ( arg0 ) ) ; }
public static Function < RestSubResourceSetting , RestSetting > function ( ) { return new Function < RestSubResourceSetting , RestSetting > ( ) { @Override
public void function ( String arg0 , Object arg1 ) { delegate ( ) . error ( arg0 , arg1 ) ; }
public void function ( ) throws Exception { DefaultExtension defaultExtension = new DefaultExtension ( ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " Test " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " Test, ASDC, as, ad " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " ASDC, as,ad " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " permessage-deflate " ) ) ; }
@Test public void function ( ) throws IOException { int timeout = 3 * 1000 ; long start = System . currentTimeMillis ( ) ; boolean threw = false ; try { Jsoup . connect ( SlowRider . Url ) . timeout ( timeout ) . get ( ) ; } catch ( SocketTimeoutException e ) { long end = System . currentTimeMillis ( ) ; long took = end - start ; assertTrue ( ( " Time taken was  " + took ) , took > timeout ) ; assertTrue ( ( " Time taken was  " + took ) , took < timeout * 1.2 ) ; threw = true ; } assertTrue ( threw ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 0 , new Draft_6455 ( ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html> " ) ; assertEquals ( " <html><head><script>one</script><noscript>&lt;p&gt;two</noscript></head><body><p>three</p><p>four</p></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
private static void function ( ) { synchronized ( SUBST_FACTORY ) { SUBST_FACTORY . postInitialization ( ) ;
public RequestSetting function ( RequestHandler arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) { slf4jMessageFormatter_TwoArg ( RUN_LENGTH ) ; double duration = slf4jMessageFormatter_TwoArg ( RUN_LENGTH ) ; System . out . println ( " duration2= " + duration ) ; long referencePerf = 120 ; BogoPerf . assertDuration ( duration , referencePerf , REFERENCE_BIPS ) ; }
void function ( String arg0 , String arg1 , int arg2 , int arg3 ) { if ( arg0 = = arg1 ) { return ; } int fillerIndex = arg1 . indexOf ( Abbreviator . FILLER ) ; assertTrue ( fillerIndex > = arg2 ) ; }
public void function ( String arg0 , Throwable arg1 ) { logger . log ( FQCN , Level . DEBUG , arg0 , arg1 ) ; }
protected Optional < String > function ( final HttpRequest arg0 ) { try { URL targetUrl = url . apply ( arg0 ) ;
public void function ( final String arg0 ) { System . out . println ( arg0 ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isDebugEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( ) throws CertificateException , UnrecoverableKeyException , NoSuchAlgorithmException , KeyManagementException , KeyStoreException , IOException , URISyntaxException , InterruptedException { SSLWebSocketClient client = testIssueWithLocalServer ( " localhost " , SocketUtil . getAvailablePort ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , null ) ; assertTrue ( client . onOpen , " client is open " ) ; assertFalse ( client . onSSLError , " client has not caught a SSLHandshakeException " ) ; }
public Builder function ( final Map < String , String [ ] > arg0 ) { if ( arg0 ! = null ) { this . arg0 = copyOf ( arg0 ) ; } return this ; }
public Connection function ( int arg0 ) { req . timeout ( arg0 ) ; return this ; }
public void function ( ) throws Exception { org . apache . http . HttpResponse response = helper . getResponse ( root ( ) ) ; HttpEntity entity = response . getEntity ( ) ; MediaType mediaType = MediaType . parse ( entity . getContentType ( ) . getValue ( ) ) ; assertThat ( mediaType . type ( ) , is ( " application " ) ) ; assertThat ( mediaType . subtype ( ) , is ( " json " ) ) ; String content = CharStreams . toString ( new InputStreamReader ( entity . getContent ( ) , Charset . defaultCharset ( ) ) ) ; ObjectMapper mapper = new ObjectMapper ( ) ; PlainA responseA = mapper . readValue ( content , PlainA . class ) ; assertThat ( responseA . code , is ( 1 ) ) ; assertThat ( responseA . message , is ( " message " ) ) ; }
private HttpServer function ( StartArgs arg0 ) { if ( arg0 . isHttps ( ) ) { return ActualHttpServer . createHttpsLogServer ( arg0 . getPort ( ) , arg0 . getHttpsCertificate ( ) . get ( ) ) ; } return ActualHttpServer . createLogServer ( arg0 . getPort ( ) ) ; }
Element function ( Token . StartTag arg0 ) { if ( arg0 . isSelfClosing ( ) & & ! Tag . isKnownTag ( arg0 . name ( ) ) ) { Element el = insertEmpty ( arg0 ) ; process ( new Token . EndTag ( el . tagName ( ) ) ) ; return el ; } Element el = new Element ( Tag . valueOf ( arg0 . name ( ) ) , baseUri , arg0 . attributes ) ; insert ( el ) ; return el ; }
public DefaultHttpRequest function ( ) { return new DefaultHttpRequest ( this . getVersion ( ) , this . getContent ( ) , method , this . uri , this . getHeaders ( ) , this . queries ) ;
@Test void function ( ) { StreamParser streamer = basic ( ) ; int count = 0 ; Iterator < Element > it = streamer . iterator ( ) ; while ( it . hasNext ( ) ) { it . next ( ) ; count + + ; } assertEquals ( 7 , count ) ; assertTrue ( isClosed ( streamer ) ) ; }
public void function ( ) throws Exception { byte [ ] bytes = BufferTools . stringToByteBuffer ( LONG_T_FRAME , 0 , LONG_T_FRAME . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( bytes , 3 ) ; ID3v2ObseleteFrame frame = new ID3v2ObseleteFrame ( bytes , 0 ) ; assertEquals ( 263 , frame . getLength ( ) ) ; assertEquals ( " TP1 " , frame . getId ( ) ) ; String s = " 0Metamorphosis A a very long album B a very long album C a very long album D a very long album E a very long album F a very long album G a very long album H a very long album I a very long album J a very long album K a very long album L a very long album M0 " ; byte [ ] expectedBytes = BufferTools . stringToByteBuffer ( s , 0 , s . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( expectedBytes , 0 ) ; assertArrayEquals ( expectedBytes , frame . getData ( ) ) ; }
private void function ( Collection < Framedata > arg0 ) { if ( ! isOpen ( ) ) { throw new WebsocketNotConnectedException ( ) ; } if ( arg0 = = null ) { throw new IllegalArgumentException ( ) ; } ArrayList < ByteBuffer > outgoingFrames = new ArrayList < ByteBuffer > ( ) ; for ( Framedata f : arg0 ) { log . trace ( " send frame: {} " , f ) ; outgoingFrames . add ( draft . createBinaryFrame ( f ) ) ; } write ( outgoingFrames ) ; }
private void function ( ) { if ( future ! = null ) { future . channel ( ) . close ( ) . syncUninterruptibly ( ) ; future = null ; } if ( bossGroup ! = null ) { bossGroup . shutdownGracefully ( ) ; bossGroup = null ; } if ( workerGroup ! = null ) { workerGroup . shutdownGracefully ( ) ;
public HttpResponse function ( final String arg0 , final String arg1 ) throws IOException { Request request = Request . Put ( arg0 ) . addHeader ( CONTENT_TYPE , PLAIN_TEXT_UTF_8 . toString ( ) ) . bodyByteArray ( arg1 . getBytes ( ) ) ; return executor . execute ( request ) . returnResponse ( ) ; }
public abstract Logger function ( ListAppendingOutputStream arg0 , Level arg1 ) ; }
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( " 1 " , toJson ( resource1 ) ) , get ( " 2 " , toJson ( resource2 ) ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( File arg0 ) { String curentFileName = arg0 . getAbsolutePath ( ) . substring ( source . length ( ) ) ; File fdest = new File ( destination + " / " + curentFileName ) ; ; if ( arg0 . isDirectory ( ) ) { File [ ] files = arg0 . listFiles ( ) ;
private Function < Field , RequestMatcher > function ( final RequestSetting arg0 ) { return field - > { try {
private ResponseHandler function ( String arg0 , Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return new AndResponseHandler ( of ( with ( text ( toJson ( arg1 ) ) ) , header ( " Content-Type " , " application/json " ) ) ) ; } if ( isResource ( arg0 ) & & TextContainer . class . isInstance ( arg1 ) ) { TextContainer container = TextContainer . class . cast ( arg1 ) ; return with ( resourceFrom ( arg0 , container ) ) ; } if ( Map . class . isInstance ( arg1 ) ) { return createCompositeHandler ( arg0 , castToMap ( arg1 ) ) ; } if ( " status " . equalsIgnoreCase ( arg0 ) ) { return invokeTarget ( arg0 , Integer . parseInt ( arg1 . toString ( ) ) , ResponseHandler . class ) ; } if ( " latency " . equalsIgnoreCase ( arg0 ) ) { return with ( invokeTarget ( arg0 , Long . parseLong ( arg1 . toString ( ) ) , MocoProcedure . class ) ) ; } if ( ProxyContainer . class . isInstance ( arg1 ) ) { return createProxy ( ( ProxyContainer ) arg1 ) ; } throw new IllegalArgumentException ( format ( " unknown field [%s] " , arg0 ) ) ; }
public void function ( ) throws Exception { server . request ( eq ( version ( ) , " HTTP/1.0 " ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( WebSocket arg0 , Framedata arg1 ) { pongBuffer = arg1 . getPayloadData ( ) . array ( ) ; pongLatch . countDown ( ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${foo} ${bar} " , of ( " foo " , var ( " ANOTHER " ) , " bar " , var ( " TEMPLATE " ) ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /template " ) ) , is ( " ANOTHER TEMPLATE " ) ) ) ; }
public Resource function ( MocoConfig arg0 , Resource arg1 ) { if ( arg0 . isFor ( template . id ( ) ) ) { return ResourceFactory . templateResource ( ( ContentResource ) template . apply ( arg0 ) ) ; } return null ; }
public FileContainer function ( ) { FileContainer container = new FileContainer ( name ) ; container . charset = toCharset ( charset ) ; return container ; }
public static Resource function ( final String arg0 ) { return resource ( id ( MocoConfig . URI_ID ) , uriConfigApplier ( MocoConfig . URI_ID , arg0 ) , request - > content ( arg0 ) ) ; }
public static CookieAttribute function ( final String arg0 ) { return new PathCookieAttribute ( arg0 ) ; }
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , post ( status ( 201 ) , header ( " Location " , " /targets/123 " ) ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( ) { String className = tq . consumeClassName ( ) ; Validate . notEmpty ( className ) ; List < Element > found = root . getElementsWithClass ( className ) ; elements . addAll ( found ) ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { MessageContent content = requireResponseContent ( arg0 ) ; arg1 . setContent ( content ) ; arg1 . addHeader ( HttpHeaders . CONTENT_LENGTH , content . getContent ( ) . length ) ; if ( ! detector . hasContentType ( arg1 ) ) { arg1 . addHeader ( HttpHeaders . CONTENT_TYPE , getContentType ( arg0 ) ) ;
protected final ChannelInitializer < SocketChannel > function ( ) { return new ChannelInitializer < SocketChannel > ( ) { @Override
public void function ( ) throws IOException { runWithConfiguration ( " template.json " ) ; assertThat ( helper . get ( remoteUrl ( " /path/path " ) ) , is ( " path " ) ) ; assertThat ( helper . get ( remoteUrl ( " /path/foo " ) ) , is ( " foo " ) ) ; }
public static Object function ( String arg0 ) throws java . io . IOException , java . lang . ClassNotFoundException { return decodeToObject ( arg0 , NO_OPTIONS , null ) ; }
public void function ( ) throws Exception { String s = " Not unicode " ; byte [ ] notUnicode = BufferTools . stringToByteBuffer ( s , 0 , s . length ( ) ) ; EncodedText encodedText = new EncodedText ( EncodedText . TEXT_ENCODING_UTF_16 , notUnicode ) ; assertNull ( encodedText . toString ( ) ) ; }
@Test public void function ( ) { String html = " <html><head></head><body><img src=foo><!-- <table><tr><td></table> --><p>Hello</p></body></html> " ; Document doc = Jsoup . parse ( html ) ; Element body = doc . body ( ) ; Comment comment = ( Comment ) body . childNode ( 1 ) ; assertEquals ( "  <table><tr><td></table>  " , comment . getData ( ) ) ; Element p = body . child ( 1 ) ; TextNode text = ( TextNode ) p . childNode ( 0 ) ; assertEquals ( " Hello " , text . getWholeText ( ) ) ; }
protected byte [ ] function ( final Request arg0 ) { String pathname = targetFileName ( arg0 ) ; Path path = Paths . get ( pathname ) ; if ( ! Files . exists ( path ) ) { throw new IllegalArgumentException ( format ( " %s does not exist " , path . getFileName ( ) . toString ( ) ) ) ; } try { return Files . readAllBytes ( path ) ;
private static Option function ( ) { Option opt = new Option ( " c " , true , " config " ) ; opt . setType ( String . class ) ; opt . setRequired ( false ) ; return opt ; }
public int function ( ) { return from ( requests ) . filter ( matched ( ) ) . size ( ) ; }
public void function ( ) throws InvalidDataException { super . isValid ( ) ; if ( ! Charsetfunctions . isValidUTF8 ( getPayloadData ( ) ) ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ;
private ID3v2WWWFrameData function ( String arg0 ) { ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { ID3v2Frame frame = frameSet . getFrames ( ) . get ( 0 ) ; ID3v2WWWFrameData frameData ; try { frameData = new ID3v2WWWFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; return frameData ; } catch ( InvalidDataException e ) { } } return null ; }
private void function ( WebSocketImpl arg0 , Framedata arg1 , Opcode arg2 ) throws InvalidDataException { if ( arg2 ! = Opcode . CONTINUOUS ) { processFrameIsNotFin ( arg1 ) ; } else if ( arg1 . isFin ( ) ) { processFrameIsFin ( arg0 , arg1 ) ; } else if ( currentContinuousFrame = = null ) { log . error ( " Protocol error: Continuous frame sequence was not started. " ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , " Continuous frame sequence was not started. " ) ; } if ( arg2 = = Opcode . TEXT & & ! Charsetfunctions . isValidUTF8 ( arg1 . getPayloadData ( ) ) ) { log . error ( " Protocol error: Payload is not UTF8 " ) ; throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } if ( arg2 = = Opcode . CONTINUOUS & & currentContinuousFrame ! = null ) { addToBufferList ( arg1 . getPayloadData ( ) ) ;
public void function ( ) { String html = " <body><div><p>One</div><div><p>Two</div><div>Three</div> " ; Document doc = Jsoup . parse ( html ) ; Elements els = doc . selectXpath ( " //div/p " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " One " , els . get ( 0 ) . text ( ) ) ; assertEquals ( " Two " , els . get ( 1 ) . text ( ) ) ; }
public void function ( String arg0 , Object [ ] arg1 ) { if ( isTraceEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( ) throws Exception { server . response ( " foo " ) ; running ( server , ( ) - > helper . get ( root ( ) ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { formatAndLog ( LOG_LEVEL_WARN , arg0 , arg1 ) ; }
public void function ( ) throws Exception { server = httpserver ( port ( ) , response ( header ( " foo " , " bar " ) ) ) ; server . response ( latency ( 1000 ) ) ; running ( server , new Runnable ( ) { @Override
private static CloseableHttpClient function ( ) { try {
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public static NormalizedParameters function ( String arg0 , Object [ ] arg1 , Throwable arg2 ) { if ( arg2 ! = null ) { return new NormalizedParameters ( arg0 , arg1 , arg2 ) ; } if ( arg1 = = null | | arg1 . length = = 0 ) { return new NormalizedParameters ( arg0 , arg1 , arg2 ) ; } Throwable throwableCandidate = getThrowableCandidate ( arg1 ) ; if ( throwableCandidate ! = null ) { Object [ ] trimmedArguments = MessageFormatter . trimmedCopy ( arg1 ) ;
public void function ( ) throws Exception { String url = WEBSITE_WITH_SNI ; Jsoup . connect ( url ) . execute ( ) ; }
public static MocoEventAction function ( final Resource arg0 ) { return new MocoGetRequestAction ( checkNotNull ( arg0 , " URL should not be null " ) , ImmutableMap . < String , Resource > of ( ) ) ; }
public static DefaultHttpResponse function ( FullHttpResponse arg0 ) { ImmutableMap . Builder < String , String > headerBuilder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , String > entry : arg0 . headers ( ) ) { headerBuilder . put ( entry ) ; } return builder ( ) . withVersion ( HttpProtocolVersion . versionOf ( arg0 . getProtocolVersion ( ) . text ( ) ) )
private boolean function ( ) { HandshakeStatus status = sslEngine . getHandshakeStatus ( ) ; return status = = SSLEngineResult . HandshakeStatus . FINISHED | | status = = SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING ;
private boolean function ( WebSocket arg0 ) { synchronized ( active_websocktes ) { if ( active_websocktes . contains ( arg0 ) ) {
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( log . isErrorEnabled ( ) ) { String msgStr = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
protected Optional < ImmutableMap < String , String > > function ( final HttpRequest arg0 ) { HttpPostRequestDecoder decoder = null ; try { HttpDataFactory factory = new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) ;
private HttpServer function ( StartArgs arg0 ) { if ( arg0 . isHttps ( ) ) { return ActualHttpServer . createHttpsLogServer ( arg0 . getPort ( ) , arg0 . getHttpsCertificate ( ) ) ; } return ActualHttpServer . createLogServer ( arg0 . getPort ( ) ) ; }
@Test public void function ( ) { String q = " a:not(:has(span.foo)) b d > e + f ~ g " ; Evaluator parse = QueryParser . parse ( q ) ; assertEquals ( q , parse . toString ( ) ) ; String parsed = sexpr ( q ) ; assertEquals ( " (And (Tag 'g')(PreviousSibling (And (Tag 'f')(ImmediatePreviousSibling (ImmediateParentRun (And (Tag 'd')(Parent (And (Tag 'b')(Parent (And (Tag 'a')(Not (Has (And (Tag 'span')(Class '.foo')))))))))(Tag 'e')))))) " , parsed ) ; }
public String function ( String arg0 ) { Validate . notNull ( arg0 , " Header name must not be null " ) ; List < String > vals = getHeadersCaseInsensitive ( arg0 ) ; if ( vals . size ( ) > 0 ) { return StringUtil . join ( vals , " ,  " ) ; } return null ; }
@Override public AuthenticationHandler function ( AuthenticationHandler arg0 ) { return arg0 ; }
public HandshakeBuilder function ( Handshakedata arg0 , HandshakeBuilder arg1 ) throws InvalidHandshakeException { arg1 . put ( " Upgrade " , " WebSocket " ) ; arg1 . put ( " Connection " , arg0 . getFieldValue ( " Connection " ) ) ; arg1 . put ( " Sec-WebSocket-Origin " , arg0 . getFieldValue ( " Origin " ) ) ; String location = " ws:// " + arg0 . getFieldValue ( " Host " ) + arg0 . getResourceDescriptor ( ) ; arg1 . put ( " Sec-WebSocket-Location " , location ) ; String key1 = arg0 . getFieldValue ( " Sec-WebSocket-Key1 " ) ; String key2 = arg0 . getFieldValue ( " Sec-WebSocket-Key2 " ) ; byte [ ] key3 = arg0 . getContent ( ) ; if ( key1 = = null | | key2 = = null | | key3 = = null | | key3 . length ! = 8 ) { throw new InvalidHandshakeException ( " Bad keys " ) ; } arg1 . setContent ( createChallenge ( key1 , key2 , key3 ) ) ; return arg1 ; }
public void function ( ) throws Exception { DefaultExtension defaultExtension = new DefaultExtension ( ) ; assertEquals ( " " , defaultExtension . getProvidedExtensionAsClient ( ) ) ; }
private Elements function ( ) { String id = tq . consumeWord ( ) ; Validate . notEmpty ( id ) ; Element found = root . getElementById ( id ) ; Elements byId = new Elements ( ) ; if ( found ! = null ) byId . add ( found ) ; return byId ; }
private void function ( ) throws IOException { file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new FileNotFoundException ( " File not found  " + filename ) ; if ( ! file . canRead ( ) ) throw new IOException ( " File not readable " ) ; }
public static MocoMonitor function ( ) { return ApiUtils . log ( new StdLogWriter ( ) ) ; }
static String function ( arg0 Object arg1 ) { return arg1 = = null ? EmptyString : ( String ) arg1 ; }
private void function ( SelectionKey arg0 ) throws WrappedIOException { WebSocketImpl conn = ( WebSocketImpl ) arg0 . attachment ( ) ; try { if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) {
static ByteBuffer function ( ) { return ByteBuffer . allocate ( 0 ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) | | isWhitespace ( arg0 ) | | ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " html " ) ) ) { return arg1 . process ( arg0 , InBody ) ; } else if ( arg0 . isEOF ( ) ) { } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " noframes " ) ) { return arg1 . process ( arg0 , InHead ) ; } else { arg1 . error ( this ) ; return false ; } return true ; }
private < T extends SimpleRestSetting > FluentIterable < T > function ( final Iterable < RestSetting > arg0 , final Class < T > arg1 , final HttpMethod arg2 ) { return filter ( arg0 , arg1 ) . filter ( isForMethod ( arg2 ) ) ;
private void function ( String . . . arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ;
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false ) ; ArrayList < ID3v2Frame > subframes = new ArrayList < > ( 2 ) ; subframes . add ( new ID3v2Frame ( " " , new byte [ ] { 'c' , 'h' , '1' , 0 } ) ) ; subframes . add ( new ID3v2Frame ( " " , new byte [ ] { 1 , 0 , 1 , 0 } ) ) ; frameData . setSubframes ( subframes ) ; assertEquals ( subframes , frameData . getSubframes ( ) ) ; }
public void function ( Exception arg0 ) { fail ( " There should not be an exception:  " + arg0 . getMessage ( ) + "  Port:  " + port ) ; }
public void function ( ) { server . request ( and ( by ( " foo " ) , by ( uri ( " /foo " ) ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
public static Session function ( arg0 ( " request " ) HttpRequest request , arg0 ( " response " ) Response response ) { Session session = new Session ( ) ; session . request = request ; session . response = response ; return session ; }
int function ( int arg0 ) { if ( ! isTrackNewlines ( ) ) return arg0 + 1 ; int i = lineNumIndex ( arg0 ) ; if ( i = = - 1 ) return arg0 + 1 ; return arg0 - newlinePositions . get ( i ) + 1 ; }
private void function ( ) { int leadingCharsToRemove = 0 ; if ( value . length > = 2 & & ( ( value [ 0 ] = = ( byte ) 0xfe & & value [ 1 ] = = ( byte ) 0xff ) | | ( value [ 0 ] = = ( byte ) 0xff & & value [ 1 ] = = ( byte ) 0xfe ) ) ) { leadingCharsToRemove = 2 ; } else if ( value . length > = 3 & & ( value [ 0 ] = = ( byte ) 0xef & & value [ 1 ] = = ( byte ) 0xbb & & value [ 2 ] = = ( byte ) 0xbf ) ) { leadingCharsToRemove = 3 ; } int trailingCharsToRemove = 0 ; for ( int i = 1 ; i < = 2 ; i + + ) { if ( ( value . length - leadingCharsToRemove - trailingCharsToRemove ) > = i & & value [ value . length - i ] = = 0 ) { trailingCharsToRemove + + ; } else { break ; } } if ( leadingCharsToRemove + trailingCharsToRemove > 0 ) { int newLength = value . length - leadingCharsToRemove - trailingCharsToRemove ;
public final void function ( final WebSocketServer arg0 ) { arg0 . ping ( ping . asResource ( ) ) . pong ( pong . asResource ( ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { log ( SELF , Level . INFO , arg0 , arg1 ) ; }
private void function ( Element arg0 , arg1 Token arg2 ) { if ( arg0 . tag ( ) . isFormListed ( ) & & formElement ! = null ) formElement . addElement ( arg0 ) ; if ( parser . getErrors ( ) . canAddError ( ) & & arg0 . hasAttr ( " xmlns " ) & & ! arg0 . attr ( " xmlns " ) . equals ( arg0 . tag ( ) . namespace ( ) ) ) error ( " Invalid xmlns attribute [%s] on tag [%s] " , arg0 . attr ( " xmlns " ) , arg0 . tagName ( ) ) ; if ( isFosterInserts ( ) & & StringUtil . inSorted ( currentElement ( ) . normalName ( ) , InTableFoster ) ) insertInFosterParent ( arg0 ) ; else currentElement ( ) . appendChild ( arg0 ) ; push ( arg0 ) ; }
public static ActualHttpServer function ( final Optional < Integer > arg0 , final HttpsCertificate arg1 , final MocoMonitor arg2 , final MocoConfig . . . arg3 ) { return new ActualHttpServer ( arg0 , of ( arg1 ) , arg2 , arg3 ) ; }
public void function ( ) { System . Logger logger = getSLF4JSystemLogger ( ) ; String message = " Test system logging! " ; logger . log ( System . Logger . Level . INFO , message ) ; String output = getOutput ( ) ; assertTrue ( " Captured output should contain logged message. " , output . contains ( message ) ) ; }
public static MocoJunitRunner function ( final int arg0 , final String arg1 ) { return new MocoJunitRunner ( Runner . runner ( MocoJsonRunner . jsonSocketServer ( arg0 , file ( arg1 ) ) ) ) ; }
public void function ( Marker arg0 , String arg1 ) { logger . info ( arg0 , arg1 ) ; }
private HttpResponse function ( HttpRequest arg0 ) { HttpResponse response = defaultResponse ( arg0 , HttpResponseStatus . OK ) ; for ( BaseSetting setting : settings ) { if ( setting . match ( arg0 ) ) { setting . writeToResponse ( arg0 , response ) ; return response ; } } if ( anyResponseHandler ! = null ) { anyResponseHandler . writeToResponse ( arg0 , response ) ; return response ; } return defaultResponse ( arg0 , HttpResponseStatus . BAD_REQUEST ) ; }
public void function ( ) { Log log = LogFactory . getLog ( CommonsLoggingTester . class ) ; Exception e = new Exception ( " just testing " ) ; log . trace ( null ) ; log . trace ( " trace message " ) ; log . debug ( null ) ; log . debug ( " debug message " ) ; log . info ( null ) ; log . info ( " info  message " ) ; log . warn ( null ) ; log . warn ( " warn message " ) ; log . error ( null ) ; log . error ( " error message " ) ; log . fatal ( null ) ; log . fatal ( " fatal message " ) ; log . trace ( null , e ) ; log . trace ( " trace message " , e ) ; log . debug ( null , e ) ; log . debug ( " debug message " , e ) ; log . info ( null , e ) ; log . info ( " info  message " , e ) ; log . warn ( null , e ) ; log . warn ( " warn message " , e ) ; log . error ( null , e ) ; log . error ( " error message " , e ) ; log . fatal ( null , e ) ; log . fatal ( " fatal message " , e ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo " ) ) ) . response ( cycle ( " bar " , " blah " ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ;
public final boolean function ( final HttpMethod arg0 ) { return this . arg0 = = arg0 ; }
public void function ( ) throws Exception { server . response ( file ( " src/test/resources/foo.response " ) ) ; running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " foo.response " ) ) ) ; }
public RunnerSetting function ( ) { return new RunnerSetting ( streams . build ( ) , context , fileRoot , request , response ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( file ( template ( " src/test/resources/${var} " , " var " , " gbk.response " ) , Charset . forName ( " GBK " ) ) ) ; running ( server , ( ) - > assertThat ( helper . getAsBytes ( remoteUrl ( " /template " ) ) , is ( Files . readAllBytes ( Paths . get ( " src/test/resources/gbk.response " ) ) ) ) ) ; }
public String function ( String arg0 ) { return headers . get ( arg0 ) ; }
public void function ( ) throws Exception { Mp3File mp3File = new Mp3File ( new File ( MP3_WITH_INCOMPLETE_MPEG_FRAME ) , 256 , false ) ; testShouldInitialiseProperlyWhenNotScanningFile ( mp3File ) ; }
default public LoggingEventBuilder function ( ) { if ( isInfoEnabled ( ) ) { return makeLoggingEventBuilder ( INFO ) ;
public String function ( String arg0 ) { ensureAttributes ( ) ; return super . absUrl ( arg0 ) ; }
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /htmltests/google-ipod.html.gz " ) ; org . jsoup . nodes . Document doc = Jsoup . parse ( in , " UTF8 " ) ; W3CDom w3c = new W3CDom ( ) ; Document wDoc = w3c . fromJsoup ( doc ) ; String out = w3c . asString ( wDoc ) ; assertEquals ( doc . location ( ) , wDoc . getDocumentURI ( ) ) ; }
private Attribute function ( ) { tq . consumeWhitespace ( ) ; String key = tq . consumeWord ( ) ; String value = " " ; tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( " = " ) ) { tq . consumeWhitespace ( ) ; if ( tq . matchChomp ( SQ ) ) { value = tq . chompTo ( SQ ) ; } else if ( tq . matchChomp ( DQ ) ) { value = tq . chompTo ( DQ ) ; } else { StringBuilder valueAccum = new StringBuilder ( ) ; while ( ! tq . matches ( " < " ) & & ! tq . matches ( " /> " ) & & ! tq . matches ( " > " ) & & ! Character . isWhitespace ( tq . peek ( ) ) & & ! tq . isEmpty ( ) ) { valueAccum . append ( tq . consume ( ) ) ; } value = valueAccum . toString ( ) ; } tq . consumeWhitespace ( ) ; } if ( ! key . isEmpty ( ) ) return Attribute . createFromEncoded ( key , value ) ;
private Evaluator function ( boolean arg0 ) { String query = arg0 ? " :matchesWholeOwnText " : " :matchesWholeText " ; String regex = consumeParens ( ) ; Validate . notEmpty ( regex , query + " (regex) query must not be empty " ) ; return arg0 ? new Evaluator . MatchesWholeOwnText ( Pattern . compile ( regex ) )
public void function ( ) { byte [ ] buffer = { BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_T , BYTE_A , BYTE_G } ; try { BufferTools . byteBufferToString ( buffer , buffer . length - 2 , 3 ) ;
public ClientHandshakeBuilder function ( ClientHandshakeBuilder arg0 ) { arg0 . put ( " Upgrade " , " websocket " ) ; arg0 . put ( " Connection " , " Upgrade " ) ; arg0 . put ( " Sec-WebSocket-Version " , " 8 " ) ; byte [ ] random = new byte [ 16 ] ; new Random ( ) . nextBytes ( random ) ; arg0 . put ( " Sec-WebSocket-Key " , Base64 . encodeBytes ( random ) ) ; return arg0 ; }
public double function ( long arg0 ) { String s = " " ; s + = " " ; long start = System . currentTimeMillis ( ) ; for ( int i = 0 ; i < arg0 ; i + + ) { s = MessageFormatter . format ( " This is some rather short message {}  " , i1 ) . getMessage ( ) ; } long end = System . currentTimeMillis ( ) ; return ( 1.0 * end - start ) ; }
public void function ( ) { ID3v2ChapterFrameData frameData1 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2ChapterFrameData frameData2 = new ID3v2ChapterFrameData ( false , " ch2 " , 1 , 380 , 3 , 400 ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
public boolean function ( String arg0 ) { return REQUEST_ID . equals ( arg0 ) ; }
public ByteChannel function ( SocketChannel arg0 , SelectionKey arg1 , String arg2 , int arg3 ) throws IOException { SSLEngine e = sslcontext . createSSLEngine ( arg2 , arg3 ) ; e . setUseClientMode ( true ) ; return new SSLSocketChannel2 ( arg0 , e , exec , arg1 ) ; }
public void function ( ) throws IOException , ClassNotFoundException { LoggerHolder lh1 = new LoggerHolder ( ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; ObjectOutputStream out = new ObjectOutputStream ( baos ) ; out . writeObject ( lh1 ) ; out . close ( ) ; lh1 = null ; byte [ ] serializedLoggerHolder = baos . toByteArray ( ) ; InputStream is = new ByteArrayInputStream ( serializedLoggerHolder ) ; ObjectInputStream in = new ObjectInputStream ( is ) ; LoggerHolder lh2 = ( LoggerHolder ) in . readObject ( ) ; Assert . assertNotNull ( lh2 ) ; Assert . assertNotNull ( lh2 . getLog ( ) ) ; lh2 . getLog ( ) . info ( " You must see this message as a log message " ) ; }
public void function ( String arg0 ) { recordEventwithoutMarkerArgArray ( Level . INFO , arg0 , null , null ) ; }
public String function ( String arg0 ) { return cookies . get ( arg0 ) ; }
public void function ( final SessionContext arg0 ) { FullHttpResponse response = arg0 . getResponse ( ) ; ByteBuf buffer = Unpooled . buffer ( ) ; writeContentResponse ( arg0 . getRequest ( ) , buffer ) ; response . content ( ) . writeBytes ( buffer ) ; setContentLength ( response , response . content ( ) . writerIndex ( ) ) ; if ( ! detector . hasContentType ( response ) ) { addHeader ( response , HttpHeaders . CONTENT_TYPE , getContentType ( arg0 . getRequest ( ) ) ) ;
public void function ( final HttpRequest arg0 ) { tape . write ( arg0 ) ; }
@Test public void function ( ) { String dirty = " <html><head><script></script><noscript></noscript></head><frameset><frame src= \" foo \"  /><frame src= \" foo \"  /></frameset></html> " ; String clean = Jsoup . clean ( dirty , Whitelist . basic ( ) ) ; assertEquals ( " " , clean ) ; Document dirtyDoc = Jsoup . parse ( dirty ) ; Document cleanDoc = new Cleaner ( Whitelist . basic ( ) ) . clean ( dirtyDoc ) ; assertNotNull ( cleanDoc ) ; assertEquals ( 0 , cleanDoc . body ( ) . childNodeSize ( ) ) ; }
String function ( ) { int start = pos ; while ( ! isEmpty ( ) ) { char c = input . charAt ( pos ) ; if ( ( c > = '0' & & c < = '9' ) | | ( c > = 'A' & & c < = 'F' ) | | ( c > = 'a' & & c < = 'f' ) ) pos + + ; else break ; } return input . substring ( start , pos ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p><a  \ 06=foo>One</a><a/ \ 06=bar><a foo \ 06=bar>Two</a></p> " ) ; assertEquals ( " <p><a>One</a><a></a><a foo= \" bar \" >Two</a></p> " , doc . body ( ) . html ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.19 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( Object arg0 , Throwable arg1 ) { logger . log ( Level . WARNING , arg0 . toString ( ) , arg1 ) ; }
public static void function ( ) throws SecurityException { java . util . logging . Logger rootLogger = getRootLogger ( ) ; Handler [ ] handlers = rootLogger . getHandlers ( ) ; for ( Handler handler : handlers ) { if ( handler instanceof SLF4JBridgeHandler ) {
public void function ( ) throws IOException { runWithConfiguration ( " json.json " ) ; assertThat ( helper . postContent ( remoteUrl ( " /json " ) , " { \ n \ t \" foo \" : \" bar \" \ n} " ) , is ( " response_for_json_request " ) ) ; }
public void function ( ByteBuffer arg0 ) { getConnection ( ) . send ( arg0 ) ; }
protected void function ( final SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; if ( serverSetting . isSecure ( ) ) { pipeline . addFirst ( " ssl " , serverSetting . sslHandler ( ) . get ( ) ) ; } pipeline . addLast ( " codec " , new HttpServerCodec ( MAX_INITIAL_LINE_LENGTH , MAX_HEADER_SIZE , MAX_CHUNK_SIZE , false ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( MAX_CONTENT_LENGTH ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
protected RestSettingBuilder function ( ) { if ( hasId ( ) ) { return MocoRest . delete ( id ( ) ) ; } throw new IllegalArgumentException ( " Delete ID is missing " ) ; }
private void function ( final Lock arg0 , final Runnable arg1 ) { arg0 . arg0 ( ) ; try { arg1 . run ( ) ;
public Optional < MocoConfig > function ( ) { if ( fileRoot ! = null ) { return of ( Moco . fileRoot ( fileRoot ) ) ; } return absent ( ) ; }
boolean function ( ) { return lastStartTag ! = null & & tagPending . tagName . equals ( lastStartTag ) ; }
public static ResponseHandler function ( final String arg0 ) { return new ReplayHandler ( RequestRecorder . getRecorder ( arg0 ) ) ; }
protected Map < String , String > function ( Map < String , String > arg0 ) { if ( arg0 = = null ) { return null ; } return new HashMap < String , String > ( arg0 ) ; }
public void function ( ) { setTrialEnabled ( true ) ; LoggerFactory . getLogger ( String . class ) ; assertIsMismatch ( true ) ; }
public void function ( ) { String result ; Integer [ ] ia = new Integer [ ] { i1 , i2 , i3 } ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {} and {}. " , ia ) ; assertEquals ( " Value 1 is smaller than 2 and 3. " , result ) ; result = MessageFormatter . arrayFormat ( " {}{}{} " , ia ) ; assertEquals ( " 123 " , result ) ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {}. " , ia ) ; assertEquals ( " Value 1 is smaller than 2. " , result ) ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {} " , ia ) ; assertEquals ( " Value 1 is smaller than 2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val={}, {, Val={} " , ia ) ; assertEquals ( " Val=1, {, Val={} " , result ) ; result = MessageFormatter . arrayFormat ( " Val={},  \\ {, Val={} " , ia ) ; assertEquals ( " Val=1, {, Val=2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val1={}, Val2={ " , ia ) ; assertEquals ( " Val1=1, Val2={ " , result ) ;
void function ( List < String > arg0 , int arg1 , String arg2 ) { assertTrue ( ( ( String ) arg0 . get ( arg1 ) ) . contains ( arg2 ) ) ; }
public void function ( ) { result = MessageFormatter . arrayFormat ( " Value {} is smaller than {} and {}. " , ia0 ) . getMessage ( ) ; assertEquals ( " Value 1 is smaller than 2 and 3. " , result ) ; result = MessageFormatter . arrayFormat ( " {}{}{} " , ia0 ) . getMessage ( ) ; assertEquals ( " 123 " , result ) ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {}. " , ia0 ) . getMessage ( ) ; assertEquals ( " Value 1 is smaller than 2. " , result ) ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {} " , ia0 ) . getMessage ( ) ; assertEquals ( " Value 1 is smaller than 2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val={}, {, Val={} " , ia0 ) . getMessage ( ) ; assertEquals ( " Val=1, {, Val=2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val={}, {, Val={} " , ia0 ) . getMessage ( ) ; assertEquals ( " Val=1, {, Val=2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val1={}, Val2={ " , ia0 ) . getMessage ( ) ; assertEquals ( " Val1=1, Val2={ " , result ) ; }
public void function ( ) { JCLMatcher jclMatcher = new JCLMatcher ( ) ; assertEquals ( " import org.slf4j.LoggerFactory; " , jclMatcher . getReplacement ( " import org.apache.commons.logging.LogFactory; " ) ) ; assertEquals ( " import org.slf4j.Logger; " , jclMatcher . getReplacement ( " import org.apache.commons.logging.Log; " ) ) ;
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . WARN_INT , arg1 , null , arg2 ) ;
private HttpServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { HttpServer targetServer = createHttpServer ( arg1 ) ; for ( RunnerSetting setting : arg0 ) { HttpServer parsedServer = httpParser . parseServer ( setting . getStream ( ) , arg1 . getPort ( ) , toConfigs ( setting ) ) ; targetServer = mergeServer ( targetServer , parsedServer ) ; } return targetServer ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.18.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public List < File > function ( File arg0 ) { if ( arg0 . isDirectory ( ) ) { selectFiles ( arg0 ) ;
public static String function ( StringBuilder arg0 ) { Validate . notNull ( arg0 ) ; String string = arg0 . toString ( ) ; if ( arg0 . length ( ) > MaxCachedBuilderSize ) arg0 = new StringBuilder ( MaxCachedBuilderSize ) ; else arg0 . delete ( 0 , arg0 . length ( ) ) ; synchronized ( builders ) { builders . push ( arg0 ) ; while ( builders . size ( ) > MaxIdleBuilders ) { builders . pop ( ) ; } } return string ; }
public T function ( String arg0 ) { Validate . notEmpty ( arg0 , " Header name must not be empty " ) ; Map . Entry < String , List < String > > entry = scanHeaders ( arg0 ) ; if ( entry ! = null ) headers . remove ( entry . getKey ( ) ) ; return ( T ) this ; }
public void function ( ) { loggerFactory = new JDK14LoggerFactory ( ) ; markerFactory = new BasicMarkerFactory ( ) ; mdcAdapter = new BasicMDCAdapter ( ) ; }
public static Identifiable function ( final Resource arg0 ) { return new Identifiable ( ) { @Override
public String function ( ) { return String . format ( " :[%s$=%s] " , key , value ) ; }
private void function ( final ChannelHandlerContext arg0 , final FullHttpRequest arg1 ) { FullHttpRequest request = arg1 ; if ( ! request . decoderResult ( ) . isSuccess ( ) | | ! ( " websocket " . equals ( request . headers ( ) . get ( " Upgrade " ) ) ) ) { FullHttpResponse response = handleRequest ( request ) ; closeIfNotKeepAlive ( request , arg0 . write ( response ) ) ; return ; } WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory ( websocketServer . getUri ( ) , null , false ) ; handshaker = wsFactory . newHandshaker ( request ) ; if ( handshaker = = null ) { WebSocketServerHandshakerFactory . sendUnsupportedVersionResponse ( arg0 . channel ( ) ) ;
public static void function ( String . . . arg0 ) throws IOException { Validate . isTrue ( arg0 . length = = 1 , " usage: supply url to fetch " ) ; String url = arg0 [ 0 ] ; Document doc = Jsoup . connect ( url ) . get ( ) ; HtmlToPlainText formatter = new HtmlToPlainText ( ) ; String plainText = formatter . getPlainText ( doc ) ; System . out . println ( plainText ) ; }
public static RequestMatcher function ( final RequestMatcher . . . arg0 ) { return new OrRequestMatcher ( copyOf ( checkNotNull ( arg0 , " Matcher should not be null " ) ) ) ; }
List < Node > function ( String arg0 , String arg1 , ParseErrorList arg2 , ParseSettings arg3 ) { initialiseParse ( arg0 , arg1 , arg2 , arg3 ) ; runParser ( ) ; return doc . childNodes ( ) ; }
private MocoConfig [ ] function ( RunnerSetting arg0 ) { ImmutableList . Builder < MocoConfig > builder = ImmutableList . builder ( ) ; addConfig ( builder , arg0 . context ( ) ) ; addConfig ( builder , arg0 . fileRoot ( ) ) ; addConfig ( builder , arg0 . response ( ) ) ; return toArray ( builder . build ( ) , MocoConfig . class ) ; }
public String function ( String arg0 ) { String data = consumeTo ( arg0 ) ; matchChomp ( arg0 ) ; return data ; }
public final void function ( final MutableHttpResponse arg0 ) { arg0 . addHeader ( " Access-Control-Allow-Origin " , origin ) ; }
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " changeThis " , true ) ; doc . updateMetaCharset ( true ) ; doc . charset ( Charset . forName ( charsetIso8859 ) ) ; final String xmlCharsetISO = " <?xml version= \" 1.0 \"  encoding= \" " + charsetIso8859 + " \" > \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetISO , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetIso8859 , doc . charset ( ) . name ( ) ) ; assertEquals ( charsetIso8859 , selectedNode . attr ( " encoding " ) ) ; assertEquals ( doc . charset ( ) , doc . outputSettings ( ) . charset ( ) ) ; }
public Optional < String > function ( FullHttpRequest arg0 ) { return of ( target . extract ( extractor . extract ( arg0 ) . get ( ) ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${req.uri} ${req.queries['foo']} " ) ) ; running ( server , ( ) - > { String response = helper . get ( remoteUrl ( " /template?foo=bar " ) ) ;
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( " HTTP/1.1 " ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest failover = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( " HTTP/1.1 " ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( failover ) . match ( request ) , is ( true ) ) ; }
public void function ( arg0 final Path arg1 ) throws Exception { HttpServer server = httpServer ( port ( ) , log ( ) ) ; server . request ( by ( " 0XCAFE " ) ) . response ( " 0XBABE " ) ; File file = arg1 . resolve ( " tempfile " ) . toFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; running ( server , ( ) - > assertThat ( helper . postContent ( remoteUrl ( " /foo?param=actual " ) , " 0XCAFE " ) , is ( " 0XBABE " ) ) ) ; String actual = asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) ; assertThat ( actual , containsString ( " 0XBABE " ) ) ; assertThat ( actual , containsString ( " 0XCAFE " ) ) ; assertThat ( actual , containsString ( " /foo?param=actual " ) ) ; }
public static String function ( String arg0 ) { if ( mdcAdapter = = null ) { throw new IllegalStateException ( " MDCAdapter cannot be null. See also  " + NULL_MDCA_URL ) ; } return mdcAdapter . get ( arg0 ) ; }
private static boolean function ( String arg0 ) { final int length = arg0 . length ( ) ; if ( length = = 0 ) return false ; for ( int i = 0 ; i < length ; i + + ) { char c = arg0 . charAt ( i ) ; if ( c < = 0x1f | | c > = 0x7f & & c < = 0x9f | | c = = ' ' | | c = = '"' | | c = = '\'' | | c = = '/' | | c = = '=' ) return false ; } return true ; }
public HttpResponseSetting function ( final RequestMatcher . . . arg0 ) { return request ( or ( arg0 ) ) ; }
private Server function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { if ( arg1 . isSocket ( ) ) { return createSocketServer ( arg0 , arg1 ) ; } return createHttpServer ( arg0 , arg1 ) ; }
public RunnerSetting function ( InputStream arg0 ) { return new RunnerSetting ( arg0 , null ) ; }
public void function ( boolean arg0 ) { if ( arg0 & & newlinePositions = = null ) { newlinePositions = new ArrayList < > ( BufferSize / 80 ) ;
static Elements function ( String arg0 , Element arg1 ) { Validate . notEmpty ( arg0 ) ; Validate . notNull ( arg1 ) ; W3CDom w3c = new W3CDom ( ) ; org . w3c . dom . Document wDoc = w3c . fromJsoup ( arg1 ) ; NodeList nodeList = w3c . selectXpath ( arg0 , wDoc ) ; return w3c . sourceElements ( nodeList ) ; }
void function ( Token . Doctype arg0 ) { DocumentType doctypeNode = new DocumentType ( settings . normalizeTag ( arg0 . getName ( ) ) , arg0 . getPublicIdentifier ( ) , arg0 . getSystemIdentifier ( ) ) ; doctypeNode . setPubSysKey ( arg0 . getPubSysKey ( ) ) ; insertNode ( doctypeNode , arg0 ) ; }
public KeyVal function ( InputStream arg0 ) { Validate . notNull ( value , " Data input stream must not be null " ) ; this . stream = arg0 ; return this ; }
protected final void function ( final Setting < T > arg0 ) { this . settings . add ( arg0 ) ; }
public static String function ( String arg0 ) { StringBuilder out = new StringBuilder ( ) ; Character last = null ; for ( Character c : arg0 . toCharArray ( ) ) { if ( c . equals ( ESC ) ) { if ( last ! = null & & last . equals ( ESC ) ) out . append ( c ) ; } else out . append ( c ) ; last = c ; } return out . toString ( ) ; }
Element function ( ) { if ( stack . peekLast ( ) . nodeName ( ) . equals ( " td " ) & & ! state . name ( ) . equals ( " InCell " ) ) Validate . isFalse ( true , " pop td not in cell " ) ; if ( stack . peekLast ( ) . nodeName ( ) . equals ( " html " ) ) Validate . isFalse ( true , " popping html! " ) ; return stack . pollLast ( ) ; }
public Object function ( ) { Class logFactoryClass = null ; try { if ( classLoader ! = null ) {
public void function ( ) throws IOException { Assert . assertEquals ( " " , Base64 . encodeBytes ( new byte [ 0 ] ) ) ; Assert . assertEquals ( " QHE= " , Base64 . encodeBytes ( new byte [ ] { 49 , 121 , 64 , 113 , - 63 , 43 , - 24 , 62 , 4 , 48 } , 2 , 2 , 0 ) ) ; Assert . assertEquals ( " H4sIAAAAAAAAADMEALfv3IMBAAAA " , Base64 . encodeBytes ( new byte [ ] { 49 , 121 , 64 , 113 , - 63 , 43 , - 24 , 62 , 4 , 48 } , 0 , 1 , 6 ) ) ; Assert . assertEquals ( " H4sIAAAAAAAAAHMoBABQHKKWAgAAAA== " , Base64 . encodeBytes ( new byte [ ] { 49 , 121 , 64 , 113 , - 63 , 43 , - 24 , 62 , 4 , 48 } , 2 , 2 , 18 ) ) ; Assert . assertEquals ( " F63= " , Base64 . encodeBytes ( new byte [ ] { 49 , 121 , 64 , 113 , 63 , 43 , - 24 , 62 , 4 , 48 } , 2 , 2 , 32 ) ) ; Assert . assertEquals ( " 6sg7---------6Bc0-0F699L-V----== " , Base64 . encodeBytes ( new byte [ ] { 49 , 121 , 64 , 113 , 63 , 43 , - 24 , 62 , 4 , 48 } , 2 , 2 , 34 ) ) ;
String function ( ) { String tempName = name ; String levelString = null ; int indexOfLastDot = tempName . length ( ) ; while ( ( levelString = = null ) & & ( indexOfLastDot > - 1 ) ) { tempName = tempName . substring ( 0 , indexOfLastDot ) ; levelString = CONFIG_PARAMS . getStringProperty ( SimpleLogger . LOG_KEY_PREFIX + tempName , null ) ; indexOfLastDot = String . valueOf ( tempName ) . lastIndexOf ( " . " ) ; } return levelString ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.2.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public static < T > T function ( final InputStream arg0 , final Class < T > arg1 ) { try { return mapper . readValue ( arg0 , arg1 ) ;
public void function ( Locale arg0 ) { Locale . setDefault ( arg0 ) ; Tag script1 = Tag . valueOf ( " script " , ParseSettings . htmlDefault ) ; Tag script2 = Tag . valueOf ( " SCRIPT " , ParseSettings . htmlDefault ) ; assertSame ( script1 , script2 ) ; }
public static Resource function ( String arg0 ) { checkNotNull ( arg0 , " Null method is not allowed " ) ; return new MethodResource ( arg0 ) ; }
public Element function ( String arg0 ) throws IOException { return ( Element ) Validate . ensureNotNull ( selectNext ( arg0 ) ,
public void function ( ) throws Exception { SocketServer server = socketServer ( ) ; SocketServer secondServer = socketServer ( 12307 ) ; final SocketServer newServer = ( ( ActualSocketServer ) server ) . mergeServer ( ( ActualSocketServer ) secondServer ) ; running ( newServer , new Runnable ( ) { @Override
static void function ( ) { if ( INITIALIZED ) { return ; } INITIALIZED = true ; init ( ) ; }
public void function ( Object arg0 ) { getNonNullArguments ( ) . add ( arg0 ) ; }
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return new XmlRequestMatcher ( ( ContentRequestExtractor ) extractor ( arg0 . id ( ) ) , arg0 ) ; }
public Connection function ( Map < String , String > arg0 ) { Validate . notNullParam ( arg0 , " arg0 " ) ; for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { req . arg0 ( KeyVal . create ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return this ; }
public Entry < String , String > function ( ) { return new Attribute ( attr . getKey ( ) . substring ( dataPrefix . length ( ) ) , attr . getValue ( ) ) ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { openCounter + + ; System . out . println ( " ///////////Opened connection number " + openCounter ) ; }
public MocoEventAction function ( ) { if ( headers = = null ) { return get ( url . asResource ( ) ) ; } HttpHeader [ ] headers = FluentIterable . from ( this . headers . entrySet ( ) ) . transform ( asHeader ( ) ) . toArray ( HttpHeader . class ) ; return get ( url . asResource ( ) , Iterables . head ( headers ) , Iterables . tail ( headers ) ) ; }
