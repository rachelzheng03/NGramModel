public boolean function ( ) { return errors . getMaxSize ( ) > 0 ; }
private void function ( final ChannelHandlerContext arg0 , final WebSocketFrame arg1 ) { WebsocketResponse response = websocketServer . handleRequest ( arg0 , arg1 ) ; ByteBuf byteBuf = Unpooled . wrappedBuffer ( response . getContent ( ) . getContent ( ) ) ; arg0 . channel ( ) . writeAndFlush ( new BinaryWebSocketFrame ( byteBuf ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public Connection function ( Proxy arg0 ) { req . arg0 ( arg0 ) ; return this ; }
public void function ( Marker arg0 , String arg1 ) { logger . debug ( arg0 , arg1 ) ; }
public static RestSetting function ( final String arg0 , final ResponseHandler arg1 , final ResponseHandler . . . arg2 ) { return new GetSingleRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , Optional . < RequestMatcher > absent ( ) ,
void function ( ) { while ( ! formattingElements . isEmpty ( ) ) { Element el = formattingElements . peekLast ( ) ;
public void function ( ) { String url = " http://direct.jsoup.org/rez/osi_logo.png " ; boolean threw = false ; try { Document doc = Jsoup . parse ( new URL ( url ) , 3000 ) ; } catch ( UnsupportedMimeTypeException e ) { threw = true ; assertEquals ( " org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://direct.jsoup.org/rez/osi_logo.png " , e . toString ( ) ) ; assertEquals ( url , e . getUrl ( ) ) ; assertEquals ( " image/png " , e . getMimeType ( ) ) ; } catch ( IOException e ) { } assertTrue ( threw ) ; }
void function ( Node arg0 ) { Element fosterParent = null ; Element lastTable = getFromStack ( " table " ) ; boolean isLastTableParent = false ; if ( lastTable ! = null ) { if ( lastTable . parent ( ) ! = null ) { fosterParent = lastTable . parent ( ) ; isLastTableParent = true ; } else fosterParent = aboveOnStack ( lastTable ) ; } else { fosterParent = stack . get ( 0 ) ; } if ( isLastTableParent ) { Validate . notNull ( lastTable ) ;
public void function ( Marker arg0 , String arg1 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . WARN_INT , arg1 , null , null ) ;
public static DefaultHttpResponse function ( final FullHttpResponse arg0 ) { ImmutableMap . Builder < String , String > headerBuilder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , String > entry : arg0 . headers ( ) ) { headerBuilder . put ( entry ) ; } return builder ( ) . withVersion ( HttpProtocolVersion . versionOf ( arg0 . getProtocolVersion ( ) . text ( ) ) )
public void function ( ) throws IOException { ByteBuffer buffer = this . bufferQueue . peek ( ) ; while ( buffer ! = null ) { sockchannel . write ( buffer ) ;
private void function ( ) { OutputSettings . Syntax syntax = outputSettings ( ) . syntax ( ) ; if ( syntax = = OutputSettings . Syntax . html ) { Element metaCharset = selectFirst ( " meta[charset] " ) ;
public void function ( ) { DocumentType fail = new DocumentType ( " " , " " , " " ) ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { if ( " get " . equalsIgnoreCase ( arg0 . getMethod ( ) ) ) { getGetHandler ( arg0 ) . writeToResponse ( new SessionContext ( arg0 , arg1 ) ) ; return ; } if ( " post " . equalsIgnoreCase ( arg0 . getMethod ( ) ) ) { Optional < ResponseHandler > postHandler = getPostHandler ( arg0 ) ; if ( postHandler . isPresent ( ) ) { postHandler . get ( ) . writeToResponse ( new SessionContext ( arg0 , arg1 ) ) ; return ; } } throw new UnsupportedOperationException ( " Unsupported REST request " ) ; }
public void function ( ) { try { assertThat ( helper . get ( " http://localhost:8080 " ) , is ( " foo " ) ) ;
private byte [ ] function ( ) { byte [ ] bytes = new byte [ 2 ] ; bytes [ 0 ] = BufferTools . setBit ( bytes [ 0 ] , PRESERVE_TAG_BIT , preserveTag ) ; bytes [ 0 ] = BufferTools . setBit ( bytes [ 0 ] , PRESERVE_FILE_BIT , preserveFile ) ; bytes [ 0 ] = BufferTools . setBit ( bytes [ 0 ] , READ_ONLY_BIT , readOnly ) ; bytes [ 1 ] = BufferTools . setBit ( bytes [ 1 ] , GROUP_BIT , group ) ; bytes [ 1 ] = BufferTools . setBit ( bytes [ 1 ] , COMPRESSION_BIT , compression ) ; bytes [ 1 ] = BufferTools . setBit ( bytes [ 1 ] , ENCRYPTION_BIT , encryption ) ; bytes [ 1 ] = BufferTools . setBit ( bytes [ 1 ] , UNSYNCHRONISATION_BIT , unsynchronisation ) ; bytes [ 1 ] = BufferTools . setBit ( bytes [ 1 ] , DATA_LENGTH_INDICATOR_BIT , dataLengthIndicator ) ; return bytes ; }
public void function ( ) { when ( request . getMethod ( ) ) . thenReturn ( HttpMethod . GET ) ; assertThat ( extractor . extract ( request ) . get ( ) , is ( HttpMethod . GET . name ( ) ) ) ; }
public void function ( ) { byte [ ] frameData = { BYTE_FF , BYTE_F9 , BYTE_A2 , BYTE_40 } ; try { new MpegFrameForTesting ( frameData ) ;
public void function ( final String arg0 ) { this . headers . remove ( arg0 ) ; }
public SocketServer function ( final ActualSocketServer arg0 ) { ActualSocketServer newServer = newBaseServer ( ) ; newServer . addSettings ( this . getSettings ( ) ) ; newServer . addSettings ( arg0 . getSettings ( ) ) ; newServer . anySetting ( configuredMatcher ( ) , configured ( this . handler ) ) ; newServer . anySetting ( arg0 . configuredMatcher ( ) , arg0 . configured ( arg0 . handler ) ) ; newServer . addEvents ( this . eventTriggers ) ; newServer . addEvents ( arg0 . eventTriggers ) ; return newServer ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /post_event_with_header " ) ) , is ( " post_foo_with_header " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " 0XMOCOHEADER " ) ) ; }
public static < T > Iterable < T > function ( final T arg0 , final T arg1 , final T [ ] arg2 ) { checkNotNull ( arg0 ) ; checkNotNull ( arg1 ) ; checkNotNull ( arg2 ) ; if ( arg2 . length = = 0 ) { return of ( arg0 , arg1 ) ; } return ImmutableList . < T > builder ( ) . add ( arg0 )
public void function ( ) { logger . warn ( marker , message , param1 , param2 , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . WARN , marker , twoParams , exception ) ; }
@Test ( expected = IllegalArgumentException . class ) public void function ( ) throws IOException { Connection con = HttpConnection . connect ( " http://example.com " ) ; con . response ( ) . body ( ) ; }
@Test public void function ( ) { String html = " <a =empty /> " ; Element el = Jsoup . parse ( html ) . getElementsByTag ( " a " ) . get ( 0 ) ; Attributes attr = el . attributes ( ) ; assertEquals ( 1 , attr . size ( ) ) ; assertTrue ( attr . hasKey ( " =empty " ) ) ; assertEquals ( " " , attr . get ( " =empty " ) ) ; }
public void function ( ) { try { helper . get ( root ( ) ) ;
protected byte [ ] function ( ) { return BufferTools . packSynchsafeInteger ( dataLength ) ; }
boolean function ( Tag arg0 ) { Validate . notNull ( arg0 ) ; if ( arg0 . isBlock & & ! this . canContainBlock ) return false ; if ( ! arg0 . isBlock & & ! this . canContainInline ) return false ; if ( this . optionalClosing & & this . equals ( arg0 ) ) return false ; if ( this . empty | | this . isData ( ) ) return false ; if ( this . requiresSpecificParent ( ) & & this . getImplicitParent ( ) . equals ( arg0 ) ) return false ; if ( limitChildren ) { for ( Tag childParent : arg0 . ancestors ) { if ( childParent . equals ( this ) ) return true ; } return false ; } if ( ! excludes . isEmpty ( ) ) { for ( Tag excluded : excludes ) { if ( arg0 . equals ( excluded ) ) return false ; } } return true ; }
private void function ( final BaseHttpSetting arg0 ) { this . settings . add ( arg0 ) ; }
public Profiler function ( ) { stopLastStopWatch ( ) ; stopNestedProfilers ( ) ; globalStopWatch . stop ( ) ; return this ; }
private static void function ( Element arg0 , Elements arg1 ) { Element parent = arg0 . parent ( ) ; if ( parent ! = null & & ! parent . tagName ( ) . equals ( " #root " ) ) { arg1 . add ( parent ) ;
public void function ( String arg0 , Throwable arg1 ) { if ( logger . isLoggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , arg0 , null , arg1 ) ;
public static RequestExtractor function ( String arg0 ) { return new CookieRequestExtractor ( checkNotNull ( arg0 , " Null cookie is not allowed " ) ) ; }
public void function ( final SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; MutableHttpResponse httpResponse = arg0 . getHttpResponse ( ) ; if ( detector . hasHeader ( httpResponse , name ) ) { httpResponse . removeHeader ( name ) ; } String value = new String ( resource . readFor ( of ( request ) ) ) ; httpResponse . addHeader ( name , value ) ; }
protected ResponseHandler function ( ) { return configured ( this . handler ) ; }
public static ActualSocketServer function ( final int arg0 ) { return new ActualSocketServer ( arg0 , new Slf4jMonitor ( new SocketRequestDumper ( ) , new SocketResponseDumper ( ) ) ) ; }
public void function ( ) { Marker blue = MarkerFactory . getMarker ( BLUE ) ; assertEquals ( BLUE , blue . getName ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private static int function ( String arg0 ) { if ( " trace " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_TRACE ; } else if ( " debug " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_DEBUG ; } else if ( " info " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_INFO ; } else if ( " warn " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_WARN ; } else if ( " error " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_ERROR ; } return LOG_LEVEL_INFO ; }
private void function ( final CloseableHttpClient arg0 ) throws IOException { HttpRequestBase request = createRequest ( url , method ) ; if ( request instanceof HttpEntityEnclosingRequest & & content . isPresent ( ) ) { ( ( HttpEntityEnclosingRequest ) request ) . setEntity ( asEntity ( ) ) ; } arg0 . execute ( request ) ; }
private < T > Function < ? super T , T > function ( final Class < T > arg0 ) { return new Function < T , T > ( ) { @Override
private static Elements function ( Collection < Element > arg0 , Collection < Element > arg1 ) { Elements children = new Elements ( ) ; CHILD : for ( Element c : arg1 ) { for ( Element p : arg0 ) { if ( c . equals ( p ) ) { children . add ( c ) ; continue CHILD ; } } } return children ; }
public void function ( ) throws Exception { HttpServer server = Moco . httpServer ( 12306 ) ; WebSocketServer webSocketServer = server . websocket ( " /ws " ) ; webSocketServer . request ( by ( binary ( new byte [ ] { 1 , 2 , 3 } ) ) ) . response ( binary ( new byte [ ] { 4 , 5 , 6 } ) ) ; webSocketServer . ping ( text ( " hello " ) ) . pong ( text ( " world " ) ) ; running ( server , ( ) - > { final Endpoint endpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws/ " ) ) ;
private Optional < Resource > function ( final String arg0 , final TextContainer arg1 ) { FileContainer fileContainer = FileContainer . class . cast ( arg1 ) ; TextContainer filename = fileContainer . getName ( ) ; if ( filename . isRawText ( ) ) { return Optional . of ( invokeTarget ( arg0 , fileContainer . getName ( ) . getText ( ) , fileContainer . getCharset ( ) , Resource . class , String . class , Optional . class ) ) ; } if ( filename . isForTemplate ( ) ) { return Optional . of ( invokeTarget ( arg0 , createTemplate ( " text " , filename ) , fileContainer . getCharset ( ) , Resource . class , Resource . class , Optional . class ) ) ; } return Optional . absent ( ) ; }
public TextContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . FIELD_NAME ) { TextContainer . Builder builder = builder ( ) ; String operation = arg0 . getText ( ) . trim ( ) ; builder . withOperation ( operation ) ; JsonToken token = arg0 . nextToken ( ) ; if ( isForTemplate ( operation ) & & token = = JsonToken . START_OBJECT ) { return template ( arg0 , builder ) ; } if ( token = = JsonToken . VALUE_STRING ) { String text = arg0 . getText ( ) . trim ( ) ; arg0 . nextToken ( ) ; return builder . withText ( text ) . build ( ) ; } } return ( TextContainer ) arg1 . handleUnexpectedToken ( TextContainer . class , arg0 ) ; }
public static ContentResource function ( final Resource arg0 , final Optional < Charset > arg1 ) { return classpathFileResource ( checkNotNull ( arg0 , " Filename should not be null " ) , checkNotNull ( arg1 , " Charset should not be null " ) ) ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws IOException , ServletException { doIt ( arg0 , arg1 ) ; }
public Attribute function ( ) { checkModified ( ) ; if ( i > = size ) throw new NoSuchElementException ( ) ; final Attribute attr = new Attribute ( keys [ i ] , ( String ) vals [ i ] , Attributes . this ) ; i + + ; return attr ; }
static URL function ( URL arg0 ) { arg0 = punyUrl ( arg0 ) ; try {
public boolean function ( Element arg0 , Element arg1 ) { return ( arg1 . data ( ) . toLowerCase ( ) . contains ( searchText ) ) ; }
public void function ( ) { assertEquals ( " foo " , Charsetfunctions . stringAscii ( new byte [ ] { 102 , 111 , 111 } ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public Optional < String > function ( FullHttpRequest arg0 ) { return Optional . fromNullable ( cookies . decodeCookie ( arg0 . headers ( ) . get ( " Cookie " ) , key ) ) ; }
void function ( StringBuilder arg0 , Document . OutputSettings arg1 ) { for ( Attribute attribute : this ) { arg0 . append ( "   " ) ;
public void function ( Node arg0 , int arg1 ) { counter . incrementAndGet ( ) ; }
public void function ( ) throws Exception { helper . get ( remoteUrl ( " /targets " ) ) ; }
public static ContentResource function ( final Supplier < Object > arg0 ) { return json ( Suppliers . from ( checkNotNull ( arg0 , " Json object should not be null " ) ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { delegate ( ) . warn ( arg0 , arg1 ) ; }
boolean function ( Element arg0 ) { return arg0 . attr ( key ) . toLowerCase ( ) . startsWith ( value ) ; }
public void function ( ) throws Exception { final String jsonText = Jsons . toJson ( of ( " foo " , " bar " ) ) ; server . request ( by ( json ( jsonText ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public static MocoConfig function ( final HttpHeader arg0 ) { return response ( with ( checkNotNull ( arg0 , " Response handler should not be null " ) ) ) ; }
public static RestSetting function ( final String arg0 , final RequestMatcher arg1 , final ResponseHandler . . . arg2 ) { return new PutRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , Optional . of ( checkNotNull ( arg1 , " Put request matcher should no be null " ) ) ,
Tag function ( ) { tagName = null ; normalName = null ; pendingAttributeName = null ; reset ( pendingAttributeValue ) ; pendingAttributeValueS = null ; hasEmptyAttributeValue = false ; hasPendingAttributeValue = false ; selfClosing = false ; attributes = null ; return this ; }
private void function ( ) { radioJUL = new JRadioButton ( ) ; radioJUL . setText ( " from JUL to SLF4J  " ) ; radioJUL . setToolTipText ( " Select this button if you wish to migrate a Java project using java.utl.logging (JUL) to use SLF4J. " ) ; }
public void function ( ) throws Exception { testIncrementalFrame ( true , size ) ; }
public void function ( String arg0 , Object arg1 ) { recordEventwithoutMarkerArgArray ( Level . ERROR , arg0 , new Object [ ] { arg1 } , null ) ;
public Builder function ( HttpsArg arg0 ) { this . arg0 = arg0 ; return this ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null | | getClass ( ) ! = arg0 . getClass ( ) ) return false ; Protocol protocol = ( Protocol ) arg0 ; return providedProtocol . equals ( protocol . providedProtocol ) ; }
private void function ( int arg0 , String arg1 , Throwable arg2 ) { if ( isLoggable ( arg0 ) ) { logInternal ( arg0 , arg1 , arg2 ) ;
public static void function ( arg0 String arg1 , String arg2 ) { if ( arg1 = = null | | arg1 . length ( ) = = 0 ) throw new IllegalArgumentException ( arg2 ) ;
protected Optional < String > function ( final HttpRequest arg0 ) { return of ( arg0 . getVersion ( ) . text ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " xpath.json " , PORT ) ; helper . postFile ( " http://localhost:8080/xpath " , " bar.xml " ) ; }
public LoggingEventBuilder function ( ) { return delegate ( ) . atWarn ( ) ; }
public void function ( ) { MountTo to = new MountTo ( " /dir " ) ; assertThat ( to . extract ( " /dir/ " ) , nullValue ( ) ) ; }
public static ByteBuf function ( final byte [ ] arg0 ) { return Unpooled . wrappedBuffer ( arg0 ) ; }
public void function ( byte [ ] arg0 ) throws NotSupportedException { int offset = packHeader ( arg0 , 0 ) ; if ( extendedHeader ) { offset = packExtendedHeader ( arg0 , offset ) ; } offset = packFrames ( arg0 , offset ) ; if ( footer ) { offset = packFooter ( arg0 , dataLength ) ;
public final void function ( final MutableHttpResponse arg0 ) { arg0 . addHeader ( " Access-Control-Allow-Methods " , String . join ( " , " , methods ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.2.4 " ) ; assertEquals ( " NON-STRICT " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " bla " ) ; logger . atDebug ( ) . log ( " hello " ) ; List < LogRecord > recordList = listHandler . recordList ; assertEquals ( 1 , recordList . size ( ) ) ; LogRecord logRecod = recordList . get ( 0 ) ; assertEquals ( this . getClass ( ) . getName ( ) , logRecod . getSourceClassName ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { formatAndLog ( INFO_STR , arg0 , arg1 , arg2 ) ; }
public void function ( ) throws Exception { assertThat ( helper . getWithVersion ( remoteUrl ( " /template " ) , HttpVersion . HTTP_1_0 ) , is ( " HTTP/1.0 " ) ) ; }
private String function ( String arg0 ) { if ( arg0 = = null ) return arg0 ; int slashIndex = arg0 . indexOf ( '/' ) ; if ( slashIndex < 0 ) return trimField ( arg0 ) ; return trimField ( arg0 . substring ( 0 , slashIndex ) ) ; }
public final void function ( Object arg0 , Throwable arg1 ) { if ( isLevelEnabled ( SimpleLog . LOG_LEVEL_FATAL ) ) { log ( SimpleLog . LOG_LEVEL_FATAL , arg0 , arg1 ) ;
public static ResponseHandler function ( final ContentResource arg0 , final Failover arg1 , final int . . . arg2 ) { return new ProxyResponseHandler ( toUrlFunction ( checkNotNull ( arg0 , " URL should not be null " ) ) , checkNotNull ( arg1 , " Failover should not be null " ) ,
public final Builder function ( final TextContainer arg0 ) { this . url = arg0 ; return this ; }
public void function ( ) throws Exception { String source = " %1-%2 something %1-%3 " ; assertEquals ( " -%2 something -%3 " , BufferTools . substitute ( source , " %1 " , null ) ) ; }
private FullHttpResponse function ( FullHttpRequest arg0 ) { FullHttpResponse response = defaultResponse ( arg0 , HttpResponseStatus . OK ) ; for ( BaseSetting setting : settings ) { if ( setting . match ( arg0 ) ) { setting . writeToResponse ( arg0 , response ) ; return response ; } } if ( anyResponseHandler ! = null ) { if ( anyRequestMatcher . match ( arg0 ) ) { anyResponseHandler . writeToResponse ( arg0 , response ) ; return response ; } } return defaultResponse ( arg0 , HttpResponseStatus . BAD_REQUEST ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { if ( ! logger . isTraceEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg1 , arg2 )
public Setting function ( RequestMatcher arg0 ) { return request ( and ( new GetMethodRequestMatcher ( ) , arg0 ) ) ; }
public String function ( ) { return String . format ( " [%s^=%s] " , key , value ) ; }
public void function ( final Throwable arg0 ) { arg0 . printStackTrace ( System . err ) ; }
public void function ( ClientHandshakeBuilder arg0 ) throws InvalidHandshakeException { this . handshakerequest = draft . postProcessHandshakeRequestAsClient ( arg0 ) ; resourceDescriptor = arg0 . getResourceDescriptor ( ) ; assert ( resourceDescriptor ! = null ) ; try { wsl . onWebsocketHandshakeSentAsClient ( this , this . handshakerequest ) ; } catch ( InvalidDataException e ) { throw new InvalidHandshakeException ( " Handshake data rejected by client. " ) ; } catch ( RuntimeException e ) { log . error ( " Exception in startHandshake: {} " , e ) ; wsl . onWebsocketError ( this , e ) ; throw new InvalidHandshakeException ( " rejected because of  " + e ) ; } write ( draft . createHandshake ( this . handshakerequest , role ) ) ; }
public FullHttpResponse function ( ) { FullHttpResponse response = new DefaultFullHttpResponse ( HttpVersion . valueOf ( this . version . text ( ) ) , HttpResponseStatus . valueOf ( this . status ) ) ; for ( Map . Entry < String , String > entry : getHeaders ( ) . entrySet ( ) ) { response . headers ( ) . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } if ( this . content ! = null ) { response . content ( ) . writeBytes ( this . content . getContent ( ) ) ; } return response ; }
private void function ( String . . . arg0 ) { Iterator < Element > it = stack . descendingIterator ( ) ; while ( it . hasNext ( ) ) { Element next = it . next ( ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { recordEvent ( Level . DEBUG , arg0 , arg1 , new Object [ ] { arg2 , arg3 } , null ) ; }
public void function ( ) { LimitExceededException limitExceededException = new LimitExceededException ( ) ; assertInstanceOf ( InvalidDataException . class , limitExceededException , " LimitExceededException must extend InvalidDataException " ) ; }
protected boolean function ( WebSocket arg0 ) { synchronized ( connections ) { return this . connections . add ( arg0 ) ;
protected < T > Predicate < Field > function ( final T arg0 ) { return new Predicate < Field > ( ) { @Override
boolean function ( ) { return tagPending . tagName . equals ( lastStartTag . tagName ) ; }
public static Elements function ( Evaluator arg0 , Element arg1 ) { Elements elements = new Elements ( ) ; accumulateMatches ( arg0 , elements , arg1 ) ; return elements ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://infohound.net/tools/302-cookie.pl " ) ; Connection . Response res = con . execute ( ) ; Map < String , String > cookies = res . cookies ( ) ; assertEquals ( " asdfg123 " , cookies . get ( " token " ) ) ; assertEquals ( " jhy " , cookies . get ( " uid " ) ) ; Document doc = Jsoup . connect ( echoURL ) . cookies ( cookies ) . get ( ) ; assertEquals ( " uid=jhy; token=asdfg123 " , ihVal ( " HTTP_COOKIE " , doc ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public boolean function ( String arg0 ) { String protocolHeader = arg0 . replaceAll ( "   " , " " ) ; String [ ] headers = protocolHeader . split ( " , " ) ; for ( String header : headers ) { if ( providedProtocol . equals ( header ) ) { return true ; } } return false ; }
public < T extends Node > List < T > function ( String arg0 , Class < T > arg1 ) { return NodeUtils . selectXpath ( arg0 , this , arg1 ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <div>Hello there</div> " ) ; Element div = doc . expectFirst ( " div " ) ; TextNode tn = ( TextNode ) div . childNode ( 0 ) ; Throwable ex = assertThrows ( ValidationException . class , ( ) - > tn . splitText ( - 5 ) ) ; assertEquals ( " Split offset must be not be negative " , ex . getMessage ( ) ) ; ex = assertThrows ( ValidationException . class , ( ) - > tn . splitText ( 500 ) ) ; assertEquals ( " Split offset must not be greater than current text length " , ex . getMessage ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${foo} " , " foo " , jsonPath ( " $.book.price " ) ) ) ; running ( server , ( ) - > { assertThat ( helper . postContent ( remoteUrl ( " /template " ) , " { \" book \" :{ \" price \" : \" 2 \" }} " ) , is ( " 2 " ) ) ;
private HttpServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { HttpServer targetServer = createBaseHttpServer ( arg0 , arg1 ) ; targetServer . request ( by ( uri ( " /favicon.ico " ) ) ) . response ( with ( pathResource ( " favicon.png " ) ) , header ( HttpHeaders . CONTENT_TYPE , " image/png " ) ) ; return targetServer ; }
public void function ( ) throws Exception { Header [ ] headers = helper . getResponse ( root ( ) ) . getHeaders ( HttpHeaders . CONTENT_TYPE ) ; assertThat ( headers . length , is ( 1 ) ) ; }
final void function ( ) { if ( attributes = = null ) attributes = new Attributes ( ) ; if ( pendingAttributeName ! = null ) { Attribute attribute ; if ( pendingAttributeValue = = null ) attribute = new Attribute ( pendingAttributeName , " " ) ; else attribute = new Attribute ( pendingAttributeName , pendingAttributeValue . toString ( ) ) ; attributes . put ( attribute ) ; } pendingAttributeName = null ; if ( pendingAttributeValue ! = null ) pendingAttributeValue . delete ( 0 , pendingAttributeValue . length ( ) ) ;
public void function ( String arg0 , Throwable arg1 ) { recordEvent ( Level . TRACE , arg0 , null , arg1 ) ; }
public static ResponseHandler function ( final RecorderConfig . . . arg0 ) { RecorderConfigurations configurations = RecorderConfigurations . create ( checkNotNull ( arg0 , " Configuration should not be null " ) ) ; return new DynamicRecordHandler ( configurations ) ; }
public void function ( ) throws Exception { runTestScenarioReconnect ( true ) ; }
public void function ( String arg0 ) { int len = arg0 . length ( ) ; if ( len > queue . size ( ) ) throw new IllegalStateException ( " Queue not long enough to consume sequence " ) ; char [ ] seqChars = arg0 . toCharArray ( ) ; for ( int i = 0 ; i < len ; i + + ) { Character qChar = consume ( ) ;
public void function ( String arg0 , Object arg1 ) { if ( isTraceEnabled ( ) ) { handle_1ArgsCall ( Level . TRACE , null , arg0 , arg1 ) ;
void function ( Appendable arg0 , int arg1 , Document . OutputSettings arg2 ) throws IOException { if ( arg2 . prettyPrint ( ) & & ( ( isEffectivelyFirst ( ) & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . formatAsBlock ( ) ) | | ( arg2 . outline ( ) ) ) ) indent ( arg0 , arg1 , arg2 ) ; arg0 . append ( " <!-- " )
private HttpResponse function ( final HttpRequest arg0 , final CloseableHttpResponse arg1 ) throws IOException { if ( failover . shouldFailover ( arg1 ) ) { return failover . failover ( arg0 ) ; } HttpResponse httpResponse = setupNormalResponse ( arg1 ) ; failover . onCompleteResponse ( arg0 , httpResponse ) ; return httpResponse ; }
private void function ( final FullHttpRequest arg0 , final FullHttpResponse arg1 , MocoHandler arg2 ) { if ( isKeepAlive ( arg0 ) ) { setKeepAlive ( arg1 , true ) ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . request ( and ( by ( uri ( " /foo " ) ) , eq ( header ( " header " ) , " blah " ) ) ) . response ( " bar " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . getWithHeader ( remoteUrl ( " /foo " ) , of ( " header " , " blah " ) ) ) ) ;
public void function ( ) { Selector . SelectorParseException exception = assertThrows ( Selector . SelectorParseException . class , ( ) - > QueryParser . parse ( " section > a[href= \" ] " ) ) ; assertEquals ( " Did not find balanced marker at 'href=' " ,
public static Failover function ( final File arg0 ) { return new DefaultFailover ( arg0 ) ; }
private static String function ( final String arg0 ) { checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) ; if ( arg0 . contains ( " / " ) ) { throw new IllegalArgumentException ( " REST ID should not contain '/' " ) ; } return arg0 ; }
public void function ( arg0 final Path arg1 ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = arg1 . resolve ( " tempfile " ) . toFile ( ) ; System . setOut ( new PrintStream ( file ) ) ; assertThat ( helper . get ( remoteUrl ( " /post_event_with_header " ) ) , is ( " post_foo_with_header " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) , containsString ( " 0XMOCOHEADER " ) ) ; }
public XmlDeclaration function ( ) { String data = getData ( ) ; Document doc = Jsoup . parse ( " < " + data . substring ( 1 , data . length ( ) - 1 ) + " > " , baseUri ( ) , Parser . xmlParser ( ) ) ; XmlDeclaration decl = null ; if ( doc . children ( ) . size ( ) > 0 ) { Element el = doc . child ( 0 ) ; decl = new XmlDeclaration ( NodeUtils . parser ( doc ) . settings ( ) . normalizeTag ( el . tagName ( ) ) , data . startsWith ( " ! " ) ) ; decl . attributes ( ) . addAll ( el . attributes ( ) ) ; } return decl ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element div = doc . getElementById ( " 1 " ) ; div . html ( " <p>there</p><p>now</p> " ) ; assertEquals ( " <p>there</p><p>now</p> " , div . html ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${random(-10)} " ) ) ; running ( server , ( ) - > { HttpResponse response = helper . getResponse ( remoteUrl ( " /template " ) ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public String function ( HttpRequest arg0 ) { return arg0 . getMethod ( ) . getName ( ) . toUpperCase ( ) ; }
public void function ( ) throws Exception { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " \ u03B3 \ u03B5 \ u03B9 \ u03AC " ; BufferTools . stringIntoByteBuffer ( s , 1 , 2 , buffer , 0 , " UTF-16BE " ) ; byte [ ] expectedBuffer = { 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0 , 0 , 0 , 0 , 0 , 0 } ; assertTrue ( Arrays . equals ( expectedBuffer , buffer ) ) ; }
public static ContentResource function ( final String arg0 , Optional < Charset > arg1 ) { return pathResource ( text ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , checkNotNull ( arg1 , " Charset should not be null " ) ) ; }
public void function ( ) throws IOException { File thumb = ParseTest . getFile ( " /htmltests/thumb.jpg " ) ; Document result = Jsoup . connect ( " http://regex.info/exif.cgi " ) . data ( " f " , thumb . getName ( ) , new FileInputStream ( thumb ) ) . post ( ) ; assertEquals ( " Baseline DCT, Huffman coding " , result . select ( " td:contains(Process) + td " ) . text ( ) ) ;
public Elements function ( ) { return siblings ( null , false , true ) ; }
public void function ( String arg0 , Object arg1 ) { recordEvent ( Level . INFO , arg0 , new Object [ ] { arg1 } , null ) ; }
private static AbstractID3v2Tag function ( byte [ ] arg0 ) throws NoSuchTagException , UnsupportedTagException , InvalidDataException { ID3v22Tag tag = new ID3v22Tag ( arg0 ) ; if ( tag . getFrameSets ( ) . isEmpty ( ) ) { tag = new ID3v22Tag ( arg0 , true ) ; } return tag ; }
Tag function ( ) { super . reset ( ) ; tagName = null ; normalName = null ; selfClosing = false ; attributes = null ; resetPendingAttr ( ) ; return this ; }
public static String function ( Map < String , Object > arg0 ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; try {
private void function ( int arg0 ) { try { Thread . sleep ( arg0 ) ;
public void function ( ) { XmlRequestMatcher unitUnderTest = new XmlRequestMatcher ( text ( " <request><parameters><id>1</id></parameters></request> " ) ) ; HttpRequest request = DefaultHttpRequest . builder ( ) . withContent ( " " ) . build ( ) ; assertThat ( unitUnderTest . match ( request ) , is ( false ) ) ; }
public ByteChannel function ( SocketChannel arg0 ) throws IOException { SSLEngine e = sslcontext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; return new SSLSocketChannel ( arg0 , e ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " query.json " ) ; assertThat ( helper . get ( remoteUrl ( " /query?param=foo " ) ) , is ( " response_for_query_request " ) ) ; }
public Elements function ( String arg0 ) { for ( Element element : contents ) element . val ( arg0 ) ; return this ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <div><p>One<p id=2>Two<p>Three " ) ; doc . filter ( ( node , depth ) - > node . attr ( " id " ) . equals ( " 2 " ) ? NodeFilter . FilterResult . REMOVE : NodeFilter . FilterResult . CONTINUE ) ; assertEquals ( " <div><p>One</p><p>Three</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " xml.json " ) ; assertThat ( helper . postFile ( remoteUrl ( " /xml " ) , " foo.xml " ) , is ( " response_for_xml_request " ) ) ; }
public void function ( Object arg0 ) { logger . debug ( String . valueOf ( arg0 ) ) ; }
public InputStream function ( ) { ClassLoader threadCL = getContextClassLoader ( ) ; if ( threadCL ! = null ) { return threadCL . getResourceAsStream ( name ) ;
@Test public void function ( ) { Attributes a = new Attributes ( ) ; a . put ( " One " , " One " ) ; a . put ( " Two " , " Two " ) ; assertEquals ( 2 , a . size ( ) ) ; a . put ( Attributes . internalKey ( " baseUri " ) , " example.com " ) ; a . put ( Attributes . internalKey ( " another " ) , " example.com " ) ; a . put ( Attributes . internalKey ( " last " ) , " example.com " ) ; a . remove ( Attributes . internalKey ( " last " ) ) ; assertEquals ( 4 , a . size ( ) ) ; assertEquals ( 2 , a . asList ( ) . size ( ) ) ; }
public PongResponse function ( String arg0 ) { PingPongSetting setting = new PingPongSetting ( arg0 ) ; settings . add ( setting ) ; return setting ; }
private String function ( final HttpRequest arg0 ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( arg0 . getMethod ( ) . name ( ) ) . append ( ' ' ) . append ( arg0 . getUri ( ) ) . append ( asQuery ( arg0 . getQueries ( ) ) ) . append ( ' ' ) . append ( arg0 . getVersion ( ) . text ( ) ) ; return buf . toString ( ) ; }
public static RestSettingBuilder function ( final RestIdMatcher arg0 ) { return single ( HttpMethod . GET , checkNotNull ( arg0 , " ID Matcher should not be null " ) ) ; }
private boolean function ( Header arg0 ) { return ! IGNORED_RESPONSE_HEADERS . contains ( arg0 . getName ( ) ) ; }
public void function ( FullHttpResponse arg0 ) { for ( MocoMonitor monitor : monitors ) { monitor . onMessageLeave ( arg0 ) ;
public void function ( Node arg0 , int arg1 ) { if ( arg0 instanceof Element ) { Element element = ( Element ) arg0 ;
public void function ( ) { connections . clear ( ) ; connections . addAll ( connections ( ) ) ; long current = ( System . currentTimeMillis ( ) - ( connectionLostTimeout * 1500 ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; if ( webSocketImpl . getLastPong ( ) < current ) { if ( WebSocketImpl . DEBUG ) System . out . println ( " Closing connection due to no pong received:  " + conn . toString ( ) ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , false ) ; } else { webSocketImpl . sendPing ( ) ; } } } connections . clear ( ) ; }
private static Iterable < InputStream > function ( final Iterable < File > arg0 ) { return FluentIterable . from ( arg0 ) . transform ( new Function < File , InputStream > ( ) { @Override
public String function ( final FullHttpResponse arg0 ) { return String . format ( " Response return: \ n \ n%s \ n " , responseDumper . dump ( arg0 ) ) ; }
public byte [ ] function ( final Optional < HttpRequest > arg0 ) { try { return toByteArray ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ) ;
public HttpProtocolVersion function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { try { return HttpProtocolVersion . versionOf ( strip ( arg0 . getText ( ) ) ) ;
private void function ( ) { TextNode textNode ; if ( tq . peek ( ) = = '<' ) { tq . advance ( ) ; textNode = new TextNode ( " < " , baseUri ) ; } else { String text = tq . consumeTo ( " < " ) ; textNode = TextNode . createFromEncoded ( text , baseUri ) ; } last ( ) . appendChild ( textNode ) ; }
public void function ( ActionEvent arg0 ) { if ( arg0 . getSource ( ) = = chatField ) { if ( cc ! = null ) {
public void function ( ) throws Exception { File temp = File . createTempFile ( " temp " , Long . toString ( System . nanoTime ( ) ) ) ; server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( " foo " , tape ( temp . getPath ( ) ) , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( " foo " , tape ( temp . getPath ( ) ) , template ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { assertThat ( helper . getForStatus ( remoteUrl ( " /tape-replay?type=bar " ) ) , is ( 400 ) ) ;
static void function ( StringBuilder arg0 , DurationUnit arg1 ) { switch ( arg1 ) { case NANOSECOND :
public void function ( Object arg0 ) { logger . warn ( String . valueOf ( arg0 ) ) ; }
private static HttpServer function ( final Resource arg0 , final int arg1 ) { return PARSER . parseServer ( ImmutableList . of ( toStream ( arg0 ) ) , arg1 , false ) ; }
private static < F , T > Function < F , T > function ( final T arg0 ) { return new Function < F , T > ( ) { @Override
public void function ( ) throws Exception { ResponseHandler handler = mock ( ResponseHandler . class ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( " content " ) ) ) . response ( handler ) ; server . request ( by ( uri ( " /event " ) ) ) . response ( " event " ) . on ( complete ( post ( text ( remoteUrl ( " /target " ) ) , text ( " content " ) ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " event " ) ) ) ; verify ( handler ) . writeToResponse ( any ( SessionContext . class ) ) ; }
private Level function ( int arg0 ) { Level log4jLevel ; switch ( arg0 ) { case LocationAwareLogger . TRACE_INT : log4jLevel = traceCapable ? Level . TRACE : Level . DEBUG ; break ; case LocationAwareLogger . DEBUG_INT : log4jLevel = Level . DEBUG ; break ; case LocationAwareLogger . INFO_INT : log4jLevel = Level . INFO ; break ; case LocationAwareLogger . WARN_INT : log4jLevel = Level . WARN ; break ; case LocationAwareLogger . ERROR_INT : log4jLevel = Level . ERROR ; break ; default : throw new IllegalStateException ( " Level number  " + arg0 + "  is not recognized. " ) ; } return log4jLevel ; }
private boolean function ( final Object arg0 , final Object arg1 ) { if ( arg0 instanceof String & & arg1 instanceof String ) { if ( ! doMatch ( ( ( String ) arg0 ) . toLowerCase ( ) , ( ( String ) arg1 ) . toLowerCase ( ) ) ) { return true ; } } if ( arg0 instanceof String [ ] & & arg1 instanceof String [ ] ) { String [ ] thisValues = ( String [ ] ) arg0 ; String [ ] thatValues = ( String [ ] ) arg1 ; if ( ! doMatchHeader ( thisValues , thatValues ) ) { return true ; } } return false ; }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; IExtension newDeflateExtension = deflateExtension . copyInstance ( ) ; assertEquals ( deflateExtension . toString ( ) , newDeflateExtension . toString ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.3.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 200 ) ;
private IllegalStateException function ( String arg0 , State arg1 , State arg2 ) { return new IllegalStateException ( " Unexpected state  " + arg2 + "  for current state  " + arg1 + "  for  " + arg0 ) ;
public void function ( ) { HttpClient client = new DefaultHttpClient ( ) ; try { client . execute ( new HttpGet ( url ) ) ;
private FullHttpResponse function ( FullHttpRequest arg0 ) { FullHttpResponse response = defaultResponse ( arg0 , HttpResponseStatus . OK ) ; LazyHttpRequest httpRequest = new LazyHttpRequest ( arg0 ) ; SessionContext context = new SessionContext ( arg0 , response ) ; for ( BaseSetting setting : settings ) { if ( setting . match ( httpRequest ) ) { setting . writeToResponse ( context ) ; return response ; } } if ( anySetting . match ( httpRequest ) ) { anySetting . writeToResponse ( context ) ; return response ; } monitor . onUnexpectedMessage ( arg0 ) ; return defaultResponse ( arg0 , HttpResponseStatus . BAD_REQUEST ) ; }
public void function ( ) throws IOException { this . socketChannel . close ( ) ; this . wsl . onClose ( this ) ; }
public Range . AttributeRange function ( ) { if ( parent = = null ) return Range . AttributeRange . Untracked ; return parent . sourceRange ( key ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <span>Hello <div>there</div> <span>now</span></span> " ) ; assertEquals ( " <span>Hello <div>there</div><span>now</span></span> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " header.json " ) ; assertThrows ( IOException . class , ( ) - > { helper . get ( remoteUrl ( " /header " ) ) ;
public void function ( LoggingEvent arg0 ) { int levelInt = arg0 . getLevel ( ) . toInt ( ) ; if ( ! isLevelEnabled ( levelInt ) ) { return ; } FormattingTuple tp = MessageFormatter . arrayFormat ( arg0 . getMessage ( ) , arg0 . getArgumentArray ( ) , arg0 . getThrowable ( ) ) ; log ( levelInt , tp . getMessage ( ) , arg0 . getThrowable ( ) ) ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( marker , message ) ; break ; case DEBUG : logger . debug ( marker , message ) ; break ; case INFO : logger . info ( marker , message ) ; break ; case WARN : logger . warn ( marker , message ) ; break ; case ERROR : logger . error ( marker , message ) ; break ; } verifyMessage ( arg0 , marker , null , null ) ; }
public void function ( ) throws Exception { assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ; assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " bar " ) ) ; }
@Test public void function ( ) { DocumentType html5 = new DocumentType ( " html " , " " , " " ) ; assertEquals ( " <!doctype html> " , html5 . outerHtml ( ) ) ; DocumentType publicDocType = new DocumentType ( " html " , " -//IETF//DTD HTML// " , " " ) ; assertEquals ( " <!DOCTYPE html PUBLIC  \" -//IETF//DTD HTML// \" > " , publicDocType . outerHtml ( ) ) ; DocumentType systemDocType = new DocumentType ( " html " , " " , " http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd " ) ; assertEquals ( " <!DOCTYPE html SYSTEM  \" http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd \" > " , systemDocType . outerHtml ( ) ) ; DocumentType combo = new DocumentType ( " notHtml " , " --public " , " --system " ) ; assertEquals ( " <!DOCTYPE notHtml PUBLIC  \" --public \"   \" --system \" > " , combo . outerHtml ( ) ) ; assertEquals ( " notHtml " , combo . name ( ) ) ; assertEquals ( " --public " , combo . publicId ( ) ) ; assertEquals ( " --system " , combo . systemId ( ) ) ; }
public InputStream function ( ) { return new ByteArrayInputStream ( text . getBytes ( ) ) ; }
private HttpServer function ( List < InputStream > arg0 , int arg1 ) { HttpServer server = new ActualHttpServer ( arg1 ) ; for ( InputStream stream : arg0 ) { HttpServer parsedServer = httpServerParser . parseServer ( stream , arg1 ) ; server = mergeServer ( server , parsedServer ) ; } return server ; }
public IProtocol function ( ) { return new Protocol ( getProvidedProtocol ( ) ) ; }
protected Optional < String [ ] > function ( final HttpRequest arg0 ) { final ImmutableMap < String , String > headers = arg0 . getHeaders ( ) ; String [ ] extractedValues = from ( headers . entrySet ( ) ) . filter ( isForName ( name ) ) . transform ( toValue ( ) ) . toArray ( String . class ) ; if ( extractedValues . length > 0 ) { return of ( extractedValues ) ; } return absent ( ) ; }
public Element function ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . childElementsList ( ) ; int index = indexInList ( this , siblings ) ; if ( index > 0 ) return siblings . get ( index - 1 ) ;
public void function ( ) throws Exception { server . get ( by ( uri ( " / " ) ) ) . response ( " foo " ) ; server . get ( by ( uri ( " /redirectTo " ) ) ) . redirectTo ( root ( ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( String arg0 , Object arg1 , Object arg2 ) { logger . warn ( arg0 , arg1 , arg2 ) ; }
public void function ( ) { attributes . remove ( attr . getKey ( ) ) ; }
public void function ( WebSocket arg0 , Exception arg1 ) { arg1 . printStackTrace ( ) ; if ( arg0 ! = null ) {
public String function ( HttpRequest arg0 ) { String uri = arg0 . getUri ( ) ; int index = uri . indexOf ( " ? " ) ; return index = = - 1 ? null : extractFromParameters ( uri . substring ( index + 1 ) ) ; }
private void function ( Node arg0 ) { currentElement ( ) . appendChild ( arg0 ) ; }
public void function ( BundleEvent arg0 ) { eventList . add ( arg0 ) ; }
public void function ( ) { final Document doc = createHtmlDocument ( " dontTouch " ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; Element selectedElement = doc . select ( " meta[charset] " ) . first ( ) ; assertEquals ( charsetUtf8 , selectedElement . attr ( " charset " ) ) ; assertTrue ( doc . select ( " meta[name=charset] " ) . isEmpty ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public FilterResult function ( Node arg0 , int arg1 ) { return FilterResult . CONTINUE ; }
public void function ( ) throws IOException { runWithConfiguration ( " cookie.json " ) ; Cookie decodeCookie = getCookie ( " /cookie " ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; }
public void function ( ) throws IOException { Header [ ] headers = helper . getResponse ( root ( ) ) . getHeaders ( " foo " ) ; assertThat ( headers . length , is ( 2 ) ) ; assertThat ( headers [ 0 ] . getValue ( ) , is ( " bar " ) ) ; assertThat ( headers [ 1 ] . getValue ( ) , is ( " moco " ) ) ; }
public void function ( ) throws InterruptedException , IOException { if ( ! socketBuffer . hasRemaining ( ) ) { socketBuffer . rewind ( ) ; socketBuffer . limit ( socketBuffer . capacity ( ) ) ; if ( sockchannel . read ( socketBuffer ) = = - 1 ) { close ( ) ; } socketBuffer . flip ( ) ; } if ( socketBuffer . hasRemaining ( ) ) { if ( DEBUG )
public void function ( ) throws IOException { if ( SSL = = 4 ) { sslEngine . closeOutbound ( ) ;
public Element function ( String arg0 , boolean arg1 ) { attributes . put ( arg0 , arg1 ) ; return this ; }
public void function ( ) { assertEquals ( " \ n<!-- This is one heck of a comment! --> " , comment . toString ( ) ) ; }
public final boolean function ( final Request arg0 ) { Optional < T > extractContent = extractor . extract ( arg0 ) ; return extractContent . filter ( this : : matchContent ) . isPresent ( ) ; }
public ResponseSetting function ( ProxyConfig arg0 ) { return proxy ( arg0 , Failover . EMPTY_FAILOVER ) ; }
@Test public void function ( ) { String h = " <div><p><A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote> " ; String cleanHtml = Jsoup . clean ( h , Whitelist . basic ( ) . removeEnforcedAttribute ( " a " , " rel " ) ) ; assertEquals ( " <p><a href= \" http://nice.com \" >Nice</a></p><blockquote>Hello</blockquote> " , TextUtil . stripNewlines ( cleanHtml ) ) ;
private Runner function ( StartArgs arg0 ) { final File configuration = new File ( arg0 . getConfigurationFile ( ) ) ; final FileRunner fileRunner = createConfigurationFileRunner ( configuration , arg0 . getPort ( ) ) ; Monitor fileMonitor = monitorFactory . createConfigurationMonitor ( configuration , fileRunner ) ; return new MonitorRunner ( fileRunner , fileMonitor ) ; }
public static byte [ ] function ( byte [ ] arg0 , int arg1 , int arg2 , int arg3 ) throws java . io . IOException { if ( arg0 = = null ) { throw new IllegalArgumentException ( " Cannot serialize a null array. " ) ; } if ( arg1 < 0 ) { throw new IllegalArgumentException ( " Cannot have negative offset:  " + arg1 ) ; } if ( arg2 < 0 ) { throw new IllegalArgumentException ( " Cannot have length offset:  " + arg2 ) ; } if ( arg1 + arg2 > arg0 . length ) { throw new IllegalArgumentException ( String . format ( " Cannot have offset of %d and length of %d with array of length %d " , arg1 , arg2 , arg0 . length ) ) ; } if ( ( arg3 & GZIP ) ! = 0 ) { java . io . ByteArrayOutputStream baos = null ;
private void function ( StringBuilder arg0 ) { appendWhitespaceIfBr ( this , arg0 ) ; for ( Node child : childNodes ) { if ( child instanceof TextNode ) {
public void function ( ) throws Exception { ID3v2 id3tag = new ID3v24Tag ( ) ; setTagFields ( id3tag ) ; id3tag . setPadding ( true ) ; byte [ ] data = id3tag . toBytes ( ) ; ID3v2 id3tagCopy = new ID3v24Tag ( data ) ; assertEquals ( 2131 + AbstractID3v2Tag . PADDING_LENGTH , data . length ) ; assertEquals ( id3tag , id3tagCopy ) ; }
@Test public void function ( ) { String html = " <p>jsoup</p><script>jsoup</script><span><!-- comments --></span> " ; Document doc = Jsoup . parse ( html ) ; Element body = doc . body ( ) ; Elements dataEls1 = body . select ( " :containsData(jsoup) " ) ; Elements dataEls2 = body . select ( " script:containsData(jsoup) " ) ; Elements dataEls3 = body . select ( " span:containsData(comments) " ) ; Elements dataEls4 = body . select ( " :containsData(s) " ) ; assertEquals ( 2 , dataEls1 . size ( ) ) ; assertEquals ( 1 , dataEls2 . size ( ) ) ; assertEquals ( dataEls1 . last ( ) , dataEls2 . first ( ) ) ; assertEquals ( " <script>jsoup</script> " , dataEls2 . outerHtml ( ) ) ; assertEquals ( 1 , dataEls3 . size ( ) ) ; assertEquals ( " span " , dataEls3 . first ( ) . tagName ( ) ) ; assertEquals ( 3 , dataEls4 . size ( ) ) ; assertEquals ( " body " , dataEls4 . first ( ) . tagName ( ) ) ; assertEquals ( " script " , dataEls4 . get ( 1 ) . tagName ( ) ) ; assertEquals ( " span " , dataEls4 . get ( 2 ) . tagName ( ) ) ; }
public void function ( ) throws Exception { server = httpserver ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . response ( text ( " blah " ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( ) throws CancelledKeyException { int size = oqueue . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { WebSocketImpl conn = oqueue . remove ( ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.20.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public static void function ( final File arg0 , final Object arg1 ) { ObjectWriter writer = DEFAULT_MAPPER . writerWithDefaultPrettyPrinter ( ) ; try { writer . writeValue ( arg0 , arg1 ) ;
public void function ( ) throws Exception { runTestScenarioReconnect ( false ) ; }
@Test public void function ( ) { Parser parser = Parser . htmlParser ( ) ; parser . settings ( new ParseSettings ( true , false ) ) ; Document doc = parser . parseInput ( " <div id=1><SPAN ID=2> " , " " ) ; assertEquals ( " <html> <head></head> <body> <div id= \" 1 \" > <SPAN id= \" 2 \" ></SPAN> </div> </body> </html> " , StringUtil . normaliseWhitespace ( doc . outerHtml ( ) ) ) ; Element div = doc . selectFirst ( " #1 " ) ; div . after ( " <TaG ID=one>One</TaG> " ) ; assertEquals ( " <TaG id= \" one \" >One</TaG> " , TextUtil . stripNewlines ( div . nextElementSibling ( ) . outerHtml ( ) ) ) ; }
public final ReplayModifierContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return new ReplayModifierContainer ( strip ( arg0 . getText ( ) ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; ResponseSetting setting = arg0 . readValueAs ( ResponseSetting . class ) ; return new ReplayModifierContainer ( setting ) ; } return ( ReplayModifierContainer ) arg1 . handleUnexpectedToken ( ReplayContainer . class , arg0 ) ; }
private StartArgs function ( final String [ ] arg0 ) throws ParseException { CommandLineParser parser = new DefaultParser ( ) ; CommandLine cmd = parser . parse ( options ( ) , arg0 ) ; return parseArgs ( cmd ) ; }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; assertTrue ( deflateExtension . isServerNoContextTakeover ( ) ) ; }
protected int function ( byte [ ] arg0 , int arg1 ) { id = BufferTools . byteBufferToString ( arg0 , arg1 + ID_OFFSET , ID_LENGTH ) ; unpackDataLength ( arg0 , arg1 ) ; return arg1 + HEADER_LENGTH ; }
private ImmutableMap < String , Object > function ( Request arg0 ) { return ImmutableMap . < String , Object > builder ( ) . putAll ( this . variables ) . put ( " req " , arg0 ) . build ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 2.10 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 60 ) ; }
public static Resource function ( String arg0 ) { checkNotNull ( arg0 , " Null text is not allowed " ) ; return new TextResource ( arg0 ) ; }
public void function ( String arg0 , String arg1 ) { this . queries . put ( arg0 , arg1 ) ; }
public void function ( String arg0 , Object . . . arg1 ) { formatAndLog ( Log . INFO , arg0 , arg1 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /get_event " ) ) , is ( " get_foo " ) ) ; Idles . idle ( IDLE ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " 0XCAFEBABE " ) ) ; }
public void function ( ) throws IOException { String html = " <html><head><meta charset=iso-8></head><body></body></html> " ; Document doc = DataUtil . parseInputStream ( stream ( html ) , null , " http://example.com " , Parser . htmlParser ( ) ) ; final String expected = " <html> \ n " + "  <head> \ n " + "   <meta charset= \" iso-8 \" > \ n " + "  </head> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( expected , doc . toString ( ) ) ; }
public void function ( ) throws IOException , UnsupportedTagException , InvalidDataException { loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 41 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 256 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 1024 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 5000 ) ; loadAndCheckTestMp3WithTags ( new File ( MP3_WITH_ID3V1_AND_ID3V23_TAGS ) , 41 ) ; loadAndCheckTestMp3WithTags ( new File ( MP3_WITH_ID3V1_AND_ID3V23_TAGS ) , 256 ) ; loadAndCheckTestMp3WithTags ( new File ( MP3_WITH_ID3V1_AND_ID3V23_TAGS ) , 1024 ) ; loadAndCheckTestMp3WithTags ( new File ( MP3_WITH_ID3V1_AND_ID3V23_TAGS ) , 5000 ) ; }
public String function ( ) { return String . format ( " :[%s] " , key ) ; }
public static HttpServer function ( final int arg0 ) { return new ActualHttpServer ( arg0 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; org . apache . http . HttpResponse response = helper . getResponseWithHeader ( remoteUrl ( " /all-resources " ) , of ( HttpHeaders . CONTENT_TYPE , " application/json " ) ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; HttpEntity entity = response . getEntity ( ) ; List < Plain > plains = mapper . readValue ( entity . getContent ( ) , new TypeReference < List < Plain > > ( ) { } ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; }
public boolean function ( ) throws IOException { ByteBuffer buffer = this . outQueue . peek ( ) ; while ( buffer ! = null ) { int written = sockchannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { bufferQueueTotalAmount . addAndGet ( - written ) ; this . outQueue . poll ( ) ; buffer = this . outQueue . peek ( ) ; } } return true ; }
public boolean function ( ) throws IOException { return socketChannel . finishConnect ( ) ; }
public void function ( ) { Pattern pattern = Pattern . compile ( " example " ) ; Evaluator . Matches evaluator = new Evaluator . Matches ( pattern ) ; assertEquals ( " :matches(example) " , evaluator . toString ( ) ) ; }
public void function ( SessionContext arg0 ) { this . procedure . execute ( ) ; }
@Test public void function ( ) { String html = " <p>test</p> \ n \ n<div /><div>Two</div> " ; Parser parser = Parser . htmlParser ( ) . setTrackErrors ( 5 ) ; parser . parseInput ( html , " " ) ; assertEquals ( 1 , parser . getErrors ( ) . size ( ) ) ; assertEquals ( " <3:8>: Tag cannot be self closing; not a void tag " , parser . getErrors ( ) . get ( 0 ) . toString ( ) ) ; assertFalse ( Jsoup . isValid ( html , Safelist . relaxed ( ) ) ) ; String clean = Jsoup . clean ( html , Safelist . relaxed ( ) ) ; assertEquals ( " <p>test</p> <div></div> <div> Two </div> " , StringUtil . normaliseWhitespace ( clean ) ) ; }
private void function ( ByteBuffer arg0 ) throws IOException { if ( DEBUG ) System . out . println ( " write: { " + new String ( arg0 . array ( ) ) + " } " ) ; arg0 . rewind ( ) ; socketChannel . write ( arg0 ) ; }
public ByteChannel function ( SocketChannel arg0 , SelectionKey arg1 ) throws IOException { SSLEngine e = sslcontext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; if ( sslParameters ! = null ) { e . setSSLParameters ( sslParameters ) ; } return new SSLSocketChannel2 ( arg0 , e , exec , arg1 ) ; }
public void function ( Marker arg0 , String arg1 , int arg2 , String arg3 , Object [ ] arg4 , Throwable arg5 ) { Level julLevel = slf4jLevelIntToJULLevel ( arg2 ) ; if ( logger . isLoggable ( julLevel ) ) { log ( arg1 , julLevel , arg3 , arg5 ) ;
protected RequestMatcher function ( Iterable < RequestMatcher > arg0 ) { return new AndRequestMatcher ( arg0 ) ; }
void function ( String arg0 ) { if ( debugEnabled & & ! quietMode ) { System . out . println ( PREFIX + arg0 ) ;
public void function ( ) throws IOException { assertThat ( helper . getWithHeader ( remoteUrl ( " /dir/dir.response " ) , of ( " foo " , " bar " ) ) , is ( " response from dir " ) ) ; }
private RequestMatcher function ( String arg0 , Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return json ( text ( Jsons . toJson ( arg1 ) ) ) ; } if ( Map . class . isInstance ( arg1 ) ) { return createCompositeMatcher ( arg0 , castToMap ( arg1 ) ) ; } if ( TextContainer . class . isInstance ( arg1 ) ) { return createSingleTextMatcher ( arg0 , TextContainer . class . cast ( arg1 ) ) ; } throw new IllegalArgumentException ( " unknown configuration : " + arg1 ) ; }
public static ActualHttpServer function ( int arg0 , MocoConfig . . . arg1 ) { return new ActualHttpServer ( arg0 , new Object ( ) , arg1 ) ; }
public void function ( ) { InputStream stream = getResourceAsStream ( " settings/env-settings.json " ) ; ImmutableList < GlobalSetting > globalSettings = parser . parse ( stream ) ; assertThat ( globalSettings . get ( 0 ) . getInclude ( ) , is ( join ( " src " , " test " , " resources " , " settings " , " foo.json " ) ) ) ; assertThat ( globalSettings . get ( 0 ) . getContext ( ) , is ( " /foo " ) ) ; assertThat ( globalSettings . get ( 0 ) . getEnv ( ) , is ( " foo " ) ) ; assertThat ( globalSettings . get ( 1 ) . getInclude ( ) , is ( join ( " src " , " test " , " resources " , " settings " , " bar.json " ) ) ) ; assertThat ( globalSettings . get ( 1 ) . getContext ( ) , is ( " /bar " ) ) ; assertThat ( globalSettings . get ( 1 ) . getEnv ( ) , is ( " bar " ) ) ; }
@Test public void function ( ) { String h = " <div title=foo /><div title=bar /><div /><p></p><img /><span title=qux> " ; Document doc = Jsoup . parse ( h ) ; Elements els = doc . select ( " p,div,[title] " ) ; assertEquals ( 5 , els . size ( ) ) ; assertEquals ( " div " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " foo " , els . get ( 0 ) . attr ( " title " ) ) ; assertEquals ( " div " , els . get ( 1 ) . tagName ( ) ) ; assertEquals ( " bar " , els . get ( 1 ) . attr ( " title " ) ) ; assertEquals ( " div " , els . get ( 2 ) . tagName ( ) ) ; assertEquals ( 0 , els . get ( 2 ) . attr ( " title " ) . length ( ) ) ; assertFalse ( els . get ( 2 ) . hasAttr ( " title " ) ) ; assertEquals ( " p " , els . get ( 3 ) . tagName ( ) ) ; assertEquals ( " span " , els . get ( 4 ) . tagName ( ) ) ; }
public Element function ( Consumer < ? super Node > arg0 ) { return ( Element ) super . forEachNode ( arg0 ) ; }
public List < Node > function ( ) { List < Node > children = new ArrayList < > ( childNodes . size ( ) ) ; for ( Node node : childNodes ) { children . add ( node . clone ( ) ) ; } return children ; }
public void function ( ) throws Exception { ID3v2 id3tag = new ID3v23Tag ( ) ; setTagFields ( id3tag ) ; try { id3tag . setGenreDescription ( " Bebop " ) ; } catch ( IllegalArgumentException e ) { return ; } fail ( " expected IllegalArgumentException " ) ; }
public void function ( ) { String html = " <html><head><title>W3c</title></head><body><p class='one' id=12>Text</p><!-- comment --><invalid>What<script>alert('!') " ; org . jsoup . nodes . Document doc = Jsoup . parse ( html ) ; W3CDom w3c = new W3CDom ( ) ; Document wDoc = w3c . fromJsoup ( doc ) ; String out = w3c . asString ( wDoc ) ; assertEquals ( " <html> " + LE +
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.18.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public Document function ( Document arg0 ) { Validate . notNull ( arg0 ) ; Document clean = Document . createShell ( arg0 . baseUri ( ) ) ; copySafeNodes ( arg0 . body ( ) , clean . body ( ) ) ; clean . outputSettings ( arg0 . outputSettings ( ) . clone ( ) ) ; return clean ; }
public MessageContent function ( final Optional < ? extends Request > arg0 ) { MessageContent messageContent = resource . readFor ( arg0 ) ; return content ( new Cookies ( ) . encodeCookie ( key , messageContent . toString ( ) , options ) ) ; }
public void function ( ) { String h = " <div id=foo><h1 class=bar><a href=http://example.com/>One</a></h1></div> " ; Document doc = Jsoup . parse ( h ) ; Elements els = SelectMatch . match ( doc , Parser . parse ( " div#foo > h1.bar > a[href*=example] " ) ) ; assertEquals ( 1 , els . size ( ) ) ; assertEquals ( " a " , els . first ( ) . tagName ( ) ) ; }
public RequestMatcher function ( Map . Entry < String , String > arg0 ) { return eq ( query ( arg0 . getKey ( ) ) , arg0 . getValue ( ) ) ; }
public static String function ( int arg0 ) { return padding ( arg0 , 30 ) ; }
public void function ( ) throws Exception { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( " " ) , TEST_URL ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 0 , 0 , 'h' , 't' , 't' , 'p' , ':' , '/' , '/' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' } ; assertTrue ( Arrays . equals ( expectedBytes , bytes ) ) ; ID3v2UrlFrameData frameDataCopy = new ID3v2UrlFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
public void function ( ) throws Exception { server . resource ( " targets " , delete ( " 1 " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( Level arg0 , ResourceBundle arg1 , String arg2 , Throwable arg3 ) { log ( arg0 , arg1 , arg2 , arg3 , ( Object [ ] ) null ) ; }
private File function ( HttpRequest arg0 ) { String relativePath = extractor . extract ( arg0 ) ; return new File ( dir , relativePath ) ; }
@Test public void function ( ) { String html = " <a/ \ 06> " ; String clean = Jsoup . clean ( html , Safelist . basic ( ) ) ; assertEquals ( " <a rel= \" nofollow \" ></a> " , clean ) ; }
public boolean function ( ) { return RECORD_ALL_EVENTS ; }
public void function ( SocketServer arg0 ) { arg0 . request ( getRequestMatcher ( ) ) . response ( getResponseHandler ( ) ) ; }
protected boolean function ( String arg0 ) { return arg0 . toLowerCase ( ) . contains ( " info " ) ; }
public void function ( ) { SimpleLogger simpleLogger = new SimpleLogger ( " x.y " ) ; assertNull ( simpleLogger . recursivelyComputeLevelString ( ) ) ; }
public static RequestMatcher function ( final RequestMatcher . . . arg0 ) { return new AndRequestMatcher ( copyOf ( checkNotNull ( arg0 , " Matcher should not be null " ) ) ) ; }
public String function ( FullHttpRequest arg0 ) { return cookies . decodeCookie ( arg0 . headers ( ) . get ( " Cookie " ) , key ) ; }
public void function ( ) { String html = " <ul> " + "   <li id='1'> \ n </li> " + "   <li id='2'></li> " + "   <li id='3'><!-- foo --></li> " + "   <li id='4'>One</li> " + "   <li id='5'><span></span></li> " + "   <li id='6'> \ n <span></span></li> " + "   <li id='7'><!-- foo --><i></i></li> " + " </ul> " ; Document doc = Jsoup . parse ( html ) ; Elements empty = doc . select ( " li:empty " ) ; assertSelectedIds ( empty , " 1 " , " 2 " , " 3 " ) ; Elements notEmpty = doc . select ( " li:not(:empty) " ) ; assertSelectedIds ( notEmpty , " 4 " , " 5 " , " 6 " , " 7 " ) ; }
private Mp3File function ( String arg0 , int arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { Mp3File mp3File = loadAndCheckTestMp3 ( arg0 , arg1 ) ; assertEquals ( 0x44B , mp3File . getXingOffset ( ) ) ; assertEquals ( 0x5EC , mp3File . getStartOffset ( ) ) ; assertEquals ( 0xF7F , mp3File . getEndOffset ( ) ) ; assertTrue ( mp3File . hasId3v1Tag ( ) ) ; assertTrue ( mp3File . hasId3v2Tag ( ) ) ; assertFalse ( mp3File . hasCustomTag ( ) ) ; return mp3File ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { delegate ( ) . trace ( arg0 , arg1 , arg2 ) ; }
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { if ( isBlock ( ) | | ( parent ( ) ! = null & & parent ( ) . tag ( ) . canContainBlock ( ) & & siblingIndex ( ) = = 0 ) ) indent ( arg0 , arg1 ) ; arg0 . append ( " < " ) . append ( tagName ( ) ) ; attributes . html ( arg0 , arg2 ) ; if ( childNodes . isEmpty ( ) & & tag . isSelfClosing ( ) ) arg0 . append ( "  /> " ) ;
private static ImmutableMap < String , String > function ( Iterable < Map . Entry < String , String > > arg0 ) { ImmutableMap . Builder < String , String > headerBuilder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , String > entry : arg0 ) { headerBuilder . put ( entry ) ; } return headerBuilder . build ( ) ; }
public void function ( ) { if ( thread = = null ) thread = Thread . currentThread ( ) ; interruptableRun ( ) ; try { if ( selector ! = null ) selector . close ( ) ; } catch ( IOException e ) { onError ( e ) ; } closelock . lock ( ) ; selector = null ; closelock . unlock ( ) ; try { channel . close ( ) ; } catch ( IOException e ) { onError ( e ) ; } channel = null ; thread = null ; }
public static RequestExtractor < String > function ( final String arg0 ) { return new ParamRequestExtractor ( checkNotNullOrEmpty ( arg0 , " Query parameter should not be null " ) ) ; }
@Test public void function ( ) { String h = " <div id=1><![CData[<html> \ n<foo><&amp;]]></div> " ; Document doc = Jsoup . parse ( h ) ; Element div = doc . getElementById ( " 1 " ) ; assertEquals ( " <html> <foo><&amp; " , div . text ( ) ) ; assertEquals ( 0 , div . children ( ) . size ( ) ) ; assertEquals ( 1 , div . childNodes ( ) . size ( ) ) ; }
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { if ( detector . hasHeader ( arg1 , name ) ) { arg1 . removeHeader ( name ) ; } HttpHeaders . addHeader ( arg1 , name , new String ( value . asByteArray ( arg0 ) ) ) ; }
protected void function ( int arg0 , Node . . . arg1 ) { Validate . noNullElements ( arg1 ) ; final List < Node > nodes = ensureChildNodes ( ) ; for ( int i = arg1 . length - 1 ; i > = 0 ; i - - ) { Node in = arg1 [ i ] ;
public Object function ( final List arg0 ) { Optional < Long > range = getRange ( arg0 ) ; Optional < ? extends NumberFormat > format = getFormat ( arg0 ) ; double result = new Random ( ) . nextDouble ( ) * range . or ( 1L ) ; if ( format . isPresent ( ) ) { return format . get ( ) . format ( result ) ; } return result ; }
public void function ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long current = ( System . currentTimeMillis ( ) - ( connectionLostTimeout * 1500 ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; if ( webSocketImpl . getLastPong ( ) < current ) { log . warn ( " Closing connection due to no pong received:  " + conn . toString ( ) ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , " The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection " ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . warn ( " Trying to ping a non open connection:  " + conn . toString ( ) ) ; } } } } } catch ( Exception e ) { } connections . clear ( ) ; }
public void function ( ) { byte [ ] buffer = { BYTE_T , BYTE_ESZETT , BYTE_G } ; assertEquals ( " TG " , BufferTools . byteBufferToString ( buffer , 0 , 3 ) ) ; }
private void function ( String arg0 ) { File f = new File ( arg0 ) ; f . mkdir ( ) ; }
public void function ( ) { testHandshakeRejection ( 10 ) ; }
public String function ( final int arg0 , final String arg1 ) { return format ( mismatchFormat , arg1 , arg0 ) ; }
ResponseSetting function ( final ProxyConfig arg0 , final Failover arg1 ) ; }
public void function ( final ChannelHandlerContext arg0 ) throws Exception { if ( sb . length ( ) > 0 ) { arg0 . fireChannelRead ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } arg0 . fireChannelReadComplete ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.28 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private String function ( Throwable arg0 ) { StringWriter writer = new StringWriter ( ) ; arg0 . printStackTrace ( new PrintWriter ( writer ) ) ; return writer . toString ( ) ; }
public List < Node > function ( ) { List < Node > children = new ArrayList < Node > ( childNodes . size ( ) ) ; for ( Node node : childNodes ) { children . add ( node . clone ( ) ) ; } return children ; }
public void function ( ) throws Exception { server . request ( by ( " foo " ) ) . response ( " bar " ) ; running ( server , ( ) - > assertThat ( helper . postContent ( root ( ) , " foo " ) , is ( " bar " ) ) ) ; }
public ResponseHandler function ( final MocoConfig arg0 ) { Resource applied = content . apply ( arg0 ) ; if ( applied = = content ) { return this ; } return new WebSocketBroadcastHandler ( applied , group ) ; }
@Test public void function ( ) { final String html = " <div>one</div><div>one</div> " ; Document doc = Jsoup . parse ( html ) ; Elements els = doc . select ( " div " ) ; assertEquals ( 2 , els . size ( ) ) ; Elements subSelect = els . select ( " :contains(one) " ) ; assertEquals ( 2 , subSelect . size ( ) ) ; }
private Resource function ( final String arg0 , final FileContainer arg1 ) { if ( arg1 . isForTemplate ( ) ) { if ( " version " . equalsIgnoreCase ( arg0 ) ) { return version ( arg1 . asTemplateResource ( ) ) ; } return arg1 . asTemplateResource ( arg0 ) ; } TextContainer filename = arg1 . getName ( ) ; if ( filename . isRawText ( ) ) { return asResource ( arg0 , arg1 ) ; } if ( filename . isForTemplate ( ) ) { Optional < Charset > charset = arg1 . getCharset ( ) ; Resource resource = filename . asTemplateResource ( ) ; return asResource ( arg0 , resource , charset ) ; } throw new IllegalArgumentException ( format ( " unknown file container:[%s] " , arg1 ) ) ; }
void function ( File arg0 ) throws IOException { long startTime = System . currentTimeMillis ( ) ; long completeBy = startTime + timeout * 1000L ; for ( int i = 0 ; i < numIters ; i + + ) { Document doc = Jsoup . parse ( arg0 , " UTF-8 " , " https://example.com/ " ) ;
public void function ( ) { SettingParser parser = new SettingParser ( ) ; InputStream stream = SettingParserTest . class . getClassLoader ( ) . getResourceAsStream ( " multiple/fileroot-settings.json " ) ; List < GlobalSetting > globalSettings = parser . parse ( stream ) ; assertThat ( globalSettings . get ( 0 ) . getInclude ( ) , is ( " src/test/resources/multiple/foo.json " ) ) ; assertThat ( globalSettings . get ( 0 ) . getContext ( ) , is ( " /foo " ) ) ; assertThat ( globalSettings . get ( 0 ) . getFileRoot ( ) , is ( " src/test/resources/ " ) ) ; assertThat ( globalSettings . get ( 1 ) . getInclude ( ) , is ( " src/test/resources/multiple/bar.json " ) ) ; assertThat ( globalSettings . get ( 1 ) . getContext ( ) , is ( " /bar " ) ) ; assertThat ( globalSettings . get ( 1 ) . getFileRoot ( ) , is ( " src/test/resources/ " ) ) ; }
public Whitelist function ( String arg0 , String . . . arg1 ) { Validate . notEmpty ( arg0 ) ; Validate . notNull ( arg1 ) ; Validate . isTrue ( arg1 . length > 0 , " No attribute names supplied. " ) ; TagName tagName = TagName . valueOf ( arg0 ) ; if ( ! tagNames . contains ( tagName ) ) tagNames . add ( tagName ) ; Set < AttributeKey > attributeSet = new HashSet < > ( ) ; for ( String key : arg1 ) { Validate . notEmpty ( key ) ; attributeSet . add ( AttributeKey . valueOf ( key ) ) ; } if ( this . arg1 . containsKey ( tagName ) ) { Set < AttributeKey > currentSet = this . arg1 . get ( tagName ) ; currentSet . addAll ( attributeSet ) ; } else { this . arg1 . put ( tagName , attributeSet ) ; } return this ; }
private static ImmutableMap < String , String > function ( final String [ ] arg0 ) { ImmutableMap . Builder < String , String > builder = ImmutableMap . builder ( ) ; for ( String cookie : arg0 ) { Set < Cookie > decodeCookies = ServerCookieDecoder . STRICT . decode ( cookie ) ; for ( Cookie decodeCookie : decodeCookies ) { builder . put ( decodeCookie . name ( ) , decodeCookie . value ( ) ) ; } } return builder . build ( ) ; }
private String function ( String arg0 ) { if ( arg0 = = null ) return null ; return BufferTools . substitute ( arg0 , " / " , " " ) ; }
protected MessageContent function ( final HttpRequest arg0 ) { HttpRequest recordedRequest = getRecordedRequest ( arg0 ) ; if ( recordedRequest = = null ) { throw new IllegalArgumentException ( " No recorded request for [ " + name + " ] " ) ; } return replayModifier . readFor ( recordedRequest ) ; }
public boolean function ( ) { return Tags . containsKey ( tagName ) ; }
@Test public void function ( ) { String h = " Hello <b>there</b>! " ; String cleanHtml = Jsoup . clean ( h , Whitelist . simpleText ( ) ) ; assertEquals ( " Hello <b>there</b>! " , TextUtil . stripNewlines ( cleanHtml ) ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { recordEvent ( Level . INFO , arg0 , arg1 , new Object [ ] { arg2 , arg3 } , null ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " post_foo " ) ) ; Idles . idle ( IDLE ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " 0XCAFEBABE " ) ) ; }
public boolean function ( String arg0 ) { if ( " " . equals ( providedProtocol ) ) { return true ; } String protocolHeader = patternSpace . matcher ( arg0 ) . replaceAll ( " " ) ; String [ ] headers = patternComma . split ( protocolHeader ) ; for ( String header : headers ) { if ( providedProtocol . equals ( header ) ) { return true ; } } return false ; }
public Connection function ( Map < String , String > arg0 ) { Validate . notNullParam ( arg0 , " arg0 " ) ; for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { req . cookie ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
public void function ( ) throws Exception { EncodedText encodedText = new EncodedText ( EncodedText . TEXT_ENCODING_UTF_8 , fromHex ( " 43 61 66 c3 a9 20 50 61 72 61 64 69 73 6f " ) ) ; try { encodedText . setTextEncoding ( ( byte ) 4 , true ) ;
public Watcher function ( final File arg0 ) { return new DefaultWatcher ( service , listener , arg0 ) ; }
public static void function ( NodeVisitor arg0 , Node arg1 ) { Node node = arg1 ; int depth = 0 ; while ( node ! = null ) { arg0 . head ( node , depth ) ;
private String function ( int arg0 ) { StringBuilder buf = new StringBuilder ( ) ; for ( int i = 0 ; i < arg0 ; i + + ) { int offset = random . nextInt ( 26 ) ; char c = ( char ) ( 'a' + offset ) ; buf . append ( c ) ; } return buf . toString ( ) ; }
public HttpResponse function ( final String arg0 ) throws IOException { Request request = Request . Delete ( arg0 ) ; return executor . execute ( request ) . returnResponse ( ) ; }
public Safelist function ( String arg0 , String arg1 , String arg2 ) { Validate . notEmpty ( arg0 ) ; Validate . notEmpty ( arg1 ) ; Validate . notEmpty ( arg2 ) ; TagName tagName = TagName . valueOf ( arg0 ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( arg1 ) ; AttributeValue attrVal = AttributeValue . valueOf ( arg2 ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap < > ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }
Evaluator function ( ) { tq . consumeWhitespace ( ) ; if ( tq . matchesAny ( Combinators ) ) { evals . add ( new StructuralEvaluator . Root ( ) ) ; combinator ( tq . consume ( ) ) ; } else { evals . add ( consumeEvaluator ( ) ) ; } while ( ! tq . isEmpty ( ) ) { boolean seenWhite = tq . consumeWhitespace ( ) ; if ( tq . matchesAny ( Combinators ) ) { combinator ( tq . consume ( ) ) ; } else if ( seenWhite ) { combinator ( ' ' ) ; } else { evals . add ( consumeEvaluator ( ) ) ; } } if ( evals . size ( ) = = 1 ) return evals . get ( 0 ) ; return new CombiningEvaluator . And ( evals ) ; }
public void function ( ) { slf4jMessageFormatter_OneArg ( RUN_LENGTH ) ; double duration = slf4jMessageFormatter_OneArg ( RUN_LENGTH ) ; System . out . println ( " duration= " + duration ) ; long referencePerf = 72 ; BogoPerf . assertDuration ( duration , referencePerf , REFERENCE_BIPS ) ; }
public Node function ( String arg0 , String arg1 ) { attributes . put ( arg0 , arg1 ) ; return this ; }
public void function ( String arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . WARNING ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public void function ( String arg0 ) { System . out . println ( " received:  " + arg0 ) ; }
public void function ( ) throws IOException { assertThat ( helper . get ( remoteUrl ( " /foo?param=multiple&param=blah " ) ) , is ( " bar " ) ) ; }
public static Session function ( Request arg0 , Response arg1 ) { Session session = new Session ( ) ; session . setRequest ( arg0 ) ; session . setResponse ( arg1 ) ; return session ; }
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws IOException { String location = arg0 . getParameter ( LocationParam ) ; if ( location = = null ) location = " " ; int intCode = DefaultCode ; String code = arg0 . getParameter ( CodeParam ) ; if ( code ! = null ) intCode = Integer . parseInt ( code ) ; arg1 . setHeader ( " Location " , location ) ; arg1 . setStatus ( intCode ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.10 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public static RequestExtractor function ( final String arg0 ) { return new CookieRequestExtractor ( checkNotNull ( arg0 , " Null cookie is not allowed " ) ) ; }
protected SocketServer function ( ImmutableList < SessionSetting > arg0 , Optional < Integer > arg1 , MocoConfig . . . arg2 ) { SocketServer server = ActualSocketServer . createLogServer ( arg1 ) ; for ( SessionSetting session : arg0 ) { logger . debug ( " Parse session: {} " , session ) ; session . bindTo ( server ) ; } return server ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { warn ( arg1 , arg2 ) ; }
static String function ( String arg0 , Document . OutputSettings arg1 ) { return escape ( arg0 , arg1 . encoder ( ) , arg1 . escapeMode ( ) ) ; }
public void function ( ) throws Exception { super . tearDown ( ) ; MDC . clear ( ) ; }
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; for ( Attribute attribute : this ) { accum . append ( "   " ) ; accum . append ( attribute . html ( ) ) ; } return accum . toString ( ) ; }
public void function ( ) throws Exception { final String jsonText = Jsons . toJson ( of ( " foo " , " bar " ) ) ; server . request ( by ( json ( jsonText ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( " 1 " ) . request ( eq ( header ( HttpHeaders . CONTENT_TYPE ) , " application/json " ) ) . response ( toJson ( resource1 ) ) , get ( " 2 " ) . request ( eq ( header ( HttpHeaders . CONTENT_TYPE ) , " application/json " ) ) . response ( toJson ( resource2 ) ) ) ; running ( server , new Runnable ( ) { @Override
@Test void function ( ) throws IOException { ControllableInputStream is = ControllableInputStream . wrap ( null , 0 ) ; assertNotNull ( is ) ; assertTrue ( is . baseReadFully ( ) ) ; is . close ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.8.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 320 ) ; }
public static MocoServer function ( int arg0 ) { return new MocoServer ( arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.9.11 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
@Test public void function ( ) { Element orphan = new Element ( " span " ) . text ( " Hello! " ) ; assertFalse ( orphan . hasParent ( ) ) ; Element wrapped = orphan . wrap ( " <div></div> There! " ) ; assertSame ( orphan , wrapped ) ; assertTrue ( orphan . hasParent ( ) ) ; assertNotNull ( orphan . parent ( ) ) ; assertEquals ( " div " , orphan . parent ( ) . tagName ( ) ) ; assertEquals ( " <div> \ n <span>Hello!</span> \ n</div> " , orphan . parent ( ) . outerHtml ( ) ) ; }
public static void function ( HttpsServer arg0 , Runnable arg1 ) throws Exception { doRunning ( runner ( arg0 ) , arg1 ) ; }
public void function ( ) { locLogger . info ( Production . APPLICATION_STARTED ) ;
public ByteChannel function ( SelectionKey arg0 , String arg1 , int arg2 ) throws IOException { SSLEngine e = sslcontext . createSSLEngine ( arg1 , arg2 ) ; e . setUseClientMode ( true ) ; return new SSLSocketChannel2 ( arg0 , e , exec ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeToAny ( attributeSingleValueCharsSorted ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; else arg0 . tagPending . setEmptyAttributeValue ( ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\'' :
public void function ( ) throws Exception { assertThat ( helper . getWithHeader ( root ( ) , of ( " foo " , " barA " ) ) , is ( " bar " ) ) ; assertThat ( helper . getWithHeader ( root ( ) , of ( " foo " , " barB " ) ) , is ( " bar " ) ) ; }
public boolean function ( Handshakedata arg0 ) { if ( ! arg0 . getFieldValue ( " Sec-WebSocket-Key1 " ) . isEmpty ( ) & & ! arg0 . getFieldValue ( " Sec-WebSocket-Key1 " ) . isEmpty ( ) ) return true ; return false ; }
public void function ( arg0 final Path arg1 ) throws Exception { File file = arg1 . resolve ( " tempfile " ) . toFile ( ) ; HttpServer server = httpServer ( port ( ) , log ( file . getAbsolutePath ( ) ) ) ; ResponseHandler mock = mock ( ResponseHandler . class ) ; doThrow ( RuntimeException . class ) . when ( mock ) . writeToResponse ( any ( SessionContext . class ) ) ; server . request ( by ( " 0XCAFE " ) ) . response ( mock ) ; running ( server , ( ) - > { try { helper . postContent ( root ( ) , " 0XCAFE " ) ; } catch ( IOException ignored ) { } } ) ; String actual = asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) ; assertThat ( actual , containsString ( " RuntimeException " ) ) ; }
@Test public void function ( ) { String html = " <div><p><span>Hello</span> " ; Document doc = Jsoup . parse ( html ) ; assertTrue ( doc . selectFirst ( " div " ) . isBlock ( ) ) ; assertTrue ( doc . selectFirst ( " p " ) . isBlock ( ) ) ; assertFalse ( doc . selectFirst ( " span " ) . isBlock ( ) ) ; }
public static CookieOption function ( ) { return new SecureCookieOption ( ) ; }
private void function ( SelectionKey arg0 , Iterator < SelectionKey > arg1 ) throws IOException , InterruptedException { if ( ! onConnect ( arg0 ) ) { arg0 . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel = = null ) { return ; } channel . configureBlocking ( false ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( true ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . channel = wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ;
private XmlDeclaration function ( ) { Node node = ensureChildNodes ( ) . get ( 0 ) ; if ( node instanceof XmlDeclaration ) { XmlDeclaration decl = ( XmlDeclaration ) node ; if ( decl . name ( ) . equals ( " xml " ) ) return decl ; } XmlDeclaration decl = new XmlDeclaration ( " xml " , false ) ; prependChild ( decl ) ; return decl ; }
public void function ( String arg0 , Object arg1 ) { if ( ! logger . isDebugEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /post-event-with-template-url " ) ) , is ( " post_foo " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) , containsString ( " 0XCAFEBABE " ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { lbLogger . warn ( ( String ) arg0 , arg1 ) ; }
public void function ( Marker arg0 , String arg1 ) { if ( ! logger . isTraceEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn ,
@Test public void function ( ) { Document doc = org . jsoup . Jsoup . parse ( " <div class=foo>Text</div> " ) ; Element el = doc . select ( " div " ) . first ( ) ; assertTrue ( el . hasClass ( " foo " ) ) ; Element elClone = doc . clone ( ) . select ( " div " ) . first ( ) ; assertTrue ( elClone . hasClass ( " foo " ) ) ; assertTrue ( elClone . text ( ) . equals ( " Text " ) ) ; el . removeClass ( " foo " ) ; el . text ( " None " ) ; assertFalse ( el . hasClass ( " foo " ) ) ; assertTrue ( elClone . hasClass ( " foo " ) ) ; assertTrue ( el . text ( ) . equals ( " None " ) ) ; assertTrue ( elClone . text ( ) . equals ( " Text " ) ) ; }
private int function ( ) { String index = consumeParens ( ) . trim ( ) ; Validate . isTrue ( StringUtil . isNumeric ( index ) , " Index must be numeric " ) ; return Integer . parseInt ( index ) ; }
public Logger function ( ) { if ( _delegate ! = null ) { return _delegate ; } if ( createdPostInitialization ) { return NOPLogger . NOP_LOGGER ;
public static HttpServer function ( final MocoConfig < ? > . . . arg0 ) { return ActualHttpServer . createQuietServer ( 0 , checkNotNull ( arg0 , " Configuration should not be null " ) ) ;
@Test public void function ( ) { String html = " \ uFEFF<html><head><title>One</title></head><body>Two</body></html> " ; ByteBuffer buffer = Charset . forName ( " UTF-8 " ) . encode ( html ) ; Document doc = DataUtil . parseByteData ( buffer , null , " http://foo.com/ " , Parser . htmlParser ( ) ) ; assertEquals ( " One " , doc . head ( ) . text ( ) ) ; assertEquals ( " UTF-8 " , doc . outputSettings ( ) . charset ( ) . displayName ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.19.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
@Test public void function ( ) { Attribute a1 = new Attribute ( " one " , " " ) ; Attribute a2 = new Attribute ( " two " , null ) ; Attribute a3 = new Attribute ( " thr " , " thr " ) ; assertTrue ( a1 . hasValue ( ) ) ; assertFalse ( a2 . hasValue ( ) ) ; assertTrue ( a3 . hasValue ( ) ) ; }
public void function ( Supplier < String > arg0 ) { if ( arg0 = = null ) { log ( ( String ) null ) ;
public static byte [ ] function ( String arg0 ) { try { return arg0 . getBytes ( UTF8 ) ;
public void function ( ) { incompleteframe = null ; if ( negotiatedExtension ! = null ) { negotiatedExtension . reset ( ) ; } negotiatedExtension = new DefaultExtension ( ) ; protocol = null ; }
private static ResponseHandler function ( final Resource arg0 ) { Class clazz = HANDLERS . get ( arg0 . id ( ) ) ; try { Constructor [ ] constructors = clazz . getConstructors ( ) ;
public void function ( ) throws Exception { runTestScenario ( true ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null ) return false ; if ( getClass ( ) ! = arg0 . getClass ( ) ) return false ; TypedValue other = ( TypedValue ) arg0 ; if ( value = = null ) { if ( other . value ! = null ) return false ; } else if ( ! value . equals ( other . value ) ) return false ; return true ; }
@Test public void function ( ) { String in = " blah blah " ; CharacterReader r = new CharacterReader ( in ) ; assertEquals ( - 1 , r . nextIndexOf ( 'x' ) ) ; assertEquals ( 3 , r . nextIndexOf ( 'h' ) ) ; String pull = r . consumeTo ( 'h' ) ; assertEquals ( " bla " , pull ) ; r . consume ( ) ; assertEquals ( 2 , r . nextIndexOf ( 'l' ) ) ; assertEquals ( "  blah " , r . consumeToEnd ( ) ) ; assertEquals ( - 1 , r . nextIndexOf ( 'x' ) ) ; }
protected Options function ( ) { Options options = new Options ( ) ; options . addOption ( configOption ( ) ) ; options . addOption ( portOption ( ) ) ; options . addOption ( ShutdownPortOption . shutdownPortOption ( ) ) ; options . addOption ( settingsOption ( ) ) ; options . addOption ( envOption ( ) ) ; options . addOption ( httpsCertificate ( ) ) ; options . addOption ( keyStore ( ) ) ; options . addOption ( cert ( ) ) ; return options ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <textarea>Hello</textarea> " ) ; Elements els = doc . select ( " textarea " ) ; assertEquals ( " Hello " , els . text ( ) ) ; assertEquals ( " Hello " , els . val ( ) ) ; }
private ResponseHandler function ( String arg0 , Map < String , TextContainer > arg1 ) { ImmutableList < ResponseHandler > handlers = from ( arg1 . entrySet ( ) ) . transform ( toTargetHandler ( arg0 ) ) . toList ( ) ; return getResponseHandler ( handlers ) ; }
public void function ( ) { FileResourceReader reader = new FileResourceReader ( text ( new File ( " src/test/resources/unknown.response " ) . getPath ( ) ) ) ; reader . readFor ( Optional . < Request > absent ( ) ) ; }
private static < T > RequestMatcher function ( RequestExtractor < T > arg0 , Resource arg1 ) { return new ContainMatcher < T > ( arg0 , arg1 ) ; }
public void function ( String arg0 , Object [ ] arg1 ) { if ( log . isDebugEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
@Test void function ( ) { Element element = new Element ( " element " ) ; Element root = element ; for ( int i = 0 ; i < 5000 ; i + + ) { Element elem2 = new Element ( " element " + i ) ; element . appendChild ( elem2 ) ; element = elem2 ; } String selector = element . cssSelector ( ) ; Evaluator eval = QueryParser . parse ( selector ) ; assertEquals ( eval . toString ( ) , selector ) ; assertTrue ( selector . startsWith ( " element > element0 > " ) ) ; assertTrue ( selector . endsWith ( " 8 > element4999 " ) ) ; Elements elements = root . select ( selector ) ; assertEquals ( 1 , elements . size ( ) ) ; assertEquals ( element , elements . first ( ) ) ; }
public void function ( ) { ByteBuffer small = ByteBuffer . wrap ( smallArray ) ; ByteBuffer big = ByteBuffer . wrap ( bigArray ) ; ByteBufferUtils . transferByteBuffer ( big , small ) ; assertArrayEquals ( " Big bytebuffer should not change " , bigArray , big . array ( ) ) ; assertEquals ( " Small bytebuffer not same to source 0 " , bigArray [ 0 ] , small . get ( 0 ) ) ; assertEquals ( " Small bytebuffer not same to source 1 " , bigArray [ 1 ] , small . get ( 1 ) ) ; assertEquals ( " Small bytebuffer not same to source 2 " , bigArray [ 2 ] , small . get ( 2 ) ) ; assertEquals ( " Small bytebuffer not same to source 3 " , bigArray [ 3 ] , small . get ( 3 ) ) ; assertEquals ( " Small bytebuffer not same to source 4 " , bigArray [ 4 ] , small . get ( 4 ) ) ; }
private HttpEntity function ( final ByteBuf arg0 , final long arg1 ) { return new InputStreamEntity ( new ByteBufInputStream ( arg0 ) , arg1 ) ; }
public void function ( ActionEvent arg0 ) { while ( ! websockets . isEmpty ( ) ) { websockets . remove ( 0 ) . close ( ) ;
public Connection function ( String arg0 ) { Validate . notEmpty ( arg0 , " Must supply a valid URL " ) ; try { req . arg0 ( new URL ( arg0 ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( " Malformed URL:  " + arg0 , e ) ; } return this ; }
public ProxyConfig function ( String arg0 ) { return new ProxyConfig ( toBase ( localBase ) , toBase ( arg0 ) ) ; }
public static int function ( byte arg0 , byte arg1 , byte arg2 , byte arg3 ) { int value = arg3 & 0xFF ; value + = BufferTools . shiftByte ( arg2 , - 8 ) ; value + = BufferTools . shiftByte ( arg1 , - 16 ) ; value + = BufferTools . shiftByte ( arg0 , - 24 ) ; return value ; }
public void function ( final MutableHttpResponse arg0 ) { arg0 . addHeader ( " Access-Control-Allow-Origin " , origin ) ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { arg0 . send ( " hi " ) ; }
public RequestMatcher function ( RequestSetting arg0 ) { String requestText = arg0 . getText ( ) ; if ( requestText = = null ) { return null ; } return by ( text ( requestText ) ) ; }
public static ElementList function ( String arg0 , Element arg1 ) { return new Selector ( arg0 , arg1 ) . select ( ) ; }
protected boolean function ( MessageContent arg0 , MessageContent arg1 ) { return arg0 = = null | | arg0 . equals ( arg1 ) ; }
protected Optional < String [ ] > function ( final HttpRequest arg0 ) { String [ ] extractedValues = from ( arg0 . getHeaders ( ) . entrySet ( ) ) . filter ( isForHeaderName ( name ) ) . transform ( toValue ( ) ) . transformAndConcat ( arrayAsIterable ( ) ) . toArray ( String . class ) ; if ( extractedValues . length > 0 ) { return of ( extractedValues ) ; } return absent ( ) ; }
private void function ( final ChannelHandlerContext arg0 , final WebSocketFrame arg1 ) { WebSocketFrame frame = getResponseFrame ( arg0 , arg1 ) ; arg0 . channel ( ) . writeAndFlush ( frame ) ; }
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /fuzztests/1595.html.gz " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertNotNull ( doc ) ; Document docXml = Jsoup . parse ( new FileInputStream ( in ) , " UTF-8 " , " https://example.com " , Parser . xmlParser ( ) ) ; assertNotNull ( docXml ) ; }
public void function ( ) { assertEquals ( " *meAndShouldBeTruncated " , AndroidLoggerFactory . loggerNameToTag ( " IAmAVeryLongLoggerNameAndShouldBeTruncated " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " post_method.json " ) ; assertThrows ( IOException . class , ( ) - > { helper . get ( remoteUrl ( " /post " ) ) ;
public Elements function ( Elements arg0 ) { List < Element > matched = new ArrayList < Element > ( ) ; for ( Element el : arg0 ) { match ( el , matched ) ; } return new Elements ( matched ) ; }
public void function ( WebSocket arg0 , int arg1 , String arg2 , boolean arg3 ) { closeCounter + + ; System . out . println ( " closed " ) ; if ( closeCounter > = limit ) { System . exit ( 0 ) ;
public boolean function ( final MocoEvent arg0 ) { return this . arg0 = = arg0 ; }
public void function ( ) throws Exception { ID3v2TextFrameData frameData = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_UTF_16 , TEST_TEXT_UNICODE ) ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 1 , ( byte ) 0xff , ( byte ) 0xfe , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac , 0x03 } ; assertArrayEquals ( expectedBytes , bytes ) ; ID3v2TextFrameData frameDataCopy = new ID3v2TextFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
public static Resource function ( final String arg0 , final String arg1 , final String arg2 , final String arg3 , final String arg4 ) { return arg0 ( text ( checkNotNullOrEmpty ( arg0 , " Template should not be null " ) ) , ImmutableMap . of ( checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
public void function ( final Object arg0 ) { this . group . writeAndFlush ( arg0 ) ; }
public static ExecutorService function ( ) { return executor ; }
public static < T > T function ( final String arg0 , final TypeReference arg1 ) { try { return mapper . readValue ( arg0 , arg1 ) ;
public List < DataNode > function ( ) { return nodesOfType ( DataNode . class ) ; }
public void function ( WebSocket arg0 , int arg1 , String arg2 , boolean arg3 ) { fail ( " There should be no onClose " ) ; }
public final void function ( WebSocket arg0 ) { WebSocketImpl conn = ( WebSocketImpl ) arg0 ; conn . key . interestOps ( SelectionKey . OP_READ | SelectionKey . OP_WRITE ) ; selector . wakeup ( ) ; }
public void function ( ) { factory . getLogger ( " foo1 " ) ; factory . getLogger ( " foo2 " ) ; Set < String > expectedNames = new HashSet < > ( Arrays . asList ( " foo1 " , " foo2 " ) ) ; Set < String > actualNames = new HashSet < > ( ) ; for ( SubstituteLogger slog : factory . getLoggers ( ) ) { actualNames . add ( slog . getName ( ) ) ; } assertEquals ( expectedNames , actualNames ) ; }
public void function ( ) throws Exception { HttpResponse response = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) ; Header header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; }
public void function ( ) throws Exception { server . request ( contain ( header ( " foo " ) , " bar " ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " changeThis " , true ) ; doc . updateMetaCharsetElement ( true ) ; doc . charset ( Charset . forName ( charsetIso8859 ) ) ; final String xmlCharsetISO = " <?xml version= \" 1.0 \"  encoding= \" " + charsetIso8859 + " \" ?> \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetISO , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetIso8859 , doc . charset ( ) . name ( ) ) ; assertEquals ( charsetIso8859 , selectedNode . attr ( " encoding " ) ) ; assertEquals ( doc . charset ( ) , doc . outputSettings ( ) . charset ( ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { log . warn ( arg0 , arg1 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " xml_struct.json " ) ; assertThat ( helper . postFile ( remoteUrl ( " /struct-xml " ) , " foo.xml " ) , is ( " response_for_xml_struct_request " ) ) ; }
public void function ( ) { try { helper . postContent ( " http://localhost:9090/foo " , " " ) ;
public int function ( ByteBuffer arg0 ) throws IOException { return read ( arg0 ) ; }
public void function ( ) { int original = 12345 ; byte [ ] bytes = BufferTools . packInteger ( original ) ; int unpacked = BufferTools . unpackInteger ( bytes [ 0 ] , bytes [ 1 ] , bytes [ 2 ] , bytes [ 3 ] ) ; assertEquals ( original , unpacked ) ; }
public final void function ( WebSocket arg0 , String arg1 ) { onMessage ( arg1 ) ; }
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /fuzztests/1544.html " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertNotNull ( doc ) ; }
public Iterator < Map . Entry < String , String > > function ( ) { return new DatasetIterator ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " , PORT ) ; helper . get ( " http://localhost:8080/mount-exclude/mount.response " ) ; }
public static Stream < Element > function ( Evaluator arg0 , Element arg1 ) { Validate . notNull ( arg0 ) ; Validate . notNull ( arg1 ) ; return Collector . stream ( arg0 , arg1 ) ; }
public static ResponseHandler function ( ProxyConfig arg0 ) { return new ProxyBatchResponseHandler ( arg0 ) ; }
public String function ( final String arg0 ) { return join ( this . fileRoot , arg0 ) ; }
public static Runner function ( final HttpServer arg0 ) { return new MocoHttpServer ( ( ActualHttpServer ) checkNotNull ( arg0 , " Server should not be null " ) ) ; }
public static byte [ ] function ( byte [ ] arg0 , int arg1 , int arg2 , int arg3 ) throws java . io . IOException { if ( arg0 = = null ) { throw new NullPointerException ( " Cannot serialize a null array. " ) ; } if ( arg1 < 0 ) { throw new IllegalArgumentException ( " Cannot have negative offset:  " + arg1 ) ; } if ( arg2 < 0 ) { throw new IllegalArgumentException ( " Cannot have length offset:  " + arg2 ) ; } if ( arg1 + arg2 > arg0 . length ) { throw new IllegalArgumentException ( String . format ( " Cannot have offset of %d and length of %d with array of length %d " , arg1 , arg2 , arg0 . length ) ) ; } if ( ( arg3 & GZIP ) ! = 0 ) { java . io . ByteArrayOutputStream baos = null ;
static void function ( int [ ] arg0 , int arg1 , int arg2 ) { int t = arg0 [ arg1 ] ; arg0 [ arg1 ] = arg0 [ arg2 ] ; arg0 [ arg2 ] = t ; }
void function ( File arg0 , byte [ ] arg1 ) throws IOException { ByteArrayInputStream bais = new ByteArrayInputStream ( arg1 ) ; Reader reader = new InputStreamReader ( bais ) ; BufferedReader breader = new BufferedReader ( reader ) ; FileWriter fileWriter = new FileWriter ( arg0 ) ; while ( true ) { String line = breader . readLine ( ) ;
private boolean function ( ID3Wrapper arg0 , String arg1 , String arg2 ) { RandomAccessFile file = null ; try { file = new RandomAccessFile ( arg1 , " r " ) ; byte [ ] bytes = new byte [ ( int ) file . length ( ) ] ; if ( file . read ( bytes ) ! = file . length ( ) ) { return false ; } arg0 . setAlbumImage ( bytes , arg2 ) ; return true ; } catch ( IOException e ) { } finally { if ( file ! = null ) { try { file . close ( ) ; } catch ( IOException e ) { } } } return false ; }
public void function ( ) { setTrialEnabled ( false ) ; System . setErr ( oldErr ) ; }
public void function ( ) throws IOException { InputStream stream = null ; try { stream = getResourceAsStream ( " settings/fileroot-settings.json " ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 ) . getMessage ( ) ;
public boolean function ( ) { return ( remainingLength ( ) > = 2 & & queue . charAt ( pos ) = = '<' & & Character . isLetterOrDigit ( queue . charAt ( pos + 1 ) ) ) ; }
public void function ( ) throws Exception { String filename = MP3_WITH_ID3V1_AND_ID3V23_AND_CUSTOM_TAGS ; testShouldRemoveId3v2Tag ( new Mp3File ( filename ) ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( html ) ; long count = doc . nodeStream ( ) . parallel ( ) . count ( ) ; assertEquals ( 14 , count ) ; }
public String function ( String arg0 ) { if ( ! arg0 . startsWith ( this . target ) ) { return null ; } return nullToEmpty ( arg0 . replaceFirst ( this . target , " " ) ) ; }
public void function ( ) throws Exception { assertThat ( helper . get ( remoteUrl ( " /proxy/1 " ) ) , is ( " target_1 " ) ) ; assertThat ( helper . get ( remoteUrl ( " /proxy/2 " ) ) , is ( " target_2 " ) ) ; }
@Test public void function ( ) { AttributeParser ap = new AttributeParser ( ) ; Attributes attr = ap . parse ( " " ) ; assertEquals ( 0 , attr . size ( ) ) ; }
public void function ( int arg0 ) { remaining + = arg0 - maxSize ; maxSize = arg0 ; }
public void function ( final SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; MutableHttpResponse httpResponse = arg0 . getHttpResponse ( ) ; if ( HttpRequest . class . isInstance ( request ) ) { doWriteToResponse ( request , httpResponse ) ;
@Test public void function ( ) throws IOException { File in = ParseTest . getFile ( " /htmltests/table-polymer-template.html " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; doc . outputSettings ( ) . prettyPrint ( true ) ; Elements templates = doc . body ( ) . getElementsByTag ( " template " ) ; for ( Element template : templates ) { assertTrue ( template . childNodes ( ) . size ( ) > 1 ) ;
public static < T > RequestMatcher function ( RequestExtractor < T > arg0 , String arg1 ) { return startsWith ( checkNotNull ( arg0 , " Extractor should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Expected resource should not be null " ) ) ) ;
private TextContainer function ( JsonParser arg0 , DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . FIELD_NAME ) { TextContainer . Builder builder = TextContainer . builder ( ) ; String operation = arg0 . getText ( ) . trim ( ) ; builder . withOperation ( operation ) ; JsonToken token = arg0 . nextToken ( ) ; if ( token = = JsonToken . VALUE_STRING ) { String text = arg0 . getText ( ) . trim ( ) ; arg0 . nextToken ( ) ; return builder . withText ( text ) . build ( ) ; } if ( TextContainer . isForTemplate ( operation ) & & token = = JsonToken . START_OBJECT ) { return template ( arg0 , builder ) ; } } throw arg1 . mappingException ( TextContainer . class , arg0 . getCurrentToken ( ) ) ; }
public void function ( ) { for ( Level level : Level . values ( ) ) { throwableCheck ( level ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element div = doc . getElementById ( " 1 " ) ; div . prependText ( " there & now >  " ) ; assertEquals ( " there &amp; now &gt; <p>Hello</p> " , div . html ( ) ) ; }
protected void function ( WebSocket arg0 ) throws InterruptedException { if ( queuesize . get ( ) > = 2 * decoders . size ( ) + 1 ) { return ; } queuesize . incrementAndGet ( ) ; buffers . put ( createBuffer ( ) ) ; }
public void function ( WebSocket arg0 , Framedata arg1 ) { receivedPingBuffer = arg1 . getPayloadData ( ) . array ( ) ; super . onWebsocketPing ( arg0 , arg1 ) ; pingLatch . countDown ( ) ; }
protected static RequestMatcher function ( String arg0 ) { return match ( uri ( arg0 + " .* " ) ) ; }
public final Builder function ( final String arg0 ) { this . arg0 = arg0 ; return this ; }
public static ResponseHandler function ( final String arg0 , final String arg1 ) { return new HeaderResponseHandler ( checkNotNull ( arg0 , " Null header name is not allowed " ) ,
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; ClassicHttpResponse httpResponse = helper . deleteForResponse ( remoteUrl ( " /targets/1 " ) ) ; assertThat ( httpResponse . getCode ( ) , is ( 200 ) ) ; }
private boolean function ( final Element arg0 , final Element arg1 ) { if ( ! arg0 . getNodeName ( ) . equals ( arg1 . getNodeName ( ) ) ) { return false ; } return doMatch ( arg0 . getChildNodes ( ) , arg1 . getChildNodes ( ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { recordEventArgArray ( Level . INFO , null , arg0 , arg1 ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { arg1 . insert ( arg0 . asCharacter ( ) ) ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { arg1 . error ( this ) ; return false ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . normalName ( ) . equals ( " html " ) ) { return arg1 . process ( arg0 , InBody ) ; } else if ( arg0 . isEndTag ( ) & & arg0 . asEndTag ( ) . normalName ( ) . equals ( " html " ) ) { arg1 . transition ( AfterAfterFrameset ) ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . normalName ( ) . equals ( " noframes " ) ) { return arg1 . process ( arg0 , InHead ) ; } else if ( arg0 . isEOF ( ) ) { } else { arg1 . error ( this ) ; return false ; } return true ; }
public void function ( ) throws Exception { final String jsonText = Jsons . toJson ( of ( " foo " , " bar " ) ) ; final String jsonText2 = Jsons . toJson ( of ( " foo " , " bar2 " ) ) ; server . request ( struct ( json ( jsonText ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . postContent ( root ( ) , jsonText2 ) , is ( " foo " ) ) ) ; }
public Connection function ( Map < String , String > arg0 ) { Validate . notNull ( arg0 , " Header map must not be null " ) ; for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { req . header ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
@Test public void function ( ) { String h = " <dIv tItle=bAr><div> " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( 2 , doc . select ( " DiV " ) . size ( ) ) ; assertEquals ( 1 , doc . select ( " DiV[TiTLE] " ) . size ( ) ) ; assertEquals ( 1 , doc . select ( " DiV[TiTLE=BAR] " ) . size ( ) ) ; assertEquals ( 0 , doc . select ( " DiV[TiTLE=BARBARELLA] " ) . size ( ) ) ; }
private boolean function ( final String [ ] arg0 , final String [ ] arg1 ) { if ( arg0 . length ! = arg1 . length ) { return false ; } for ( int i = 0 ; i < arg1 . length ; i + + ) { if ( ! doMatch ( arg0 [ i ] , arg1 [ i ] ) ) { return false ; } } return true ; }
private boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { arg1 . insertStartTag ( " html " ) ; arg1 . transition ( BeforeHead ) ; return arg1 . process ( arg0 ) ; }
private String function ( String arg0 , int arg1 ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < arg1 ; i + + ) { sb . append ( arg0 ) ; } return sb . toString ( ) ; }
public void function ( Object arg0 , Object arg1 ) { parameterizedLog ( INFO_STR , arg0 , arg1 , null ) ; }
public void function ( ) { logger . error ( marker , message , param1 , param2 , param3 , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . ERROR , marker , threeParams , exception ) ; }
public static VerificationMode function ( final int arg0 , final int arg1 ) { checkArgument ( arg0 > = 0 , " Min should be greater than or equal to 0 " ) ; checkArgument ( arg1 > arg0 , " Max should be greater than min " ) ; return new BetweenVerification ( arg0 , arg1 ) ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( marker , message , param1 , param2 , param3 ) ; break ; case DEBUG : logger . debug ( marker , message , param1 , param2 , param3 ) ; break ; case INFO : logger . info ( marker , message , param1 , param2 , param3 ) ; break ; case WARN : logger . warn ( marker , message , param1 , param2 , param3 ) ; break ; case ERROR : logger . error ( marker , message , param1 , param2 , param3 ) ; break ; } verifyMessage ( arg0 , marker , threeParams , null ) ; }
public void function ( ) { logger . info ( message , param1 , param2 , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . INFO , twoParams , exception ) ; }
public void function ( ) throws IOException { String url = " http://jsoup.org " ; Proxy proxy = new Proxy ( Proxy . Type . HTTP , InetSocketAddress . createUnresolved ( " localhost " , 8888 ) ) ; Document doc = Jsoup . connect ( url ) . proxy ( proxy ) . get ( ) ; assertTrue ( doc . title ( ) . contains ( " jsoup " ) ) ; }
@Test public void function ( ) { TextNode one = new TextNode ( " " ) ; TextNode two = new TextNode ( "       " ) ; TextNode three = new TextNode ( "    \ n \ n    " ) ; TextNode four = new TextNode ( " Hello " ) ; TextNode five = new TextNode ( "    \ nHello  " ) ; assertTrue ( one . isBlank ( ) ) ; assertTrue ( two . isBlank ( ) ) ; assertTrue ( three . isBlank ( ) ) ; assertFalse ( four . isBlank ( ) ) ; assertFalse ( five . isBlank ( ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>One <span>Two</span> Three <br> Four</p> " ) ; Element p = doc . select ( " p " ) . first ( ) ; List < TextNode > textNodes = p . textNodes ( ) ; textNodes . get ( 1 ) . text ( "  three-more  " ) ; textNodes . get ( 2 ) . splitText ( 3 ) . text ( " -ur " ) ; assertEquals ( " One Two three-more Fo-ur " , p . text ( ) ) ; assertEquals ( " One three-more Fo-ur " , p . ownText ( ) ) ; assertEquals ( 4 , p . textNodes ( ) . size ( ) ) ; }
public void function ( ) { final List < Integer > first = Iterables . asIterable ( 1 , new Integer [ ] { 2 , 3 } ) ; assertThat ( first . get ( 0 ) , is ( 1 ) ) ; assertThat ( first . get ( 1 ) , is ( 2 ) ) ; assertThat ( first . get ( 2 ) , is ( 3 ) ) ; assertThat ( first . size ( ) , is ( 3 ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( null , new Integer [ 0 ] ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( 1 , null ) ) ; final List < Integer > second = Iterables . asIterable ( 1 , 2 , new Integer [ ] { 3 , 4 } ) ; assertThat ( second . get ( 0 ) , is ( 1 ) ) ; assertThat ( second . get ( 1 ) , is ( 2 ) ) ; assertThat ( second . get ( 2 ) , is ( 3 ) ) ; assertThat ( second . get ( 3 ) , is ( 4 ) ) ; assertThat ( second . size ( ) , is ( 4 ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( null , 2 , new Integer [ 0 ] ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.8.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 320 ) ;
public void function ( ChangeEvent arg0 ) { intervallabel . setText ( " Interval:  " + interval . getValue ( ) + "  ms  " ) ;
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( marker , message , param1 , exception ) ; break ; case DEBUG : logger . debug ( marker , message , param1 , exception ) ; break ; case INFO : logger . info ( marker , message , param1 , exception ) ; break ; case WARN : logger . warn ( marker , message , param1 , exception ) ; break ; case ERROR : logger . error ( marker , message , param1 , exception ) ; break ; } verifyMessage ( arg0 , marker , oneParam , exception ) ; }
public static ContentResource function ( final File arg0 ) { String fileId = " arg0 " ; return new DefaultContentResource ( id ( fileId ) , fileConfigApplier ( fileId , arg0 ) , new FileResourceReader ( arg0 ) ) ; }
@Test public void function ( ) { String ok = " <p>Test <b><a href='http://example.com/'>OK</a></b></p> " ; String nok1 = " <p><script></script>Not <b>OK</b></p> " ; String nok2 = " <p align=right>Test Not <b>OK</b></p> " ; assertTrue ( Jsoup . isValid ( ok , Whitelist . basic ( ) ) ) ; assertFalse ( Jsoup . isValid ( nok1 , Whitelist . basic ( ) ) ) ; assertFalse ( Jsoup . isValid ( nok2 , Whitelist . basic ( ) ) ) ; }
public void function ( ) throws Exception { final String jsonText = Jsons . toJson ( of ( " foo " , " bar " ) ) ; final String jsonText2 = Jsons . toJson ( of ( " foo " , " bar2 " ) ) ; server . request ( as ( json ( jsonText ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . postContent ( root ( ) , jsonText2 ) , is ( " foo " ) ) ) ; }
private void function ( ) { if ( connectionLostCheckerService ! = null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture ! = null ) { connectionLostCheckerFuture . cancel ( false ) ;
public void function ( ) throws Exception { runTestScenario ( 6 ) ; }
public static String function ( Object arg0 ) { if ( arg0 = = null ) { return String . valueOf ( arg0 ) ; } Class objectClass = arg0 . getClass ( ) ; if ( unrenderableClasses . containsKey ( objectClass ) = = false ) { try { if ( objectClass . isArray ( ) ) { return renderArray ( arg0 , objectClass ) . toString ( ) ; } else { return arg0 . toString ( ) ; } } catch ( Exception e ) { Long now = new Long ( System . currentTimeMillis ( ) ) ; unrenderableClasses . put ( objectClass , now ) ; } } return arg0 . getClass ( ) . getName ( ) + " @ " + Integer . toHexString ( arg0 . hashCode ( ) ) ; }
private BinaryWebSocketFrame function ( final WebsocketResponse arg0 ) { ByteBuf byteBuf = ByteBufs . toByteBuf ( arg0 . getContent ( ) . getContent ( ) ) ; return new BinaryWebSocketFrame ( byteBuf ) ; }
static String function ( String arg0 , Charset arg1 ) { StringBuilder accum = new StringBuilder ( ( int ) ( arg0 . length ( ) * 1.5 ) ) ; CharsetEncoder encoder = arg1 . newEncoder ( ) ; for ( int pos = 0 ; pos < arg0 . length ( ) ; pos + + ) { Character c = arg0 . charAt ( pos ) ; if ( fullByVal . containsKey ( ( int ) c ) ) accum . append ( " & " ) . append ( fullByVal . get ( ( int ) c ) ) . append ( " ; " ) ; else if ( encoder . canEncode ( c ) ) accum . append ( c ) ; else accum . append ( " &# " ) . append ( ( int ) c ) . append ( " ; " ) ; } return accum . toString ( ) ; }
boolean function ( ) { if ( isEmpty ( ) ) return false ; char c = charBuf [ bufPos ] ; return ( c > = '0' & & c < = '9' ) ; }
public void function ( ) { ID3v2ChapterTOCFrameData frameData = new ID3v2ChapterTOCFrameData ( false ) ; frameData . setOrdered ( true ) ; assertTrue ( frameData . isOrdered ( ) ) ; }
public void function ( File arg0 ) { FileSelector fs = new FileSelector ( progressListener ) ; List < File > fileList = fs . selectJavaFilesInFolder ( arg0 ) ; scanFileList ( fileList ) ; progressListener . onDone ( ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { readData ( arg0 , arg1 , this , RawtextLessthanSign ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.2.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public static RestSettingBuilder function ( ) { return new PostSettingBuilder ( ) ; }
public void function ( ) { String result ; Integer i1 = new Integer ( 1 ) ; Integer i2 = new Integer ( 2 ) ; Integer i3 = new Integer ( 3 ) ; Integer [ ] ia = new Integer [ ] { i1 , i2 , i3 } ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {} and {}. " , ia ) ; assertEquals ( " Value 1 is smaller than 2 and 3. " , result ) ; result = MessageFormatter . arrayFormat ( " {}{}{} " , ia ) ; assertEquals ( " 123 " , result ) ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {}. " , ia ) ; assertEquals ( " Value 1 is smaller than 2. " , result ) ; result = MessageFormatter . arrayFormat ( " Value {} is smaller than {} " , ia ) ; assertEquals ( " Value 1 is smaller than 2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val={}, {, Val={} " , ia ) ; assertEquals ( " Val=1, {, Val={} " , result ) ; result = MessageFormatter . arrayFormat ( " Val={},  \\ {, Val={} " , ia ) ; assertEquals ( " Val=1, {, Val=2 " , result ) ; result = MessageFormatter . arrayFormat ( " Val1={}, Val2={ " , ia ) ; assertEquals ( " Val1=1, Val2={ " , result ) ;
public void function ( ) throws Exception { runTestScenario ( true ) ; }
private String function ( String arg0 ) throws IOException { Content content = Request . Get ( arg0 ) . execute ( ) . returnContent ( ) ; return content . asString ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { if ( isInfoEnabled ( arg0 ) ) { handle_1ArgsCall ( Level . INFO , arg0 , arg1 , arg2 ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " " ) ; assertEquals ( " <html><head></head><body></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
public void function ( WebSocket arg0 ) { if ( this . connections . remove ( arg0 ) ) { onClientClose ( arg0 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " query.json " ) ; helper . get ( remoteUrl ( " /query?param=foo2 " ) ) ; }
public static ResponseHandler function ( final String arg0 , final ContentResource arg1 , final ContentResource arg2 ) { return new DynamicReplayHandler ( RecorderRegistry . registryOf ( arg0 , IN_MEMORY ) , arg1 , arg2 ) ;
public void function ( ) throws Exception { File temp = File . createTempFile ( " temp " , Long . toString ( System . nanoTime ( ) ) ) ; server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( " foo " , tape ( temp . getPath ( ) ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( " foo " , tape ( temp . getPath ( ) ) , identifier ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { assertThat ( helper . getForStatus ( remoteUrl ( " /tape-replay?type=bar " ) ) , is ( 400 ) ) ;
@Nullable public Attribute function ( String arg0 ) { int i = indexOfKey ( arg0 ) ; return i = = NotFound ? null : new Attribute ( arg0 , checkNotNull ( vals [ i ] ) , this ) ; }
private void function ( byte [ ] arg0 , ByteArrayOutputStream arg1 ) throws DataFormatException { inflater . setInput ( arg0 ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesInflated ; while ( ( bytesInflated = inflater . inflate ( buffer ) ) > 0 ) { arg1 . write ( buffer , 0 , bytesInflated ) ;
private static void function ( Tokeniser arg0 , CharacterReader arg1 , TokeniserState arg2 , TokeniserState arg3 ) { switch ( arg1 . arg2 ( ) ) { case '<' :
public void function ( ) throws Exception { assertThat ( helper . getAsBytes ( remoteUrl ( " /template " ) ) , is ( Files . readAllBytes ( Paths . get ( " src/test/resources/gbk.response " ) ) ) ) ; }
private int function ( String arg0 , int arg1 , String arg2 ) { int skipped = 0 ; while ( arg0 . startsWith ( arg2 , arg1 + skipped ) ) { skipped + = arg2 . length ( ) ; } return skipped ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object [ ] arg3 , Throwable arg4 ) { SubstituteLoggingEvent loggingEvent = new SubstituteLoggingEvent ( ) ; loggingEvent . setTimeStamp ( System . currentTimeMillis ( ) ) ; loggingEvent . setLevel ( arg0 ) ; loggingEvent . setMessage ( arg2 ) ; loggingEvent . setArgumentArray ( arg3 ) ; loggingEvent . setThrowable ( arg4 ) ; loggingEvent . setThreadName ( Thread . currentThread ( ) . getName ( ) ) ; eventList . add ( loggingEvent ) ; }
public boolean function ( final Request arg0 ) { Optional < String > optionalPath = extractor . extract ( arg0 ) ; if ( optionalPath . isPresent ( ) ) { String relativePath = optionalPath . get ( ) ; return isTarget ( relativePath ) & & new File ( dir , relativePath ) . exists ( ) ; } return false ; }
private static void function ( ) { MyRandom myRandom = new MyRandom ( 100 ) ; int len = 150 ; int [ ] intArray = new int [ len ] ; for ( int i = 0 ; i < len ; i + + ) { intArray [ i ] = myRandom . nextInt ( ) ; } BubbleSort . sort ( intArray ) ; }
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { char c = arg1 . consume ( ) ; switch ( c ) { case '-' :
public void function ( ) throws Exception { HttpResponse httpResponse = helper . putForResponseWithHeaders ( remoteUrl ( " /targets/1 " ) , mapper . writeValueAsString ( resource1 ) , of ( HttpHeaders . IF_MATCH , " moco " ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; }
private HttpEntity function ( ByteBuf arg0 , long arg1 ) { return new ByteArrayEntity ( asBytes ( arg0 ) , 0 , ( int ) arg1 ) ; }
protected void function ( String arg0 , String arg1 , ParseErrorList arg2 ) { Validate . notNull ( arg0 , " String input must not be null " ) ; Validate . notNull ( arg1 , " BaseURI must not be null " ) ; doc = new Document ( arg1 ) ; reader = new CharacterReader ( arg0 ) ; this . arg2 = arg2 ; tokeniser = new Tokeniser ( reader , arg2 ) ; stack = new ArrayList < Element > ( 32 ) ; this . arg1 = arg1 ; }
public boolean function ( final String arg0 ) { Pattern pattern = Pattern . compile ( expected . readFor ( null ) . toString ( ) ) ; return pattern . matcher ( arg0 ) . matches ( ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { if ( isInfoEnabled ( arg0 ) ) { handle_0ArgsCall ( Level . INFO , arg0 , arg1 , arg2 ) ;
public void function ( String arg0 , Object arg1 ) { if ( log . isDebugEnabled ( ) ) { String msgStr = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " proxy_batch.json " ) ; String content = helper . postContent ( remoteUrl ( " /failover/1 " ) , " proxy " ) ; assertThat ( content , is ( " proxy " ) ) ; }
final static public void function ( StringBuilder arg0 , String arg1 , int arg2 ) { int actualLen = 0 ; if ( arg1 ! = null ) { actualLen = arg1 . length ( ) ; } if ( actualLen < arg2 ) { spacePad ( arg0 , arg2 - actualLen ) ; } if ( arg1 ! = null ) { arg0 . append ( arg1 ) ;
public static void function ( String arg0 , Instrumentation arg1 ) { LogTransformer . Builder builder = new LogTransformer . Builder ( ) ; builder = builder . addEntryExit ( true ) ; if ( arg0 ! = null ) { Properties args = parseArguments ( arg0 , " , " ) ; if ( args . containsKey ( AgentOptions . VERBOSE ) ) { builder = builder . verbose ( true ) ; } if ( args . containsKey ( AgentOptions . TIME ) ) { printStartStopTimes ( ) ; } if ( args . containsKey ( AgentOptions . IGNORE ) ) { String ignore = args . getProperty ( AgentOptions . IGNORE ) ; builder = builder . ignore ( ignore . split ( " : " ) ) ; } if ( args . containsKey ( AgentOptions . LEVEL ) ) { builder = builder . level ( args . getProperty ( AgentOptions . LEVEL ) ) ; } } arg1 . addTransformer ( builder . build ( ) ) ; }
@Test public void function ( ) { String in = " One Two something Two Three Four " ; CharacterReader r = new CharacterReader ( in ) ; assertEquals ( - 1 , r . nextIndexOf ( " Foo " ) ) ; assertEquals ( 4 , r . nextIndexOf ( " Two " ) ) ; assertEquals ( " One Two  " , r . consumeTo ( " something " ) ) ; assertEquals ( 10 , r . nextIndexOf ( " Two " ) ) ; assertEquals ( " something Two Three Four " , r . consumeToEnd ( ) ) ; assertEquals ( - 1 , r . nextIndexOf ( " Two " ) ) ; }
public static < T > boolean function ( final Iterable < T > arg0 ) { return arg0 = = null | | com . google . common . collect . Iterables . isEmpty ( arg0 ) ; }
private HttpResponseSetting function ( final HttpServer arg0 ) { if ( isMount ( ) ) { return arg0 . mount ( mount . getDir ( ) , to ( mount . getUri ( ) ) , mount . getMountPredicates ( ) ) . response ( mount . getResponseHandler ( ) ) ; } if ( isProxy ( ) ) { if ( proxy . hasUrl ( ) ) { throw new IllegalArgumentException ( " It's not allowed to have URL in proxy from server " ) ; } return arg0 . proxy ( proxy . getProxyConfig ( ) , proxy . getFailover ( ) ) ; } if ( isAnyResponse ( ) ) { return arg0 . response ( getResponseHandler ( ) ) ; } HttpResponseSetting targetRequest = arg0 . request ( getRequestMatcher ( ) ) ; if ( isRedirectResponse ( ) ) { return targetRequest . redirectTo ( this . redirectTo . asResource ( ) ) ; } return targetRequest . response ( getResponseHandler ( ) ) ; }
protected List < Node > function ( ) { return EmptyNodes ; }
public Element function ( Evaluator arg0 ) { return Collector . findFirst ( arg0 , this ) ; }
public static Document function ( File arg0 , arg1 String arg2 , String arg3 , Parser arg4 ) throws IOException { InputStream stream = new FileInputStream ( arg0 ) ; String name = Normalizer . lowerCase ( arg0 . getName ( ) ) ; if ( name . endsWith ( " .gz " ) | | name . endsWith ( " .z " ) ) { boolean zipped ; try { zipped = ( stream . read ( ) = = 0x1f & & stream . read ( ) = = 0x8b ) ; } finally { stream . close ( ) ; } stream = zipped ? new GZIPInputStream ( new FileInputStream ( arg0 ) ) : new FileInputStream ( arg0 ) ; } return parseInputStream ( stream , arg2 , arg3 , arg4 ) ; }
public final Builder function ( final InputStream arg0 ) { try { this . content = toByteArray ( arg0 ) ;
@Test public void function ( ) { String html = " <body><div><p>One</div><div><p>Two</div><div>Three</div> " ; Document doc = Jsoup . parse ( html ) ; Element div = doc . selectFirst ( " div " ) ; assertNotNull ( div ) ; Elements els = div . selectXpath ( " /div/p " ) ; assertEquals ( 1 , els . size ( ) ) ; assertEquals ( " One " , els . get ( 0 ) . text ( ) ) ; assertEquals ( " p " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( 0 , div . selectXpath ( " //body " ) . size ( ) ) ; assertEquals ( 1 , doc . selectXpath ( " //body " ) . size ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( " foo " ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { assertThrows ( IllegalArgumentException . class , ( ) - > {
private void function ( Level arg0 , Marker arg1 , String arg2 , Object arg3 , Object arg4 ) { if ( arg4 instanceof Throwable ) { recordEvent ( arg0 , arg1 , arg2 , new Object [ ] { arg3 } , ( Throwable ) arg4 ) ;
@Test public void function ( ) { String html = " foo <b>bar</b> baz " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " foo bar baz " , doc . text ( ) ) ;
public Element function ( String arg0 ) { Validate . notNull ( arg0 ) ; List < Node > nodes = NodeUtils . parser ( this ) . parseFragmentInput ( arg0 , this , baseUri ( ) ) ; addChildren ( nodes . toArray ( new Node [ nodes . size ( ) ] ) ) ; return this ; }
public boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof ID3v2FrameSet ) ) return false ; if ( super . equals ( arg0 ) ) return true ; ID3v2FrameSet other = ( ID3v2FrameSet ) arg0 ; if ( id = = null ) { if ( other . id ! = null ) return false ; } else if ( other . id = = null ) return false ; else if ( ! id . equals ( other . id ) ) return false ; if ( frames = = null ) { if ( other . frames ! = null ) return false ; } else if ( other . frames = = null ) return false ; else if ( ! frames . equals ( other . frames ) ) return false ; return true ; }
public void function ( ) throws InterruptedException , BrokenBarrierException { System . out . println ( " THREAD_COUNT= " + THREAD_COUNT ) ; LoggerAccessingThread [ ] accessors = harness ( ) ; for ( LoggerAccessingThread accessor : accessors ) { EVENT_COUNT . getAndIncrement ( ) ; accessor . logger . info ( " post harness " ) ; } Logger logger = LoggerFactory . getLogger ( loggerName + " .slowInitialization- " + diff ) ; logger . info ( " hello " ) ; EVENT_COUNT . getAndIncrement ( ) ; int NUM_LINES_IN_SLF4J_REPLAY_WARNING = 3 ; assertEquals ( EVENT_COUNT . get ( ) + NUM_LINES_IN_SLF4J_REPLAY_WARNING , sps . stringList . size ( ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isInfoEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public boolean function ( ) throws InterruptedException { reset ( ) ; return connectBlocking ( ) ; }
public static String function ( String arg0 , Properties arg1 ) { return arg0 ; }
public RequestMatcher function ( final MocoConfig arg0 ) { Resource appliedResource = this . expected . apply ( arg0 ) ; if ( appliedResource = = this . expected ) { return this ; } return new JsonRequestMatcher ( appliedResource , this . extractor , this . matchMode ) ; }
public Optional < MocoConfig > function ( ) { if ( request . isPresent ( ) ) { return of ( Moco . request ( request . get ( ) . getRequestMatcher ( ) ) ) ; } return absent ( ) ; }
public void function ( ) throws Exception { server . response ( text ( ( request ) - > " foo " ) ) ; running ( server , ( ) - > { String response = helper . get ( root ( ) ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { logger . error ( arg0 , arg1 , arg2 ) ; }
protected void function ( ) { StringBuffer cat = new StringBuffer ( ) ; catalogMp3Fields ( cat ) ; catalogId3Fields ( cat ) ; catalogCustomTag ( cat ) ; printOut ( cat . toString ( ) ) ; }
public String function ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; ownText ( sb ) ; return StringUtil . releaseBuilder ( sb ) . trim ( ) ; }
public LogTransformer function ( ) { if ( verbose ) { System . err . println ( " Creating LogTransformer " ) ; } return new LogTransformer ( this ) ; }
public static void function ( String [ ] arg0 ) throws URISyntaxException { Draft_6455 draft_ocppOnly = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " ocpp2.0 " ) ) ) ; ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " ocpp2.0 " ) ) ; protocols . add ( new Protocol ( " " ) ) ; Draft_6455 draft_ocppAndFallBack = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ; ChatServer chatServer = new ChatServer ( 8887 , draft_ocppOnly ) ; chatServer . start ( ) ; }
public byte [ ] function ( ClassLoader arg0 , String arg1 , Class < ? > arg2 , ProtectionDomain arg3 , byte [ ] arg4 ) { try { return transform0 ( arg1 , arg2 , arg3 , arg4 ) ;
private String function ( arg0 . arg1 . arg2 . Element arg3 ) { Attributes attributes = arg3 . attributes ( ) ; for ( Attribute attr : attributes ) { String key = attr . getKey ( ) ; String prefix ; if ( key . equals ( xmlnsKey ) ) { prefix = " " ; } else if ( key . startsWith ( xmlnsPrefix ) ) { prefix = key . substring ( xmlnsPrefix . length ( ) ) ; } else { continue ; } namespacesStack . peek ( ) . put ( prefix , attr . getValue ( ) ) ; } int pos = arg3 . tagName ( ) . indexOf ( " : " ) ; return pos > 0 ? arg3 . tagName ( ) . substring ( 0 , pos ) : " " ; }
private void function ( ) throws IOException { if ( ! file . exists ( ) ) throw new FileNotFoundException ( " File not found  " + file . getPath ( ) ) ; if ( ! file . canRead ( ) ) throw new IOException ( " File not readable " ) ; length = file . length ( ) ; lastModified = file . lastModified ( ) ; }
public void function ( ) throws IOException { InputStream stream = getResourceAsStream ( " multiple/settings.json " ) ; runner = new SettingRunner ( stream , createStartArgs ( 12306 ) ) ; runner . run ( ) ; assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " foo " ) ) ; assertThat ( helper . get ( remoteUrl ( " /bar " ) ) , is ( " bar " ) ) ; }
public List < Node > function ( ) throws IOException { treeBuilder . runParser ( ) ; return treeBuilder . completeParseFragment ( ) ; }
public void function ( ) throws IOException { for ( WebSocket ws : connections ) { ws . close ( ) ; } thread . interrupt ( ) ; this . server . close ( ) ;
@Test ( expected = IllegalArgumentException . class ) public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( echoUrl ) . execute ( ) ; Document doc = res . parse ( ) ; String body = res . body ( ) ; }
public BaseSetting function ( BaseSetting arg0 ) { return configItem ( arg0 ) ; }
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; Character c = queue . peek ( ) ; while ( ! queue . isEmpty ( ) & & ( Character . isLetterOrDigit ( c ) | | c . equals ( '-' ) | | c . equals ( '_' ) ) ) { accum . append ( queue . removeFirst ( ) ) ; } return accum . toString ( ) ; }
private synchronized ByteBuffer function ( ) throws SSLException { int rem ; do { rem = inData . remaining ( ) ; res = sslEngine . unwrap ( inCrypt , inData ) ; } while ( rem ! = inData . remaining ( ) ) ; inData . flip ( ) ; return inData ; }
public static Elements function ( Evaluator arg0 , Element arg1 ) { Elements elements = new Elements ( ) ; new NodeTraversor ( new Accumulator ( elements , arg0 ) ) . traverse ( arg1 ) ; return elements ; }
public void function ( final ChannelHandlerContext arg0 , final WebSocketFrame arg1 ) { if ( this . websocketServer = = null ) { return ; } Optional < WebSocketFrame > frame = getResponseFrame ( arg0 , arg1 ) ; frame . ifPresent ( webSocketFrame - > arg0 . channel ( ) . writeAndFlush ( webSocketFrame ) ) ; }
public void function ( ) throws Exception { DefaultExtension defaultExtension = new DefaultExtension ( ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " Test " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " Test, ASDC, as, ad " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " ASDC, as,ad " ) ) ; assertTrue ( defaultExtension . acceptProvidedExtensionAsClient ( " permessage-deflate " ) ) ; }
public static String function ( String arg0 , boolean arg1 ) { Parser parser = Parser . htmlParser ( ) ; parser . treeBuilder . initialiseParse ( new StringReader ( arg0 ) , " " , parser ) ; Tokeniser tokeniser = new Tokeniser ( parser . treeBuilder ) ; return tokeniser . unescapeEntities ( arg1 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) throws Exception { server . request ( by ( uri ( " /target " ) ) ) . response ( " proxy " ) ; final File file = tempFolder . newFile ( ) ; server . request ( by ( uri ( " /proxy_playback " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) , playback ( file . getAbsolutePath ( ) ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws InterruptedException { final String [ ] body = new String [ 1 ] ; Thread runner = new Thread ( ( ) - > { try { Connection . Response res = Jsoup . connect ( SlowRider . Url ) . timeout ( 15 * 1000 ) . execute ( ) ; body [ 0 ] = res . parse ( ) . text ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } ) ; runner . start ( ) ; Thread . sleep ( 1000 * 3 ) ; runner . interrupt ( ) ; assertTrue ( runner . isInterrupted ( ) ) ; runner . join ( ) ; assertEquals ( 0 , body [ 0 ] . length ( ) ) ; }
public void function ( ) { LoggerFactoryFriend . reset ( ) ; System . setErr ( sps ) ; }
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /fuzztests/1580-attrname.html.gz " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertNotNull ( doc ) ; Document docXml = Jsoup . parse ( new FileInputStream ( in ) , " UTF-8 " , " https://example.com " , Parser . xmlParser ( ) ) ; assertNotNull ( docXml ) ; }
@Test void function ( ) { String html = " <div>One <span>Hello</span><span>!</span></div><div> \ n<span>There</span></div><div> <span>Now</span></div> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <div> \ n " +
private void function ( Logger arg0 ) { arg0 . setUseParentHandlers ( false ) ; Handler [ ] handlers = arg0 . getHandlers ( ) ; for ( int i = 0 ; i < handlers . length ; i + + ) { arg0 . removeHandler ( handlers [ i ] ) ;
public static MountPredicate function ( final String arg0 ) { checkNotNullOrEmpty ( arg0 , " Glob should not be null or empty " ) ; final PathMatcher matcher = FileSystems . getDefault ( ) . getPathMatcher ( " glob: " + arg0 ) ; return new MountPredicate ( ) { @Override
@Test public void function ( ) { String h = " <div title=foo /><div title=bar /><div /><p></p><img /><span title=qux> " ; Document doc = Jsoup . parse ( h ) ; Elements els = doc . select ( " p,div,[title] " ) ; assertEquals ( 5 , els . size ( ) ) ; assertEquals ( " p " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " div " , els . get ( 1 ) . tagName ( ) ) ; assertEquals ( " foo " , els . get ( 1 ) . attr ( " title " ) ) ; assertEquals ( " div " , els . get ( 2 ) . tagName ( ) ) ; assertEquals ( " bar " , els . get ( 2 ) . attr ( " title " ) ) ; assertEquals ( " div " , els . get ( 3 ) . tagName ( ) ) ; assertNull ( els . get ( 3 ) . attr ( " title " ) ) ; assertEquals ( " span " , els . get ( 4 ) . tagName ( ) ) ; }
public static boolean function ( ) { java . util . logging . Logger rootLogger = getRootLogger ( ) ; Handler [ ] handlers = rootLogger . getHandlers ( ) ; for ( Handler handler : handlers ) { if ( handler instanceof SLF4JBridgeHandler ) { return true ; } } return false ; }
public void function ( final byte [ ] arg0 ) { clearMessage ( ) ; ByteBuffer buffer = ByteBuffer . wrap ( arg0 ) ; this . userSession . getAsyncRemote ( ) . sendBinary ( buffer ) ; }
private static void function ( Set < URL > arg0 ) { if ( isAmbiguousStaticLoggerBinderPathSet ( arg0 ) ) { Util . report ( " Class path contains multiple SLF4J bindings. " ) ;
public static RestSetting function ( final String arg0 , final ResponseHandler arg1 ) { return new RestSetting ( arg0 , arg1 ) ; }
public Element function ( String arg0 ) { return closest ( QueryParser . parse ( arg0 ) ) ; }
protected int function ( Element arg0 , Element arg1 ) { if ( arg1 . parent ( ) = = null ) return 0 ; return arg1 . parent ( ) . childrenSize ( ) - arg1 . elementSiblingIndex ( ) ; }
public void function ( final SessionContext arg0 ) { MessageContent content = this . content . readFor ( arg0 . getRequest ( ) ) ; ByteBuf byteBuf = ByteBufs . toByteBuf ( content . getContent ( ) ) ; arg0 . writeAndFlush ( new BinaryWebSocketFrame ( byteBuf ) , group ) ; }
private List < File > function ( File arg0 ) { if ( javaFiles = = null ) { javaFiles = new ArrayList < File > ( ) ; } if ( arg0 . isDirectory ( ) ) { File [ ] files = arg0 . listFiles ( ) ; if ( files ! = null ) { for ( int i = 0 ; i < files . length ; i + + ) { selectFiles ( files [ i ] ) ; } } } else { if ( arg0 . getName ( ) . endsWith ( " .java " ) ) { javaFiles . add ( arg0 ) ; logger . info ( " Adding java file  " + arg0 . getAbsolutePath ( ) ) ; } } return javaFiles ; }
private static boolean function ( ArrayList < Element > arg0 , Element arg1 ) { final int bottom = arg0 . size ( ) - 1 ; final int upper = bottom > = maxQueueDepth ? bottom - maxQueueDepth : 0 ; for ( int pos = bottom ; pos > = upper ; pos - - ) { Element next = arg0 . get ( pos ) ; if ( next = = arg1 ) { return true ; } } return false ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { arg0 . send ( " Welcome to the server! " ) ; broadcast ( " new connection:  " + arg1 . getResourceDescriptor ( ) ) ; System . out . println ( arg0 . getRemoteSocketAddress ( ) . getAddress ( ) . getHostAddress ( ) + "  entered the room! " ) ; }
@Test public void function ( ) { String s = new String ( Character . toChars ( 135361 ) ) ; Document doc = Jsoup . parse ( " <div k " + s + " =' " + s + " '>^ " + s + " $/div> " ) ; assertEquals ( " div " , doc . select ( " div[k " + s + " ] " ) . first ( ) . tagName ( ) ) ; assertEquals ( " div " , doc . select ( " div:containsOwn( " + s + " ) " ) . first ( ) . tagName ( ) ) ; }
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , put ( " 1 " ) ) ; running ( server , new Runnable ( ) { @Override
public List < String > function ( String arg0 ) { Validate . notEmpty ( arg0 ) ; return getHeadersCaseInsensitive ( arg0 ) ; }
public void function ( ) throws Exception { HttpsServer server = httpsServer ( port ( ) , DEFAULT_CERTIFICATE ) ; server . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public HttpSetting function ( final RequestMatcher arg0 ) { return this . onRequestAttached ( checkNotNull ( arg0 , " Matcher should not be null " ) ) ; }
public void function ( ) throws Exception { server . response ( text ( " hello " ) . transform ( content - > { byte [ ] raw = content . getContent ( ) ; byte [ ] transformed = new byte [ raw . length ] ; for ( int i = 0 ; i < raw . length ; i + + ) { transformed [ i ] = ( byte ) ( raw [ i ] + 1 ) ; } return MessageContent . content ( ) . withContent ( transformed ) . withCharset ( content . getCharset ( ) ) . build ( ) ; } ) ) ; running ( server , ( ) - > { String response = helper . get ( root ( ) ) ;
protected boolean function ( ) { try { loadClass ( " org.apache.log4j.Logger " ) ;
public boolean function ( Element arg0 , Element arg1 ) { return ! memoMatches ( arg0 , arg1 ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { if ( ! logger . isDebugEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { FormattingTuple ft = MessageFormatter . arg1 ( arg1 , arg2 ) ;
@Test public void function ( ) { String h = " <div><p><A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote> " ; String cleanHtml = Jsoup . clean ( h , Safelist . basic ( ) . removeTags ( " a " ) ) ; assertEquals ( " <p>Nice</p><blockquote>Hello</blockquote> " , TextUtil . stripNewlines ( cleanHtml ) ) ; }
public void function ( ) throws IOException { assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " 0XCAFEBABE " ) ) ; assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " 0XCAFEBABE " ) ) ; assertThat ( asCharSource ( tempFile , Charset . defaultCharset ( ) ) . read ( ) , countString ( " /proxy " , 1 ) ) ; }
public void function ( ) { getSLF4JSystemLoggerFinder ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.8.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { try { assertThat ( helper . get ( " http://localhost:8080/foo " ) , is ( " bar " ) ) ;
public Socket function ( InetAddress arg0 , int arg1 , InetAddress arg2 , int arg3 ) throws IOException { throw new UnsupportedOperationException ( ) ; }
public void function ( ) throws Exception { server . request ( and ( by ( uri ( " /foo " ) ) , eq ( query ( " param " ) , " " ) ) ) . response ( " bar " ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /foo?param " ) ) , is ( " bar " ) ) ) ; }
@Test public void function ( ) { String h = " <body> \ n " + " <input type= \" hidden \"  name= \" a \"  value= \" \" > \ n " + " <table> \ n " + " <input type= \" hidden \"  name= \" b \"  value= \" \"  /> \ n " + " </table> \ n " + " </body> " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( 1 , doc . select ( " table input " ) . size ( ) ) ; assertEquals ( 2 , doc . select ( " input " ) . size ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { if ( isInfoEnabled ( arg0 ) ) { handle_1ArgsCall ( Level . INFO , arg0 , arg1 , arg2 ) ;
public boolean function ( final HttpRequest arg0 ) { String requestOrigin = arg0 . getHeader ( " Origin " ) ; return origin . equals ( requestOrigin ) | | origin . equals ( " * " ) ; }
protected void function ( final SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; if ( serverSetting . isSecure ( ) ) { pipeline . addFirst ( " ssl " , serverSetting . sslHandler ( ) . get ( ) ) ; } ServerConfig serverConfig = serverSetting . getServerConfig ( ) ; pipeline . addLast ( " codec " , new HttpServerCodec ( MAX_INITIAL_LINE_LENGTH , serverConfig . getHeaderSize ( ) , MAX_CHUNK_SIZE , false ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( MAX_CONTENT_LENGTH ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.5.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 400 ) ; }
public static String function ( final String arg0 ) { return checkValidUrlItem ( arg0 , " Resource name " ) ; }
public void function ( final SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; Response response = arg0 . getResponse ( ) ; if ( HttpRequest . class . isInstance ( request ) & & MutableHttpResponse . class . isInstance ( response ) ) { if ( ! canResponseHaveContent ( HttpRequest . class . cast ( request ) ) ) { return ; } HttpRequest httpRequest = HttpRequest . class . cast ( request ) ; MutableHttpResponse httpResponse = MutableHttpResponse . class . cast ( response ) ; doWriteToResponse ( httpRequest , httpResponse ) ; return ; } MutableResponse mutableResponse = MutableResponse . class . cast ( response ) ; mutableResponse . setContent ( requireResponseContent ( request ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { lbLogger . info ( convertToString ( arg0 ) , arg1 ) ; }
public void function ( ) throws Exception { EncodedText encodedText ; encodedText = new EncodedText ( EncodedText . TEXT_ENCODING_UTF_8 , UNICODE_TEST_STRING ) ; try { encodedText . setTextEncoding ( EncodedText . TEXT_ENCODING_ISO_8859_1 , true ) ;
public void function ( ) { Document doc = Jsoup . parse ( " <div><p>Hello</p><p>There</p></div> " ) ; Element p1 = doc . select ( " p " ) . first ( ) ; p1 . after ( " <div>one</div><div>two</div> " ) ; assertEquals ( " <div><p>Hello</p><div>one</div><div>two</div><p>There</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; doc . select ( " p " ) . last ( ) . after ( " <p>Three</p><!-- four --> " ) ; assertEquals ( " <div><p>Hello</p><div>one</div><div>two</div><p>There</p><p>Three</p><!-- four --></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public synchronized boolean function ( Marker arg0 ) { if ( children = = null ) { return false ; } int size = children . size ( ) ; for ( int i = 0 ; i < size ; i + + ) { Marker m = ( Marker ) children . get ( i ) ; if ( m = = arg0 ) { children . remove ( i ) ; return true ; } } return false ; }
public RequestMatcher function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . REQUEST_ID ) ) { return ( RequestMatcher ) arg0 . apply ( this ) ; } return doApply ( arg0 ) ; }
public void function ( ) throws IOException { ByteBuffer buffer = this . bufferQueue . peek ( ) ; while ( buffer ! = null ) { int written = sockchannel . write ( buffer ) ;
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { if ( " get " . equalsIgnoreCase ( arg0 . getMethod ( ) ) ) { writeGetResponse ( arg0 , arg1 ) ; return ; } throw new UnsupportedOperationException ( " Unsupported REST request " ) ;
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( " 1 " ) . response ( json ( resource1 ) ) , get ( " 2 " ) . response ( json ( resource2 ) ) ) ; server . response ( " hello " ) ; running ( server , ( ) - > { Plain response1 = getResource ( " /targets/1 " ) ;
private static int function ( String arg0 ) { if ( " trace " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_TRACE ; } else if ( " debug " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_DEBUG ; } else if ( " info " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_INFO ; } else if ( " warn " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_WARN ; } else if ( " error " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_ERROR ; } else if ( " off " . equalsIgnoreCase ( arg0 ) ) { return LOG_LEVEL_OFF ; } return LOG_LEVEL_INFO ; }
public int function ( ) { int result = super . hashCode ( ) ; result = 31 * result + code ; result = 31 * result + ( reason ! = null ? reason . hashCode ( ) : 0 ) ; return result ; }
public void function ( ) throws Exception { server . get ( by ( uri ( " /target " ) ) ) . response ( " get_proxy " ) ; server . post ( and ( by ( uri ( " /target " ) ) , by ( " proxy " ) ) ) . response ( " post_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " put " ) ) , by ( " proxy " ) ) ) . response ( " put_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " delete " ) ) ) ) . response ( " delete_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " head " ) ) ) ) . response ( status ( 200 ) ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " options " ) ) ) ) . response ( " options_proxy " ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( method ( " trace " ) ) ) ) . response ( " trace_proxy " ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /proxy " ) ) , is ( " get_proxy " ) ) ;
public LatencyContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_NUMBER_INT ) { return LatencyContainer . latency ( arg0 . getLongValue ( ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; InternalLatencyContainer container = get ( arg0 . readValuesAs ( InternalLatencyContainer . class ) , 0 ) ; return LatencyContainer . latencyWithUnit ( container . duration , TimeUnit . valueOf ( container . unit . toUpperCase ( ) + 'S' ) ) ; } throw arg1 . mappingException ( TextContainer . class , currentToken ) ; }
public static ResponseHandler function ( long arg0 ) { return new LatencyResponseHandler ( arg0 ) ; }
private static HttpServer function ( final Resource arg0 , final int arg1 ) { return PARSER . parseServer ( ImmutableList . of ( toStream ( arg0 ) ) , arg1 ) ; }
protected final String function ( Object arg0 ) { if ( arg0 = = null ) { return ( String ) arg0 ;
@Test void function ( ) throws IOException { String url = EchoServlet . Url + " #fragment " ; Document doc = Jsoup . connect ( url ) . get ( ) ; assertEquals ( url , doc . location ( ) ) ; }
protected void function ( HttpRequest arg0 , ByteBuf arg1 ) { try { arg1 . writeBytes ( toByteArray ( targetFile ( arg0 ) ) ) ;
public void function ( String arg0 , Throwable arg1 ) { if ( isErrorEnabled ( ) ) { handle_0ArgsCall ( Level . ERROR , null , arg0 , arg1 ) ;
public Element function ( Node arg0 ) { Validate . notNull ( arg0 ) ; reparentChild ( arg0 ) ; childNodes . add ( arg0 ) ; arg0 . setSiblingIndex ( childNodes . size ( ) - 1 ) ; return this ; }
void function ( ) { boolean last = false ; Iterator < Element > it = stack . descendingIterator ( ) ; while ( it . hasNext ( ) ) { Element node = it . next ( ) ;
public boolean function ( ) { assert ( readystate ! = READYSTATE . OPEN | | ! flushandclosestate ) ; return readystate = = READYSTATE . OPEN ; }
public void function ( ) throws Exception { server . request ( exist ( xpath ( " /request/parameters/id/text() " ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { ID3v2UrlFrameData frameData = createTestUrlFrameData ( ) ; byte [ ] bytes = frameData . toBytes ( ) ; ID3v2UrlFrameData frameDataCopy = new ID3v2UrlFrameData ( false , bytes ) ; assertEquals ( 1 + TEST_DESCRIPTION . length ( ) + 1 + TEST_URL . length ( ) , bytes . length ) ; assertEquals ( frameData , frameDataCopy ) ; }
public final RequestRecorder function ( final String arg0 ) { RequestRecorder recorder = recorders . get ( arg0 ) ; if ( recorder ! = null ) { return recorder ; } return recorders . computeIfAbsent ( arg0 , s - > factory . newRecorder ( arg0 ) ) ; }
public static void function ( MocoHttpServer arg0 , Runnable arg1 ) { try { arg0 . start ( ) ;
@Override public boolean function ( Element arg0 , Element arg1 ) { NodeIterator < Element > it = ThreadElementIter . get ( ) ; it . restart ( arg1 ) ; while ( it . hasNext ( ) ) { Element el = it . next ( ) ; if ( el = = arg1 ) continue ; if ( evaluator . matches ( arg1 , el ) ) return true ; } return false ; }
protected RestSettingBuilder function ( ) { if ( hasId ( ) ) { return MocoRest . head ( id ( ) ) ; } return MocoRest . head ( ) ; }
public Element function ( ) { List < Element > siblings = parent ( ) . elementChildren ; return siblings . size ( ) > 1 ? siblings . get ( 0 ) : null ; }
public static ResponseHandler function ( final ContentResource arg0 , final Failover arg1 , final int . . . arg2 ) { return new ProxyResponseHandler ( toUrlFunction ( checkNotNull ( arg0 , " URL should not be null " ) ) , checkNotNull ( arg1 , " Failover should not be null " ) , arg2 ) ;
public final ResponseSetting function ( ) { ResponseSetting responseSetting = asBaseResourceSetting ( new ResponseSetting ( ) ) ; responseSetting . status = status ; responseSetting . proxy = proxy ; responseSetting . headers = headers ; responseSetting . cookies = cookies ; responseSetting . latency = latency ; responseSetting . version = version ; responseSetting . attachment = attachment ; responseSetting . seq = seq ; responseSetting . cycle = cycle ; return responseSetting ; }
public Builder function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
public List < ByteBuffer > function ( Handshakedata arg0 , Role arg1 , boolean arg2 ) { return createHandshake ( arg0 , arg2 ) ; }
private static Option function ( ) { Option opt = new Option ( " g " , true , " global settings " ) ; opt . setType ( String . class ) ; opt . setRequired ( false ) ; return opt ; }
@Test public void function ( ) { String html = " <a id= \" 123 \"  class= \" baz = 'bar' \"  style = 'border: 2px'qux zim foo = 12 mux=18 /> " ; Element el = Jsoup . parse ( html ) . getElementsByTag ( " a " ) . get ( 0 ) ; Attributes attr = el . getAttributes ( ) ; assertEquals ( 7 , attr . size ( ) ) ; assertEquals ( " 123 " , attr . get ( " id " ) ) ; assertEquals ( " baz = 'bar' " , attr . get ( " class " ) ) ; assertEquals ( " border: 2px " , attr . get ( " style " ) ) ; assertEquals ( " " , attr . get ( " qux " ) ) ; assertEquals ( " " , attr . get ( " zim " ) ) ; assertEquals ( " 12 " , attr . get ( " foo " ) ) ; assertEquals ( " 18 " , attr . get ( " mux " ) ) ; }
public void function ( ) throws IOException , UnsupportedTagException , InvalidDataException { loadAndCheckTestMp3WithTags ( MP3_WITH_DUMMY_START_AND_END_FRAMES , 41 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_DUMMY_START_AND_END_FRAMES , 256 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_DUMMY_START_AND_END_FRAMES , 1024 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_DUMMY_START_AND_END_FRAMES , 5000 ) ; }
public void function ( String arg0 ) { recordEvent ( Level . INFO , arg0 , null , null ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " ends_with.json " ) ; assertThat ( helper . getWithHeader ( remoteUrl ( " /header-match " ) , of ( " Content-type " , " application/json " ) ) , is ( " header_match " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.1.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 70 ) ;
public boolean function ( Element arg0 ) { for ( Selector s : selectors ) { if ( ! s . select ( arg0 ) ) return false ; } return true ; }
public void function ( ) throws IOException { int bufferSize = 5 * 1024 ; String url = FileServlet . urlTo ( " /htmltests/large.html " ) ; try ( BufferedInputStream stream = Jsoup . connect ( url ) . execute ( ) . bodyStream ( ) ) {
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.9 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 125 ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( ! logger . isWarnEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( null , fqcn , LocationAwareLogger . WARN_INT , arg0 , new Object [ ] { arg1 , arg2 } , null ) ;
private MocoRunnerWatcher function ( final File arg0 , final FileAlterationListener arg1 ) { return new ThreadSafeRunnerWatcher ( new CommonsIoWatcher ( monitorFile ( arg0 , arg1 ) ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { synchronized ( this ) { if ( selectorthread ! = null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + "  can only be started once. " ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return ; } } selectorthread . setName ( " WebsocketSelector " + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return ; } try { while ( ! selectorthread . isInterrupted ( ) ) {
@Test void function ( ) { String html = " <div>One</div><div>DESTROY</div><div>Two</div> " ; StreamParser parser = new StreamParser ( Parser . htmlParser ( ) ) . parse ( html , " " ) ; parser . parse ( html , " " ) ; Iterator < Element > it = parser . iterator ( ) ; while ( it . hasNext ( ) ) { Element el = it . next ( ) ; if ( el . ownText ( ) . equals ( " DESTROY " ) ) it . remove ( ) ; } Document doc = parser . document ( ) ; Elements divs = doc . select ( " div " ) ; assertEquals ( 2 , divs . size ( ) ) ; assertEquals ( " One Two " , divs . text ( ) ) ; }
public Element function ( int arg0 , Collection < ? extends Node > arg1 ) { Validate . notNull ( arg1 , " Children collection to be inserted must not be null. " ) ; int currentSize = childNodeSize ( ) ; if ( arg0 < 0 ) arg0 + = currentSize + 1 ; Validate . isTrue ( arg0 > = 0 & & arg0 < = currentSize , " Insert position out of bounds. " ) ; ArrayList < Node > nodes = new ArrayList < > ( arg1 ) ; Node [ ] nodeArray = nodes . toArray ( new Node [ 0 ] ) ; addChildren ( arg0 , nodeArray ) ; return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 3.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { server . request ( and ( by ( " foo " ) , by ( uri ( " /foo " ) ) ) ) . response ( " bar " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . get ( remoteUrl ( " /foo " ) ) ) ) ;
private static String function ( String arg0 , Document arg1 ) { return arg1 . select ( " th:contains( " + arg0 + " ) + td " ) . first ( ) . text ( ) ; }
private HttpEntity function ( ) { return new ByteArrayEntity ( content . get ( ) . readFor ( Optional . < Request > absent ( ) ) . getContent ( ) ) ; }
public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( " http://aamo.info/ " ) . execute ( ) ; res . parse ( ) ; assertEquals ( " ISO-8859-1 " , res . charset ( ) ) ; }
public boolean function ( Marker arg0 ) { return RECORD_ALL_EVENTS ; }
@Test public void function ( ) { String html = " <?xml encoding='UTF-8' ?><body>One</body> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <!--?xml encoding='UTF-8' ?--> <html> <head></head> <body> One </body> </html> " , StringUtil . normaliseWhitespace ( doc . outerHtml ( ) ) ) ; }
public boolean function ( int arg0 , Collection < ? extends Element > arg1 ) { return contents . addAll ( arg0 , arg1 ) ; }
static final public void function ( String arg0 ) { getTarget ( ) . println ( SLF4J_ERROR_PREFIX + arg0 ) ; }
private InputSupplier < InputStreamReader > function ( final Socket arg0 ) { return new InputSupplier < InputStreamReader > ( ) { @Override
public void function ( ) throws Exception { testHandshakeRejection ( 0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.5.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 150 ) ; }
public OutputSettings function ( boolean arg0 ) { this . arg0 = arg0 ; return this ; }
public static ResponseHandler function ( int arg0 ) { return new StatusCodeResponseHandler ( arg0 ) ; }
public static HttpResponse function ( FullHttpResponse arg0 ) { return DumpHttpResponse . newResponse ( arg0 ) ; }
public void function ( WebSocket arg0 , ClientHandshake arg1 ) { arg0 . send ( " Welcome to the server! " ) ; broadcast ( " new connection:  " + arg1 . getResourceDescriptor ( ) ) ; System . out . println ( arg0 . getRemoteSocketAddress ( ) . getAddress ( ) . getHostAddress ( ) + "  entered the room! " ) ;
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " none " , false ) ; doc . updateMetaCharsetElement ( true ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; final String xmlCharsetUTF8 = " <?xml version= \" 1.0 \"  encoding= \" " + charsetUtf8 + " \" > \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetUTF8 , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetUtf8 , selectedNode . attr ( " encoding " ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p name='1,2'>One</p><div>Two</div><ol><li>123</li><li>Text</li></ol> " ) ; Elements ps = doc . select ( " [name=1,2] " ) ; assertEquals ( 1 , ps . size ( ) ) ; Elements containers = doc . select ( " div, li:matches([0-9,]+) " ) ; assertEquals ( 2 , containers . size ( ) ) ; assertEquals ( " div " , containers . get ( 0 ) . tagName ( ) ) ; assertEquals ( " li " , containers . get ( 1 ) . tagName ( ) ) ; assertEquals ( " 123 " , containers . get ( 1 ) . text ( ) ) ; }
public void function ( ) throws IOException { helper . get ( remoteUrl ( " /dir/foo.bar " ) ) ; }
boolean function ( Element arg0 ) { return onStack ( formattingElements , arg0 ) ; }
public static void function ( ByteBuffer arg0 , ByteBuffer arg1 ) { if ( arg0 = = null | | arg1 = = null ) { throw new IllegalArgumentException ( ) ; } int fremain = arg0 . remaining ( ) ; int toremain = arg1 . remaining ( ) ; if ( fremain > toremain ) { arg0 . limit ( Math . min ( fremain , toremain ) ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { Character c = arg0 . consumeCharacterReference ( null , false ) ; if ( c = = null ) arg0 . emit ( '&' ) ; else arg0 . emit ( c ) ; arg0 . transition ( Data ) ; }
private void function ( String arg0 , String arg1 , Throwable arg2 ) { StringBuffer buf = new StringBuffer ( ) ; long millis = System . currentTimeMillis ( ) ; buf . append ( millis - startTime ) ; buf . append ( "  [ " ) ; buf . append ( Thread . currentThread ( ) . getName ( ) ) ; buf . append ( " ]  " ) ; buf . append ( arg0 ) ; buf . append ( "   " ) ; buf . append ( loggerName ) ; buf . append ( "  -  " ) ; buf . append ( arg1 ) ; buf . append ( LINE_SEPARATOR ) ; System . out . print ( buf . toString ( ) ) ; if ( arg2 ! = null ) { arg2 . printStackTrace ( System . out ) ; } System . out . flush ( ) ; }
public void function ( ) { SLF4JBridgeHandler . install ( ) ; String msg = " foo {18=bad} {0} " ; julLogger . log ( Level . INFO , msg , " ignored parameter due to IllegalArgumentException " ) ; assertEquals ( 1 , listAppender . list . size ( ) ) ; LoggingEvent le = ( LoggingEvent ) listAppender . list . get ( 0 ) ; assertEquals ( msg , le . getMessage ( ) ) ; }
public static ResponseHandler function ( final String arg0 ) { return new DynamicRecordHandler ( RecorderRegistry . registryOf ( arg0 ) , Moco . text ( arg0 ) ) ; }
public static ByteBuffer function ( InputStream arg0 , int arg1 ) throws IOException { Validate . isTrue ( arg1 > = 0 , " maxSize must be 0 (unlimited) or larger " ) ; final boolean capped = arg1 > 0 ; byte [ ] buffer = new byte [ capped & & arg1 < bufferSize ? arg1 : bufferSize ] ; ByteArrayOutputStream outStream = new ByteArrayOutputStream ( capped ? arg1 : bufferSize ) ; int read ; int remaining = arg1 ; while ( true ) { read = arg0 . read ( buffer ) ; if ( read = = - 1 ) break ; if ( capped ) { if ( read > remaining ) { outStream . write ( buffer , 0 , remaining ) ; break ; } remaining - = read ; } outStream . write ( buffer , 0 , read ) ; } return ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; }
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_T , BYTE_ESZETT , BYTE_G , BYTE_T , 0 , 0 , BYTE_G , BYTE_A , 0 , 0 , BYTE_G , BYTE_A } ; assertEquals ( 8 , BufferTools . indexOfTerminator ( buffer , 6 , 2 ) ) ; }
static URL function ( URL arg0 ) { try {
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false ) ; frameData . setEndTime ( 9 ) ; assertEquals ( 9 , frameData . getEndTime ( ) ) ; }
public void function ( ) throws Exception { final HttpServer server = jsonHttpsServer ( port ( ) , file ( " src/test/resources/foo.json " ) , DEFAULT_CERTIFICATE ) ; running ( server , ( ) - > assertThat ( helper . get ( httpsRoot ( ) ) , is ( " foo " ) ) ) ; }
protected boolean function ( ) { try { loadClass ( " java.util.logging.Logger " ) ;
public void function ( Framedata arg0 ) { conn . sendFrame ( arg0 ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null ) return false ; if ( getClass ( ) ! = arg0 . getClass ( ) ) return false ; ID3v2FrameSet other = ( ID3v2FrameSet ) arg0 ; if ( frames = = null ) { if ( other . frames ! = null ) return false ; } else if ( ! frames . equals ( other . frames ) ) return false ; if ( id = = null ) { if ( other . id ! = null ) return false ; } else if ( ! id . equals ( other . id ) ) return false ; return true ; }
public int function ( ByteBuffer arg0 ) throws IOException { if ( ! arg0 . hasRemaining ( ) ) return 0 ; if ( ! isHandShakeComplete ( ) ) { if ( isBlocking ( ) ) { while ( ! isHandShakeComplete ( ) ) { processHandshake ( ) ; } } else { processHandshake ( ) ; if ( ! isHandShakeComplete ( ) ) { return 0 ; } } } int purged = readRemaining ( arg0 ) ; if ( purged ! = 0 ) return purged ; assert ( inData . position ( ) = = 0 ) ; inData . clear ( ) ; if ( ! inCrypt . hasRemaining ( ) ) inCrypt . clear ( ) ; else inCrypt . compact ( ) ; if ( ( isBlocking ( ) & & inCrypt . position ( ) = = 0 ) | | engineStatus = = Status . BUFFER_UNDERFLOW ) if ( socketChannel . read ( inCrypt ) = = - 1 ) { return - 1 ; } inCrypt . flip ( ) ; unwrap ( ) ; return transfereTo ( inData , arg0 ) ;
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " test1 " ) ; logger . debug ( " Hello world. " ) ; }
public void function ( ) throws UnsupportedEncodingException { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " TAG- " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 0 ) ; byte [ ] expectedBuffer = { BYTE_T , BYTE_A , BYTE_G , BYTE_DASH , 0 , 0 , 0 , 0 , 0 , 0 } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
public boolean function ( HttpRequest arg0 ) { return expected . equals ( arg0 . getHeader ( header . getHeader ( ) ) ) ; }
protected ID3v2CommentFrameData function ( String arg0 ) { ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { Iterator < ID3v2Frame > iterator = frameSet . getFrames ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { ID3v2Frame frame = ( ID3v2Frame ) iterator . next ( ) ; ID3v2CommentFrameData frameData ; try { frameData = new ID3v2CommentFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; return frameData ; } catch ( InvalidDataException e ) { } } } return null ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.3.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
private String function ( ) { return tq . chompBalanced ( '(' , ')' ) ; }
protected final void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { Optional < URL > url = remoteUrl ( arg0 ) ; if ( ! url . isPresent ( ) ) { return ; } HttpResponse response = doProxy ( arg0 , url . get ( ) ) ; doWritHttpResponse ( response , arg1 ) ; }
public void function ( ProfilerRegistry arg0 ) { if ( arg0 = = null ) { return ; } this . arg0 = arg0 ; arg0 . put ( this ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo " ) ) ) . response ( seq ( text ( " bar " ) , text ( " blah " ) ) ) ; running ( server , new Runnable ( ) { @Override
public static Session function ( DumpHttpRequest arg0 , Response arg1 ) { Session session = new Session ( ) ; session . setRequest ( arg0 ) ; session . setResponse ( arg1 ) ; return session ; }
private void function ( ) { awareCheckBox = new JCheckBox ( ) ; awareCheckBox . setToolTipText ( " <html><p>Check this box of you understand that the migration tool<p>will <b>not</b> backup your Java source files.</html> " ) ;
protected void function ( Node arg0 , Token arg1 ) { currentElement ( ) . appendChild ( arg0 ) ; onNodeInserted ( arg0 , arg1 ) ; }
private Resource function ( final String arg0 , final TextContainer arg1 ) { if ( arg1 . isRawText ( ) ) { return invokeTarget ( arg0 , arg1 . getText ( ) , Resource . class ) ; } if ( arg1 . isForTemplate ( ) ) { if ( " version " . equalsIgnoreCase ( arg0 ) ) { return version ( arg1 . asTemplateResource ( ) ) ; } return arg1 . asTemplateResource ( arg0 ) ; } throw new IllegalArgumentException ( format ( " unknown text container:[%s] " , arg1 ) ) ; }
public Builder function ( ImmutableMap < String , TextContainer > arg0 ) { this . arg0 = arg0 ; return this ; }
public final MessageContent function ( ) { MessageContent messageContent = new MessageContent ( ) ; messageContent . charset = Optional . fromNullable ( charset ) ; messageContent . content = targetContent ( content ) ; return messageContent ; }
protected Optional < String > function ( HttpRequest arg0 ) { Optional < ImmutableMap < String , String > > forms = extractor . extract ( arg0 ) ; return forms . isPresent ( ) ? fromNullable ( forms . get ( ) . get ( key ) ) : Optional . < String > absent ( ) ; }
private void function ( ) throws IOException , InvalidHandshakeException , InterruptedException { String path ; String part1 = uri . getPath ( ) ; String part2 = uri . getQuery ( ) ; if ( part1 = = null | | part1 . length ( ) = = 0 ) path = " / " ; else path = part1 ; if ( part2 ! = null ) path + = " ? " + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( port ! = WebSocket . DEFAULT_PORT ? " : " + port : " " ) ; HandshakedataImpl1 handshake = new HandshakedataImpl1 ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( " Host " , host ) ; conn . startHandshake ( handshake ) ; }
public ResponseSetting function ( MocoEventTrigger arg0 ) { this . eventTriggers . add ( arg0 ) ; return this ; }
public T function ( final InputStream arg0 , final Optional < Integer > arg1 , final MocoConfig . . . arg2 ) { return createServer ( reader . read ( arg0 , SessionSetting . class ) , arg1 , arg2 ) ; }
public static ProxyConfig . Builder function ( final String arg0 ) { return ProxyConfig . builder ( checkNotNullOrEmpty ( arg0 , " Local base should not be null " ) ) ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " testNullParameter_BUG78 " ) ; String [ ] parameters = null ; String msg = " hello {} " ; logger . debug ( msg , ( Object [ ] ) parameters ) ; assertEquals ( 1 , listAppender . list . size ( ) ) ; LoggingEvent e = ( LoggingEvent ) listAppender . list . get ( 0 ) ; assertEquals ( msg , e . getMessage ( ) ) ; }
private ImmutableMap < String , RequestExtractor < ? > > toVariables ( Map < String , TextContainer > props ) { return copyOf ( Maps . transformEntries ( props , toVariable ( ) ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p class=' \\ &'>One</p> " ) ; Element one = doc . expectFirst ( " . \\ \\ \\ & " ) ; assertEquals ( " One " , one . text ( ) ) ; String q = one . cssSelector ( ) ; assertEquals ( " html > body > p. \\ \\ \\ & " , q ) ; assertEquals ( one , doc . expectFirst ( q ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " , PORT ) ; assertThat ( helper . get ( " http://localhost:8080/file " ) , is ( " foo.response " ) ) ; }
public void function ( ) { ID3v2ChapterTOCFrameData frameData = new ID3v2ChapterTOCFrameData ( false , true , true , " toc1 " , new String [ ] { " ch1 " , " ch2 " } ) ; assertEquals ( " ID3v2ChapterTOCFrameData [isRoot=true, isOrdered=true, id=toc1, children=[ch1, ch2], subframes=[]] " ,
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isErrorEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
private byte [ ] function ( ) { return localCache . read ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <input value='one' /><textarea>two</textarea> " ) ; Elements els = doc . select ( " form > * " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " one " , els . val ( ) ) ; assertEquals ( " two " , els . last ( ) . val ( ) ) ; els . val ( " three " ) ; assertEquals ( " three " , els . first ( ) . val ( ) ) ; assertEquals ( " three " , els . last ( ) . val ( ) ) ; assertEquals ( " <textarea>three</textarea> " , els . last ( ) . outerHtml ( ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( isErrorEnabled ( ) ) { handleArgArrayCall ( Level . ERROR , null , arg0 , arg1 ) ;
public static ResponseHandler function ( String arg0 , String arg1 ) { checkNotNull ( arg0 , " Null cookie key is not allowed " ) ; checkNotNull ( arg0 , " Null cookie value is not allowed " ) ; return header ( " Set-Cookie " , new Cookies ( ) . encodeCookie ( arg0 , arg1 ) ) ; }
public boolean function ( ) { return delegate ( ) . isErrorEnabled ( ) ; }
public T function ( URL arg0 ) { this . arg0 = arg0 ; return ( T ) this ; }
@Test public void function ( ) { String h = " <h1>Head</h1><td>One<td>Two</td> " ; String cleanHtml = Jsoup . clean ( h , Whitelist . relaxed ( ) ) ; assertEquals ( " <h1>Head</h1><table><tbody><tr><td>One</td><td>Two</td></tr></tbody></table> " , TextUtil . stripNewlines ( cleanHtml ) ) ; }
public boolean function ( ) { return ! isEmpty ( ) & & StringUtil . isWhitespace ( queue . charAt ( pos ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg1 , arg2 ) . getMessage ( ) ;
protected static ClassLoader function ( ) { throw new UnsupportedOperationException ( " Operation [directGetContextClassLoader] is not supported in jcl-over-slf4j. See also  " + UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J ) ;
public void function ( ByteBuffer arg0 ) { assert ( arg0 . hasRemaining ( ) ) ; log . trace ( " process({}): ({}) " , arg0 . remaining ( ) , ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) , arg0 . position ( ) , arg0 . remaining ( ) ) ) ) ; if ( readyState ! = ReadyState . NOT_YET_CONNECTED ) { if ( readyState = = ReadyState . OPEN ) {
public void function ( ) throws java . io . IOException { if ( ! closed ) { try {
int function ( ) { y = ( a * y + 1 ) % m ; unused = y > > > ( 48 - bits ) ; return ( int ) ( y ) ; }
public void function ( ) throws Exception { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , TEST_URL ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 0 , 'D' , 'E' , 'S' , 'C' , 'R' , 'I' , 'P' , 'T' , 'I' , 'O' , 'N' , 0 , 'h' , 't' , 't' , 'p' , ':' , '/' , '/' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' } ; assertArrayEquals ( expectedBytes , bytes ) ; ID3v2UrlFrameData frameDataCopy = new ID3v2UrlFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
FormElement function ( Token . StartTag arg0 , boolean arg1 , boolean arg2 ) { Tag tag = tagFor ( arg0 . name ( ) , settings ) ; FormElement el = new FormElement ( tag , null , settings . normalizeAttributes ( arg0 . attributes ) ) ; if ( arg2 ) { if ( ! arg1 ( " template " ) ) setFormElement ( el ) ; } else setFormElement ( el ) ; insertNode ( el , arg0 ) ; if ( arg1 ) stack . add ( el ) ; return el ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String value = arg1 . consumeAttributeQuoted ( true ) ; if ( value . length ( ) > 0 ) arg0 . tagPending . appendAttributeValue ( value ) ; else arg0 . tagPending . setEmptyAttributeValue ( ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\'' :
public boolean function ( Element arg0 , Element arg1 ) { return arg1 . hasAttr ( key ) & & arg1 . attr ( key ) . toLowerCase ( ) . endsWith ( value ) ; }
public ResponseHandler function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( resource . id ( ) ) ) { return new HeaderResponseHandler ( name , resource . apply ( arg0 ) ) ; } return this ; }
void function ( ) { dataBuffer = new StringBuilder ( ) ; }
public void function ( ) { ta . append ( " You have been disconnected from:  " + getURI ( ) + " \ n " ) ; ta . setCaretPosition ( ta . getDocument ( ) . getLength ( ) ) ; connect . setEnabled ( true ) ; uriField . setEditable ( true ) ; draft . setEditable ( true ) ; close . setEnabled ( false ) ; }
public static boolean function ( String arg0 , String . . . arg1 ) { for ( String hay : arg1 ) { if ( hay . equals ( arg0 ) ) return true ; } return false ; }
protected void function ( final HttpRequest arg0 , MutableHttpResponse arg1 ) { MessageContent content = responseContent ( arg0 ) ; arg1 . setContent ( content ) ; arg1 . addHeader ( HttpHeaders . CONTENT_LENGTH , content . getContent ( ) . length ) ; if ( ! detector . hasContentType ( arg1 ) ) { arg1 . addHeader ( HttpHeaders . CONTENT_TYPE , getContentType ( arg0 ) ) ;
protected ClassicHttpRequest function ( final String arg0 , final Request arg1 ) { return new HttpGet ( arg0 ) ; }
public void function ( ) throws Exception { assertThat ( helper . get ( remoteUrl ( " /dir/dir.response " ) ) , is ( " response from dir " ) ) ; }
public RequestMatcher function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . URI_ID ) ) { return context ( ( String ) arg0 . apply ( " " ) ) ; } return this ; }
public void function ( ) { System . setProperty ( Constants . LOGGER_FA_FACTORY , " org.slf4j.XLoggerFAFactory " ) ; Logger logger = LoggerFactory . getLogger ( " foo " ) ; if ( ! ( logger instanceof XLogger ) ) { fail ( " returned logger of type  " + logger . getClass ( ) . getName ( ) + "  is not of type SimpleLogger " ) ;
static void function ( Throwable arg0 ) { INITIALIZATION_STATE = FAILED_INITIALIZATION ; Util . report ( " Failed to instantiate SLF4J LoggerFactory " , arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 125 ) ; }
public void function ( ) throws Exception { httpServer = httpServer ( 12306 , context ( " /foo " ) ) ; anotherServer = httpServer ( context ( " /bar " ) ) ; final HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeHttpServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public static Document function ( String arg0 , Parser arg1 ) { return arg1 . parseInput ( arg0 , " " ) ; }
public Setting function ( final RequestMatcher arg0 ) { return requestByHttpMethod ( HttpMethod . POST , checkNotNull ( arg0 , " Matcher should not be null " ) ) ; }
public WebSocketServer function ( final String arg0 ) { checkArgument ( websocketServer = = null , " Only one websocket can be setup " ) ; this . websocketServer = new ActualWebSocketServer ( checkNotNullOrEmpty ( arg0 , " uri should not be null or empty " ) ) ; return websocketServer ; }
@Test void function ( ) { String html = " <h1>One</h1><h2>Two</h2><h10>Ten</h10> " ; Document doc = Jsoup . parse ( html , TrackingParser ) ; Elements els = doc . body ( ) . children ( ) ; for ( Element el : els ) { assertTrue ( el . sourceRange ( ) . isTracked ( ) ) ; assertTrue ( el . endSourceRange ( ) . isTracked ( ) ) ; } Element h2 = doc . expectFirst ( " h2 " ) ; assertEquals ( " 1,13:12-1,17:16 " , h2 . sourceRange ( ) . toString ( ) ) ; assertEquals ( " 1,20:19-1,25:24 " , h2 . endSourceRange ( ) . toString ( ) ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <p><p id=1>Hello  there now<em>!</em> " ) ; Elements a = doc . select ( " p:contains(Hello   there  now!) " ) ; Elements b = doc . select ( " :containsOwn(hello   there  now) " ) ; Elements c = doc . select ( " p:contains(Hello there now) " ) ; Elements d = doc . select ( " :containsOwn(hello There now) " ) ; Elements e = doc . select ( " p:contains(HelloThereNow) " ) ; assertEquals ( 1 , a . size ( ) ) ; assertEquals ( a , b ) ; assertEquals ( a , c ) ; assertEquals ( a , d ) ; assertEquals ( 0 , e . size ( ) ) ; assertNotEquals ( a , e ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <table> <td>One <td><table><td>Two</table> <table><td>Three " ) ; assertEquals ( " <table> <tr><td>One </td><td><table><tr><td>Two</td></tr></table> <table><tr><td>Three</td></tr></table></td></tr></table> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ;
public void function ( String arg0 ) { if ( logger . isLoggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , arg0 , null , null ) ;
public void function ( ) { assertEquals ( " parentValue " , mdc . get ( " sharedKey " ) ) ; mdc . put ( " sharedKey " , " childValue " ) ; assertEquals ( " childValue " , mdc . get ( " sharedKey " ) ) ; }
public static MDCCloseable function ( String arg0 , String arg1 ) throws IllegalArgumentException { put ( arg0 , arg1 ) ; return new MDCCloseable ( arg0 ) ; }
private void function ( ) { if ( bodyStream ! = null ) { try { bodyStream . close ( ) ; } catch ( IOException e ) { } finally { bodyStream = null ; } } if ( conn ! = null ) { conn . disconnect ( ) ;
public static void function ( String arg0 ) { int next = getDepth ( ) ; MDC . put ( PREFIX + next , arg0 ) ; }
private boolean function ( Element arg0 , Attribute arg1 , Set < Protocol > arg2 ) { String value = arg0 . absUrl ( arg1 . getKey ( ) ) ; if ( value . length ( ) = = 0 ) value = arg1 . getValue ( ) ; if ( ! preserveRelativeLinks ) arg1 . setValue ( value ) ; for ( Protocol protocol : arg2 ) { String prot = protocol . toString ( ) ; if ( prot . equals ( " # " ) ) { if ( isValidAnchor ( value ) ) { return true ; } else { continue ; } } prot + = " : " ; if ( value . toLowerCase ( ) . startsWith ( prot ) ) { return true ; } } return false ; }
@Test public void function ( ) { Element div = new Element ( Tag . valueOf ( " div " ) , " " ) ; div . attr ( " true " , true ) ; div . attr ( " false " , " value " ) ; div . attr ( " false " , false ) ; assertTrue ( div . hasAttr ( " true " ) ) ; assertEquals ( " " , div . attr ( " true " ) ) ; List < Attribute > attributes = div . attributes ( ) . asList ( ) ; assertEquals ( " There should be one attribute " , 1 , attributes . size ( ) ) ; assertFalse ( div . hasAttr ( " false " ) ) ; assertEquals ( " <div true></div> " , div . outerHtml ( ) ) ; }
public void function ( ) { for ( Level level : Level . values ( ) ) { throwableCheck ( level ) ;
public boolean function ( ) { while ( attrIter . hasNext ( ) ) { attr = attrIter . next ( ) ; if ( attr . isDataAttribute ( ) ) return true ; } return false ; }
Element function ( String arg0 ) { Element el = new Element ( Tag . valueOf ( arg0 , settings ) , baseUri ) ; insert ( el ) ; return el ; }
static String function ( ) { final StringBuilder mime = new StringBuilder ( boundaryLength ) ; final Random rand = new Random ( ) ; for ( int i = 0 ; i < boundaryLength - 2 ; i + + ) { mime . append ( mimeBoundaryChars [ rand . nextInt ( mimeBoundaryChars . length ) ] ) ; } return mime . toString ( ) ; }
private static < T > Function < InputStream , Stream < T > > function ( final CollectionType arg0 ) { return input - > { try ( InputStream actual = input ) {
public void function ( ) throws IOException { assertThat ( helper . postFile ( root ( ) , " foobar.xml " ) , is ( " bar " ) ) ; }
public void function ( ) throws Exception { ID3v2PopmFrameData iD3v2PopmFrameData1 = new ID3v2PopmFrameData ( false , 0 ) ; ID3v2PopmFrameData iD3v2PopmFrameData2 = new ID3v2PopmFrameData ( false , 0 ) ; assertEquals ( iD3v2PopmFrameData1 , iD3v2PopmFrameData2 ) ; }
public RequestMatcher function ( MocoConfig arg0 ) { if ( arg0 . isFor ( " uri " ) ) { return context ( arg0 . apply ( " " ) ) ; } return this ; }
public static SocketServer function ( int arg0 ) { return ActualSocketServer . createQuietServer ( arg0 ) ; }
public void function ( ) throws Exception { Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; Plain resource2 = new Plain ( ) ; resource2 . code = 2 ; resource2 . message = " world " ; server . resource ( " targets " , get ( ) . response ( json ( ImmutableList . of ( resource1 , resource2 ) ) ) ) ; running ( server , ( ) - > { String uri = " /targets " ;
public DumpHttpResponse function ( ) { return new DumpHttpResponse ( version , status , headers , content ) ; }
public void function ( ) throws Exception { helper . get ( remoteUrl ( " /bar/anything " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " , PORT ) ; assertThat ( helper . get ( " http://localhost:8080/mount-exclude/foo.bar " ) , is ( " foo.bar " ) ) ; }
final void function ( String arg0 ) { arg0 = arg0 . replace ( TokeniserState . nullChar , Tokeniser . replacementChar ) ; ensureAttrName ( ) ; if ( attrName . length ( ) = = 0 ) { attrNameS = arg0 ;
public void function ( ) { frame . progressBar . setVisible ( false ) ; frame . otherLabel . setText ( " <html><font color='BLUE'>Scanned  " + addFileCount + "  java files,  " + inplaceConversionCount + "  files were modified.</font></html> " ) ; frame . migrateButton . setActionCommand ( MigratorFrame . EXIT_COMMAND ) ; frame . migrateButton . setText ( " Exit " ) ; frame . migrateButton . setToolTipText ( " Click on this button to exit this application. " ) ; frame . migrateButton . setEnabled ( true ) ;
void function ( Token . Character arg0 ) { final Node node ; Element el = currentElement ( ) ; final String tagName = el . normalName ( ) ; final String data = arg0 . getData ( ) ; if ( arg0 . isCData ( ) ) node = new CDataNode ( data ) ; else if ( isContentForTagData ( tagName ) ) node = new DataNode ( data ) ; else node = new TextNode ( data ) ; el . appendChild ( node ) ; onNodeInserted ( node , arg0 ) ; }
public boolean function ( ) { return logger . isEnabledFor ( Level . ERROR ) ; }
public static String function ( byte [ ] arg0 ) throws CharacterCodingException { return stringUtf8 ( arg0 , 0 , arg0 . length ) ; }
String function ( ) { int start = pos ; while ( pos < length ) { char c = input [ pos ] ; if ( ( c > = 'A' & & c < = 'Z' ) | | ( c > = 'a' & & c < = 'z' ) ) pos + + ; else break ; } while ( ! isEmpty ( ) ) { char c = input [ pos ] ; if ( c > = '0' & & c < = '9' ) pos + + ; else break ; } return new String ( input , start , pos - start ) ; }
public final ResponseHandler function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . URI_ID ) ) { return new MountHandler ( this . dir , this . target . apply ( arg0 ) ) ; } if ( arg0 . isFor ( MocoConfig . FILE_ID ) ) { return new MountHandler ( new File ( ( String ) arg0 . apply ( this . dir . getName ( ) ) ) , this . target ) ; } return this ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { formatAndLog ( LOG_LEVEL_INFO , arg0 , arg1 , arg2 ) ; }
public void function ( String arg0 , Object . . . arg1 ) { recordEventArgArray ( Level . TRACE , null , arg0 , arg1 ) ; }
private void function ( SeekableByteChannel arg0 ) throws IOException , InvalidDataException { ByteBuffer byteBuffer = ByteBuffer . allocate ( bufferLength ) ; int fileOffset = preScanFile ( arg0 ) ; arg0 . position ( fileOffset ) ; boolean lastBlock = false ; int lastOffset = fileOffset ; while ( ! lastBlock ) { byteBuffer . clear ( ) ;
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isCharacter ( ) ) { arg1 . insert ( arg0 . asCharacter ( ) ) ; } else if ( arg0 . isEOF ( ) ) { arg1 . error ( this ) ; arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; } return true ; }
public String function ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Node childNode : childNodes ) { if ( childNode instanceof TextNode ) { TextNode textNode = ( TextNode ) childNode ; sb . append ( textNode . getWholeText ( ) ) ; } else if ( childNode instanceof Element ) { Element element = ( Element ) childNode ; String elementText = element . text ( ) ; if ( element . isBlock ( ) & & sb . length ( ) > 0 & & elementText . length ( ) > 0 ) sb . append ( "   " ) ; sb . append ( elementText ) ; } } return sb . toString ( ) ; }
private static Options function ( ) { Options options = new Options ( ) ; options . addOption ( ShutdownPortOption . shutdownPortOption ( ) ) ; return options ; }
public void function ( ) { if ( draft = = null ) { closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ;
public Watcher function ( final Function < File , Void > arg0 , final File . . . arg1 ) { if ( arg1 . length = = 0 ) { throw new IllegalArgumentException ( " No file is specified " ) ; } return new CompositeWatcher ( from ( arg1 ) . transform ( new Function < File , Watcher > ( ) { @Override
public void function ( ) throws Exception { String url = WEBSITE_WITH_INVALID_CERTIFICATE ; assertThrows ( IOException . class , ( ) - > Jsoup . connect ( url ) . execute ( ) ) ; }
private void function ( Logger arg0 ) { arg0 . setUseParentHandlers ( false ) ; Handler [ ] handlers = arg0 . getHandlers ( ) ; for ( int i = 0 ; i < handlers . length ; i + + ) { arg0 . removeHandler ( handlers [ i ] ) ;
public static ContentResource function ( final Resource arg0 , Charset arg1 ) { return classpathFileResource ( checkNotNull ( arg0 , " Filename should not be null " ) , of ( checkNotNull ( arg1 , " Charset should not be null " ) ) ) ; }
public void function ( ) { when ( request . getVersion ( ) ) . thenReturn ( HttpVersion . HTTP_1_0 . toString ( ) ) ; assertThat ( extractor . extract ( request ) . get ( ) , is ( HttpVersion . HTTP_1_0 . toString ( ) ) ) ;
public Connection function ( boolean arg0 ) { this . arg0 = arg0 ; return this ; }
public String function ( ) { return String . format ( " :gt(%d) " , index ) ; }
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ServerRejectHandshakeExample s = new ServerRejectHandshakeExample ( port ) ; s . start ( ) ; System . out . println ( " Server started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String name = arg1 . consumeToAnySorted ( attributeNameCharsSorted ) ; arg0 . tagPending . appendAttributeName ( name ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\t' :
public boolean function ( final Request arg0 ) { return this . ping . match ( arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.23.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
protected boolean function ( WebSocket arg0 ) { if ( ! isclosed . get ( ) ) { synchronized ( connections ) {
protected final HttpHeader [ ] function ( final MocoConfig arg0 ) { HttpHeader [ ] appliedHeaders = new HttpHeader [ this . headers . length ] ; boolean applied = false ; for ( int i = 0 ; i < headers . length ; i + + ) { HttpHeader appliedHeader = headers [ i ] . apply ( arg0 ) ; if ( ! headers [ i ] . equals ( appliedHeader ) ) { applied = true ; } appliedHeaders [ i ] = appliedHeader ; } if ( applied ) { return appliedHeaders ; } return this . headers ; }
public Watcher function ( final File arg0 ) { return new Java7Watcher ( listener , arg0 ) ; }
public Elements function ( ) { for ( Element element : this ) { element . unwrap ( ) ; } return this ; }
public void function ( Marker arg0 , String arg1 , Object [ ] arg2 ) { logger . warn ( arg0 , arg1 , arg2 ) ; }
public ResponseHandler function ( final SimpleRestSetting arg0 ) { return arg0 . getHandler ( ) ; }
public void function ( FullHttpRequest arg0 , FullHttpResponse arg1 ) { CloseableHttpClient httpclient = HttpClients . createDefault ( ) ; try { setupResponse ( arg0 , arg1 , httpclient . execute ( prepareRemoteRequest ( arg0 ) ) ) ;
public static Watcher function ( final Watcher arg0 ) { return new ThreadSafeRunnerWatcher ( arg0 ) ; }
Element function ( Token . StartTag arg0 ) { Tag tag = Tag . valueOf ( arg0 . name ( ) , settings ) ; Element el = new Element ( tag , null , arg0 . attributes ) ; insertNode ( el ) ; if ( arg0 . isSelfClosing ( ) ) { if ( tag . isKnownTag ( ) ) { if ( ! tag . isEmpty ( ) ) tokeniser . error ( " Tag cannot be self closing; not a void tag " ) ; } else tag . setSelfClosing ( ) ; } return el ; }
private void function ( ByteBuffer arg0 ) throws InterruptedException { if ( DEBUG ) System . out . println ( " write( " + arg0 . limit ( ) + " ): { " + ( arg0 . limit ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) ) ) + " } " ) ; arg0 . rewind ( ) ; bufferQueueTotalAmount . addAndGet ( arg0 . limit ( ) ) ; if ( ! bufferQueue . offer ( arg0 ) ) { try { flush ( ) ; } catch ( IOException e ) { wsl . onWebsocketError ( this , e ) ; closeConnection ( CloseFrame . ABNROMAL_CLOSE , true ) ; return ; } bufferQueue . put ( arg0 ) ; } wsl . onWriteDemand ( this ) ; }
public void function ( WebSocket arg0 ) { counter + + ; System . out . println ( " Opened connection number " + counter ) ; }
static boolean function ( Level arg0 ) { return ( arg0 . levelInt > = INTERNAL_VERBOSITY . levelInt ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <html><body><span class= \" foo \" >bar</span> " ) ; assertEquals ( " <html><head></head><body><span class= \" foo \" >bar</span></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ;
public void function ( ) throws IOException , ProtocolException { runWithConfiguration ( " cors.json " ) ; ClassicHttpResponse response = helper . getResponseWithHeader ( remoteUrl ( " /cors-alias " ) , of ( " Origin " , " https://www.github.com/ " ) ) ; assertThat ( response . getHeader ( " Access-Control-Allow-Origin " ) . getValue ( ) , is ( " * " ) ) ; assertThat ( response . getHeader ( " Access-Control-Allow-Methods " ) . getValue ( ) , is ( " GET,POST,PUT,DELETE,OPTIONS " ) ) ; assertThat ( response . getHeader ( " Access-Control-Allow-Headers " ) . getValue ( ) , is ( " Content-Type, Authorization, Accept, X-Requested-With " ) ) ; assertThat ( response . getHeader ( " Access-Control-Max-Age " ) . getValue ( ) , is ( " 1728000 " ) ) ; assertThat ( response . getHeader ( " Access-Control-Expose-Headers " ) . getValue ( ) , is ( " X-My-Custom-Header, X-Another-Custom-Header " ) ) ; }
public static ResponseHandler function ( final String arg0 , final Resource arg1 , final CookieAttribute . . . arg2 ) { return with ( header ( SET_COOKIE , cookieResource ( checkNotNullOrEmpty ( arg0 , " Cookie key should not be null " ) ,
public void function ( ) throws CertificateException , UnrecoverableKeyException , NoSuchAlgorithmException , KeyManagementException , KeyStoreException , IOException , URISyntaxException , InterruptedException { SSLWebSocketClient client = testIssueWithLocalServer ( " 127.0.0.1 " , SocketUtil . getAvailablePort ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , " " ) ; assertTrue ( client . onOpen , " client is open " ) ; assertFalse ( client . onSSLError , " client has not caught a SSLHandshakeException " ) ; }
private void function ( ) throws IOException { engine . closeOutbound ( ) ; try { doHandshake ( ) ; } catch ( IOException e ) { } socketChannel . close ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " starts_with.json " ) ; assertThat ( helper . getWithHeader ( remoteUrl ( " /header-match " ) , of ( " Content-type " , " application/json " ) ) , is ( " header_match " ) ) ; assertThat ( helper . getWithHeader ( remoteUrl ( " /header-match " ) , of ( " Content-type " , " application/xml " ) ) , is ( " header_match " ) ) ; }
public void function ( ) throws CertificateException , UnrecoverableKeyException , NoSuchAlgorithmException , KeyManagementException , KeyStoreException , IOException , URISyntaxException , InterruptedException { SSLWebSocketClient client = testIssueWithLocalServer ( " 127.0.0.1 " , SocketUtil . getAvailablePort ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , SSLContextUtil . getLocalhostOnlyContext ( ) , " HTTPS " ) ; assertFalse ( client . onOpen , " client is not open " ) ; assertTrue ( client . onSSLError , " client has caught a SSLHandshakeException " ) ; }
public boolean function ( String arg0 ) { Validate . notEmpty ( arg0 , " Header name must not be empty " ) ; return getHeadersCaseInsensitive ( arg0 ) . size ( ) ! = 0 ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " foo " ) ) ; Idles . idle ( 2000 ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " success " ) ) ; }
public ByteChannel function ( SelectionKey arg0 ) throws IOException { SSLEngine e = sslcontext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; return new SSLSocketChannel2 ( arg0 , e ) ; }
private static boolean function ( String arg0 ) { for ( int i = 0 ; i < arg0 . length ( ) ; i + + ) { char c = arg0 . charAt ( i ) ; if ( ! StringUtil . isWhitespace ( c ) ) return false ; } return true ; }
private Resource function ( final String arg0 , final TextContainer arg1 ) { if ( arg1 . isFileContainer ( ) ) { return fileResource ( arg0 , FileContainer . class . cast ( arg1 ) ) ; } return textResource ( arg0 , arg1 ) ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://infohound.net/tools/302.pl " ) . followRedirects ( false ) ; Connection . Response res = con . execute ( ) ; assert ( res . statusCode ( ) = = 302 ) ; }
public static Document function ( arg0 . arg1 . arg2 . Document arg3 ) { return ( new W3CDom ( ) . fromJsoup ( arg3 ) ) ; }
public void function ( String arg0 , Object arg1 ) { if ( logger . isEnabledFor ( Level . WARN ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 ) ;
@Test void function ( ) { String html = " <div><math><mi><p>One</p><svg><text>Blah</text></svg></mi><ms></ms></div> " ; Document doc = Jsoup . parse ( html ) ; assertHtmlNamespace ( doc . expectFirst ( " div " ) ) ; assertMathNamespace ( doc . expectFirst ( " math " ) ) ; assertMathNamespace ( doc . expectFirst ( " mi " ) ) ; assertHtmlNamespace ( doc . expectFirst ( " p " ) ) ; assertSvgNamespace ( doc . expectFirst ( " svg " ) ) ; assertSvgNamespace ( doc . expectFirst ( " text " ) ) ; assertMathNamespace ( doc . expectFirst ( " ms " ) ) ; String serialized = doc . expectFirst ( " div " ) . html ( ) ; assertEquals ( " <math> \ n " + "  <mi> \ n " +
@Test public void function ( ) { Evaluator eval = QueryParser . parse ( " p ~ p " ) ; CombiningEvaluator . And andEval = ( CombiningEvaluator . And ) eval ; StructuralEvaluator . PreviousSibling prevEval = ( StructuralEvaluator . PreviousSibling ) andEval . evaluators . get ( 0 ) ; IdentityHashMap < Element , IdentityHashMap < Element , Boolean > > map = prevEval . threadMemo . get ( ) ; assertEquals ( 0 , map . size ( ) ) ; Document doc1 = Jsoup . parse ( " <p>One<p>Two<p>Three " ) ; Document doc2 = Jsoup . parse ( " <p>One2<p>Two2<p>Three2 " ) ; Elements s1 = doc1 . select ( eval ) ; assertEquals ( 2 , s1 . size ( ) ) ; assertEquals ( " Two " , s1 . first ( ) . text ( ) ) ; Elements s2 = doc2 . select ( eval ) ; assertEquals ( 2 , s2 . size ( ) ) ; assertEquals ( " Two2 " , s2 . first ( ) . text ( ) ) ; assertEquals ( 1 , map . size ( ) ) ; }
public void function ( String arg0 , Object [ ] arg1 ) { if ( logger . isLoggable ( Level . FINE ) ) { String msgStr = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public static HttpsServer function ( final Resource arg0 , final HttpsCertificate arg1 ) { checkNotNull ( arg1 , " Certificate should not be null " ) ; ActualHttpServer httpsServer = ( ActualHttpServer ) Moco . httpsServer ( arg1 ) ; return httpsServer . mergeServer ( ( ActualHttpServer ) parseHttpServer ( checkNotNull ( arg0 , " resource should not be null " ) , empty ( ) ) ) ;
private void function ( WebSocket arg0 , IOException arg1 ) { onWebsocketError ( arg0 , arg1 ) ; if ( arg0 ! = null ) { arg0 . close ( CloseFrame . ABNROMAL_CLOSE ) ;
public void function ( ) throws Exception { byte [ ] bytes = BufferTools . stringToByteBuffer ( " xxxxx " + T_FRAME , 0 , 5 + T_FRAME . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( bytes , 9 ) ; ID3v2Frame frame = new ID3v2Frame ( bytes , 5 ) ; assertEquals ( 42 , frame . getLength ( ) ) ; assertEquals ( " TPE1 " , frame . getId ( ) ) ; String s = " 0ABCDEFGHIJKLMNOPQRSTUVWXYZABCDE " ; byte [ ] expectedBytes = BufferTools . stringToByteBuffer ( s , 0 , s . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( expectedBytes , 0 ) ; assertTrue ( Arrays . equals ( expectedBytes , frame . getData ( ) ) ) ; }
public boolean function ( final String arg0 ) { return RESPONSE_ID . equals ( arg0 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.3.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object arg3 , Object arg4 ) { if ( arg4 instanceof Throwable ) { recordEvent ( arg0 , arg1 , arg2 , new Object [ ] { arg3 } , ( Throwable ) arg4 ) ;
public void function ( WebSocket arg0 , int arg1 , String arg2 ) { onCloseInitiated ( arg0 , arg1 , arg2 ) ; }
public void function ( ) throws IOException { String xmlUrl = " http://direct.infohound.net/tools/jsoup-xml-test.xml " ; Document xmlDoc = Jsoup . connect ( xmlUrl ) . parser ( Parser . xmlParser ( ) ) . get ( ) ; Document htmlDoc = Jsoup . connect ( xmlUrl ) . get ( ) ; assertEquals ( " <doc><val>One<val>Two</val>Three</val></doc> " , TextUtil . stripNewlines ( xmlDoc . html ( ) ) ) ; assertNotSame ( htmlDoc , xmlDoc ) ; assertEquals ( 1 , htmlDoc . select ( " head " ) . size ( ) ) ; assertEquals ( 0 , xmlDoc . select ( " head " ) . size ( ) ) ; }
public void function ( ) { ID3v1 id3v1Tag = new ID3v1TagForTesting ( ) ; ID3Wrapper wrapper = new ID3Wrapper ( id3v1Tag , null ) ; wrapper . setYear ( " a year " ) ; assertEquals ( " a year " , id3v1Tag . getYear ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; }
public Object function ( Object arg0 , Method arg1 , Object [ ] arg2 ) throws Throwable { invokedMethodSignatures . add ( getMethodSignature ( arg1 ) ) ; if ( arg1 . getName ( ) . startsWith ( " is " ) ) { return true ; } return null ; }
public ListIterator < Element > function ( int arg0 ) { return contents . listIterator ( arg0 ) ; }
public void function ( final String arg0 ) { this . connected ( arg0 ( checkNotNull ( arg0 , " Connected text should not be null " ) ) ) ; }
public String function ( final String arg0 ) { String relative = nullToEmpty ( arg0 . replaceFirst ( this . localBase , " " ) ) ; return join ( remoteBase , relative ) ; }
public void function ( ) throws Exception { server . request ( eq ( jsonPath ( " $.book[*].price " ) , " 1 " ) ) . response ( " jsonpath match success " ) ; running ( server , new Runnable ( ) { @Override
public void function ( Exception arg0 ) { } } ; String actualURI = client . getURI ( ) . getScheme ( ) + " :// " + client . getURI ( ) . getHost ( ) ; assertEquals ( " ws://localhost " , actualURI ) ; } }
private void function ( Document arg0 ) { assertEquals ( 2 , arg0 . select ( " table tr " ) . size ( ) ) ; Elements doc3Els = keyEls ( " One " , arg0 ) ; assertEquals ( 2 , doc3Els . size ( ) ) ; assertEquals ( " CookieServlet " , doc3Els . get ( 0 ) . text ( ) ) ; assertEquals ( " Root " , doc3Els . get ( 1 ) . text ( ) ) ; }
public void function ( ) throws Exception { server . post ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , ( ) - > helper . get ( remoteUrl ( " /foo " ) ) ) ; }
public void function ( String arg0 , Object [ ] arg1 ) { if ( log . isWarnEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( String arg0 ) throws IOException { for ( WebSocket c : this . connections ) { c . send ( arg0 ) ;
public void function ( ServerHandshake arg0 ) { this . onOpen = true ; }
public Optional < String > function ( HttpRequest arg0 ) { Optional < ImmutableMap < String , String > > cookies = extractor . extract ( arg0 ) ; return cookies . isPresent ( ) ? fromNullable ( cookies . get ( ) . get ( this . key ) ) : Optional . < String > absent ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div>Hello there</div> " ) ; Element div = doc . select ( " div " ) . first ( ) ; TextNode tn = ( TextNode ) div . childNode ( 0 ) ; List < Node > nodes = tn . childNodes ( ) ; assertEquals ( 0 , nodes . size ( ) ) ; }
public final void function ( final Cookie arg0 ) { arg0 . setMaxAge ( unit . toSeconds ( maxAge ) ) ; }
private boolean function ( ) { HandshakeStatus status = engineResult . getHandshakeStatus ( ) ; return status = = SSLEngineResult . HandshakeStatus . FINISHED | | status = = SSLEngineResult . HandshakeStatus . NOT_HANDSHAKING ; }
public void function ( ) { SoftPool < char [ ] > softLocalPool = new SoftPool < > ( ( ) - > new char [ BufSize ] ) ; char [ ] buffer = softLocalPool . borrow ( ) ; assertNotNull ( buffer , " Borrowed null from an empty pool " ) ; assertEquals ( BufSize , buffer . length ) ; }
public void function ( ) { assertEquals ( 0 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { } ) ) ; assertEquals ( 0 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { BYTE_FF , 1 , BYTE_FB } ) ) ; assertEquals ( 1 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { BYTE_FF , 0 , BYTE_FB } ) ) ; assertEquals ( 1 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { 0 , BYTE_FF , 0 , BYTE_FB , 0 } ) ) ; assertEquals ( 1 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { 0 , BYTE_FF , 0 } ) ) ; assertEquals ( 2 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { BYTE_FF , 0 , BYTE_FB , 0 , BYTE_FF , 0 , BYTE_FB } ) ) ; assertEquals ( 3 , BufferTools . sizeSynchronisationWouldSubtract ( new byte [ ] { BYTE_FF , 0 , BYTE_FF , 0 , BYTE_FF , 0 } ) ) ; }
public static Function < RestPatchSetting , RestSetting > function ( ) { return new Function < RestPatchSetting , RestSetting > ( ) { @Override
public void function ( ) throws IOException { LoggerFinder finder = System . LoggerFinder . getLoggerFinder ( ) ; assertEquals ( EXPECTED_FINDER_CLASS , finder . getClass ( ) . getName ( ) ) ; Logger systemLogger = finder . getLogger ( " throwTest " , null ) ; systemLogger . log ( Level . INFO , " we have a problem " , new Exception ( ) ) ; List < String > results = SPS . stringList ; assertEquals ( " INFO throwTest - we have a problem " , results . get ( 0 ) ) ; assertEquals ( Exception . class . getName ( ) , results . get ( 1 ) ) ; assertTrue ( results . get ( 2 ) . contains ( " at  " ) ) ; assertTrue ( results . get ( 2 ) . contains ( this . getClass ( ) . getName ( ) ) ) ; }
public static MocoJunitRunner function ( final HttpServer arg0 ) { return new MocoJunitRunner ( Runner . runner ( arg0 ) ) ; }
public void function ( ) { InputStream is = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " foo.request " ) ; server . request ( by ( stream ( is ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public void function ( final Server arg0 ) { runner = createRunner ( arg0 ) ; runner . start ( ) ; logger . info ( " Server is started at {} " , arg0 . port ( ) ) ; }
public MessageContent function ( final Optional < ? extends Request > arg0 ) { return content ( ) . withContent ( text ) . build ( ) ; }
public void function ( ) { try { assertThat ( postFile ( " http://localhost:8080 " , " foo.xml " ) , is ( " foo " ) ) ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( by ( uri ( " /path " ) ) ) ) ; final String jsonContent = " { \" foo \" : \" bar \" } " ; server . request ( by ( json ( jsonContent ) ) ) . response ( " foo " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . postContent ( root ( ) , jsonContent ) ) ) ; }
public String function ( ) { int start = pos ; while ( ! isEmpty ( ) & & ( matchesWord ( ) | | matchesAny ( " : " , " _ " , " - " ) ) ) pos + + ; return queue . substring ( start , pos ) ; }
public @Nullable Element function ( String arg0 ) throws IOException { return selectFirst ( QueryParser . parse ( arg0 ) ) ; }
public void function ( ) throws InvalidDataException { byte [ ] frameData = { BYTE_FF , BYTE_F3 , BYTE_A2 , BYTE_40 } ; MpegFrameForTesting mpegFrame = new MpegFrameForTesting ( frameData ) ; assertEquals ( MpegFrame . MPEG_VERSION_2_0 , mpegFrame . getVersion ( ) ) ; assertEquals ( MpegFrame . MPEG_LAYER_3 , mpegFrame . getLayer ( ) ) ; assertEquals ( 96 , mpegFrame . getBitrate ( ) ) ; assertEquals ( 22050 , mpegFrame . getSampleRate ( ) ) ; assertEquals ( MpegFrame . CHANNEL_MODE_JOINT_STEREO , mpegFrame . getChannelMode ( ) ) ; assertEquals ( " None " , mpegFrame . getModeExtension ( ) ) ; assertEquals ( " None " , mpegFrame . getEmphasis ( ) ) ; assertEquals ( true , mpegFrame . isProtection ( ) ) ; assertEquals ( true , mpegFrame . hasPadding ( ) ) ; assertEquals ( false , mpegFrame . isPrivate ( ) ) ; assertEquals ( false , mpegFrame . isCopyright ( ) ) ; assertEquals ( false , mpegFrame . isOriginal ( ) ) ; assertEquals ( 627 , mpegFrame . getLengthInBytes ( ) ) ; }
@Override boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { arg1 . insertCharacterNode ( arg0 . asCharacter ( ) ) ; } else if ( arg0 . isComment ( ) ) { arg1 . insertCommentNode ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { arg1 . error ( this ) ; return false ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . normalName ( ) . equals ( " html " ) ) { return arg1 . process ( arg0 , InBody ) ; } else if ( arg0 . isEndTag ( ) & & arg0 . asEndTag ( ) . normalName ( ) . equals ( " html " ) ) { arg1 . transition ( AfterAfterFrameset ) ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . normalName ( ) . equals ( " noframes " ) ) { return arg1 . process ( arg0 , InHead ) ; } else if ( arg0 . isEOF ( ) ) { } else { arg1 . error ( this ) ; return false ; } return true ; }
public void function ( String arg0 ) { logger . log ( FQCN , traceCapable ? Level . TRACE : Level . DEBUG , arg0 , null ) ; }
public Optional < String [ ] > function ( final HttpRequest arg0 ) { try { Object content = jsonPath . read ( extractor . extract ( arg0 ) . get ( ) ) ;
public void function ( ) { HttpServer server = httpserver ( port ( ) ) ; server . response ( " foo " ) ; runner = httpRunner ( server ) ; runner . start ( ) ; helper = new MocoTestHelper ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p id=1>Hello <b>there</b> now</p> " ) ; Elements p1 = doc . select ( " p:matchesOwn((?i)hello now) " ) ; assertEquals ( 1 , p1 . size ( ) ) ; assertEquals ( " 1 " , p1 . first ( ) . id ( ) ) ; assertEquals ( 0 , doc . select ( " p:matchesOwn(there) " ) . size ( ) ) ; }
public String function ( ) { return Objects . toStringHelper ( this ) . add ( " URI " , uri ) . add ( " text " , text ) . add ( " file " , file ) . toString ( ) ; }
private List < WebSocketClient > function ( int arg0 , int arg1 ) throws URISyntaxException , InterruptedException { List < WebSocketClient > clients = new ArrayList < WebSocketClient > ( arg0 ) ; for ( int i = 0 ; i < arg0 ; i + + ) { WebSocketClient client = new SimpleClient ( new URI ( " ws://localhost: " + arg1 ) ) ; client . connect ( ) ; Thread . sleep ( 1 ) ; clients . add ( client ) ; } return clients ; }
public byte [ ] function ( Optional < HttpRequest > arg0 ) { return new Cookies ( ) . encodeCookie ( key , new String ( resource . readFor ( arg0 ) ) ) . getBytes ( ) ; }
private boolean function ( String arg0 ) { int len = arg0 . length ( ) ; if ( len > queue . size ( ) ) return false ; List < Character > chars = queue . subList ( 0 , len ) ; char [ ] seqChars = arg0 . toCharArray ( ) ; for ( int i = 0 ; i < len ; i + + ) { if ( ! chars . get ( i ) . equals ( seqChars [ i ] ) ) return false ; } return true ; }
public void function ( ) throws UnsupportedEncodingException { byte [ ] buffer = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " \ u03B3 \ u03B5 \ u03B9 \ u03AC " ; BufferTools . stringIntoByteBuffer ( s , 1 , 2 , buffer , 0 , " UTF-16BE " ) ; byte [ ] expectedBuffer = { 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0 , 0 , 0 , 0 , 0 , 0 } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
public void function ( final HttpUriRequest arg0 ) { final URIBuilder uriBuilder = new URIBuilder ( arg0 . getURI ( ) ) ; final DefaultHttpRequest . Builder builder = DefaultHttpRequest . builder ( ) . withVersion ( HttpProtocolVersion . versionOf ( arg0 . getProtocolVersion ( ) . toString ( ) ) ) . withUri ( toPath ( arg0 . getURI ( ) ) ) . withQueries ( asQueries ( uriBuilder . getQueryParams ( ) ) ) . withMethod ( HttpMethod . valueOf ( arg0 . getMethod ( ) . toUpperCase ( ) ) ) . withHeaders ( asHeaders ( arg0 . getAllHeaders ( ) ) ) ; if ( arg0 instanceof HttpEntityEnclosingRequest ) { final HttpEntityEnclosingRequest entityRequest = ( HttpEntityEnclosingRequest ) arg0 ; try { builder . withContent ( MessageContent . content ( ) . withContent ( entityRequest . getEntity ( ) . getContent ( ) ) . build ( ) ) ; } catch ( IOException e ) { } } logger . info ( " Action Request:{} \ n " , requestDumper . dump ( builder . build ( ) ) ) ; }
public SSLWebSocketClient function ( String arg0 , int arg1 , SSLContext arg2 , SSLContext arg3 , String arg4 ) throws IOException , URISyntaxException , InterruptedException { CountDownLatch countServerDownLatch = new CountDownLatch ( 1 ) ; SSLWebSocketClient client = new SSLWebSocketClient ( arg0 , arg1 , arg4 ) ; WebSocketServer server = new SSLWebSocketServer ( arg1 , countServerDownLatch ) ; server . setWebSocketFactory ( new DefaultSSLWebSocketServerFactory ( arg2 ) ) ; if ( arg3 ! = null ) { client . setSocketFactory ( arg3 . getSocketFactory ( ) ) ; } server . start ( ) ; countServerDownLatch . await ( ) ; client . connectBlocking ( 1 , TimeUnit . SECONDS ) ; return client ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div id=Boo> " ) ; Element el = doc . selectFirst ( " div " ) ; el . id ( " Foo " ) ; assertEquals ( " Foo " , el . id ( ) ) ; }
public String function ( String arg0 , byte [ ] arg1 ) throws IOException { Request request = Request . Post ( arg0 ) . addHeader ( CONTENT_TYPE , PLAIN_TEXT_UTF_8 . toString ( ) ) . bodyByteArray ( arg1 ) ; return EXECUTOR . execute ( request ) . returnContent ( ) . asString ( ) ; }
public void function ( final WebSocketServer arg0 ) { for ( WebsocketSession session : sessions ) { arg0 . request ( by ( session . request . asResource ( ) ) )
default public LoggingEventBuilder function ( ) { if ( isWarnEnabled ( ) ) { return new DefaultLoggingEventBuilder ( WARN , this ) ;
public String function ( final Map . Entry < String , String > arg0 ) { return arg0 . getValue ( ) ; }
private static void function ( ) { final LinkedBlockingQueue < SubstituteLoggingEvent > queue = SUBST_FACTORY . getEventQueue ( ) ; final int queueSize = queue . size ( ) ; int count = 0 ; final int maxDrain = 128 ; List < SubstituteLoggingEvent > eventList = new ArrayList < SubstituteLoggingEvent > ( maxDrain ) ; while ( true ) { int numDrained = queue . drainTo ( eventList , maxDrain ) ;
public static Predicate < Map . Entry < String , String [ ] > > function ( final String arg0 ) { return new Predicate < Map . Entry < String , String [ ] > > ( ) { @Override
public void function ( Object arg0 , Throwable arg1 ) { logger . log ( null , FQCN , LocationAwareLogger . ERROR_INT , String . valueOf ( arg0 ) , arg1 ) ; logger . error ( String . valueOf ( arg0 ) , arg1 ) ; }
public RequestSetting function ( String arg0 ) { return new UriRequestSetting ( this , arg0 ) ; }
public boolean function ( final Request arg0 ) { try { Document requestDocument = extractDocument ( arg0 , extractor ) ;
public void function ( String arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . FINEST ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public ProxyContainer function ( ) { if ( this . url ! = null & & ( this . from ! = null | | this . to ! = null ) ) { throw new IllegalArgumentException ( " Proxy cannot be set in multiple mode " ) ; } if ( this . url = = null & & ( this . from = = null | | this . to = = null ) ) { throw new IllegalArgumentException ( " Batch proxy needs both 'from' and 'to' " ) ; } ProxyContainer container = new ProxyContainer ( ) ; container . url = url ; container . from = from ; container . to = to ; container . failover = failover ; container . playback = playback ; return container ; }
public MessageContent function ( final Optional < ? extends Request > arg0 ) { MessageContent messageContent = resource . readFor ( arg0 ) ; return content ( new Cookies ( ) . encodeCookie ( key , messageContent . toString ( ) ) ) ; }
public static Resource function ( String arg0 ) { return new UriResource ( checkNotNull ( arg0 , " Null URI is not allowed " ) ) ; }
public static JsonRunner function ( Iterable < ? extends RunnerSetting > arg0 , StartArgs arg1 ) { return new JsonRunner ( arg0 , arg1 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " header.json " , port ( ) ) ; Content content = Request . Get ( remoteUrl ( " /header " ) ) . addHeader ( " content-type " , " application/json " ) . execute ( ) . returnContent ( ) ; assertThat ( content . asString ( ) , is ( " response_for_header_request " ) ) ; }
@Test public void function ( ) { String h = " <p>One <![CDATA[ Two <& ]]> Three</p> " ; Document doc = Jsoup . parse ( h ) ; Element p = doc . selectFirst ( " p " ) ; List < TextNode > nodes = p . textNodes ( ) ; assertEquals ( " One  " , nodes . get ( 0 ) . text ( ) ) ; assertEquals ( "  Two <&  " , nodes . get ( 1 ) . text ( ) ) ; assertEquals ( "  Three " , nodes . get ( 2 ) . text ( ) ) ; }
public PongResponse function ( final Resource arg0 ) { PingPongSetting setting = new PingPongSetting ( checkNotNull ( arg0 , " Ping message should not be null " ) ) ; settings . add ( setting ) ; return setting ; }
public int function ( ) { return hasAttributes ( ) ? attributes ( ) . size ( ) : 0 ; }
public String function ( String arg0 , int arg1 ) { os . print ( arg0 ) ; os . flush ( ) ; try { char [ ] buffer = new char [ arg1 ] ;
public void function ( Charset arg0 ) { updateMetaCharsetElement ( true ) ; outputSettings . arg0 ( arg0 ) ; ensureMetaCharsetElement ( ) ; }
public void function ( ) { this . lastPong = System . currentTimeMillis ( ) ; }
public void function ( ) { ClasspathFileResourceReader reader = new ClasspathFileResourceReader ( text ( " unknown.response " ) , null ) ; reader . readFor ( ( Request ) null ) ; }
private void function ( Tokeniser arg0 , CharacterReader arg1 ) { arg0 . emit ( " </ " + arg0 . dataBuffer . toString ( ) ) ; arg0 . transition ( ScriptDataEscaped ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private void function ( ) throws IOException , InvalidHandshakeException , InterruptedException { if ( client . isConnectionPending ( ) ) { client . finishConnect ( ) ; } client . register ( selector , SelectionKey . OP_READ ) ; sendHandshake ( ) ; }
public Connection function ( String arg0 ) { try { req . arg0 ( new URL ( arg0 ) ) ; } catch ( MalformedURLException e ) { throw new IllegalArgumentException ( " Malformed URL:  " + arg0 , e ) ; } return this ; }
private void function ( Collection < Element > arg0 ) { elements . addAll ( arg0 ) ; }
public void function ( ) { logger . warn ( marker , message , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . WARN , marker , null , exception ) ; }
void function ( ) throws IOException { File inputFile = ParseTest . getFile ( " /htmltests/large.html " ) ; String input = ParseTest . getFileAsString ( inputFile ) ; VaryingReadInputStream stream = new VaryingReadInputStream ( ParseTest . inputStreamFrom ( input ) ) ; ByteBuffer byteBuffer = DataUtil . readToByteBuffer ( stream , 0 ) ; String read = new String ( byteBuffer . array ( ) , 0 , byteBuffer . limit ( ) , StandardCharsets . UTF_8 ) ; assertEquals ( input , read ) ; }
public byte [ ] function ( HttpRequest arg0 ) { return reader . readFor ( arg0 ) ; }
public static MocoEventTrigger function ( MocoEventAction arg0 ) { return new MocoEventTrigger ( MocoEvent . COMPLETE , checkNotNull ( arg0 , " Action should not be null " ) ) ; }
public void function ( Exception arg0 ) { arg0 . printStackTrace ( ) ; }
public void function ( ) throws Exception { server . request ( by ( " foo " ) ) . response ( line ( " bar " ) ) ; running ( server , ( ) - > { helper . connect ( ) ;
private ID3v2CommentFrameData function ( String arg0 , boolean arg1 ) { ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { for ( ID3v2Frame frame : frameSet . getFrames ( ) ) { ID3v2CommentFrameData frameData ; try { frameData = new ID3v2CommentFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; if ( arg1 & & ITUNES_COMMENT_DESCRIPTION . equals ( frameData . getDescription ( ) . toString ( ) ) ) { return frameData ; } else if ( ! arg1 ) { return frameData ; } } catch ( InvalidDataException e ) { } } } return null ; }
public static ResponseHandler function ( final String arg0 , final String arg1 ) { return header ( " Set-Cookie " , new Cookies ( ) . encodeCookie ( checkNotNull ( arg0 , " Null cookie key is not allowed " ) ,
void function ( File arg0 ) throws IOException { long startTime = System . currentTimeMillis ( ) ; long completeBy = startTime + timeout * 1000L ; for ( int i = 0 ; i < numIters ; i + + ) { Document doc = Jsoup . parse ( arg0 , " UTF-8 " , " https://example.com/ " , Parser . xmlParser ( ) ) ;
public String function ( final Request arg0 ) { return arg0 . getContent ( ) . toString ( ) ; }
protected void function ( SocketChannel arg0 ) throws Exception { SSLEngine sslEngine = MocoSslContextFactory . createServerContext ( serverSetting . getCertificate ( ) ) . createSSLEngine ( ) ; sslEngine . setUseClientMode ( false ) ; ChannelPipeline pipeline = arg0 . pipeline ( ) ; pipeline . addLast ( " ssl " , new SslHandler ( sslEngine ) ) ; pipeline . addLast ( " decoder " , new HttpRequestDecoder ( ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( 1048576 ) ) ; pipeline . addLast ( " encoder " , new HttpResponseEncoder ( ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { server . get ( by ( uri ( " /target/1 " ) ) ) . response ( " target_1 " ) ; server . get ( by ( uri ( " /target/2 " ) ) ) . response ( " target_2 " ) ; server . get ( match ( uri ( " /proxy/.* " ) ) ) . response ( proxy ( from ( " /proxy " ) . to ( remoteUrl ( " /target " ) ) ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /proxy/1 " ) ) , is ( " target_1 " ) ) ;
@Test public void function ( ) { Evaluator parse = QueryParser . parse ( "  span div   " ) ; assertEquals ( " span div " , parse . toString ( ) ) ; }
public String function ( ) { return searchUpForAttribute ( this , BaseUriKey ) ; }
public ProxyContainer function ( JsonParser arg0 , DeserializationContext arg1 ) throws IOException , JsonProcessingException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return new ProxyContainer ( arg0 . getText ( ) . trim ( ) , null ) ; } else if ( currentToken = = JsonToken . START_OBJECT ) { JsonToken jsonToken = arg0 . nextToken ( ) ; if ( jsonToken = = JsonToken . FIELD_NAME ) { return createFailoverProxy ( arg0 ) ; } } throw arg1 . mappingException ( TextContainer . class , currentToken ) ; }
public void function ( String arg0 ) { recordEvent ( Level . TRACE , arg0 , null , null ) ; }
public void function ( ) { Attributes ats = new Attributes ( ) ; ats . put ( " a " , " a " ) ; ats . put ( " B " , " b " ) ; ats . put ( " c " , null ) ; assertTrue ( ats . hasValue ( " a " ) ) ; assertFalse ( ats . hasValue ( " A " ) ) ; assertTrue ( ats . hasValueIgnoreCase ( " A " ) ) ; assertFalse ( ats . hasValue ( " c " ) ) ; assertFalse ( ats . hasValue ( " C " ) ) ; assertFalse ( ats . hasValueIgnoreCase ( " C " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " settings/foo.json " , " settings/bar.json " ) ; assertThat ( helper . get ( remoteUrl ( " /foo " ) ) , is ( " foo " ) ) ; assertThat ( helper . get ( remoteUrl ( " /bar " ) ) , is ( " bar " ) ) ; }
public void function ( ) throws Exception { server . request ( eq ( xpath ( " /request/parameters/id/text() " ) , " 1 " ) ) . response ( " foo " ) ; server . request ( eq ( xpath ( " /request/parameters/id/text() " ) , " 2 " ) ) . response ( " bar " ) ; running ( server , ( ) - > { assertThat ( helper . postFile ( root ( ) , " foo.xml " ) , is ( " foo " ) ) ;
Document function ( String arg0 , String arg1 ) { state = HtmlTreeBuilderState . Initial ; return super . parse ( arg0 , arg1 ) ; }
void function ( ) { boolean last = false ; final int bottom = stack . size ( ) - 1 ; final int upper = bottom > = maxQueueDepth ? bottom - maxQueueDepth : 0 ; for ( int pos = bottom ; pos > = upper ; pos - - ) { Element node = stack . get ( pos ) ;
public void function ( Object arg0 , Throwable arg1 ) { logger . log ( null , FQCN , LocationAwareLogger . DEBUG_INT , String . valueOf ( arg0 ) , arg1 ) ; }
boolean function ( Element arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = stack . get ( pos ) ; if ( next = = arg0 ) { stack . remove ( pos ) ; onNodeClosed ( arg0 ) ; return true ; } } return false ; }
public void function ( ) throws IOException { Mp3FileForTesting mp3File = new Mp3FileForTesting ( MP3_WITH_ID3V1_AND_ID3V23_TAGS ) ; testShouldFindProbableStartOfMpegFramesWithPrescan ( mp3File ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div><p>The Rain.</p> <p class=light>The <i>rain</i>.</p> <p>Rain, the.</p></div> " ) ; Elements ps1 = doc . select ( " p:contains(Rain) " ) ; assertEquals ( 3 , ps1 . size ( ) ) ; Elements ps2 = doc . select ( " p:contains(the rain) " ) ; assertEquals ( 2 , ps2 . size ( ) ) ; assertEquals ( " The Rain. " , ps2 . first ( ) . html ( ) ) ; assertEquals ( " The <i>rain</i>. " , ps2 . last ( ) . html ( ) ) ; Elements ps3 = doc . select ( " p:contains(the Rain):has(i) " ) ; assertEquals ( 1 , ps3 . size ( ) ) ; assertEquals ( " light " , ps3 . first ( ) . className ( ) ) ; Elements ps4 = doc . select ( " .light:contains(rain) " ) ; assertEquals ( 1 , ps4 . size ( ) ) ; assertEquals ( " light " , ps3 . first ( ) . className ( ) ) ; Elements ps5 = doc . select ( " :contains(rain) " ) ; assertEquals ( 8 , ps5 . size ( ) ) ; }
private < T > T function ( String arg0 , long arg1 , Class < T > arg2 ) { try { Method method = Moco . class . getMethod ( arg0 , Long . TYPE ) ;
public Optional < String > function ( final HttpRequest arg0 ) { return of ( arg0 . getVersion ( ) . text ( ) ) ; }
public static HttpsServer function ( final int arg0 , final HttpsCertificate arg1 , final MocoConfig . . . arg2 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualHttpServer . createHttpsQuietServer ( arg0 , checkNotNull ( arg1 , " Certificate should not be null " ) , arg2 ) ; }
final public static FormattingTuple function ( String arg0 , Object arg1 ) { return arrayFormat ( arg0 , new Object [ ] { arg1 } ) ; }
public static byte [ ] function ( String arg0 , int arg1 , int arg2 ) { try { return stringToByteBuffer ( arg0 , arg1 , arg2 ) ;
public static ContentResource function ( final Supplier < byte [ ] > arg0 ) { return binary ( Suppliers . from ( checkNotNull ( arg0 , " Binary supplier should not be null " ) ) ) ; }
private static MocoMonitor function ( final LogWriter arg0 ) { return new LogMonitor ( new DefaultLogFormatter ( ) , arg0 ) ; }
private static boolean function ( Token arg0 ) { if ( arg0 . isCharacter ( ) ) { String data = arg0 . asCharacter ( ) . getData ( ) ; return StringUtil . isBlank ( data ) ; } return false ; }
@Test public void function ( ) { String text = new String ( Character . toChars ( 135361 ) ) ; String escapedAscii = Entities . escape ( text , Charset . forName ( " ascii " ) . newEncoder ( ) , Entities . EscapeMode . base ) ; assertEquals ( " &#135361; " , escapedAscii ) ; String escapedUtf = Entities . escape ( text , Charset . forName ( " UTF-8 " ) . newEncoder ( ) , Entities . EscapeMode . base ) ; assertEquals ( text , escapedUtf ) ; }
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; for ( Node node : childNodes ) accum . append ( node . outerHtml ( ) ) ; return accum . toString ( ) ; }
public void function ( ) throws Exception { server . put ( by ( " foo " ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( ) { matcher = AbstractMatcher . getMatcherImpl ( conversionType ) ; if ( matcher = = null ) { return false ; } matcher . setCommentConversion ( commentConversion ) ; writer = new Writer ( ) ; return true ; }
protected Node [ ] function ( ) { return ensureChildNodes ( ) . toArray ( new Node [ childNodeSize ( ) ] ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <a>Hello <div>there</div> <span>now</span></a> " ) ; assertEquals ( " <a>Hello <div>there</div> <span>now</span></a> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
@Test public void function ( ) { String h = " <![CDATA[]] " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( 1 , doc . body ( ) . childNodeSize ( ) ) ; }
public void function ( Object arg0 ) { innerLog ( null , CATEGORY_FQCN , LocationAwareLogger . ERROR_INT , arg0 , null ) ; }
public boolean function ( Element arg0 , Element arg1 ) { return arg1 . hasAttr ( key ) & & pattern . matcher ( arg1 . attr ( key ) ) . find ( ) ; }
@Test public void function ( ) { String html = " <img /onerror='doMyJob'/> " ; Document doc = Jsoup . parse ( html ) ; assertFalse ( " SelfClosingStartTag ignores last character " , doc . select ( " img[onerror] " ) . isEmpty ( ) ) ; assertEquals ( " <img onerror= \" doMyJob \" > " , doc . body ( ) . html ( ) ) ; doc = Jsoup . parse ( html , " " , Parser . xmlParser ( ) ) ; assertEquals ( " <img onerror= \" doMyJob \"  /> " , doc . html ( ) ) ; }
public static UnexpectedRequestMatcher function ( ) { return new UnexpectedRequestMatcher ( ) { } ; }
public static byte [ ] function ( ByteBuf arg0 ) { if ( arg0 . hasArray ( ) ) { return arg0 . array ( ) ; } if ( arg0 . nioBufferCount ( ) > 0 ) { ByteBuffer byteBuffer = arg0 . nioBuffer ( ) ; byte [ ] bytes = new byte [ byteBuffer . capacity ( ) ] ; byteBuffer . get ( bytes ) ; return bytes ; } throw new IllegalArgumentException ( " unknown content " ) ; }
@Test public void function ( ) { String html = " <a href='/foo'>Link</a> " ; String clean = Jsoup . clean ( html , " http://example.com/ " , Whitelist . basic ( ) ) ; assertEquals ( " <a href= \" http://example.com/foo \"  rel= \" nofollow \" >Link</a> " , clean ) ; }
public List < Framedata > function ( String arg0 , boolean arg1 ) { FrameBuilder curframe = new FramedataImpl1 ( ) ; try { curframe . setPayload ( ByteBuffer . wrap ( Charsetfunctions . utf8Bytes ( arg0 ) ) ) ; } catch ( InvalidDataException e ) { throw new NotSendableException ( e ) ; } curframe . setFin ( true ) ; curframe . setOptcode ( Opcode . TEXT ) ; curframe . setTransferemasked ( arg1 ) ; return Collections . singletonList ( ( Framedata ) curframe ) ; }
public void function ( ) throws IOException , JSONException { runWithConfiguration ( " json.json " ) ; JsonSupport . assertEquals ( " { \" foo \" : \" bar \" } " , helper . getResponse ( remoteUrl ( " /json_response_shortcut " ) ) ) ; }
private boolean function ( String [ ] arg0 , String [ ] arg1 , String [ ] arg2 ) { final int bottom = stack . size ( ) - 1 ; final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0 ; for ( int pos = bottom ; pos > = top ; pos - - ) { final String elName = stack . get ( pos ) . nodeName ( ) ; if ( inSorted ( elName , arg0 ) ) return true ; if ( inSorted ( elName , arg1 ) ) return false ; if ( arg2 ! = null & & inSorted ( elName , arg2 ) ) return false ; } return false ; }
public String function ( FullHttpResponse arg0 ) { StringBuilder buf = new StringBuilder ( ) ; appendResponseProtocolLine ( arg0 , buf ) ; buf . append ( StringUtil . NEWLINE ) ; headerJoiner . appendTo ( buf , arg0 . headers ( ) ) ; appendContent ( arg0 , buf ) ; return buf . toString ( ) ; }
public String function ( ) { Element titleEl = getElementsByTag ( " title " ) . first ( ) ; return titleEl ! = null ? titleEl . text ( ) . trim ( ) : " " ; }
public String function ( ) { return String . format ( " <!--%s--> " , getData ( ) ) ; }
public List < Framedata > function ( ByteBuffer arg0 , boolean arg1 ) { BinaryFrame curframe = new BinaryFrame ( ) ; curframe . setPayload ( arg0 ) ; curframe . setTransferemasked ( arg1 ) ; try { curframe . isValid ( ) ; } catch ( InvalidDataException e ) { throw new NotSendableException ( e ) ; } return Collections . singletonList ( ( Framedata ) curframe ) ; }
public static MocoEventAction function ( final String arg0 , final ContentResource arg1 , final HttpHeader . . . arg2 ) { return post ( text ( checkNotNullOrEmpty ( arg0 , " URL should not be null " ) ) , checkNotNull ( arg1 , " Content should not be null " ) ,
public static String function ( final String arg0 , final String . . . arg1 ) { return Arrays . stream ( arg1 ) . reduce ( arg0 , URLs : : doJoin ) ; }
private boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { arg1 . insert ( " html " ) ; arg1 . transition ( BeforeHead ) ; return arg1 . process ( arg0 ) ; }
public static String function ( ByteBuffer arg0 ) { int start = arg0 . position ( ) ; byte [ ] buffer = new byte [ arg0 . remaining ( ) ] ; arg0 . get ( buffer ) ; String s = new String ( buffer ) ; int nullPos = s . indexOf ( 0 ) ; s = s . substring ( 0 , nullPos ) ; arg0 . position ( start + s . length ( ) + 1 ) ; return s ; }
public void function ( ) throws Exception { server . response ( " foo " ) ; running ( server , ( ) - > { Request request = Request . get ( root ( ) ) . version ( HttpVersion . HTTP_1_1 ) . addHeader ( " Connection " , " keep-alive " ) ;
public final void function ( final ChannelHandlerContext arg0 , final WebSocketFrame arg1 ) { if ( this . websocketServer = = null ) { return ; } Optional < WebSocketFrame > frame = getResponseFrame ( arg0 , arg1 ) ; frame . ifPresent ( webSocketFrame - > arg0 . channel ( ) . writeAndFlush ( webSocketFrame ) ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isTraceEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public String function ( String arg0 ) { Validate . notNull ( arg0 , " Cookie name must not be null " ) ; return cookies . get ( arg0 ) ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( marker , message , param1 , exception ) ; break ; case DEBUG : logger . debug ( marker , message , param1 , exception ) ; break ; case INFO : logger . info ( marker , message , param1 , exception ) ; break ; case WARN : logger . warn ( marker , message , param1 , exception ) ; break ; case ERROR : logger . error ( marker , message , param1 , exception ) ; break ; } verifyMessage ( arg0 , marker , oneParam , exception ) ; }
Character function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
void function ( StringBuffer arg0 , Throwable arg1 ) { TARGET_STREAM . println ( arg0 . toString ( ) ) ; if ( arg1 ! = null ) { arg1 . printStackTrace ( TARGET_STREAM ) ; } TARGET_STREAM . flush ( ) ; }
void function ( Token . Character arg0 ) { final String data = arg0 . getData ( ) ; insertNode ( arg0 . isCData ( ) ? new CDataNode ( data ) : new TextNode ( data ) , arg0 ) ; }
public static RestIdMatcher function ( final String arg0 ) { return new BaseRestIdMatcher ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) ) ; }
public void function ( String arg0 , Object arg1 ) { recordEvent ( Level . ERROR , arg0 , new Object [ ] { arg1 } , null ) ;
public void function ( LoggingEvent arg0 ) { int levelInt = arg0 . getLevel ( ) . toInt ( ) ; if ( ! isLevelEnabled ( levelInt ) ) { return ; } FormattingTuple tp = MessageFormatter . arrayFormat ( arg0 . getMessage ( ) , arg0 . getArgumentArray ( ) , arg0 . getThrowable ( ) ) ; log ( levelInt , tp . getMessage ( ) , arg0 . getThrowable ( ) ) ; }
boolean function ( Element arg0 ) { return ( arg0 . hasClass ( className ) ) ; }
public static boolean function ( WebSocketImpl arg0 , ByteChannel arg1 ) throws IOException { ByteBuffer buffer = arg0 . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer = = null ) { if ( arg1 instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) arg1 ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do { arg1 . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { arg0 . outQueue . poll ( ) ; buffer = arg0 . outQueue . peek ( ) ; } } while ( buffer ! = null ) ; } if ( arg0 . outQueue . isEmpty ( ) & & arg0 . isFlushAndClose ( ) ) { synchronized ( arg0 ) { arg0 . closeConnection ( ) ; } } return c ! = null ? ! ( ( WrappedByteChannel ) arg1 ) . isNeedWrite ( ) : true ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://direct.infohound.net/tools/302-cookie.pl " ) ; Connection . Response res = con . execute ( ) ; Map < String , String > cookies = res . cookies ( ) ; assertEquals ( " asdfg123 " , cookies . get ( " token " ) ) ; assertEquals ( " jhy " , cookies . get ( " uid " ) ) ; Document doc = Jsoup . connect ( echoURL ) . cookies ( cookies ) . get ( ) ; assertEquals ( " token=asdfg123; uid=jhy " , ihVal ( " HTTP_COOKIE " , doc ) ) ; }
public void function ( ) { server . request ( by ( " foo " ) ) . response ( " foo " ) ; assertThrows ( HttpResponseException . class , ( ) - > { running ( server , ( ) - > helper . postContent ( root ( ) , " foo " ) ) ;
public static RestSettingBuilder function ( final RestIdMatcher arg0 ) { return single ( HttpMethod . DELETE , checkNotNull ( arg0 , " ID Matcher should not be null " ) ) ; }
public T function ( String arg0 , String arg1 ) { Validate . notEmpty ( arg0 ) ; Validate . notNull ( arg1 ) ; List < String > values = headers ( arg0 ) ; if ( values . isEmpty ( ) ) { values = new ArrayList < > ( ) ; headers . put ( arg0 , values ) ; } values . add ( arg1 ) ; return ( T ) this ; }
private Option function ( ) { Option opt = new Option ( " p " , true , " port " ) ; opt . setType ( Number . class ) ; opt . setRequired ( false ) ; return opt ; }
public ProxyContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return builder ( ) . withUrl ( strip ( arg0 . getText ( ) ) ) . build ( ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { InternalProxyContainer container = arg0 . readValueAs ( InternalProxyContainer . class ) ; return container . toProxyContainer ( ) ; } return ( ProxyContainer ) arg1 . handleUnexpectedToken ( ProxyContainer . class , arg0 ) ; }
public void function ( ) throws Exception { server . response ( file ( " src/test/resources/gbk.response " , Charset . forName ( " GBK " ) ) ) ; running ( server , ( ) - > assertThat ( helper . getAsBytes ( root ( ) ) , is ( Files . readAllBytes ( Paths . get ( " src/test/resources/gbk.response " ) ) ) ) ) ; }
public void function ( ) { try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; server . socket ( ) . bind ( new java . net . InetSocketAddress ( port ) ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; } catch ( IOException ex ) { onIOError ( ex ) ; return ; } while ( true ) { try {
public void function ( Locale arg0 ) { Locale . setDefault ( arg0 ) ; Whitelist safelist = Whitelist . none ( ) . addTags ( " a " ) . addAttributes ( " a " , " href " ) . addProtocols ( " a " , " href " , " something " ) ; String cleanHtml = Jsoup . clean ( " <a href= \" SOMETHING://x \" ></a> " , safelist ) ; assertEquals ( " <a href= \" SOMETHING://x \" ></a> " , TextUtil . stripNewlines ( cleanHtml ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.2.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public Optional < MocoConfig > function ( ) { if ( context ! = null ) { return of ( Moco . context ( context ) ) ; } return absent ( ) ; }
public void function ( String arg0 , Object arg1 ) { formatAndLog ( Log . DEBUG , arg0 , arg1 ) ; }
public void function ( String arg0 ) { threadLocalMapOfDeques . clearDequeByKey ( arg0 ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /target " ) ) ) . response ( seq ( status ( 500 ) , status ( 400 ) ) ) ; server . request ( match ( uri ( " /proxy/.* " ) ) ) . response ( proxy ( from ( " /proxy " ) . to ( remoteUrl ( " /target " ) ) , failover ( " src/test/resources/failover.response " , 500 , 400 ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( WebSocket arg0 , Framedata arg1 ) { receivedPingBuffer = arg1 . getPayloadData ( ) . array ( ) ; super . onWebsocketPing ( arg0 , arg1 ) ; pingLatch . countDown ( ) ; }
public void function ( ) throws IOException { runner . run ( ) ; try { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; } catch ( HttpHostConnectException e ) { fail ( e . getMessage ( ) ) ; } shutdownMoco ( SHUTDOWN_PORT , SHUTDOWN_MOCO_KEY ) ; waitChangeHappens ( ) ; helper . get ( root ( ) ) ; }
protected final ResponseHandler function ( final MocoConfig arg0 ) { RecorderIdentifier appliedIdentifier = this . identifier . apply ( arg0 ) ; ReplayModifier appliedModifier = this . modifier . apply ( arg0 ) ; if ( appliedIdentifier ! = this . identifier | | appliedModifier ! = this . modifier ) { RecorderConfigurations configurations = RecorderConfigurations . create ( ImmutableList . of ( group ( this . registry . getGroup ( ) ) , appliedIdentifier , appliedModifier ) ) ; return new DynamicReplayHandler ( configurations ) ; } return this ; }
protected Tag function ( String arg0 , ParseSettings arg1 ) { Tag tag = seenTags . get ( arg0 ) ; if ( tag = = null ) { tag = Tag . valueOf ( arg0 , arg1 ) ; seenTags . put ( arg0 , tag ) ; } return tag ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( isWarnEnabled ( arg0 ) ) { handle2ArgsCall ( Level . WARN , arg0 , arg1 , arg2 , arg3 ) ;
protected void function ( ) { try { Idles . idle ( FileMocoRunnerWatcher . INTERVAL * 3 ) ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , fileRoot ( " src/test/resources " ) ) ; server . request ( by ( uri ( " /record " ) ) ) . response ( record ( group ( " foo " ) ) ) ; server . request ( by ( uri ( " /replay " ) ) ) . response ( replay ( group ( " foo " ) , modifier ( template ( " ${req.content} " ) , header ( " X-REPLAY " , template ( file ( " foo.template " ) ) ) ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /record?type=blah " ) , " foo " ) ;
protected boolean function ( ) { return isDataAttribute ( key ) ; }
public void function ( ) throws Exception { assertThat ( asContent ( messageWithHeaders ( EMPTY_MAP ) ) , isEmptyString ( ) ) ; }
public void function ( ) { HttpRequest request = mock ( HttpRequest . class ) ; when ( request . getUri ( ) ) . thenReturn ( " /foo?param=bar " ) ; assertThat ( extractor . extract ( request ) , is ( " /foo " ) ) ; }
public void function ( int arg0 , String arg1 , boolean arg2 ) { if ( connectionClosed ) { return ; } connectionClosed = true ; if ( key ! = null ) { key . attach ( null ) ; key . cancel ( ) ; } this . wsl . onWebsocketClose ( this , arg0 , arg1 , arg2 ) ; if ( draft ! = null ) draft . reset ( ) ; currentframe = null ; handshakerequest = null ; }
public void function ( ) { final Document doc = createHtmlDocument ( " dontTouch " ) ; doc . charset ( Charset . forName ( charsetUtf8 ) ) ; Element selectedElement = doc . select ( " meta[charset] " ) . first ( ) ; assertEquals ( charsetUtf8 , selectedElement . attr ( " charset " ) ) ; assertTrue ( doc . select ( " meta[name=charset] " ) . isEmpty ( ) ) ; }
public static ActualHttpServer function ( int arg0 , Object arg1 , MocoConfig . . . arg2 ) { return new ActualHttpServer ( arg0 , arg1 , arg2 ) ; }
private Function < HttpsArg , HttpsCertificate > function ( ) { return new Function < HttpsArg , HttpsCertificate > ( ) { @Override
public HandshakeState function ( Handshakedata arg0 ) { if ( arg0 . hasFieldValue ( " Origin " ) & & basicAccept ( arg0 ) ) { return HandshakeState . MATCHED ; } return HandshakeState . NOT_MATCHED ; }
public void function ( ) throws IOException { final long latency = 1000 ; final long delta = 200 ; runWithConfiguration ( " foo.json " ) ; long start = System . currentTimeMillis ( ) ; int code = helper . getForStatus ( remoteUrl ( " /latency-with-unit " ) ) ; long stop = System . currentTimeMillis ( ) ; long gap = stop - start + delta ; assertThat ( gap , greaterThan ( latency ) ) ; assertThat ( code , is ( 200 ) ) ; }
public static VerificationMode function ( final int arg0 ) { checkArgument ( arg0 > = 0 , " Times count must not be less than zero " ) ; return new TimesVerification ( arg0 ) ; }
public HandshakeState function ( ByteBuffer arg0 ) { ByteBuffer buf ; if ( tmpHandshakeBytes = = null ) { buf = arg0 ; } else { buf = tmpHandshakeBytes ; tmpHandshakeBytes . position ( tmpHandshakeBytes . limit ( ) ) ; tmpHandshakeBytes . limit ( tmpHandshakeBytes . capacity ( ) ) ; if ( arg0 . remaining ( ) > tmpHandshakeBytes . remaining ( ) ) return HandshakeState . NOT_MATCHED ; tmpHandshakeBytes . put ( arg0 ) ; tmpHandshakeBytes . flip ( ) ; } if ( buf . limit ( ) > Draft . FLASH_POLICY_REQUEST . length ) { tmpHandshakeBytes = null ;
public int [ ] function ( ) { ProfilerRegistry profilerRegistry = ProfilerRegistry . getThreadContextInstance ( ) ; Profiler sortProfiler = profilerRegistry . get ( NESTED_PROFILER_NAME ) ; sortProfiler . start ( " SORT " ) ; int [ ] sortedArray = sort ( ) ; sortProfiler . start ( " PRUNE_COMPOSITES " ) ; int [ ] result = pruneComposites ( sortedArray ) ; return result ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { delegate ( ) . error ( arg0 , arg1 , arg2 ) ; }
@Test public void function ( ) throws XPathExpressionException { String html = " <p><script>1 && 2</script><style>3 && 4</style> 5 &amp;&amp; 6</p> " ; org . jsoup . nodes . Document jdoc = Jsoup . parse ( html ) ; jdoc . outputSettings ( ) . syntax ( org . jsoup . nodes . Document . OutputSettings . Syntax . xml ) ; String xml = jdoc . body ( ) . html ( ) ; assertTrue ( xml . contains ( " <script><![CDATA[ " ) ) ; Document doc = parseXml ( xml , false ) ; NodeList list = xpath ( doc , " //script " ) ; assertEquals ( 1 , list . getLength ( ) ) ; Node script = list . item ( 0 ) ; assertEquals ( " 1 && 2 " , script . getTextContent ( ) ) ; }
public @Nullable Element function ( ) { Node next = this ; while ( ( next = next . nextSibling ( ) ) ! = null ) { if ( next instanceof Element ) return ( Element ) next ; } return null ; }
public void function ( ) throws IOException { runWithConfiguration ( " match.json " ) ; assertThat ( helper . getWithHeader ( remoteUrl ( " /header-match " ) , of ( HttpHeaders . CONTENT_TYPE , " application/json " ) ) , is ( " header_match " ) ) ; assertThat ( helper . getWithHeader ( remoteUrl ( " /header-match " ) , of ( HttpHeaders . CONTENT_TYPE , " application/xml " ) ) , is ( " header_match " ) ) ; }
public void function ( ) { logger . info ( marker , message , param1 ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . INFO , marker , oneParam , null ) ; }
public void function ( final String arg0 ) { try { Files . append ( arg0 , file , Charset . defaultCharset ( ) ) ;
public void function ( ) throws Exception { testHandshakeRejection ( 11 ) ; }
public void function ( ) throws Exception { RequestHit hit = requestHit ( ) ; SocketServer socketServer = socketServer ( port ( ) , hit ) ; socketServer . request ( by ( " 0XCAFE " ) ) . response ( line ( " 0XBABE " ) ) ; running ( socketServer , ( ) - > { helper . connect ( ) ; assertThat ( helper . send ( " 0XCAFE " ) , is ( " 0XBABE " ) ) ; helper . close ( ) ; } ) ; hit . verify ( by ( " 0XCAFE " ) , once ( ) ) ; }
public boolean function ( Element arg0 , Element arg1 ) { Element prev = arg1 . previousElementSibling ( ) ; if ( prev ! = null & & sel . matches ( arg0 , prev ) ) return true ; return false ; }
public final RequestRecorder function ( final String arg0 ) { return new FileRequestRecorder ( arg0 , tape ) ; }
public void function ( ) { WebSocketServer webSocketServer = new MyWebSocketServer ( ) ; webSocketServer . setWebSocketFactory ( new LocalWebSocketFactory ( ) ) ; Assert . assertFalse ( " Close should not have been called yet " , isClosedCalled ) ; webSocketServer . setWebSocketFactory ( new LocalWebSocketFactory ( ) ) ; Assert . assertTrue ( " Close has been called " , isClosedCalled ) ; }
private static String function ( String arg0 , Document arg1 ) { final Element first = arg1 . select ( " th:contains( " + arg0 + " ) + td " ) . first ( ) ; return first ! = null ? first . text ( ) : null ; }
public final void function ( final SessionContext arg0 ) { Request request = arg0 . getRequest ( ) ; HttpRequest recordedRequest = getRequiredRecordedRequest ( ( HttpRequest ) request ) ; SessionContext newContext = new SessionContext ( recordedRequest , arg0 . getResponse ( ) ) ; modifier . writeToResponse ( newContext ) ; }
public List < Node > function ( ) { if ( childNodeSize ( ) = = 0 ) return EmptyNodes ; List < Node > children = ensureChildNodes ( ) ; List < Node > rewrap = new ArrayList < > ( children . size ( ) ) ; rewrap . addAll ( children ) ; return Collections . unmodifiableList ( rewrap ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isStartTag ( ) & & inSorted ( arg0 . asStartTag ( ) . normalName ( ) , InSelecTableEnd ) ) { arg1 . error ( this ) ;
void function ( ) { boolean last = false ; final int bottom = stack . size ( ) - 1 ; final int upper = bottom > = maxQueueDepth ? bottom - maxQueueDepth : 0 ; if ( stack . size ( ) = = 0 ) { transition ( HtmlTreeBuilderState . InBody ) ; } for ( int pos = bottom ; pos > = upper ; pos - - ) { Element node = stack . get ( pos ) ;
private boolean function ( final String [ ] arg0 , final String [ ] arg1 ) { if ( arg0 . length ! = arg1 . length ) { return false ; } return IntStream . range ( 0 , arg1 . length ) . allMatch ( index - > doMatch ( arg0 [ index ] . toLowerCase ( ) , arg1 [ index ] . toLowerCase ( ) ) ) ;
RunnerWatcher function ( final FileRunner arg0 , final File . . . arg1 ) ; }
protected void function ( ChannelBuffer arg0 ) { arg0 . writeBytes ( stream . asByteArray ( ) ) ; }
private Mp3File function ( Mp3File arg0 ) throws NotSupportedException , IOException , UnsupportedTagException , InvalidDataException { String saveFilename = arg0 . getFilename ( ) + " .copy " ; try { arg0 . save ( saveFilename ) ;
public List < DataNode > function ( ) { List < DataNode > dataNodes = new ArrayList < > ( ) ; for ( Node node : childNodes ) { if ( node instanceof DataNode ) dataNodes . add ( ( DataNode ) node ) ; } return Collections . unmodifiableList ( dataNodes ) ; }
public RestSetting function ( final RestSubResourceSetting arg0 ) { RestSetting [ ] settings = arg0 . getSettings ( ) ; return MocoRest . id ( arg0 . id ) . name ( arg0 . getName ( ) ) . settings ( settings [ 0 ] , Arrays . copyOfRange ( settings , 1 , settings . length ) ) ;
public void function ( InputStream arg0 , int arg1 ) throws IOException { HttpServer server = httpServerParser . parseServer ( arg0 , arg1 ) ; runner . run ( server ) ; }
private static Options function ( ) { Options options = new Options ( ) ; options . addOption ( configOption ( ) ) ; options . addOption ( portOption ( ) ) ; options . addOption ( shutdownPortOption ( ) ) ; options . addOption ( settingsOption ( ) ) ; options . addOption ( envOption ( ) ) ; options . addOption ( httpsCertificate ( ) ) ; options . addOption ( keyStore ( ) ) ; options . addOption ( cert ( ) ) ; return options ; }
public final HttpResponseSetting function ( final ProxyConfig arg0 ) { return proxy ( checkNotNull ( arg0 , " Proxy config should not be null " ) , Failover . DEFAULT_FAILOVER ) ; }
public MocoEventAction function ( ) { if ( content ! = null ) { return post ( this . url . asResource ( ) , content . asResource ( ) ) ; } if ( json ! = null ) { return post ( this . url . asResource ( ) , Moco . json ( json ) ) ; } throw new IllegalArgumentException ( " content or json should be setup for post " ) ; }
public static String function ( final Object arg0 ) { try { return mapper . writeValueAsString ( arg0 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.3.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 250 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 20 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.7.12 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { assertThat ( LoggerFactory . loadExplicitlySpecified ( " org.slf4j.LoggerFactoryTest$TestingProvider " ) , is ( instanceOf ( TestingProvider . class ) ) ) ;
public void function ( ) { logger . trace ( message , param1 , param2 , param3 , exception ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . TRACE , threeParams , exception ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) throws IOException { Assert . assertEquals ( " " , Base64 . encodeBytes ( new byte [ 0 ] ) ) ; Assert . assertEquals ( " QHE= " , Base64 . encodeBytes ( new byte [ ] { 49 , 121 , 64 , 113 , - 63 , 43 , - 24 , 62 , 4 , 48 } , 2 , 2 , 0 ) ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
protected void function ( Appendable arg0 ) { new NodeTraversor ( new OuterHtmlVisitor ( arg0 , getOutputSettings ( ) ) ) . traverse ( this ) ; }
private String [ ] function ( final String arg0 , final Object arg1 ) { if ( this . headers . containsKey ( arg0 ) ) { String [ ] values = this . headers . get ( arg0 ) ; String [ ] newValues = new String [ values . length + 1 ] ; System . arraycopy ( values , 0 , newValues , 0 , values . length ) ; newValues [ values . length ] = arg1 . toString ( ) ; return newValues ; } return new String [ ] { arg1 . toString ( ) } ; }
public void function ( ) throws IOException { runWithConiguration ( " foo.json " ) ; HttpResponse response = Request . Get ( " http://localhost:8080/response_header " ) . execute ( ) . returnResponse ( ) ; assertThat ( response . getHeaders ( " content-type " ) [ 0 ] . getValue ( ) , is ( " application/json " ) ) ; assertThat ( response . getHeaders ( " foo " ) [ 0 ] . getValue ( ) , is ( " bar " ) ) ; }
public Builder function ( final InputStream arg0 ) { this . arg0 = arg0 ; return this ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( marker , message ) ; break ; case DEBUG : logger . debug ( marker , message ) ; break ; case INFO : logger . info ( marker , message ) ; break ; case WARN : logger . warn ( marker , message ) ; break ; case ERROR : logger . error ( marker , message ) ; break ; } verifyMessage ( arg0 , marker , null , null ) ; }
public void function ( ) { testHandshakeRejection ( 1 ) ; }
public boolean function ( HttpRequest arg0 ) { String relativePath = target . extract ( extractor . extract ( arg0 ) ) ; if ( isNullOrEmpty ( relativePath ) | | ! and ( predicates ) . apply ( relativePath ) ) { return false ; } return new File ( dir , relativePath ) . exists ( ) ; }
public void function ( ) { Integer [ ] [ ] multiIntegerA = new Integer [ ] [ ] { ia0 , ia1 } ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , multiIntegerA } ) ; assertEquals ( " a[[1, 2, 3], [10, 20, 30]] " , result ) ; int [ ] [ ] multiIntA = new int [ ] [ ] { { 1 , 2 } , { 10 , 20 } } ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , multiIntA } ) ; assertEquals ( " a[[1, 2], [10, 20]] " , result ) ; float [ ] [ ] multiFloatA = new float [ ] [ ] { { 1 , 2 } , { 10 , 20 } } ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , multiFloatA } ) ; assertEquals ( " a[[1.0, 2.0], [10.0, 20.0]] " , result ) ; Object [ ] [ ] multiOA = new Object [ ] [ ] { ia0 , ia1 } ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , multiOA } ) ; assertEquals ( " a[[1, 2, 3], [10, 20, 30]] " , result ) ; Object [ ] [ ] [ ] _3DOA = new Object [ ] [ ] [ ] { multiOA , multiOA } ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , _3DOA } ) ; assertEquals ( " a[[[1, 2, 3], [10, 20, 30]], [[1, 2, 3], [10, 20, 30]]] " , result ) ;
public void function ( byte [ ] arg0 ) throws NotSupportedException { int offset = packHeader ( arg0 , 0 ) ; if ( extendedHeader ) { offset = packExtendedHeader ( arg0 , offset ) ; } offset = packFrames ( arg0 , offset ) ; if ( footer ) { offset = packFooter ( arg0 , dataLength ) ;
public FileContainer function ( JsonParser arg0 , DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return asFileContainer ( text ( arg0 ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; String target = arg0 . getText ( ) . trim ( ) ; if ( isForFileContainer ( target ) ) { return toFileContainer ( arg0 ) ; } return asFileContainer ( textContainer ( arg0 , arg1 ) ) ; } throw arg1 . mappingException ( TextContainer . class , currentToken ) ; }
@Test @MultiLocaleTest public void function ( ) { Tag script1 = Tag . valueOf ( " script " , ParseSettings . htmlDefault ) ; Tag script2 = Tag . valueOf ( " SCRIPT " , ParseSettings . htmlDefault ) ; assertSame ( script1 , script2 ) ; }
public Socket function ( ) throws IOException { Socket socket = socketFactory . createSocket ( ) ; socket . bind ( new InetSocketAddress ( bindingAddress , 0 ) ) ; return socket ; }
public void function ( ) throws Exception { String response = Request . Get ( remoteUrl ( " /template?foo=bar " ) ) . version ( HttpVersion . HTTP_1_0 ) . execute ( ) . returnContent ( ) . asString ( ) ; assertThat ( response , is ( " bar " ) ) ; }
public void function ( String arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . INFO ) ) { String msgStr = MessageFormatter . arg0 ( arg0 , arg1 ) ;
protected void function ( LogRecord arg0 , Logger arg1 ) { arg1 . debug ( arg0 . getMessage ( ) , arg0 . getThrown ( ) ) ; }
public void function ( Thread arg0 , Throwable arg1 ) { exception = arg1 ; }
public static ResponseHandler function ( final String arg0 , final String . . . arg1 ) { checkNotNull ( arg0 , " Sequence content should not be null " ) ; checkArgument ( arg1 . length > 0 , " Sequence content should not be null " ) ; return newSeq ( FluentIterable . from ( asIterable ( arg0 , arg1 ) ) . transform ( textToResource ( ) ) ) ; }
public Element function ( String arg0 ) { Validate . notNull ( arg0 ) ; attr ( " arg0 " , arg0 ) ; return this ; }
public static void function ( byte [ ] arg0 ) throws NoSuchTagException , UnsupportedTagException { if ( arg0 . length < AbstractID3v2Tag . HEADER_LENGTH ) { throw new NoSuchTagException ( " Buffer too short " ) ; } if ( ! AbstractID3v2Tag . TAG . equals ( BufferTools . byteBufferToStringIgnoringEncodingIssues ( arg0 , 0 , AbstractID3v2Tag . TAG . length ( ) ) ) ) { throw new NoSuchTagException ( ) ; } int majorVersion = arg0 [ AbstractID3v2Tag . MAJOR_VERSION_OFFSET ] ; if ( majorVersion ! = 2 & & majorVersion ! = 3 & & majorVersion ! = 4 ) { int minorVersion = arg0 [ AbstractID3v2Tag . MINOR_VERSION_OFFSET ] ;
public static String function ( byte [ ] arg0 , int arg1 , int arg2 ) { try { return new String ( arg0 , arg1 , arg2 , " ASCII " ) ;
@Test void function ( ) throws IOException { StreamParser parser = basic ( ) ; Element el = parser . expectNext ( " div:has(p) " ) ; assertEquals ( " Two " , el . text ( ) ) ; }
private void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 , final Predicate < CorsConfig > arg2 ) { if ( configs . length = = 0 ) { arg1 . addHeader ( " Access-Control-Allow-Origin " , " * " ) ; return ; } writeCorsResponse ( arg0 , arg1 , arg2 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.12 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
private HttpEntity function ( final ByteBuf arg0 , final long arg1 ) { return new InputStreamEntity ( new ByteBufInputStream ( arg0 ) , arg1 , null ) ; }
boolean function ( Tag arg0 ) { for ( Tag endTag : ignoreEndTags ) { if ( arg0 . equals ( endTag ) ) return true ; } return false ; }
public < T extends Throwable > T function ( T arg0 ) { if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( THROWING_MARKER , FQCN , LocationAwareLogger . ERROR_INT , " throwing " , null , arg0 ) ; } return arg0 ; }
public void function ( ) { assertTrue ( multiComp . contains ( COMP_STR ) ) ; assertTrue ( multiComp . contains ( BLUE_STR ) ) ; assertTrue ( multiComp . contains ( GREEN_STR ) ) ; assertFalse ( multiComp . contains ( RED_STR ) ) ; }
public void function ( ) throws Exception { Request request = Request . Post ( root ( ) ) . bodyForm ( new BasicNameValuePair ( " name " , " dreamhead " ) ) ; String content = helper . executeAsString ( request ) ; assertThat ( content , is ( " foobar " ) ) ; }
public void function ( ) throws Exception { server . resource ( " targets " , patch ( anyId ( ) ) . response ( with ( text ( " patch result " ) ) ) ) ; running ( server , ( ) - > assertThat ( helper . patchForResponse ( remoteUrl ( " /targets/1 " ) , " result " ) , is ( " patch result " ) ) ) ; }
public void function ( ) { Document doc = new Document ( " " ) ; Element body = doc . appendElement ( " body " ) ; body . appendElement ( " div1 " ) ; body . appendElement ( " div2 " ) ; final Element div3 = body . appendElement ( " div3 " ) ; div3 . text ( " Check " ) ; final Element div4 = body . appendElement ( " div4 " ) ; ArrayList < Element > toMove = new ArrayList < Element > ( ) ; toMove . add ( div3 ) ; toMove . add ( div4 ) ; body . insertChildren ( 0 , toMove ) ; String result = doc . toString ( ) . replaceAll ( " \\ s+ " , " " ) ; assertEquals ( " <body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body> " , result ) ; }
public ClientHandshakeBuilder function ( ClientHandshakeBuilder arg0 ) throws InvalidHandshakeException { arg0 . put ( " Upgrade " , " WebSocket " ) ; arg0 . put ( " Connection " , " Upgrade " ) ; if ( ! arg0 . hasFieldValue ( " Origin " ) ) { arg0 . put ( " Origin " , " random " + new Random ( ) . nextInt ( ) ) ; } return arg0 ; }
public static Resource function ( final ContentResource arg0 ) { return template ( checkNotNull ( arg0 , " Template should not be null " ) , ImmutableMap . < String , String > of ( ) ) ; }
@Test public void function ( ) { String h = " <foo:bar id='1' /><abc:def id=2>Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar> " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <foo:bar id= \" 1 \"  /><abc:def id= \" 2 \" >Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { if ( ! logger . isTraceEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg1 , arg2 ) . getMessage ( ) ;
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( arg0 . isDoctype ( ) ) { arg1 . error ( this ) ; return false ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " html " ) ) { arg1 . insert ( arg0 . asStartTag ( ) ) ; arg1 . transition ( BeforeHead ) ; } else if ( arg0 . isEndTag ( ) & & ( StringUtil . in ( arg0 . asEndTag ( ) . name ( ) , " head " , " body " , " html " , " br " ) ) ) { return anythingElse ( arg0 , arg1 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . error ( this ) ; return false ; } else { return anythingElse ( arg0 , arg1 ) ; } return true ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public static ResponseHandler function ( final String arg0 , final String arg1 , final CookieAttribute . . . arg2 ) { return cookie ( checkNotNullOrEmpty ( arg0 , " Cookie key should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Cookie value should not be null " ) ) ,
public void function ( String arg0 , Object arg1 ) { logger . debug ( arg0 , arg1 ) ; }
public boolean function ( ) { return pathResource ! = null ; }
public boolean function ( Handshakedata arg0 ) { if ( arg0 . getFieldValue ( " Sec-WebSocket-Key1 " ) . equals ( " 8 " ) & & new String ( arg0 . getContent ( ) ) . endsWith ( " \ r \ n \ r \ n " ) ) return true ; return false ; }
private Optional < ResponseHandler > function ( final HttpRequest arg0 ) { HttpMethod method = arg0 . getMethod ( ) ; if ( HttpMethod . GET = = method ) { return getGetHandler ( arg0 ) ; } if ( HttpMethod . POST = = method ) { return getPostHandler ( arg0 ) ; } if ( HttpMethod . PUT = = method ) { return getSingleResponseHandler ( putSettings , arg0 ) ; } if ( HttpMethod . DELETE = = method ) { return getSingleResponseHandler ( deleteSettings , arg0 ) ; } if ( HttpMethod . HEAD = = method ) { return getHeadHandler ( arg0 ) ; } if ( HttpMethod . PATCH = = method ) { return getSingleResponseHandler ( patchSettings , arg0 ) ; } return absent ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.19.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException , InterruptedException { stop ( 0 ) ; }
public static ResponseHandler function ( final MocoProcedure arg0 ) { return new ProcedureResponseHandler ( arg0 ) ; }
public void function ( ) throws Exception { HttpsServer server = httpsServer ( port ( ) , DEFAULT_CERTIFICATE , context ( " /foo " ) ) ; server . request ( by ( uri ( " /bar " ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public T function ( String arg0 , String arg1 ) { Validate . notEmpty ( arg0 , " Cookie name must not be empty " ) ; Validate . notNull ( arg1 , " Cookie value must not be null " ) ; cookies . put ( arg0 , arg1 ) ; return ( T ) this ; }
public final T function ( final MocoProcedure arg0 ) { return this . response ( with ( checkNotNull ( arg0 , " Procedure should not be null " ) ) ) ; }
public void function ( ) throws IOException { String json = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) . getHeaders ( " content-type " ) [ 0 ] . getValue ( ) ; assertThat ( json , is ( " application/json " ) ) ; String bar = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) . getHeaders ( " foo " ) [ 0 ] . getValue ( ) ; assertThat ( bar , is ( " bar " ) ) ; }
public static ImmutableList < String > function ( final String arg0 ) { Path path = getGlobPath ( arg0 ) ; int globIndex = getGlobIndex ( path ) ; if ( globIndex < 0 ) { return of ( arg0 ) ; } return doGlob ( path , searchPath ( path , globIndex ) ) ; }
@Test public void function ( ) { String bareFragment = " <h2>text</h2> " ; List < Node > nodes = new Document ( " " ) . parser ( ) . parseFragmentInput ( bareFragment , new Element ( " p " ) , " " ) ; assertEquals ( 1 , nodes . size ( ) ) ; Node node = nodes . get ( 0 ) ; assertEquals ( " h2 " , node . nodeName ( ) ) ; assertEquals ( " <p><h2>text</h2></p> " , node . parent ( ) . outerHtml ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { warn ( arg1 , arg2 ) ; }
protected final Optional < String [ ] > function ( final HttpRequest arg0 ) { return helper . extractAsInputSource ( arg0 , extractor ) . flatMap ( this : : doExtract ) ; }
protected void function ( final List < MocoEventTrigger > arg0 ) { this . arg0 . addAll ( arg0 ) ; }
public void function ( ) throws Exception { server . request ( eq ( xpath ( " /request/parameters/id/text() " ) , " 3 " ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
protected void function ( ChannelHandlerContext arg0 , String arg1 ) throws Exception { try { MessageContent content = content ( ) . withContent ( arg1 . getBytes ( ) ) . build ( ) ;
protected Optional < Object > function ( final HttpRequest arg0 ) { Optional < MessageContent > requestBody = extractor . extract ( arg0 ) ; try { if ( ! requestBody . isPresent ( ) ) {
static void function ( Appendable arg0 , String arg1 , Document . OutputSettings arg2 , boolean arg3 , boolean arg4 , boolean arg5 ) throws IOException { boolean lastWasWhite = false ; boolean reachedNonWhite = false ; final EscapeMode escapeMode = arg2 . escapeMode ( ) ; final CharsetEncoder encoder = arg2 . encoder ( ) ; final CoreCharset coreCharset = arg2 . coreCharset ; final int length = arg1 . length ( ) ; int codePoint ; for ( int offset = 0 ; offset < length ; offset + = Character . charCount ( codePoint ) ) { codePoint = arg1 . codePointAt ( offset ) ;
private ID3v2PictureFrameData function ( String arg0 ) { ID3v2FrameSet frameSet = frameSets . get ( arg0 ) ; if ( frameSet ! = null ) { ID3v2Frame frame = ( ID3v2Frame ) frameSet . getFrames ( ) . get ( 0 ) ; ID3v2PictureFrameData frameData ; try { if ( obseleteFormat ) frameData = new ID3v2ObseletePictureFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; else frameData = new ID3v2PictureFrameData ( useFrameUnsynchronisation ( ) , frame . getData ( ) ) ; return frameData ; } catch ( InvalidDataException e ) { } } return null ; }
public void function ( ) throws Exception { HttpResponse httpResponse = helper . putForResponse ( remoteUrl ( " /targets/2 " ) , Jsons . toJson ( resource1 ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 404 ) ) ; }
public boolean function ( ) { for ( Node child : childNodes ) { if ( child instanceof TextNode ) { TextNode textNode = ( TextNode ) child ; if ( ! textNode . isBlank ( ) ) return true ; } } return false ; }
public void function ( ) throws Exception { String url = WEBSITE_WITH_INVALID_CERTIFICATE ; Jsoup . connect ( url ) . execute ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; org . apache . http . HttpResponse httpResponse = helper . putForResponse ( remoteUrl ( " /targets/1 " ) , mapper . writeValueAsString ( resource1 ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; }
public static ResponseHandler function ( final ResponseHandler . . . arg0 ) { checkArgument ( arg0 . length > 0 , " seq contents should not be null " ) ; return seq ( copyOf ( arg0 ) ) ; }
public MessageContent function ( final Request arg0 ) { MessageContent messageContent = reader . readFor ( arg0 ) ; if ( transformer = = null ) { return messageContent ; } byte [ ] transformed = transformer . apply ( messageContent . getContent ( ) ) ; return MessageContent . content ( ) . withCharset ( messageContent . getCharset ( ) )
public void function ( ) { runWithConfiguration ( " get_method.json " ) ; assertThrows ( IOException . class , ( ) - > { helper . postContent ( remoteUrl ( " /get " ) , " " ) ;
protected Option function ( ) { Option opt = new Option ( " c " , true , " config " ) ; opt . setType ( String . class ) ; opt . setRequired ( false ) ; return opt ; }
public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( " http://www.baidu.com/ " ) . timeout ( 10 * 1000 ) . execute ( ) ; Document doc = res . parse ( ) ; assertEquals ( " GBK " , doc . outputSettings ( ) . charset ( ) . displayName ( ) ) ; assertEquals ( " GBK " , res . charset ( ) ) ; assert ( res . hasCookie ( " BAIDUID " ) ) ; assertEquals ( " text/html;charset=gbk " , res . contentType ( ) ) ; }
public FullHttpResponse function ( ) { FullHttpResponse response = new DefaultFullHttpResponse ( HttpVersion . valueOf ( this . version . text ( ) ) , HttpResponseStatus . valueOf ( this . status ) ) ; for ( Map . Entry < String , String > entry : getHeaders ( ) . entrySet ( ) ) { response . headers ( ) . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } response . content ( ) . writeBytes ( this . content . getBytes ( ) ) ; return response ; }
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return ApiUtils . match ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
public Request function ( Proxy arg0 ) { this . arg0 = arg0 ; return this ; }
protected void function ( LoggingEvent arg0 ) { setCallerBoundary ( DLEB_FQCN ) ; if ( logger instanceof LoggingEventAware ) { ( ( LoggingEventAware ) logger ) . log ( arg0 ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div class=left>One</div><div class=right id=1><p>Two</p></div> " ) ; Elements el1 = doc . select ( " div:not(.left) " ) ; assertEquals ( 1 , el1 . size ( ) ) ; assertEquals ( " 1 " , el1 . first ( ) . id ( ) ) ; }
void function ( FullHttpRequest arg0 , FullHttpResponse arg1 ) ; }
public Builder function ( Charset arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) throws Exception { try { new Mp3File ( new File ( NOT_AN_MP3 ) ) ;
public void function ( Locale arg0 ) { Locale . setDefault ( arg0 ) ; Document doc = Jsoup . parse ( " <div><p>The Rain.</p> <p class=light>The <i>RAIN</i>.</p> <p>Rain, the.</p></div> " ) ; Elements ps1 = doc . select ( " p:contains(Rain) " ) ; assertEquals ( 3 , ps1 . size ( ) ) ; Elements ps2 = doc . select ( " p:contains(the rain) " ) ; assertEquals ( 2 , ps2 . size ( ) ) ; assertEquals ( " The Rain. " , ps2 . first ( ) . html ( ) ) ; assertEquals ( " The <i>RAIN</i>. " , ps2 . last ( ) . html ( ) ) ; Elements ps3 = doc . select ( " p:contains(the Rain):has(i) " ) ; assertEquals ( 1 , ps3 . size ( ) ) ; assertEquals ( " light " , ps3 . first ( ) . className ( ) ) ; Elements ps4 = doc . select ( " .light:contains(rain) " ) ; assertEquals ( 1 , ps4 . size ( ) ) ; assertEquals ( " light " , ps3 . first ( ) . className ( ) ) ; Elements ps5 = doc . select ( " :contains(rain) " ) ; assertEquals ( 8 , ps5 . size ( ) ) ; Elements ps6 = doc . select ( " :contains(RAIN) " ) ; assertEquals ( 8 , ps6 . size ( ) ) ; }
public void function ( LoggingEvent arg0 ) { Level julLevel = slf4jLevelIntToJULLevel ( arg0 . getLevel ( ) . toInt ( ) ) ; if ( logger . isLoggable ( julLevel ) ) { LogRecord record = eventToRecord ( arg0 , julLevel ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.2.4 " ) ; assertEquals ( " NON-STRICT " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( Node arg0 , int arg1 ) { if ( arg0 instanceof Element ) { Element element = ( Element ) arg0 ;
private SocketServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { SocketServer socketServer = ActualSocketServer . createLogServer ( arg1 . getPort ( ) ) ; for ( RunnerSetting setting : arg0 ) { SocketServer parsedServer = socketParser . parseServer ( setting . getStreams ( ) , arg1 . getPort ( ) , toConfigs ( setting ) ) ; socketServer = mergeServer ( socketServer , parsedServer ) ; } return socketServer ; }
public void function ( ) { NDC . push ( " a " ) ; NDC . push ( " b " ) ; String result1 = NDC . pop ( ) ; String result0 = NDC . pop ( ) ; assertEquals ( " b " , result1 ) ; assertEquals ( " a " , result0 ) ; }
public Optional < MessageContent > function ( final Request arg0 ) { MessageContent content = arg0 . getContent ( ) ; if ( content . hasContent ( ) | | content . getContent ( ) . length > 0 ) { return of ( content ) ; } return empty ( ) ; }
public static < T extends ConfigApplier > ImmutableList < T > function ( List < T > arg0 , MocoConfig . . . arg1 ) { return from ( arg0 ) . transform ( Configs . < T > config ( arg1 ) ) . toList ( ) ; }
@Test public void function ( ) { Attributes attributes = new Attributes ( ) ; attributes . put ( " checked " , " CHECKED " ) ; Attribute attribute = attributes . iterator ( ) . next ( ) ; assertEquals ( " checked " , attribute . html ( ) ) ; assertEquals ( "  checked " , attributes . html ( ) ) ; }
public static Resource function ( final String arg0 ) { return uriResource ( checkNotNull ( arg0 , " URI should not be null " ) ) ; }
public boolean function ( Object arg0 ) { if ( arg0 instanceof Priority ) { Priority r = ( Priority ) arg0 ;
public void function ( final SessionContext arg0 ) { String content = responseContent ( arg0 . getRequest ( ) ) ; MutableHttpResponse httpResponse = arg0 . getHttpResponse ( ) ; httpResponse . setContent ( content ) ; httpResponse . addHeader ( HttpHeaders . CONTENT_LENGTH , content . getBytes ( ) . length ) ; if ( ! detector . hasContentType ( httpResponse ) ) { httpResponse . addHeader ( HttpHeaders . CONTENT_TYPE , getContentType ( arg0 . getRequest ( ) ) ) ;
public boolean function ( ) { return preserveAttributeCase ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.2.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 15 ) ;
public int function ( byte [ ] arg0 , int arg1 , int arg2 ) throws IOException { if ( Thread . interrupted ( ) | | capped & & remaining < = 0 ) return - 1 ; if ( capped & & arg2 > remaining ) arg2 = remaining ; final int read = super . read ( arg0 , arg1 , arg2 ) ; remaining - = read ; return read ; }
void function ( HttpRequest arg0 , MutableHttpResponse arg1 ) ; }
public void function ( final int arg0 , final ChannelHandler arg1 ) { Bootstrap bootstrap = new Bootstrap ( ) ; bootstrap . group ( group ) . channel ( NioSocketChannel . class ) . option ( ChannelOption . TCP_NODELAY , true ) . handler ( arg1 ) ; try { ChannelFuture f = bootstrap . connect ( " 127.0.0.1 " , arg0 ) . sync ( ) ;
public static < ExtractorType1 , ExtractorType2 > Resource function ( final ContentResource arg0 , final String arg1 , final RequestExtractor < ExtractorType1 > arg2 , final String arg3 , final RequestExtractor < ExtractorType2 > arg4 ) { return templateResource ( checkNotNull ( arg0 , " Template should not be null " ) , ImmutableMap . of ( checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
public boolean function ( int arg0 ) { return false ; }
private void function ( final Level arg0 , final ResourceBundle arg1 , final String arg2 , final Throwable arg3 , final Object . . . arg4 ) { final Level jplLevelReduced = fixExtremeLevels ( arg0 ) ; org . slf4j . event . Level slf4jLevel = jplLevelToSLF4JLevel ( jplLevelReduced ) ; boolean isEnabled = slf4jLogger . isEnabledForLevel ( slf4jLevel ) ; if ( isEnabled ) { performLog ( slf4jLevel , arg1 , arg2 , arg3 , arg4 ) ;
public void function ( String arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . WARNING ) ) { String msgStr = MessageFormatter . arg0 ( arg0 , arg1 ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String tagName = arg1 . consumeTagName ( ) ; arg0 . tagPending . appendTagName ( tagName ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\t' :
public void function ( ) { if ( this . uri = = null ) throw new NullPointerException ( " WebSocketClient must have a URI to connect to. See WebSocketClient#setURI " ) ; ( new Thread ( this ) ) . start ( ) ; }
public Predicate < SimpleRestSetting > function ( final String arg0 , final HttpRequest arg1 ) { return new Predicate < SimpleRestSetting > ( ) { @Override
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { WebSocket . DEBUG = true ; int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ChatServer s = new ChatServer ( port ) ; s . start ( ) ; System . out . println ( " ChatServer started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
final static public void function ( StringBuilder arg0 , int arg1 ) { while ( arg1 > = 32 ) { arg0 . append ( SPACES [ 5 ] ) ; arg1 - = 32 ; } for ( int i = 4 ; i > = 0 ; i - - ) { if ( ( arg1 & ( 1 < < i ) ) ! = 0 ) {
public TextNode function ( int arg0 ) { final String text = coreValue ( ) ; Validate . isTrue ( arg0 > = 0 , " Split offset must be not be negative " ) ; Validate . isTrue ( arg0 < text . length ( ) , " Split offset must not be greater than current text length " ) ; String head = text . substring ( 0 , arg0 ) ; String tail = text . substring ( arg0 ) ; text ( head ) ; TextNode tailNode = new TextNode ( tail , this . baseUri ( ) ) ; if ( parent ( ) ! = null ) parent ( ) . addChildren ( siblingIndex ( ) + 1 , tailNode ) ; return tailNode ; }
public void function ( ) { Profiler profiler = new Profiler ( " BAS " ) ; profiler . setLogger ( logger ) ; profiler . start ( " doX " ) ; doX ( 1 ) ; profiler . start ( " doYYYYY " ) ; for ( int i = 0 ; i < 5 ; i + + ) { doY ( i ) ; } Profiler nested = profiler . startNested ( " subtask " ) ; doSubtask ( nested ) ; profiler . start ( " doZ " ) ; doZ ( 2 ) ; profiler . stop ( ) ; profiler . sanityCheck ( ) ; StopWatch gSW = profiler . globalStopWatch ; assertEquals ( TimeInstrumentStatus . STOPPED , gSW . status ) ; assertEquals ( 4 , profiler . childTimeInstrumentList . size ( ) ) ; assertNotNull ( profiler . getLastTimeInstrument ( ) ) ; assertEquals ( " doZ " , profiler . getLastTimeInstrument ( ) . getName ( ) ) ;
public void function ( ) { ID3v2PopmFrameData iD3v2PopmFrameData = new ID3v2PopmFrameData ( false , 0 ) ; assertFalse ( iD3v2PopmFrameData . equals ( null ) ) ; }
public HttpServer function ( InputStream arg0 , Optional < Integer > arg1 , MocoConfig . . . arg2 ) { return createHttpServer ( reader . read ( arg0 , SessionSetting . class ) , arg1 , arg2 ) ; }
private Predicate < ? super GlobalSetting > function ( final Optional < String > arg0 ) { return new Predicate < GlobalSetting > ( ) { @Override
private void function ( ) throws IOException { this . service = FileSystems . getDefault ( ) . newWatchService ( ) ; this . running = true ; result = executor . submit ( ( ) - > { while ( running ) {
public static Document function ( arg0 InputStream arg1 , arg2 String arg3 , String arg4 , Parser arg5 ) throws IOException { return parseInputStream ( arg1 , arg3 , arg4 , arg5 ) ; }
public static UrlResource function ( String arg0 ) { try { return new UrlResource ( new URL ( checkNotNull ( arg0 , " Null url is not allowed " ) ) ) ;
private static void function ( Tokeniser arg0 , TokeniserState arg1 ) { char [ ] c = arg0 . consumeCharacterReference ( null , false ) ; if ( c = = null ) arg0 . emit ( '&' ) ; else arg0 . emit ( c ) ; arg0 . transition ( arg1 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private void function ( ) { tq . consume ( " :has " ) ; String subQuery = tq . chompBalanced ( '(' , ')' ) ; Validate . notEmpty ( subQuery , " :has(el) subselect must not be empty " ) ; s . push ( new HasSelector ( parse ( subQuery ) ) ) ;
@Test public void function ( ) throws IOException { long start = System . currentTimeMillis ( ) ; String url = " http://sv.stargate.wikia.com/wiki/M2J " ; Document doc = Jsoup . connect ( url ) . get ( ) ; assertEquals ( " M2J | Sv.stargate Wiki | FANDOM powered by Wikia " , doc . title ( ) ) ; assertEquals ( 110160 , doc . select ( " dd " ) . size ( ) ) ; assertTrue ( System . currentTimeMillis ( ) - start < 1000 ) ;
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { String value = resource . readFor ( of ( arg0 ) ) . toString ( ) ; arg1 . addHeader ( name , value ) ; }
public static HttpHeader function ( final String arg0 , final String arg1 ) { return new HttpHeader ( checkNotNullOrEmpty ( checkNotNullOrEmpty ( arg0 , " Header name should not be null " ) , " Header name should not be null " ) , checkNotNull ( ( Resource ) text ( checkNotNullOrEmpty ( arg1 , " Header value should not be null " ) ) , " Header value should not be null " ) ) ;
protected ClassicHttpRequest function ( final String arg0 , final Request arg1 ) { HttpPost targetRequest = new HttpPost ( arg0 ) ; targetRequest . setEntity ( asEntity ( content , arg1 ) ) ; return targetRequest ; }
private RequestMatcher function ( final String arg0 , final Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return by ( json ( arg1 ) ) ; } if ( arg1 instanceof Map ) { return createCompositeMatcher ( arg0 , castToMap ( arg1 ) ) ; } if ( arg1 instanceof TextContainer ) { return createSingleTextMatcher ( arg0 , ( TextContainer ) arg1 ) ; } if ( arg1 instanceof StructSetting ) { final StructSetting struct = ( StructSetting ) arg1 ; if ( struct . isJson ( ) ) { return Moco . struct ( json ( struct . getJson ( ) ) ) ; } } throw new IllegalArgumentException ( " unknown configuration : " + arg1 ) ; }
public void function ( ServiceReference arg0 , int arg1 , String arg2 ) { String output = createMessage ( arg0 , arg2 ) ; switch ( arg1 ) { case LOG_DEBUG :
public void function ( ) throws Exception { Plain resource = new Plain ( ) ; resource . code = 1 ; resource . message = " hello " ; server . resource ( " targets " , get ( anyId ( ) ) . response ( toJson ( resource ) ) ) ; running ( server , new Runnable ( ) { @Override
@Test public void function ( ) { String html = " <p>test<br/>test<br/></p> " ; Parser parser = Parser . htmlParser ( ) . setTrackErrors ( 5 ) ; parser . parseInput ( html , " " ) ; assertEquals ( 0 , parser . getErrors ( ) . size ( ) ) ; assertTrue ( Jsoup . isValid ( html , Safelist . basic ( ) ) ) ; String clean = Jsoup . clean ( html , Safelist . basic ( ) ) ; assertEquals ( " <p>test<br> \ n test<br></p> " , clean ) ; }
static DurationUnit function ( StopWatch arg0 ) { return selectDurationUnitForDisplay ( arg0 . elapsedTime ( ) ) ; }
public void function ( Thread arg0 , Throwable arg1 ) { log . error ( " Uncaught exception in thread {}: {} " , arg0 . getName ( ) , arg1 ) ; }
public void function ( ) { ID3v2 id3v2Tag = new ID3v2TagForTesting ( ) ; ID3Wrapper wrapper = new ID3Wrapper ( null , id3v2Tag ) ; wrapper . setTrack ( " a track " ) ; assertEquals ( " a track " , id3v2Tag . getTrack ( ) ) ; }
public void function ( ) throws IOException { InputStream stream = getResourceAsStream ( " settings/response-settings.json " ) ; runner = new SettingRunner ( stream , createStartArgs ( 12306 ) ) ; runner . run ( ) ; Header header = Request . Get ( remoteUrl ( " /foo " ) ) . execute ( ) . returnResponse ( ) . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; }
public static String function ( byte [ ] arg0 , int arg1 , int arg2 ) throws CharacterCodingException { CharsetDecoder encode = Charset . forName ( " UTF8 " ) . newDecoder ( ) ; encode . onMalformedInput ( codingErrorAction ) ; return encode . decode ( ByteBuffer . wrap ( arg0 , arg1 , arg2 ) ) . toString ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.1.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 750 ) ; }
public void function ( ) { { Object [ ] cyclicA = new Object [ 1 ] ; cyclicA [ 0 ] = cyclicA ; assertEquals ( " [[...]] " , MessageFormatter . arrayFormat ( " {} " , cyclicA ) . getMessage ( ) ) ; } { Object [ ] a = new Object [ 2 ] ;
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( message , param1 , param2 , param3 , exception ) ; break ; case DEBUG : logger . debug ( message , param1 , param2 , param3 , exception ) ; break ; case INFO : logger . info ( message , param1 , param2 , param3 , exception ) ; break ; case WARN : logger . warn ( message , param1 , param2 , param3 , exception ) ; break ; case ERROR : logger . error ( message , param1 , param2 , param3 , exception ) ; break ; } verifyMessageWithoutMarker ( arg0 , threeParams , exception ) ; }
public void function ( Exception arg0 ) { } } ; webSocket . connectBlocking ( ) ; assertTrue ( webSocket . isOpen ( ) ) ; webSocket . getSocket ( ) . close ( ) ; countDownLatch . await ( ) ; assertTrue ( ! webSocket . isOpen ( ) ) ; assertTrue ( ! wasOpenClient ) ; assertTrue ( ! wasOpenServer ) ; server . stop ( ) ; } }
public void function ( ) { CloseableHttpClient client = HttpClients . createDefault ( ) ; try { doExecute ( client ) ;
public void function ( String arg0 , Object [ ] arg1 ) { if ( log . isInfoEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 3.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 20 ) ; }
@Override public void function ( Node arg0 , int arg1 ) { if ( arg0 instanceof Element ) { Element element = ( Element ) arg0 ;
public void function ( int arg0 ) { JLabel lab ; lab = new JLabel ( " RUNNING CONVERTER WILL REPLACE  " + arg0 + "  JAVA FILES CONTAINED IN SELECTED FOLDER, DO YOU WANT TO CONTINUE ? " ) ; confirmationPan . add ( lab ) ; butNo = new JButton ( " No " ) ; butNo . addActionListener ( this ) ; confirmationPan . add ( butNo ) ; butYes = new JButton ( " Yes " ) ; butYes . addActionListener ( this ) ; confirmationPan . add ( butYes ) ; principalPan . add ( confirmationPan ) ; setSize ( 900 , 200 ) ; }
public Element function ( ) { return getElementsByTag ( " head " ) . get ( 0 ) ; }
public void function ( String arg0 ) { recordEvent_0Args ( Level . DEBUG , null , arg0 , null ) ; }
public T function ( final HttpProtocolVersion arg0 ) { this . arg0 = arg0 ; return clazz . cast ( this ) ; }
@Test ( expected = IllegalArgumentException . class ) public void function ( ) throws IOException { Connection con = HttpConnection . connect ( " http://example.com " ) ; con . response ( ) . parse ( ) ; }
public Element function ( ) { if ( parent ( ) ! = null ) {
public void function ( ) { Document doc = Jsoup . parse ( " <p>Hello<br>there<BR>now</p> " , Parser . htmlParser ( ) . settings ( ParseSettings . preserveCase ) ) ; assertEquals ( " Hello there now " , doc . text ( ) ) ; assertEquals ( " Hello there now " , doc . select ( " p " ) . first ( ) . ownText ( ) ) ; doc = Jsoup . parse ( " <p>Hello <br> there <BR> now</p> " ) ; assertEquals ( " Hello there now " , doc . text ( ) ) ; }
@Test public void function ( ) { String html = " <p =a>One<a <p>Something</p>Else " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <p =a= \" \" >One<a <p= \" \" >Something</a></p> \ n " + " <a <p= \" \" >Else</a> " , doc . body ( ) . html ( ) ) ; doc = Jsoup . parse ( " <p .....> " ) ; assertEquals ( " <p .....= \" \" ></p> " , doc . body ( ) . html ( ) ) ; }
public LoggingEventBuilder function ( String arg0 , Object arg1 ) { loggingEvent . addKeyValue ( arg0 , arg1 ) ; return this ; }
private Resource function ( final String arg0 , final FileContainer arg1 ) { Optional < Charset > charset = arg1 . getCharset ( ) ; String text = arg1 . getName ( ) . getText ( ) ; return asResource ( arg0 , Moco . text ( text ) , charset ) ;
public final void function ( final MutableHttpResponse arg0 ) { arg0 . addHeader ( " Access-Control-Allow-Credentials " , this . allowed ) ; }
public void function ( ) { String html = " <html><head></head><body style= \" color: red \"   \"  name \" ></body></html> " ; org . jsoup . nodes . Document jsoupDoc ; jsoupDoc = Jsoup . parse ( html ) ; Element body = jsoupDoc . select ( " body " ) . first ( ) ; assertTrue ( body . hasAttr ( " \" " ) ) ; assertTrue ( body . hasAttr ( " name \" " ) ) ; Document w3Doc = W3CDom . convert ( jsoupDoc ) ; String xml = W3CDom . asString ( w3Doc , W3CDom . OutputXml ( ) ) ; assertEquals ( " <?xml version= \" 1.0 \"  encoding= \" UTF-8 \" ?><html xmlns= \" http://www.w3.org/1999/xhtml \" ><head/><body _= \" \"  name_= \" \"  style= \" color: red \" /></html> " , xml ) ; }
public static ResponseHandler function ( final String arg0 ) { return new WebSocketBroadcastHandler ( checkNotNullOrEmpty ( arg0 , " Content should not be null " ) ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . request ( by ( uri ( " /global-request " ) ) ) . response ( " blah " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > {
public void function ( final Object arg0 , final ExtensionContext arg1 ) throws Exception { Class < ? > testInstanceClass = arg0 . getClass ( ) ; MocoHttpServer configuration = testInstanceClass . getAnnotation ( MocoHttpServer . class ) ; MocoCertificate certificate = testInstanceClass . getAnnotation ( MocoCertificate . class ) ; if ( configuration = = null ) { throw new IllegalStateException ( " No Moco server found. Please check if @MocoConfiguration is added. " ) ; } arg1 . getStore ( MOCO ) . put ( SERVER , runner ( newServer ( configuration , certificate ) ) ) ; }
protected RestSetting function ( final Optional < RequestMatcher > arg0 , final ResponseHandler arg1 ) { return new GetAllRestSetting ( arg0 , arg1 ) ; }
@Test public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( echoUrl ) . execute ( ) . bufferUp ( ) ; Document doc = res . parse ( ) ; assertTrue ( doc . title ( ) . contains ( " Environment " ) ) ; Document doc2 = res . parse ( ) ; assertTrue ( doc2 . title ( ) . contains ( " Environment " ) ) ; }
public static ResourceConfigApplier function ( final ContentResource arg0 , final ImmutableMap < String , String > arg1 ) { return new EmbeddedResourceConfigApplier ( arg0 ) { @Override
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.6.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 450 ) ; }
public void function ( String arg0 , Object arg1 ) { if ( isWarnEnabled ( ) ) { handle_1ArgsCall ( Level . WARN , null , arg0 , arg1 ) ;
public void function ( final SessionContext arg0 ) { this . handler . writeToResponse ( arg0 ) ; this . fireCompleteEvent ( arg0 . getRequest ( ) ) ; }
public void function ( LoggingEvent arg0 ) { int levelInt = arg0 . getLevel ( ) . toInt ( ) ; if ( ! isLevelEnabled ( levelInt ) ) { return ; } FormattingTuple tp = MessageFormatter . arrayFormat ( arg0 . getMessage ( ) , arg0 . getArgumentArray ( ) , arg0 . getThrowable ( ) ) ; log ( levelInt , tp . getMessage ( ) , arg0 . getThrowable ( ) ) ; }
Element function ( Element arg0 ) { assert onStack ( arg0 ) ; Iterator < Element > it = stack . descendingIterator ( ) ; while ( it . hasNext ( ) ) { Element next = it . next ( ) ; if ( next = = arg0 ) { return it . next ( ) ; } } return null ; }
public Elements function ( ) { Elements clone ; try { clone = ( Elements ) super . clone ( ) ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; } List < Element > elements = new ArrayList < Element > ( ) ; clone . contents = elements ; for ( Element e : contents ) elements . add ( e . clone ( ) ) ; return clone ; }
public void function ( Opcode arg0 , ByteBuffer arg1 , boolean arg2 ) { send ( draft . continuousFrame ( arg0 , arg1 , arg2 ) ) ; }
public void function ( ServerHandshake arg0 ) { countDownLatch1 . countDown ( ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( html ) ; NodeIterator < Element > it = new NodeIterator < > ( doc , Element . class ) ; StringBuilder seen = new StringBuilder ( ) ; while ( it . hasNext ( ) ) { Element el = it . next ( ) ; if ( ! el . ownText ( ) . isEmpty ( ) ) el . text ( el . ownText ( ) + " ++ " ) ; trackSeen ( el , seen ) ; } assertEquals ( " #root;html;head;body;div#1;p;p;div#2;p;p; " , seen . toString ( ) ) ; assertContents ( doc , " #root;html;head;body;div#1;p;One++;p;Two++;div#2;p;Three++;p;Four++; " ) ; }
default MessageContent function ( final Function < Request , Object > arg0 , final Request arg1 ) { Object value = checkApply ( arg0 , arg1 ) ; if ( value instanceof String ) { return MessageContent . content ( ( String ) value ) ; } if ( value instanceof Resource ) { Resource resource = ( Resource ) value ; return resource . readFor ( arg1 ) ; } if ( value instanceof InputStream ) { return MessageContent . content ( ) . withContent ( ( InputStream ) value ) . build ( ) ; } return this . defaultRead ( value ) ; }
public void function ( Bundle arg0 , ServiceRegistration arg1 , Object arg2 ) { } }
public void function ( ) throws Exception { removeHandlers ( Logger . getLogger ( " TEST " ) ) ; }
protected void function ( Reader arg0 , String arg1 , ParseErrorList arg2 , ParseSettings arg3 ) { super . initialiseParse ( arg0 , arg1 , arg2 , arg3 ) ; state = HtmlTreeBuilderState . Initial ; originalState = null ; baseUriSetFromDoc = false ; headElement = null ; formElement = null ; contextElement = null ; formattingElements = new ArrayList < > ( ) ; pendingTableCharacters = new ArrayList < > ( ) ; emptyEnd = new Token . EndTag ( ) ; framesetOk = true ; fosterInserts = false ; fragmentParsing = false ; }
public FileContainerBuilder function ( final String arg0 ) { this . arg0 = arg0 ; return this ; }
public ByteBuffer function ( Framedata arg0 ) { getExtension ( ) . encodeFrame ( arg0 ) ; log . trace ( " afterEnconding({}): {} " , arg0 . getPayloadData ( ) . remaining ( ) , ( arg0 . getPayloadData ( ) . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . getPayloadData ( ) . array ( ) ) ) ) ; return createByteBufferFromFramedata ( arg0 ) ; }
public void function ( ) throws IOException { assertThat ( helper . get ( remoteUrl ( " /proxy " ) ) , is ( " get_proxy " ) ) ; }
public void function ( ) { slf4jMessageFormatter_OneArg ( RUN_LENGTH ) ; double duration = slf4jMessageFormatter_OneArg ( RUN_LENGTH ) ; long referencePerf = 36 ; BogoPerf . assertDuration ( duration , referencePerf , REFERENCE_BIPS ) ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isInfoEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( ! ( arg0 instanceof Attributes ) ) return false ; Attributes that = ( Attributes ) arg0 ; if ( attributes ! = null ? ! attributes . equals ( that . attributes ) : that . attributes ! = null ) return false ; return true ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>Hello <b>there</b> now " ) ; Element p = doc . select ( " p " ) . first ( ) ; assertEquals ( " Hello there now " , p . text ( ) ) ; assertEquals ( " Hello now " , p . ownText ( ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { lbLogger . debug ( TRACE_MARKER , convertToString ( arg0 ) , arg1 ) ; }
public void function ( ) throws Exception { server . request ( eq ( xpath ( " /response/parameters/id/text() " ) , " 3 " ) ) . response ( " foo " ) ; running ( server , ( ) - > helper . postFile ( root ( ) , " foo.xml " ) ) ; }
public void function ( ) throws Exception { server . request ( by ( " foo " ) ) . response ( line ( " bar " ) ) ; server . request ( by ( " bar " ) ) . response ( line ( " blah " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { Mp3RenameForTesting mp3Rename = new Mp3RenameForTesting ( " 10 " , ARTIST , TITLE , ALBUM , YEAR , GENRE ) ; String newFilename = mp3Rename . composeNewFilename ( " WHATEVER " , " @N " ) ; assertEquals ( " 10 " , newFilename ) ; mp3Rename = new Mp3RenameForTesting ( " 108 " , ARTIST , TITLE , ALBUM , YEAR , GENRE ) ; newFilename = mp3Rename . composeNewFilename ( " WHATEVER " , " @N " ) ; assertEquals ( " 108 " , newFilename ) ; mp3Rename = new Mp3RenameForTesting ( " 5-21 " , ARTIST , TITLE , ALBUM , YEAR , GENRE ) ; newFilename = mp3Rename . composeNewFilename ( " WHATEVER " , " @N " ) ; assertEquals ( " 5-21 " , newFilename ) ; }
public static RestSetting function ( final String arg0 , final ResponseHandler . . . arg1 ) { return new PutRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , Optional . < RequestMatcher > absent ( ) ,
public SocketChannel function ( SelectionKey arg0 ) { return ( SocketChannel ) arg0 . channel ( ) ; }
public HttpsArgs function ( ) { return new HttpsArgs ( port , shutdownPort , configurationFile , settings , env , httpsArg ) ; }
public void function ( Matcher arg0 , String arg1 ) { logger . info ( " replacing into " + arg1 ) ; arg1 = arg0 . replaceAll ( " " ) ; logger . info ( " new line  " + arg1 ) ; }
public static void function ( String [ ] arg0 ) throws UnknownHostException { WebSocketImpl . DEBUG = false ; int port ; try { port = new Integer ( arg0 [ 0 ] ) ; } catch ( Exception e ) { System . out . println ( " No port specified. Defaulting to 9003 " ) ; port = 9003 ; } AutobahnServerTest test = new AutobahnServerTest ( port , new Draft_6455 ( ) ) ; test . setConnectionLostTimeout ( 0 ) ; test . start ( ) ; }
public boolean function ( ) { return clientNoContextTakeover ; }
@Test public void function ( ) { Tag p1 = Tag . valueOf ( " p " ) ; Tag p2 = Tag . valueOf ( "  p  " ) ; assertEquals ( p1 , p2 ) ; }
private Range function ( final List < ? > arg0 ) { final Object start = arg0 . get ( 0 ) ; final Object end = arg0 . get ( 1 ) ; if ( start instanceof SimpleNumber & & end instanceof SimpleNumber ) { return getDoubleRange ( ( SimpleNumber ) start , ( SimpleNumber ) end ) ; } if ( start instanceof SimpleNumber ) { return getSingleRange ( ( SimpleNumber ) start ) ; } throw new IllegalArgumentException ( " Range should be number " ) ; }
public void function ( Marker arg0 , String arg1 ) { if ( ! logger . isDebugEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . DEBUG_INT , arg1 , null , null ) ;
protected byte [ ] function ( ) { byte [ ] bytes = address . getBytes ( ) ; bytes = Arrays . copyOf ( bytes , address . length ( ) + 2 ) ; bytes [ bytes . length - 2 ] = 0 ; bytes [ bytes . length - 1 ] = wmp9encodedRatings [ rating ] ; return bytes ; }
private void function ( ByteBuffer arg0 ) { if ( flushandclosestate ) return ; List < Framedata > frames ; try { frames = draft . translateFrame ( arg0 ) ;
public int function ( byte [ ] arg0 , int arg1 , int arg2 ) throws IOException { if ( interrupted | | capped & & remaining < = 0 ) return - 1 ; if ( Thread . currentThread ( ) . isInterrupted ( ) ) { interrupted = true ; return - 1 ; } if ( expired ( ) ) throw new SocketTimeoutException ( " Read timeout " ) ; if ( capped & & arg2 > remaining ) arg2 = remaining ; try { final int read = super . read ( arg0 , arg1 , arg2 ) ;
public void function ( String arg0 , Object [ ] arg1 ) { if ( log . isErrorEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public void function ( ) throws Exception { httpServer = httpsServer ( 12306 , DEFAULT_CERTIFICATE , context ( " /foo " ) ) ; httpServer . response ( " foo " ) ; HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , ( ) - > assertThat ( helper . get ( remoteHttpsUrl ( " /foo/anything " ) ) , is ( " foo " ) ) ) ; }
public static ResponseHandler function ( final String arg0 , final RecorderTape arg1 , final ContentResource arg2 ) { return new DynamicRecordHandler ( RecorderRegistry . registryOf ( arg0 , new TapeRecorderFactory ( arg1 ) ) , arg2 ) ;
public void function ( ) { conn = null ; client = null ; selector = null ; running = false ; draft = null ; }
public void function ( String arg0 , Object [ ] arg1 ) { if ( isTraceEnabled ( ) ) { String msgStr = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
protected void function ( ) throws Exception { System . clearProperty ( CONFIG_FILE_KEY ) ; super . tearDown ( ) ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " testMarker " ) ; listAppender . extractLocationInfo = true ; logger . atDebug ( ) . log ( " hello " ) ; LoggingEvent event = listAppender . list . get ( 0 ) ; assertEquals ( this . getClass ( ) . getName ( ) , event . getLocationInformation ( ) . getClassName ( ) ) ; }
private Document function ( ) { while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( " <!-- " ) ) { parseComment ( ) ; } else if ( tq . matches ( " <![CDATA[ " ) ) { parseCdata ( ) ; } else if ( tq . matches ( " <? " ) | | tq . matches ( " <! " ) ) { parseXmlDecl ( ) ; } else if ( tq . matches ( " </ " ) ) { parseEndTag ( ) ; } else if ( tq . matches ( " < " ) ) { parseStartTag ( ) ; } else { parseTextNode ( ) ; } } return doc . normalise ( ) ; }
public static RestIdMatcher function ( final String arg0 ) { return new RestIdMatcher ( ) { @Override
public final boolean function ( final String arg0 ) { return TAPE . equalsIgnoreCase ( arg0 ) ; }
private final String function ( Object arg0 ) { if ( arg0 = = null ) { return ( String ) arg0 ;
public void function ( ) throws IOException { assertThat ( helper . postBytes ( root ( ) , toByteArray ( new File ( " src/test/resources/gbk.response " ) ) , gbk ) , is ( " bar " ) ) ;
@Test void function ( ) { Document doc = Jsoup . parse ( " <div><a id=1>One</a> Two <a id=2>Three<b>Four</a><a id=3>Five</a></div> " ) ; String expect = " div;a#1;a#2;b;b;a#3; " ; Element div = doc . expectFirst ( " div " ) ; StringBuilder seen = new StringBuilder ( ) ; for ( Element el : div ) { trackSeen ( el , seen ) ; } assertEquals ( expect , seen . toString ( ) ) ; seen = new StringBuilder ( ) ; Iterator < Element > iterator = div . iterator ( ) ; assertIterates ( iterator , expect ) ; }
public void function ( ) throws IOException { String url = FileServlet . urlTo ( " /htmltests/large.html " ) ; Connection . Response defaultRes = Jsoup . connect ( url ) . execute ( ) ; Connection . Response smallRes = Jsoup . connect ( url ) . maxBodySize ( 50 * 1024 ) . execute ( ) ; Connection . Response mediumRes = Jsoup . connect ( url ) . maxBodySize ( 200 * 1024 ) . execute ( ) ; Connection . Response largeRes = Jsoup . connect ( url ) . maxBodySize ( 300 * 1024 ) . execute ( ) ; Connection . Response unlimitedRes = Jsoup . connect ( url ) . maxBodySize ( 0 ) . execute ( ) ; int actualDocText = 280735 ; assertEquals ( actualDocText , defaultRes . body ( ) . length ( ) ) ; assertEquals ( 50 * 1024 , smallRes . body ( ) . length ( ) ) ; assertEquals ( 200 * 1024 , mediumRes . body ( ) . length ( ) ) ; assertEquals ( actualDocText , largeRes . body ( ) . length ( ) ) ; assertEquals ( actualDocText , unlimitedRes . body ( ) . length ( ) ) ; }
public boolean function ( String arg0 ) { Validate . notEmpty ( arg0 , " Header name must not be empty " ) ; return headers . containsKey ( arg0 ) ; }
public boolean function ( final Request arg0 ) { for ( RequestMatcher matcher : matchers ) { if ( matcher . match ( arg0 ) ) { return true ; } } return false ; }
public void function ( ) { assertThat ( URLs . isValidUrl ( " base " ) , is ( true ) ) ; assertThat ( URLs . isValidUrl ( " base path " ) , is ( false ) ) ; }
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { String html = Entities . escape ( getWholeText ( ) , arg2 ) ; if ( arg2 . prettyPrint ( ) & & parent ( ) instanceof Element & & ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( arg2 . prettyPrint ( ) & & ( ( siblingIndex ( ) = = 0 & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . formatAsBlock ( ) & & ! isBlank ( ) ) | | ( arg2 . forceAllElementAsBlock ( ) & & siblingNodes ( ) . size ( ) > 0 & & ! isBlank ( ) ) ) ) indent ( arg0 , arg1 , arg2 ) ; arg0 . append ( html ) ; }
protected void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { String requestOrigin = arg0 . getHeader ( " Origin " ) ; if ( Strings . isNullOrEmpty ( requestOrigin ) ) { return ; } if ( configs . length = = 0 ) { arg1 . addHeader ( " Access-Control-Allow-Origin " , " * " ) ; arg1 . addHeader ( " Access-Control-Allow-Methods " , " * " ) ; arg1 . addHeader ( " Access-Control-Allow-Headers " , " * " ) ; return ; } for ( CorsConfig config : configs ) { config . configure ( arg0 , arg1 ) ;
public void function ( Framedata arg0 ) throws InvalidFrameException { if ( unmaskedpayload = = null ) { unmaskedpayload = ByteBuffer . wrap ( arg0 . getPayloadData ( ) ) ; } else { ByteBuffer tmp = ByteBuffer . allocate ( arg0 . getPayloadData ( ) . length + unmaskedpayload . capacity ( ) ) ; tmp . put ( unmaskedpayload . array ( ) ) ; tmp . put ( arg0 . getPayloadData ( ) ) ; unmaskedpayload = tmp ; } fin = arg0 . isFin ( ) ; }
public LoggingEventBuilder function ( Object arg0 ) { loggingEvent . addArgument ( arg0 ) ; return this ; }
public boolean function ( ) { return ( referenceList . size ( ) > 0 ) ; }
public List < Framedata > function ( ByteBuffer arg0 ) throws InvalidDataException { while ( true ) { List < Framedata > frames = new LinkedList < Framedata > ( ) ;
public boolean function ( String arg0 ) { String [ ] requestedExtensions = arg0 . split ( " , " ) ; for ( String extension : requestedExtensions ) if ( EXTENSION_REGISTERED_NAME . equalsIgnoreCase ( extension . trim ( ) ) ) return true ; return false ; }
private void function ( byte [ ] arg0 ) throws IOException , NoSuchAlgorithmException { byte [ ] handshakeBytes = this . remoteHandshake . array ( ) ; String handshake = new String ( handshakeBytes , UTF8_CHARSET ) ; this . handshakeComplete = true ; if ( this . wsl . onHandshakeRecieved ( this , handshake , arg0 ) ) { this . wsl . onOpen ( this ) ;
private HttpServer function ( final StartArgs arg0 ) { final int port = arg0 . getPort ( ) . orElse ( 0 ) ; Optional < Integer > contentLength = arg0 . getContentLength ( ) ; if ( contentLength . isPresent ( ) ) { if ( arg0 . isHttps ( ) ) { return ActualHttpServer . createHttpsServer ( port , arg0 . getHttpsCertificate ( ) . get ( ) , arg0 . isQuiet ( ) , contentLength . get ( ) ) ; } return ActualHttpServer . createHttpServer ( port , arg0 . isQuiet ( ) , contentLength . get ( ) ) ; } return doCreateHttpServer ( arg0 , port ) ; }
public static RequestMatcher function ( final String arg0 ) { return by ( text ( checkNotNull ( arg0 , " Content should not be null " ) ) ) ; }
protected void function ( final SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; pipeline . addLast ( " decoder " , new StringDecoder ( ) ) ; pipeline . addLast ( " handler " , new ShutdownHandler ( ) ) ; }
protected Resource function ( final MocoConfig arg0 ) { return templateResource ( ( ContentResource ) template . apply ( arg0 ) , variables ) ; }
public static String function ( ) { HelpFormatter formatter = new HelpFormatter ( ) ; StringWriter textWriter = new StringWriter ( ) ; PrintWriter writer = new PrintWriter ( textWriter ) ; formatter . printHelp ( writer , HelpFormatter . DEFAULT_WIDTH , " moco start [options] " , null , parser . createMocoOptions ( ) , HelpFormatter . DEFAULT_LEFT_PAD , HelpFormatter . DEFAULT_DESC_PAD , null ) ; writer . flush ( ) ; return textWriter . toString ( ) ; }
public void function ( ) { MocoHttpServer server = new MocoHttpServer ( new ActualHttpServer ( 8080 ) ) ; server . start ( ) ; server . stop ( ) ; server . stop ( ) ; }
public Builder function ( final String arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) throws Exception { runTestScenario ( 0 ) ; }
private void function ( Element arg0 ) { List < Node > toMove = new ArrayList < Node > ( ) ; for ( Node node : arg0 . childNodes ) { if ( node instanceof TextNode ) { TextNode tn = ( TextNode ) node ; if ( ! tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( int i = toMove . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = toMove . get ( i ) ;
public List < Framedata > function ( Opcode arg0 , ByteBuffer arg1 , boolean arg2 ) { if ( arg0 ! = Opcode . BINARY & & arg0 ! = Opcode . TEXT ) { throw new IllegalArgumentException ( " Only Opcode.BINARY or  Opcode.TEXT are allowed " ) ; } DataFrame bui = null ; if ( continuousFrameType ! = null ) { bui = new ContinuousFrame ( ) ; } else { continuousFrameType = arg0 ; if ( arg0 = = Opcode . BINARY ) { bui = new BinaryFrame ( ) ; } else if ( arg0 = = Opcode . TEXT ) { bui = new TextFrame ( ) ; } } bui . setPayload ( arg1 ) ; bui . setFin ( arg2 ) ; try { bui . isValid ( ) ; } catch ( InvalidDataException e ) { throw new IllegalArgumentException ( e ) ; } if ( arg2 ) { continuousFrameType = null ; } else { continuousFrameType = arg0 ; } return Collections . singletonList ( ( Framedata ) bui ) ; }
@Test void function ( ) { String xml = " <p>One</p><title>Two</title><data>Three</data> " ; Document doc = Jsoup . parse ( xml , TrackingXmlParser ) ; Elements els = doc . children ( ) ; for ( Element el : els ) { assertTrue ( el . sourceRange ( ) . isTracked ( ) ) ;
protected Runner function ( String [ ] arg0 ) { StartArgs startArgs = parse ( ServerType . HTTP , arg0 ) ; return factory . createRunner ( startArgs ) ; }
public Builder function ( HttpProtocolVersion arg0 ) { this . arg0 = arg0 ; return this ; }
protected void function ( HttpRequest arg0 , FullHttpResponse arg1 , arg2 . arg3 . arg4 . HttpResponse arg5 ) throws IOException { int statusCode = arg5 . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode = = HttpResponseStatus . BAD_REQUEST . code ( ) ) { failover . failover ( arg0 , arg1 ) ; return ; } setupNormalResponse ( arg1 , arg5 ) ; failover . onCompleteResponse ( arg0 , arg1 ) ; }
void function ( ) { if ( bufMark = = - 1 ) throw new UncheckedIOException ( new IOException ( " Mark invalid " ) ) ; bufPos = bufMark ; unmark ( ) ; }
public void function ( Object arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . WARNING ) ) { if ( arg0 instanceof String ) {
public boolean function ( Field arg0 ) { return Modifier . isFinal ( arg0 . getModifiers ( ) ) ; }
public static String function ( HttpMessage arg0 ) { long length = getContentLength ( arg0 , - 1 ) ; if ( length > 0 ) { return StringUtil . NEWLINE + StringUtil . NEWLINE + contentForDump ( arg0 ) ; } return " " ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 2.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 30 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " json.json " ) ; assertThat ( helper . postContent ( remoteUrl ( " /json " ) , " { \ n \ t \" foo \" : \" bar \" \ n} " ) , is ( " response_for_json_request " ) ) ; }
public void function ( ) throws IOException { sslEngine . closeOutbound ( ) ; sslEngine . getSession ( ) . invalidate ( ) ; try { if ( socketChannel . isOpen ( ) ) {
public static RequestExtractor < String > function ( final String arg0 ) { return new CookieRequestExtractor ( checkNotNull ( arg0 , " Cookie key should not be null " ) ) ; }
@Test public void function ( ) { String html = " <p id=0><span>A</p> <p id=1><b><i><span>B</p> <p id=2><i>C</p> \ n " ; Document doc = Jsoup . parse ( html ) ; Elements els = doc . select ( " p:has(> span, > i) " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " 0 " , els . get ( 0 ) . id ( ) ) ; assertEquals ( " 2 " , els . get ( 1 ) . id ( ) ) ; }
default public LoggingEventBuilder function ( ) { if ( isTraceEnabled ( ) ) { return makeLoggingEventBuilder ( TRACE ) ;
@Test public void function ( ) { String html = " <p \ n<p<div id=one <span>Two " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <p></p><p></p><div id= \" one \" ><span>Two</span></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
public void function ( ) { final Document doc = createHtmlDocument ( " changeThis " ) ; doc . updateMetaCharset ( true ) ; doc . charset ( Charset . forName ( charsetIso8859 ) ) ; final String htmlCharsetISO = " <html> \ n " + "  <head> \ n " + "   <meta charset= \" " + charsetIso8859 + " \" > \ n " + "  </head> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( htmlCharsetISO , doc . toString ( ) ) ; Element selectedElement = doc . select ( " meta[charset] " ) . first ( ) ; assertEquals ( charsetIso8859 , doc . charset ( ) . name ( ) ) ; assertEquals ( charsetIso8859 , selectedElement . attr ( " charset " ) ) ; assertEquals ( doc . charset ( ) , doc . outputSettings ( ) . charset ( ) ) ; }
private void function ( Level arg0 , Marker arg1 , Object [ ] arg2 , Throwable arg3 ) { assertEquals ( " missing event:  " , 1 , queue . size ( ) ) ; SubstituteLoggingEvent event = queue . poll ( ) ; assertNotNull ( event ) ; if ( arg1 = = null ) { assertNull ( event . getMarkers ( ) ) ; } else { assertEquals ( arg1 , event . getMarkers ( ) . get ( 0 ) ) ; } assertEquals ( message , event . getMessage ( ) ) ; if ( arg2 = = null ) { assertNull ( event . getArgumentArray ( ) ) ; } else { assertArrayEquals ( arg2 , event . getArgumentArray ( ) ) ; } assertEquals ( " wrong level:  " , arg0 , event . getLevel ( ) ) ; if ( arg3 = = null ) { assertNull ( event . getThrowable ( ) ) ;
public void function ( String arg0 ) { attributes . remove ( arg0 ) ; }
public void function ( ) throws IOException { stream = getResourceAsStream ( " settings/response-settings.json " ) ; runner = new SettingRunner ( stream , createStartArgs ( 12306 ) ) ; runner . run ( ) ; Header header = helper . getResponse ( remoteUrl ( " /foo " ) ) . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; }
protected static boolean function ( ) { throw new UnsupportedOperationException ( " Operation [isDiagnosticsEnabled] is not supported in jcl-over-slf4j. See also  " + UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J ) ;
public final Builder function ( final String arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( final UnexpectedRequestMatcher arg0 , final VerificationMode arg1 ) { arg1 . verify ( new VerificationData ( copyOf ( unexpectedRequests ) , arg0 , " expect unexpected request hit %s times but %d times " ) ) ; }
@Test public void function ( ) { String html = " <!doctype HTML><IMG ALT=One></DIV> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <!doctype html> <html> <head></head> <body> <img alt= \" One \" > </body> </html> " , StringUtil . normaliseWhitespace ( doc . outerHtml ( ) ) ) ; }
public String function ( final Response arg0 ) { return arg0 . getContent ( ) . toString ( ) ; }
public void function ( String arg0 , Object . . . arg1 ) { delegate ( ) . trace ( arg0 , arg1 ) ; }
public void function ( Exception arg0 ) { ta . append ( " Exception occurred ... \ n " + arg0 + " \ n " ) ; ta . setCaretPosition ( ta . getDocument ( ) . getLength ( ) ) ; arg0 . printStackTrace ( ) ; connect . setEnabled ( true ) ; uriField . setEditable ( true ) ; draft . setEditable ( true ) ; close . setEnabled ( false ) ; }
protected Optional < ImmutableMap < String , String > > function ( HttpRequest arg0 ) { HttpPostRequestDecoder decoder = null ; try { decoder = new HttpPostRequestDecoder ( ( ( DefaultHttpRequest ) arg0 ) . toFullHttpRequest ( ) ) ;
private void function ( ) { String tagName = tq . consumeElementSelector ( ) ; Validate . notEmpty ( tagName ) ; if ( tagName . contains ( " | " ) ) tagName = tagName . replace ( " | " , " : " ) ; s . add ( new Evaluator . Tag ( tagName . trim ( ) . toLowerCase ( ) ) ) ; }
public List < Framedata > function ( byte [ ] arg0 , boolean arg1 ) { FrameBuilder curframe = new FramedataImpl1 ( ) ; curframe . setPayload ( arg0 ) ; curframe . setFin ( true ) ; curframe . setOptcode ( Opcode . BINARY ) ; curframe . setTransferemasked ( arg1 ) ; return Collections . singletonList ( ( Framedata ) curframe ) ; }
public JsonResponseHandler function ( final ResponseHandler arg0 ) { return JsonResponseHandler . class . cast ( arg0 ) ; }
public Element function ( int arg0 , Collection < ? extends Node > arg1 ) { Validate . notNull ( arg1 , " Children collection to be inserted must not be null. " ) ; int currentSize = childNodeSize ( ) ; if ( arg0 < 0 ) arg0 + = currentSize + 1 ; Validate . isTrue ( arg0 > = 0 & & arg0 < = currentSize , " Insert position out of bounds. " ) ; ArrayList < Node > nodes = new ArrayList < > ( arg1 ) ; Node [ ] nodeArray = nodes . toArray ( new Node [ nodes . size ( ) ] ) ; addChildren ( arg0 , nodeArray ) ; return this ; }
public static ResponseHandler function ( final String arg0 , final ContentResource arg1 ) { return new DynamicReplayHandler ( RecorderRegistry . registryOf ( arg0 , IN_MEMORY ) , arg1 , template ( " ${req.content} " ) ) ;
public void function ( HttpServer arg0 ) { runner = runner ( arg0 ) ; runner . start ( ) ; logger . info ( " Server is started at {} " , arg0 . port ( ) ) ; }
public void function ( ) throws IOException { String url = " http://direct.infohound.net/tools/bad-charset.pl " ; Connection . Response res = Jsoup . connect ( url ) . execute ( ) ; assertEquals ( " text/html; charset=UFT8 " , res . header ( " Content-Type " ) ) ; assertEquals ( null , res . charset ( ) ) ; Document doc = res . parse ( ) ; assertTrue ( doc . text ( ) . contains ( " Hello! " ) ) ; assertEquals ( " UTF-8 " , res . charset ( ) ) ; }
public void function ( Marker arg0 , String arg1 , int arg2 , String arg3 , Throwable arg4 ) { Level julLevel ; switch ( arg2 ) { case LocationAwareLogger . DEBUG_INT : julLevel = Level . FINE ; break ; case LocationAwareLogger . INFO_INT : julLevel = Level . INFO ; break ; case LocationAwareLogger . WARN_INT : julLevel = Level . WARNING ; break ; case LocationAwareLogger . ERROR_INT : julLevel = Level . SEVERE ; break ; default : throw new IllegalStateException ( " Level number  " + arg2 + "  is not recognized. " ) ; } log ( arg1 , julLevel , arg3 , arg4 ) ; }
public void function ( ) throws IOException { helper . postContent ( remoteUrl ( " /foo " ) , " " ) ; }
public void function ( ) throws Exception { HttpResponse response = helper . getResponse ( root ( ) ) ; Header header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; response = helper . getResponse ( root ( ) ) ; header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; }
public void function ( ) throws Exception { try { Mp3RetagForTesting mp3Retag = new Mp3RetagForTesting ( TEST_FILE_WITH_ALL_TAGS_SET ) ;
protected ResponseHandler function ( ) { return configured ( this . handler ) ; }
public synchronized Iterator < Marker > function ( ) { if ( refereceList ! = null ) { return refereceList . iterator ( ) ;
protected void function ( HttpServletRequest arg0 , HttpServletResponse arg1 ) throws IOException { pause ( 1000 ) ; arg1 . setContentType ( TextHtml ) ; arg1 . setStatus ( HttpServletResponse . SC_OK ) ; PrintWriter w = arg1 . getWriter ( ) ; int maxTime = - 1 ; String maxTimeP = arg0 . getParameter ( MaxTimeParam ) ; if ( maxTimeP ! = null ) { maxTime = Integer . valueOf ( maxTimeP ) ; } long startTime = System . currentTimeMillis ( ) ; while ( true ) { w . println ( " <p>Are you still there? " ) ;
public void function ( ) throws Exception { HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeHttpServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public Optional < String > function ( final HttpRequest arg0 ) { return of ( target . extract ( extractor . extract ( arg0 ) . get ( ) ) ) ; }
protected Option function ( ) { Option option = new Option ( null , " cert " , true , " Cert password " ) ; option . setType ( String . class ) ; option . setRequired ( false ) ; return option ; }
private static Level function ( arg0 . arg1 . arg2 . Level arg3 ) { Level julLevel ; switch ( arg3 ) { case TRACE : julLevel = Level . FINEST ; break ; case DEBUG : julLevel = Level . FINE ; break ; case INFO : julLevel = Level . INFO ; break ; case WARN : julLevel = Level . WARNING ; break ; case ERROR : julLevel = Level . SEVERE ; break ; default : throw new IllegalStateException ( " Level  " + arg3 + "  is not recognized. " ) ; } return julLevel ; }
boolean function ( ) { if ( isEmpty ( ) ) return false ; char c = input [ pos ] ; return ( c > = '0' & & c < = '9' ) ; }
boolean function ( Token arg0 ) { currentToken = arg0 ; return this . state . process ( arg0 , this ) ; }
protected void function ( ) throws Exception { super . tearDown ( ) ; felixHost . stop ( ) ; }
FormElement function ( Token . StartTag arg0 , boolean arg1 ) { Tag tag = Tag . valueOf ( arg0 . name ( ) , settings ) ; FormElement el = new FormElement ( tag , null , settings . normalizeAttributes ( arg0 . attributes ) ) ; setFormElement ( el ) ; insertNode ( el ) ; if ( arg1 ) stack . add ( el ) ; return el ; }
public void function ( ) { byte b = - 0x36 ; assertEquals ( - 0x36 , BufferTools . setBit ( b , 7 , true ) ) ; assertEquals ( - 0x35 , BufferTools . setBit ( b , 0 , true ) ) ; assertEquals ( - 0x26 , BufferTools . setBit ( b , 4 , true ) ) ; assertEquals ( - 0x36 , BufferTools . setBit ( b , 0 , false ) ) ; assertEquals ( 0x4A , BufferTools . setBit ( b , 7 , false ) ) ; assertEquals ( - 0x3E , BufferTools . setBit ( b , 3 , false ) ) ; }
protected Resource function ( MocoConfig arg0 ) { return templateResource ( ( ContentResource ) template . apply ( arg0 ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.23.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public static < T > T function ( final String arg0 , final Class < T > arg1 ) { try { return mapper . readValue ( arg0 , arg1 ) ;
public static Level function ( String arg0 , Level arg1 ) { if ( arg0 = = null ) return arg1 ; String s = arg0 . toUpperCase ( ) ; if ( s . equals ( " ALL " ) ) return Level . ALL ; if ( s . equals ( " DEBUG " ) ) return Level . DEBUG ; if ( s . equals ( " INFO " ) ) return Level . INFO ; if ( s . equals ( " WARN " ) ) return Level . WARN ; if ( s . equals ( " ERROR " ) ) return Level . ERROR ; if ( s . equals ( " FATAL " ) ) return Level . FATAL ; if ( s . equals ( " OFF " ) ) return Level . OFF ; if ( s . equals ( " TRACE " ) ) return Level . TRACE ; return arg1 ; }
public void function ( int arg0 , String arg1 , Throwable arg2 ) { switch ( arg0 ) { case LOG_DEBUG :
public boolean function ( final Request arg0 ) { Optional < byte [ ] > content = extractor . extract ( arg0 ) ; return content . isPresent ( ) & & doMatch ( arg0 , content . get ( ) ) ; }
public static Resource function ( final String arg0 ) { return methodResource ( checkNotNull ( arg0 , " Null HTTP method is not allowed " ) ) ; }
private void function ( Handshakedata arg0 ) { log . trace ( " open using draft: {} " , draft ) ; setReadyState ( ReadyState . OPEN ) ; try { wsl . onWebsocketOpen ( this , arg0 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; HttpResponse response = Request . Get ( remoteUrl ( " /composite-response " ) ) . execute ( ) . returnResponse ( ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; assertThat ( response . getHeaders ( " foo " ) [ 0 ] . getValue ( ) , is ( " bar " ) ) ; }
private static MocoMonitor function ( MocoMonitor arg0 , MocoMonitor arg1 , MocoMonitor [ ] arg2 ) { MocoMonitor [ ] targetMonitors = new MocoMonitor [ 2 + arg2 . length ] ; targetMonitors [ 0 ] = checkNotNull ( arg0 , " Monitor should not be null " ) ; targetMonitors [ 1 ] = checkNotNull ( arg1 , " Monitor should not be null " ) ; if ( arg2 . length > 0 ) { System . arraycopy ( arg2 , 0 , targetMonitors , 2 , arg2 . length ) ; } return new CompositeMonitor ( targetMonitors ) ; }
public void function ( ) { try { assertContentFromUri ( " http://localhost:8080/foo " , " foo.response " ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.2.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
private void function ( ) { if ( future ! = null ) { future . channel ( ) . closeFuture ( ) ; } if ( bossGroup ! = null ) { bossGroup . shutdownGracefully ( ) ; bossGroup = null ; } if ( workerGroup ! = null ) { workerGroup . shutdownGracefully ( ) ;
public MessageContent function ( final Optional < ? extends Request > arg0 ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( format ( " %s does not exist " , file . getPath ( ) ) ) ; } try { MessageContent . Builder builder = content ( ) . withContent ( toByteArray ( file ) ) ;
public void function ( ) { DefaultRequest request = new DefaultRequest ( ) ; request . setVersion ( " HTTP/1.1 " ) ; request . setMethod ( " POST " ) ; request . setContent ( " proxy " ) ; request . addHeader ( " Cookie " , " loggedIn=true " ) ; request . addHeader ( " Host " , " localhost:12306 " ) ; assertThat ( request . match ( request ) , is ( true ) ) ; }
public void function ( ) { SLF4JBridgeHandler . install ( ) ; String resourceBundleName = " org.slf4j.bridge.testLogStrings " ; ResourceBundle bundle = ResourceBundle . getBundle ( resourceBundleName ) ; String resourceKey = " resource_key " ; String expectedMsg = bundle . getString ( resourceKey ) ; String msg = resourceKey ; java . util . logging . Logger julResourceBundleLogger = java . util . logging . Logger . getLogger ( " yay " , resourceBundleName ) ; julResourceBundleLogger . info ( msg ) ; assertEquals ( 1 , listAppender . list . size ( ) ) ; LoggingEvent le = ( LoggingEvent ) listAppender . list . get ( 0 ) ; assertEquals ( LOGGER_NAME , le . getLoggerName ( ) ) ; assertEquals ( expectedMsg , le . getMessage ( ) ) ; }
public boolean function ( ) { return delegate ( ) . isDebugEnabled ( ) ; }
private void function ( File arg0 ) { try { InplaceFileConverter fc = new InplaceFileConverter ( ruleSet , progressListener ) ;
public void function ( ) { request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_0 , HttpMethod . POST , " /foo " ) ; assertThat ( extractor . extract ( request ) . get ( ) , is ( HttpMethod . POST . toString ( ) ) ) ; }
public void function ( ) { Document htmlDoc = Jsoup . parse ( " <br>one</br> " ) ; assertEquals ( " <br />one \ n<br /> " , htmlDoc . body ( ) . html ( ) ) ; Document xmlDoc = Jsoup . parse ( " <br>one</br> " , " " , Parser . xmlParser ( ) ) ; assertEquals ( " <br>one</br> " , xmlDoc . html ( ) ) ; }
public RequestMatcher function ( final MocoConfig arg0 ) { Resource appliedResource = expected . apply ( arg0 ) ; if ( appliedResource = = expected ) { return this ; } return newMatcher ( extractor , appliedResource ) ; }
private Optional < SslHandler > function ( ) { return serverSetting . getCertificate ( ) . transform ( toSslHandler ( ) ) ; }
private static String function ( final String arg0 , final String arg1 ) { return joinedFile ( arg0 , arg1 ) . getPath ( ) ; }
public void function ( WebSocket arg0 , String arg1 ) { fail ( " There should be no onMessage " ) ; }
public void function ( ) { if ( adjustthread ! = null ) { adjustthread . interrupt ( ) ;
public ByteChannel function ( SocketChannel arg0 , SelectionKey arg1 ) throws IOException ; } }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { handleDataEndTag ( arg0 , arg1 , Rawtext ) ; }
public static MocoJunitRunner function ( int arg0 , Resource arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; checkNotNull ( arg1 , " File should not be null " ) ; return jsonHttpRunner ( arg0 , arg1 ) ; }
public ResponseSetting function ( ) { ResponseSetting responseSetting = new ResponseSetting ( ) ; responseSetting . text = text ; responseSetting . file = file ; responseSetting . pathResource = pathResource ; responseSetting . status = status ; responseSetting . proxy = proxy ; responseSetting . headers = headers ; responseSetting . cookies = cookies ; responseSetting . latency = latency ; responseSetting . version = version ; responseSetting . json = json ; responseSetting . attachment = attachment ; return responseSetting ; }
@Test public void function ( ) throws MalformedURLException { URL url1 = new URL ( " https://test.com/foo bar/[One]?q=white space#frag " ) ; URL url2 = new UrlBuilder ( url1 ) . build ( ) ; assertEquals ( " https://test.com/foo%20bar/%5BOne%5D?q=white+space#frag " , url2 . toExternalForm ( ) ) ; }
protected Object function ( String arg0 , ClassLoader arg1 ) { throw new UnsupportedOperationException ( " Operation [factoryClass] is not supported in jcl-over-slf4j. See also  "
private boolean function ( final NamedNodeMap arg0 , final NamedNodeMap arg1 ) { final int actualLength = arg0 . getLength ( ) ; final int expectedLength = arg1 . getLength ( ) ; if ( actualLength = = 0 & & expectedLength = = 0 ) { return true ; } for ( int i = 0 ; i < actualLength ; i + + ) { final Node item = arg0 . item ( i ) ; if ( arg1 . getNamedItem ( item . getNodeName ( ) ) = = null ) { return false ; } } return true ; }
@Test void function ( ) { String html = " <body><div> <a>Text</a> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <div><a>Text</a> \ n</div> " , doc . body ( ) . html ( ) ) ; }
public static String function ( String arg0 , boolean arg1 ) { Tokeniser tokeniser = new Tokeniser ( new CharacterReader ( arg0 ) , ParseErrorList . noTracking ( ) , false ) ; return tokeniser . unescapeEntities ( arg1 ) ; }
public void function ( ) throws Exception { byte [ ] bytes = { 'A' , 'd' , 'd' , 'r' , 'e' , 's' , 's' , 0 , ( byte ) 0x33 } ; ID3v2PopmFrameData iD3v2PopmFrameData = new ID3v2PopmFrameData ( false , bytes ) ; assertEquals ( - 1 , iD3v2PopmFrameData . getRating ( ) ) ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://infohound.net/tools/302-cookie.pl " ) ; Connection . Response res = con . execute ( ) ; assertEquals ( " asdfg123 " , res . cookie ( " token " ) ) ; Document doc = res . parse ( ) ; assertEquals ( " token=asdfg123 " , ihVal ( " HTTP_COOKIE " , doc ) ) ; }
public static ResponseHandler function ( final String arg0 , final MocoGroup arg1 ) { return broadcast ( text ( checkNotNullOrEmpty ( arg0 , " Broadcast content should not be null " ) ) , arg1 ) ; }
public boolean function ( Element arg0 , Element arg1 ) { for ( Evaluator s : selectors ) { if ( s . matches ( arg0 , arg1 ) ) return true ; } return false ; }
private ProxyContainer function ( JsonParser arg0 ) throws IOException { Map < String , String > fields = newHashMap ( ) ; while ( fetchField ( fields , arg0 ) ) { } return new ProxyContainer ( fields . get ( " url " ) , fields . get ( " failover " ) , fields . get ( " from " ) , fields . get ( " to " ) ) ; }
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ChatServerAttachmentExample s = new ChatServerAttachmentExample ( port ) ; s . start ( ) ; System . out . println ( " ChatServer started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
protected RestSettingBuilder function ( ) { return MocoRest . delete ( id ) ; }
public static ResponseHandler function ( final ResponseHandler arg0 , final ResponseHandler . . . arg1 ) { checkNotNull ( arg0 , " Sequence handler should not be null " ) ; checkArgument ( arg1 . length > 0 , " Sequence handlers should not be null " ) ; return newSeq ( asIterable ( arg0 , arg1 ) ) ; }
public void function ( int arg0 , String arg1 , boolean arg2 ) { if ( connectionClosed ) { return ; } connectionClosed = true ; try { if ( key ! = null ) { key . attach ( null ) ; key . cancel ( ) ; } if ( sockchannel ! = null ) sockchannel . close ( ) ; else sockchannel2 . close ( ) ; } catch ( IOException e ) { wsl . onWebsocketError ( this , e ) ; } this . wsl . onWebsocketClose ( this , arg0 , arg1 , arg2 ) ; if ( draft ! = null ) draft . reset ( ) ; currentframe = null ; handshakerequest = null ; }
public void function ( final String arg0 ) { try { Files . append ( arg0 , file , charset ) ;
public void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( DeflateServlet . Url ) . execute ( ) ; assertEquals ( " deflate " , res . header ( " Content-Encoding " ) ) ; Document doc = res . parse ( ) ; assertEquals ( " Hello, World! " , doc . selectFirst ( " p " ) . text ( ) ) ; }
public void function ( ) throws Exception { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " \ u03B3 \ u03B5 \ u03B9 \ u03AC " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 2 , " UTF-16BE " ) ; byte [ ] expectedBuffer = { 0 , 0 , 0x03 , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac } ; assertTrue ( Arrays . equals ( expectedBuffer , buffer ) ) ; }
public void function ( ) throws Exception { testHandshakeRejection ( 10 ) ; }
public WebSocket [ ] function ( ) { return this . connections . toArray ( new WebSocket [ 0 ] ) ; }
@Test public void function ( ) { String html = " <ul id=outer><li>Foo</li><li>Bar <ul id=inner><li>Baz</li><li>Qux</li></ul> </li></ul> " ; Document doc = Jsoup . parse ( html ) ; Element ul = doc . expectFirst ( " #outer " ) ; assertEquals ( 2 , ul . childrenSize ( ) ) ; Element li1 = ul . expectFirst ( " > li:nth-child(1) " ) ; assertEquals ( " Foo " , li1 . ownText ( ) ) ; assertTrue ( li1 . select ( " ul " ) . isEmpty ( ) ) ; Element li2 = ul . expectFirst ( " > li:nth-child(2) " ) ; assertEquals ( " Bar " , li2 . ownText ( ) ) ; Elements innerLis = li2 . select ( " ul > li " ) ; assertSelectedOwnText ( innerLis , " Baz " , " Qux " ) ; Elements innerLisFromParent = li2 . select ( " ul li " ) ; assertEquals ( innerLis , innerLisFromParent ) ; }
public void function ( String arg0 , String arg1 ) { if ( arg0 = = null ) { throw new IllegalArgumentException ( " key cannot be null " ) ; } Map map = ( Map ) inheritableThreadLocal . get ( ) ; if ( map = = null ) { map = Collections . synchronizedMap ( new HashMap ( ) ) ; inheritableThreadLocal . set ( map ) ; } map . put ( arg0 , arg1 ) ; }
public static MocoJunitRunner function ( final int arg0 , final String arg1 ) { return new MocoJunitRunner ( runner ( jsonHttpServer ( arg0 , file ( arg1 ) ) ) ) ; }
public void function ( String arg0 ) { if ( DEBUG ) { System . out . println ( " Aborting:  " + arg0 ) ; } close ( ) ; }
private Element function ( Element arg0 ) { String sourceTag = arg0 . tagName ( ) ; Attributes destAttrs = new Attributes ( ) ; Element dest = new Element ( Tag . valueOf ( sourceTag ) , arg0 . baseUri ( ) , destAttrs ) ; Attributes sourceAttrs = arg0 . attributes ( ) ; for ( Attribute sourceAttr : sourceAttrs ) { if ( whitelist . isSafeAttribute ( sourceTag , sourceAttr ) ) destAttrs . put ( sourceAttr ) ; } Attributes enforcedAttrs = whitelist . getEnforcedAttributes ( sourceTag ) ; destAttrs . mergeAttributes ( enforcedAttrs ) ; return dest ; }
protected void function ( SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; pipeline . addLast ( " decoder " , new StringDecoder ( ) ) ; pipeline . addLast ( " encoder " , new StringEncoder ( ) ) ; pipeline . addLast ( " aggregator " , new MocoStringAggregator ( ) ) ; pipeline . addLast ( " handler " , new MocoSocketHandler ( serverSetting ) ) ; }
private void function ( ByteBuffer arg0 ) { synchronized ( byteBufferList ) { byteBufferList . add ( arg0 ) ;
@Test public void function ( ) { String h = " <div title=foo /><div title=bar /><div /><p></p><img /><span title=qux> " ; Elements els = Jsoup . parse ( h ) . select ( " p,div,[title] " ) ; assertEquals ( 5 , els . size ( ) ) ; assertEquals ( " p " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " div " , els . get ( 1 ) . tagName ( ) ) ; assertEquals ( " foo " , els . get ( 1 ) . attr ( " title " ) ) ; assertEquals ( " div " , els . get ( 2 ) . tagName ( ) ) ; assertEquals ( " bar " , els . get ( 2 ) . attr ( " title " ) ) ; assertEquals ( " div " , els . get ( 3 ) . tagName ( ) ) ; assertNull ( els . get ( 3 ) . attr ( " title " ) ) ; assertEquals ( " span " , els . get ( 4 ) . tagName ( ) ) ;
public void function ( Level arg0 , ResourceBundle arg1 , String arg2 , Throwable arg3 ) { String message = getResourceStringOrMessage ( arg1 , arg2 ) ; switch ( arg0 ) { case ALL :
private RequestMatcher function ( String arg0 , TextContainer arg1 ) { if ( arg1 . isRawText ( ) ) { return createSingleMatcher ( arg0 , arg1 . getText ( ) ) ; } if ( isExistOperator ( arg1 ) ) { return existMatcher ( Extractors . extractor ( arg0 ) , arg1 ) ; } return createRequestMatcherWithResource ( arg1 . getOperation ( ) , createResource ( arg0 , arg1 . getText ( ) ) ) ; }
@Override List < Node > function ( ) { return doc . childNodes ( ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( isInfoEnabled ( ) ) { handle2ArgsCall ( Level . INFO , null , arg0 , arg1 , arg2 ) ;
private ReplayContainer function ( ) { return new ReplayContainer ( group , identifier , modifier ) ; }
public void function ( ) { String xml = " <doc id=2 href='/bar'>Foo <br /><link>One</link><link>Two</link></doc> " ; XmlTreeBuilder tb = new XmlTreeBuilder ( ) ; Document doc = tb . parse ( xml , " http://foo.com/ " ) ; assertEquals ( " <doc id= \" 2 \"  href= \" /bar \" >Foo <br /><link>One</link><link>Two</link></doc> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ; assertEquals ( doc . getElementById ( " 2 " ) . absUrl ( " href " ) , " http://foo.com/bar " ) ; }
public static void function ( Elements arg0 , String . . . arg1 ) { assertNotNull ( arg0 ) ; assertEquals ( arg1 . length , arg0 . size ( ) , " Incorrect number of selected elements " ) ; for ( int i = 0 ; i < arg1 . length ; i + + ) { assertEquals ( arg1 [ i ] , arg0 . get ( i ) . id ( ) , " Incorrect content at index " ) ;
public void function ( ) throws Exception { server . request ( by ( uri ( " /random " ) ) ) . response ( template ( " ${random(99,100)} " ) ) ; running ( server , ( ) - > { String response = helper . get ( remoteUrl ( " /random " ) ) ;
public void function ( ) { StartArgs args = startArgsParser . parse ( new String [ ] { " start " , " -c " , " foo.json " } ) ; assertThat ( args . getPort ( ) . isPresent ( ) , is ( false ) ) ; assertThat ( args . getConfigurationFile ( ) . get ( ) , is ( " foo.json " ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { recordEvent_0Args ( Level . TRACE , null , arg0 , arg1 ) ; }
public void function ( WebSocket arg0 , int arg1 , String arg2 , boolean arg3 ) { closeCalledLatch . countDown ( ) ; }
public static HttpsServer function ( final int arg0 , final Resource arg1 , final HttpsCertificate arg2 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; checkNotNull ( arg2 , " Certificate should not be null " ) ; ActualHttpServer httpsServer = ( ActualHttpServer ) Moco . httpsServer ( arg0 , arg2 ) ; return httpsServer . mergeServer ( ( ActualHttpServer ) parseHttpServer ( checkNotNull ( arg1 , " resource should not be null " ) , arg0 ) ) ;
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { String html = Entities . escape ( getWholeText ( ) , arg2 ) ; if ( arg2 . prettyPrint ( ) & & parent ( ) instanceof Element & & ! Element . preserveWhitespace ( ( Element ) parent ( ) ) ) { html = normaliseWhitespace ( html ) ; } if ( arg2 . prettyPrint ( ) & & siblingIndex ( ) = = 0 & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . formatAsBlock ( ) & & ! isBlank ( ) ) indent ( arg0 , arg1 , arg2 ) ; arg0 . append ( html ) ; }
public void function ( ) throws Exception { ResponseHandler handler = mock ( ResponseHandler . class ) ; server . request ( by ( uri ( " /target " ) ) ) . response ( handler ) ; server . request ( by ( uri ( " /event " ) ) ) . response ( " event " ) . on ( complete ( get ( text ( remoteUrl ( " /target " ) ) ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " event " ) ) ) ; verify ( handler ) . writeToResponse ( any ( SessionContext . class ) ) ; }
public int function ( ByteBuffer arg0 ) throws IOException { return channel instanceof WrappedByteChannel ? ( ( WrappedByteChannel ) channel ) . readMore ( arg0 ) : 0 ; }
public void function ( ) throws Exception { testHandshakeRejection ( 8 ) ; }
private static String function ( String arg0 ) { return arg0 . replace ( ' ' , '+' ) ; }
@Test public void function ( ) { String html = " <a href='/foo'>Link</a> " ; String clean = Jsoup . clean ( html , Safelist . basic ( ) ) ; assertEquals ( " <a rel= \" nofollow \" >Link</a> " , clean ) ; }
@Override public boolean function ( Object arg0 ) { int index = super . indexOf ( arg0 ) ; if ( index = = - 1 ) { return false ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , response ( header ( " Content-Type " , " text/plain " ) ) ) ; server . response ( version ( VERSION_1_0 ) ) ; running ( server , new Runnable ( ) { @Override
public static Tag function ( String arg0 , String arg1 , ParseSettings arg2 ) { Validate . notEmpty ( arg0 ) ; Validate . notNull ( arg1 ) ; Tag tag = Tags . get ( arg0 ) ; if ( tag ! = null & & tag . arg1 . equals ( arg1 ) ) return tag ; arg0 = arg2 . normalizeTag ( arg0 ) ; Validate . notEmpty ( arg0 ) ; String normalName = Normalizer . lowerCase ( arg0 ) ; tag = Tags . get ( normalName ) ; if ( tag ! = null & & tag . arg1 . equals ( arg1 ) ) { if ( arg2 . preserveTagCase ( ) & & ! arg0 . equals ( normalName ) ) { tag = tag . clone ( ) ; tag . arg0 = arg0 ; } return tag ; } tag = new Tag ( arg0 , arg1 ) ; tag . isBlock = false ; return tag ; }
public void function ( ) throws IOException { runWithConfiguration ( " proxy_server.json " ) ; String content = helper . postContent ( remoteUrl ( " /failover/1 " ) , " proxy " ) ; assertThat ( content , is ( " proxy " ) ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div><p>Hello</p><p>There</p></div> " ) ; Element p = doc . select ( " p " ) . first ( ) ; p . wrap ( " <div class='head'></div> " ) ; assertEquals ( " <div><div class= \" head \" ><p>Hello</p></div><p>There</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; Element ret = p . wrap ( " <div><div class=foo></div><p>What?</p></div> " ) ; assertEquals ( " <div><div class= \" head \" ><div><div class= \" foo \" ><p>Hello</p></div><p>What?</p></div></div><p>There</p></div> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; assertEquals ( ret , p ) ; }
private int function ( ) { int maxEndOffset = ( int ) getLength ( ) ; if ( hasId3v1Tag ( ) ) maxEndOffset - = ID3v1Tag . TAG_LENGTH ; return maxEndOffset ; }
public void function ( ) { LineConverter trivialLC = new LineConverter ( new TrivialMatcher ( ) ) ; assertEquals ( " simple replacement with an unique capturing group " , trivialLC . getReplacement ( " import org.slf4j.converter " ) ) ; assertEquals ( " 1st group second group 4th group " , trivialLC . getReplacement ( " first group second group third group 4th group " ) ) ;
public void function ( ) { httpServer ( port ( ) , hit ) ; assertThrows ( VerificationException . class , ( ) - > hit . verify ( by ( uri ( " /foo " ) ) , atLeast ( 1 ) ) ) ;
public static boolean function ( final ByteBuffer arg0 , WebSocketImpl arg1 , ByteChannel arg2 ) throws IOException { arg0 . clear ( ) ; int read = arg2 . read ( arg0 ) ; arg0 . flip ( ) ; if ( read = = - 1 ) { arg1 . eot ( ) ; return false ; } return read ! = 0 ; }
@Test public void function ( ) { Connection . KeyVal kv = HttpConnection . KeyVal . create ( " file " , " thumb.jpg " , ParseTest . inputStreamFrom ( " Check " ) ) ; assertEquals ( " file " , kv . key ( ) ) ; assertEquals ( " thumb.jpg " , kv . value ( ) ) ; assertTrue ( kv . hasInputStream ( ) ) ; kv = HttpConnection . KeyVal . create ( " one " , " two " ) ; assertEquals ( " one " , kv . key ( ) ) ; assertEquals ( " two " , kv . value ( ) ) ; assertFalse ( kv . hasInputStream ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 60 ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { if ( isDebugEnabled ( arg0 ) ) { handle_0ArgsCall ( Level . DEBUG , arg0 , arg1 , arg2 ) ;
public List < String > function ( String arg0 ) { List < String > attrs = new ArrayList < String > ( size ( ) ) ; for ( Element element : this ) { if ( element . hasAttr ( arg0 ) ) attrs . add ( element . attr ( arg0 ) ) ; } return attrs ; }
public void function ( ) throws Exception { HttpServer httpServer = httpserver ( 12306 , context ( " /foo " ) ) ; httpServer . response ( " foo " ) ; HttpServer anotherServer = httpserver ( 12306 , context ( " /bar " ) ) ; HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeHttpServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public final void function ( ) { BaseActualServer < T , U > setting = serverSetting ( ) ; int port = this . server . start ( setting . getPort ( ) . or ( 0 ) , channelInitializer ( ) ) ; setting . setPort ( port ) ; }
public void function ( ) throws Exception { server . resource ( " targets " , delete ( " 1 " , status ( 409 ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { TextFrame frame = new TextFrame ( ) ; assertEquals ( " Frame must extend dataframe " , true , frame instanceof DataFrame ) ; }
public void function ( ServerHandshake arg0 ) { countDownLatch . countDown ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 30 ) ; }
public void function ( ) throws Exception { try { Mp3Retag . attachImage = true ;
public void function ( int arg0 , String arg1 , boolean arg2 ) { System . out . println ( " Connection closed by  " + ( arg2 ? " remote peer " : " us " ) ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 29 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " opc " ) ) ) ) ;
public static byte [ ] function ( String arg0 , String arg1 , byte [ ] arg2 ) throws InvalidHandshakeException { byte [ ] part1 = getPart ( arg0 ) ; byte [ ] part2 = getPart ( arg1 ) ; byte [ ] challenge = new byte [ 16 ] ; challenge [ 0 ] = part1 [ 0 ] ; challenge [ 1 ] = part1 [ 1 ] ; challenge [ 2 ] = part1 [ 2 ] ; challenge [ 3 ] = part1 [ 3 ] ; challenge [ 4 ] = part2 [ 0 ] ; challenge [ 5 ] = part2 [ 1 ] ; challenge [ 6 ] = part2 [ 2 ] ; challenge [ 7 ] = part2 [ 3 ] ; challenge [ 8 ] = arg2 [ 0 ] ; challenge [ 9 ] = arg2 [ 1 ] ; challenge [ 10 ] = arg2 [ 2 ] ; challenge [ 11 ] = arg2 [ 3 ] ; challenge [ 12 ] = arg2 [ 4 ] ; challenge [ 13 ] = arg2 [ 5 ] ; challenge [ 14 ] = arg2 [ 6 ] ; challenge [ 15 ] = arg2 [ 7 ] ; MessageDigest md5 ; try { md5 = MessageDigest . getInstance ( " MD5 " ) ; } catch ( NoSuchAlgorithmException e ) { throw new RuntimeException ( e ) ; } return md5 . digest ( challenge ) ; }
public void function ( ) { assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " bar " ) ) ) ) ;
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /fuzztests/1605.html.gz " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertNotNull ( doc ) ; Document docXml = Jsoup . parse ( new FileInputStream ( in ) , " UTF-8 " , " https://example.com " , Parser . xmlParser ( ) ) ; assertNotNull ( docXml ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.10 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private void function ( arg0 . arg1 . arg2 . Level arg3 , ResourceBundle arg4 , String arg5 , Throwable arg6 , Object . . . arg7 ) { String message = getResourceStringOrMessage ( arg4 , arg5 ) ; LoggingEventBuilder leb = slf4jLogger . makeLoggingEventBuilder ( arg3 ) ; if ( arg6 ! = null ) { leb = leb . setCause ( arg6 ) ; } if ( arg7 ! = null & & arg7 . length > 0 ) { for ( Object p : arg7 ) { leb = leb . addArgument ( p ) ; } message = String . format ( message , arg7 ) ; } if ( leb instanceof CallerBoundaryAware ) { CallerBoundaryAware cba = ( CallerBoundaryAware ) leb ; cba . setCallerBoundary ( PRESUMED_CALLER_BOUNDARY ) ; } leb . log ( message ) ; }
private static void function ( Token . StartTag arg0 , HtmlTreeBuilder arg1 ) { arg1 . tokeniser . transition ( TokeniserState . Rcdata ) ; arg1 . markInsertionMode ( ) ; arg1 . transition ( Text ) ; arg1 . insertElementFor ( arg0 ) ; }
public void function ( ) { int LEN = 1000 * 1000 * 10 ; debugLoop ( LEN ) ; double avg = debugLoop ( LEN ) ; long referencePerf = 93 ; BogoPerf . assertDuration ( avg , referencePerf , REFERENCE_BIPS ) ;
@Test void function ( ) { String html = " <body> " ; Parser parser = Parser . htmlParser ( ) ; parser . setTrackErrors ( 10 ) ; Document doc = Jsoup . parse ( html , parser ) ; ParseErrorList errors = parser . getErrors ( ) ; assertEquals ( 0 , errors . size ( ) ) ; }
@Override protected Token . Character function ( ) { try { return ( Token . Character ) super . clone ( ) ;
public boolean function ( Element arg0 ) { Element next = arg0 . nextElementSibling ( ) ; if ( next ! = null & & sel . matches ( next ) ) return true ; return false ; }
public int function ( final int arg0 , ChannelHandler arg1 ) { ServerBootstrap bootstrap = new ServerBootstrap ( ) ; bootstrap . group ( bossGroup , workerGroup ) . channel ( NioServerSocketChannel . class ) . childHandler ( arg1 ) ; try { future = bootstrap . bind ( arg0 ) . sync ( ) ;
public final void function ( WebSocket arg0 , Handshakedata arg1 ) { connectLatch . countDown ( ) ; onOpen ( ( ServerHandshake ) arg1 ) ; }
public void function ( ) { if ( selectorthread ! = null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + "  can only be started once. " ) ; new Thread ( this ) . start ( ) ; ; }
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ServerAdditionalHeaderExample s = new ServerAdditionalHeaderExample ( port ) ; s . start ( ) ; System . out . println ( " Server started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
public void function ( String arg0 , Object arg1 , Object arg2 ) { parameterizedLog ( ERROR_STR , arg0 , arg1 , arg2 ) ; }
public void function ( final File arg0 ) { listener . apply ( arg0 ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 18 , new Draft_6455 ( ) ) ; }
public void function ( ) { Evaluator . AttributeWithValueEnding evaluator = new Evaluator . AttributeWithValueEnding ( " example " , " value " ) ; assertEquals ( " [example$=value] " , evaluator . toString ( ) ) ; }
private void function ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ;
public void function ( ) { System . out . println ( " running cTest in  " + Thread . currentThread ( ) . getName ( ) ) ; }
public static Attribute function ( String arg0 , String arg1 ) { String value = StringEscapeUtils . unescapeHtml ( arg1 ) ; return new Attribute ( arg0 , value ) ; }
boolean function ( String arg0 ) { return input . regionMatches ( true , pos , arg0 , 0 , arg0 . length ( ) ) ; }
public void function ( ) throws IOException , ProtocolException { runWithConfiguration ( " cors.json " ) ; ClassicHttpResponse response = helper . getResponseWithHeader ( remoteUrl ( " /cors-allows-origin-star " ) , of ( " Origin " , " https://www.github.com/ " ) ) ; assertThat ( response . getHeader ( " Access-Control-Allow-Origin " ) . getValue ( ) , is ( " * " ) ) ; }
private void function ( Framedata arg0 ) throws InvalidDataException { if ( currentContinuousFrame ! = null ) { log . trace ( " Protocol error: Previous continuous frame sequence not completed. " ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , " Previous continuous frame sequence not completed. " ) ; } currentContinuousFrame = arg0 ; addToBufferList ( arg0 . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
public T function ( URL arg0 ) { Validate . notNullParam ( arg0 , " arg0 " ) ; this . arg0 = new UrlBuilder ( arg0 ) . build ( ) ; return ( T ) this ; }
public static int function ( byte arg0 , byte arg1 , byte arg2 , byte arg3 ) { int value = ( ( byte ) ( arg3 & 0x7f ) ) ; value + = shiftByte ( ( byte ) ( arg2 & 0x7f ) , - 7 ) ; value + = shiftByte ( ( byte ) ( arg1 & 0x7f ) , - 14 ) ; value + = shiftByte ( ( byte ) ( arg0 & 0x7f ) , - 21 ) ; return value ; }
protected HttpServer function ( final int arg0 ) { return httpServer ( arg0 ) ; }
public void function ( Enum < ? > arg0 , Object . . . arg1 ) { if ( ! logger . isErrorEnabled ( ) ) { return ; } String translatedMsg = imc . getMessage ( arg0 , arg1 ) ; MessageParameterObj mpo = new MessageParameterObj ( arg0 , arg1 ) ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( LOCALIZED , FQCN , LocationAwareLogger . ERROR_INT , translatedMsg , arg1 , null ) ;
private void function ( Inflater arg0 , byte [ ] arg1 , ByteArrayOutputStream arg2 ) throws DataFormatException { arg0 . setInput ( arg1 ) ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesInflated ; while ( ( bytesInflated = arg0 . inflate ( buffer ) ) > 0 ) { arg2 . write ( buffer , 0 , bytesInflated ) ;
public void function ( WebSocket arg0 , int arg1 , String arg2 , boolean arg3 ) { onClosing ( arg0 , arg1 , arg2 , arg3 ) ;
public void function ( Attribute arg0 ) { Validate . notNull ( arg0 ) ; if ( attributes = = null ) attributes = new LinkedHashMap < String , Attribute > ( 2 ) ; attributes . put ( arg0 . getKey ( ) , arg0 ) ; }
private void function ( HttpURLConnection arg0 , Connection . Response arg1 ) throws IOException { method = Method . valueOf ( arg0 . getRequestMethod ( ) ) ; url = arg0 . getURL ( ) ; statusCode = arg0 . getResponseCode ( ) ; statusMessage = arg0 . getResponseMessage ( ) ; contentType = arg0 . getContentType ( ) ; Map < String , List < String > > resHeaders = createHeaderMap ( arg0 ) ; processResponseHeaders ( resHeaders ) ; if ( arg1 ! = null ) { for ( Map . Entry < String , String > prevCookie : arg1 . cookies ( ) . entrySet ( ) ) {
public Element function ( Node arg0 ) { Validate . notNull ( arg0 ) ; childNodes . add ( arg0 ) ; arg0 . setParentNode ( this ) ; return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.13.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " delete_method.json " ) ; String response = helper . executeAsString ( Request . delete ( remoteUrl ( " /delete " ) ) ) ; assertThat ( response , is ( " response_for_delete_method " ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " template.json " ) ; Header header = Request . Get ( remoteUrl ( " /header_template " ) ) . addHeader ( " foo " , " bar " ) . execute ( ) . returnResponse ( ) . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; }
@Test public void function ( ) { Element div = new Element ( Tag . valueOf ( " div " ) , " " ) ; div . attr ( " true " , true ) ; div . attr ( " false " , " value " ) ; div . attr ( " false " , false ) ; assertTrue ( div . hasAttr ( " true " ) ) ; assertEquals ( " " , div . attr ( " true " ) ) ; assertFalse ( div . hasAttr ( " false " ) ) ; assertEquals ( " <div true></div> " , div . outerHtml ( ) ) ; }
public static boolean function ( int arg0 ) { return Character . getType ( arg0 ) = = 16 & & ( arg0 = = 8203 | | arg0 = = 8204 | | arg0 = = 8205 | | arg0 = = 173 ) ;
@Test public void function ( ) throws MalformedURLException { URL url1 = new URL ( " https://test.com/foo%20bar/%5BOne%5D?q=white+space#frag " ) ; URL url2 = new UrlBuilder ( url1 ) . build ( ) ; assertEquals ( " https://test.com/foo%20bar/%5BOne%5D?q=white+space#frag " , url2 . toExternalForm ( ) ) ; }
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( " POST " ) . withTextContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest failover = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( " POST " ) . withTextContent ( " proxy " ) . withHeaders ( of ( " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( failover ) . match ( request ) , is ( true ) ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <html><head id=2><title id=1></title></head></html> " ) ; Element title = doc . getElementById ( " 1 " ) ; title . html ( " good " ) ; assertEquals ( " good " , title . html ( ) ) ; title . html ( " <i>bad</i> " ) ; assertEquals ( " &lt;i&gt;bad&lt;/i&gt; " , title . html ( ) ) ; Element head = doc . getElementById ( " 2 " ) ; head . html ( " <title><i>bad</i></title> " ) ; assertEquals ( " <title>&lt;i&gt;bad&lt;/i&gt;</title> " , head . html ( ) ) ; }
public void function ( ) throws IOException { assertThat ( helper . postContent ( remoteUrl ( " /proxy " ) , " proxy " ) , is ( " post_proxy " ) ) ; assertThat ( Files . toString ( tempFile , Charset . defaultCharset ( ) ) . isEmpty ( ) , is ( false ) ) ; }
void function ( Appendable arg0 , Document . OutputSettings arg1 ) throws IOException { if ( attributes = = null ) return ; for ( Map . Entry < String , Attribute > entry : attributes . entrySet ( ) ) { Attribute attribute = entry . getValue ( ) ;
public static MocoJunitRunner function ( final int arg0 , final String arg1 , final HttpsCertificate arg2 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; checkNotNullOrEmpty ( arg1 , " Filename should not be null " ) ; checkNotNull ( arg2 , " Filename should not be null " ) ; return new MocoJunitRunner ( runner ( jsonHttpsServer ( arg0 , file ( arg1 ) , arg2 ) ) ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { String name = arg1 . consumeToAnySorted ( attributeNameCharsSorted ) ; arg0 . tagPending . appendAttributeName ( name . toLowerCase ( ) ) ; char c = arg1 . consume ( ) ; switch ( c ) { case '\t' :
public void function ( ) throws Exception { JDK14LoggerFactory factory = new JDK14LoggerFactory ( ) ; SLF4JLog log = new SLF4JLog ( factory . getLogger ( " x " ) ) ; oos . writeObject ( log ) ; verify ( ) ; }
public void function ( ) throws Exception { webSocketServer . connected ( " hello " ) ; running ( server , ( ) - > { final Endpoint endpoint = new Endpoint ( new URI ( " ws://localhost:12306/ws/ " ) ) ;
public static TextId function ( String arg0 ) { return new TextId ( arg0 ) ; }
public static void function ( String [ ] arg0 ) { int port ; try { port = new Integer ( arg0 [ 0 ] ) ; } catch ( Exception e ) { System . out . println ( " No port specified. Defaulting to 9001 " ) ; port = 9002 ; } new AutobahnServerTest ( port , new Draft_17 ( ) ) . start ( ) ; }
public int function ( ) { int count = 0 ; Iterator < Entry < String , String > > iter = new DatasetIterator ( ) ; while ( iter . hasNext ( ) ) count + + ; return count ; }
public int function ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + ( ( text = = null ) ? 0 : text . hashCode ( ) ) ; return result ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.13.1 " ) ; assertEquals ( " INFORMATIONAL " , testResult . get ( " behavior " ) ) ; assertEquals ( " INFORMATIONAL " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private void function ( SeekableByteChannel arg0 ) throws IOException { int bufferLength = ( int ) ( getLength ( ) - ( endOffset + 1 ) ) ; if ( hasId3v1Tag ( ) ) bufferLength - = ID3v1Tag . TAG_LENGTH ; if ( bufferLength < = 0 ) { customTag = null ;
public void function ( WebSocket arg0 ) { try { this . sendToAll ( arg0 + "  has left the room! " ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } System . out . println ( arg0 + "  has left the room! " ) ; }
private Supplier < ImmutableMap < String , String > > function ( ) { return Suppliers . memoize ( ( ) - > { Optional < ImmutableMap < String , String > > forms =
public int function ( ByteBuffer arg0 ) throws SSLException { return readRemaining ( arg0 ) ; }
@Test public void function ( ) throws IOException { File in = getFile ( " /htmltests/xwiki-1324.html.gz " ) ; Document doc = Jsoup . parse ( in ) ; assertEquals ( " XWiki Jetty HSQLDB 12.1-SNAPSHOT " , doc . select ( " #xwikiplatformversion " ) . text ( ) ) ; }
public static SocketServer function ( final int arg0 , final MocoMonitor arg1 , final MocoMonitor arg2 , final MocoMonitor . . . arg3 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualSocketServer . createServerWithMonitor ( of ( arg0 ) , ApiUtils . mergeMonitor ( checkNotNull ( arg1 , " Monitor should not be null " ) ,
private String function ( ServiceReference arg0 , String arg1 ) { StringBuffer output = new StringBuffer ( ) ; if ( arg0 ! = null ) { output . append ( '[' ) . append ( arg0 . toString ( ) ) . append ( ']' ) . append ( arg1 ) ; } else { output . append ( UNKNOWN ) . append ( arg1 ) ; } return output . toString ( ) ; }
public ByteBuffer function ( int arg0 ) throws IOException { Validate . isTrue ( arg0 > = 0 , " maxSize must be 0 (unlimited) or larger " ) ; final boolean localCapped = arg0 > 0 ; final int bufferSize = localCapped & & arg0 < DefaultSize ? arg0 : DefaultSize ; final byte [ ] readBuffer = new byte [ bufferSize ] ; final ByteArrayOutputStream outStream = new ByteArrayOutputStream ( bufferSize ) ; int read ; while ( true ) { read = read ( readBuffer , 0 , bufferSize ) ; if ( read = = - 1 ) break ; if ( localCapped ) { if ( read > = arg0 ) { outStream . write ( readBuffer , 0 , arg0 ) ; break ; } } outStream . write ( readBuffer , 0 , read ) ; } return ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; }
public boolean function ( FullHttpRequest arg0 ) { return data . getMatcher ( ) . match ( arg0 ) ; }
String function ( ) { int start = pos ; while ( pos < length ) { char c = input [ pos ] ; if ( ( c > = 'A' & & c < = 'Z' ) | | ( c > = 'a' & & c < = 'z' ) ) pos + + ; else break ; } return new String ( input , start , pos - start ) ; }
public RestSetting function ( final RestPutSetting arg0 ) { return MocoRest . put ( arg0 . id ) . response ( arg0 . getResponseHandler ( ) ) ; }
private String function ( DurationUnit arg0 , String arg1 , String arg2 , String arg3 ) { StringBuilder buf = new StringBuilder ( ) ; buf . append ( arg1 ) ; buf . append ( "  Profiler [ " ) ; buf . append ( name ) ; buf . append ( " ] " ) ; buf . append ( SpacePadder . LINE_SEP ) ; for ( TimeInstrument child : childTimeInstrumentList ) { if ( child instanceof StopWatch ) { buildStopWatchString ( buf , arg0 , ELAPSED_TIME , arg3 , ( StopWatch ) child ) ; } else if ( child instanceof Profiler ) { Profiler profiler = ( Profiler ) child ; String subString = profiler . buildProfilerString ( arg0 , NESTED_PROFILER_FIRST_PREFIX , SUBTOTAL_ELAPSED , arg3 + "      " ) ; buf . append ( subString ) ; buildStopWatchString ( buf , arg0 , ELAPSED_TIME , arg3 , profiler . globalStopWatch ) ; } } buildStopWatchString ( buf , arg0 , arg2 , arg3 , globalStopWatch ) ; return buf . toString ( ) ; }
protected static Object function ( String arg0 , ClassLoader arg1 ) { throw new UnsupportedOperationException ( " Operation [factoryClass] is not supported in jcl-over-slf4j. See also  " + UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J ) ;
public String function ( String arg0 ) { return consumeToAny ( arg0 ) ; }
public void function ( ) throws Exception { httpServer ( port ( ) , hit ) ; assertThrows ( VerificationException . class , ( ) - > hit . verify ( by ( uri ( " /foo " ) ) , times ( 1 ) ) ) ; }
public void function ( ) throws Exception { String content = org . apache . http . client . fluent . Request . Post ( root ( ) ) . bodyForm ( new BasicNameValuePair ( " name " , " dreamhead " ) ) . execute ( ) . returnContent ( ) . asString ( ) ; assertThat ( content , is ( " foobar " ) ) ; }
private static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { return new EndsWithMatcher < T > ( arg0 , arg1 ) ; }
public Builder function ( final TextContainer arg0 ) { this . url = arg0 ; return this ; }
public boolean function ( Element arg0 , Element arg1 ) { Element prev = arg1 . previousElementSibling ( ) ; while ( prev ! = null ) { if ( sel . matches ( arg0 , prev ) ) return true ; prev = prev . previousElementSibling ( ) ; } return false ; }
public void function ( ) { InputStream stream = getResourceAsStream ( " settings/settings.json " ) ; ImmutableList < GlobalSetting > globalSettings = parser . parse ( stream ) ; assertThat ( globalSettings . get ( 0 ) . includes ( ) . get ( 0 ) , is ( join ( " src " , " test " , " resources " , " settings " , " details " , " foo.json " ) ) ) ; assertThat ( globalSettings . get ( 1 ) . includes ( ) . get ( 0 ) , is ( join ( " src " , " test " , " resources " , " settings " , " details " , " bar.json " ) ) ) ; }
public boolean function ( String arg0 ) { if ( arg0 = = null ) { throw new IllegalArgumentException ( " Other cannot be null " ) ; } if ( this . arg0 . equals ( arg0 ) ) { return true ; } if ( hasChildren ( ) ) { for ( int i = 0 ; i < children . size ( ) ; i + + ) { Marker child = ( Marker ) children . get ( i ) ; if ( child . contains ( arg0 ) ) { return true ; } } } return false ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 175 ) ;
public static RestSetting function ( final RequestMatcher arg0 , final ResponseHandler arg1 ) { return new GetAllRestSetting ( arg0 , checkNotNull ( arg1 , " Get response handler should not be null " ) ) ;
public static MocoJunitRunner function ( final SocketServer arg0 ) { checkNotNull ( arg0 , " Server should not be null " ) ; return new MocoJunitRunner ( runner ( arg0 ) ) ; }
public void function ( ) { int old = 15 ; int t = 16 ; { String msg = " Temperature set to {}. Old temperature was {}. " ; logger . atDebug ( ) . addArgument ( t ) . addArgument ( old ) . log ( msg ) ; assertLogMessage ( " Temperature set to 16. Old temperature was 15. " , 0 ) ; } { String msg = " Temperature set to {}. Old temperature was {}. " ; logger . atDebug ( ) . log ( msg , t , old ) ; assertLogMessage ( " Temperature set to 16. Old temperature was 15. " , 0 ) ; } { String msg = " Temperature set to {}. Old temperature was {}. " ; logger . atDebug ( ) . addArgument ( t ) . log ( msg , old ) ; assertLogMessage ( " Temperature set to 16. Old temperature was 15. " , 0 ) ; } { String msg = " Temperature set to {}. Old temperature was {}. " ;
public ResponseSetting function ( final Resource arg0 ) { return this . response ( with ( checkNotNull ( arg0 , " Resource should not be null " ) ) ) ; }
private void function ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 = = null | | part1 . length ( ) = = 0 ) path = " / " ; else path = part1 ; if ( part2 ! = null ) path + = '?' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port ! = WebSocketImpl . DEFAULT_PORT & & port ! = WebSocketImpl . DEFAULT_WSS_PORT ) ? " : " + port : " " ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( " Host " , host ) ; if ( headers ! = null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
public final T function ( final ImmutableList < InputStream > arg0 , final Optional < Integer > arg1 , final MocoConfig . . . arg2 ) { ImmutableList < SessionSetting > settings = Jsons . toObjects ( arg0 , SessionSetting . class ) ; return createServer ( settings , arg1 . orElse ( 0 ) , arg2 ) ; }
public MessageContent function ( final Request arg0 ) { MessageContent messageContent = reader . readFor ( arg0 ) ; byte [ ] transformed = transformer . apply ( messageContent . getContent ( ) ) ; return MessageContent . content ( ) . withCharset ( messageContent . getCharset ( ) )
public void function ( Marker arg0 , String arg1 , Object [ ] arg2 ) { info ( arg1 , arg2 ) ; }
public void function ( ) throws Exception { Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; String msg = " hello world  " + diff ; logger . info ( msg ) ; assertEquals ( 1 , sps . stringList . size ( ) ) ; String s0 = ( String ) sps . stringList . get ( 0 ) ; assertTrue ( s0 . contains ( msg ) ) ;
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . request ( not ( by ( uri ( " /foo " ) ) ) ) . response ( " bar " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . get ( remoteUrl ( " /bar " ) ) ) ) ;
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_T , BYTE_ESZETT , BYTE_G , 0 , 0 , BYTE_T , BYTE_G , BYTE_A , 0 , 0 , BYTE_G , BYTE_A } ; assertEquals ( 8 , BufferTools . indexOfTerminator ( buffer , 0 , 2 ) ) ; }
public static Resource function ( final String arg0 ) { return arg0 ( text ( checkNotNull ( arg0 , " Version should not be null " ) ) ) ; }
public void function ( ) throws Exception { ID3v2TextFrameData frameData = new ID3v2TextFrameData ( false , new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_TEXT ) ) ; assertEquals ( frameData , frameData ) ; }
public void function ( byte [ ] arg0 ) { try { getConnection ( ) . send ( arg0 ) ;
public void function ( String arg0 , Object . . . arg1 ) { formatAndLog ( LOG_LEVEL_TRACE , arg0 , arg1 ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , response ( header ( " foo " , " bar " ) ) ) ; server . response ( status ( 200 ) , with ( version ( VERSION_1_0 ) ) ) ; running ( server , new Runnable ( ) { @Override
public FileContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return asFileContainer ( helper . text ( arg0 ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; String target = arg0 . getText ( ) . trim ( ) ; if ( isForFileContainer ( target ) ) { return toFileContainer ( arg0 ) ; } return asFileContainer ( helper . textContainer ( arg0 , arg1 ) ) ; } return ( FileContainer ) arg1 . handleUnexpectedToken ( FileContainer . class , arg0 ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( logger . isDebugEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
@Test public void function ( ) { Tag p1 = Tag . valueOf ( " P " ) ; Tag p2 = Tag . valueOf ( " p " ) ; assertEquals ( p1 , p2 ) ; }
public String function ( ) { StringBuilder accum = StringUtil . stringBuilder ( ) ; html ( accum ) ; return getOutputSettings ( ) . prettyPrint ( ) ? accum . toString ( ) . trim ( ) : accum . toString ( ) ; }
public boolean function ( Element arg0 ) { Matcher m = pattern . matcher ( arg0 . ownText ( ) ) ; return m . find ( ) ; }
public static String function ( byte [ ] arg0 ) throws CharacterCodingException { return stingAscii ( arg0 , 0 , arg0 . length ) ; }
private void function ( ) { fileChooser = new JFileChooser ( ) ; fileChooser . setDialogTitle ( " Source folder selector " ) ; fileChooser . setFileSelectionMode ( JFileChooser . DIRECTORIES_ONLY ) ; }
public void function ( ) { logger . warn ( message , param1 , param2 , param3 ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . WARN , threeParams , null ) ; }
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , put ( " 1 " ) . request ( eq ( header ( HttpHeaders . IF_MATCH ) , " moco " ) ) . response ( status ( 200 ) ) ) ; running ( server , ( ) - > { HttpResponse httpResponse = helper . putForResponseWithHeaders ( remoteUrl ( " /targets/1 " ) ,
public void function ( ) throws Exception { server . request ( not ( by ( uri ( " /foo " ) ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
private static void function ( StringBuilder arg0 , boolean [ ] arg1 ) { arg0 . append ( '[' ) ; final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { arg0 . append ( arg1 [ i ] ) ; if ( i ! = len - 1 ) arg0 . append ( " ,  " ) ; } arg0 . append ( ']' ) ; }
protected void function ( Level arg0 , Marker arg1 , String arg2 , Object [ ] arg3 , Throwable arg4 ) { List < Marker > markers = null ; if ( arg1 ! = null ) { markers = new ArrayList < > ( ) ; markers . add ( arg1 ) ; } innerHandleNormalizedLoggingCall ( arg0 , markers , arg2 , arg3 , arg4 ) ; }
public static Runner function ( final SocketServer arg0 ) { return new MocoSocketServer ( ( ActualSocketServer ) checkNotNull ( arg0 , " server should not be null " ) ) ; }
public void function ( ) throws Exception { final long latency = 1000 ; final long delta = 200 ; server . response ( latency ( latency ) ) ; running ( server , new Runnable ( ) { @Override
public WebSocketImpl function ( WebSocketAdapter arg0 , List < Draft > arg1 ) { return null ; }
public void function ( ) throws Exception { server . request ( match ( uri ( " /proxy/.* " ) ) ) . response ( proxy ( from ( " /proxy " ) . to ( remoteUrl ( " /target " ) ) , failover ( " src/test/resources/failover.response " ) ) ) ; running ( server , ( ) - > assertThat ( helper . postContent ( remoteUrl ( " /proxy/1 " ) , " proxy " ) , is ( " proxy " ) ) ) ; }
public static String function ( Object arg0 ) { if ( arg0 = = null ) { return String . valueOf ( arg0 ) ; } Class < ? > objectClass = arg0 . getClass ( ) ; if ( unrenderableClasses . containsKey ( objectClass ) = = false ) { try { if ( objectClass . isArray ( ) ) { return renderArray ( arg0 , objectClass ) . toString ( ) ; } else { return arg0 . toString ( ) ; } } catch ( Exception e ) { Long now = Long . valueOf ( System . currentTimeMillis ( ) ) ; System . err . println ( " Disabling exception throwing class  " + objectClass . getName ( ) + " ,  " + e . getMessage ( ) ) ; unrenderableClasses . put ( objectClass , now ) ; } } String name = arg0 . getClass ( ) . getName ( ) ; return name + " @ " + Integer . toHexString ( arg0 . hashCode ( ) ) ; }
public boolean function ( Element arg0 , Element arg1 ) { if ( arg0 = = arg1 ) return false ; for ( Element parent = arg1 . parent ( ) ; parent ! = null ; parent = parent . parent ( ) ) { if ( memoMatches ( arg0 , parent ) ) return true ; if ( parent = = arg0 ) break ; } return false ; }
private org . apache . http . HttpVersion function ( HttpRequest arg0 ) { HttpVersion protocolVersion = arg0 . getProtocolVersion ( ) ; return new org . apache . http . HttpVersion ( protocolVersion . getMajorVersion ( ) , protocolVersion . getMinorVersion ( ) ) ; }
public Optional < String > function ( FullHttpRequest arg0 ) { return of ( arg0 . getMethod ( ) . name ( ) . toUpperCase ( ) ) ; }
private static Elements function ( Collection < Element > arg0 , Collection < Element > arg1 ) { Elements children = new Elements ( ) ; CHILDREN : for ( Element c : arg1 ) { for ( Element p : arg0 ) { if ( c . parent ( ) . equals ( p ) ) { children . add ( c ) ; continue CHILDREN ; } } } return children ; }
public void function ( ) { String version = Slf4jEnvUtil . slf4jVersion ( ) ; assertNotNull ( version ) ; assertTrue ( version . startsWith ( " 2 " ) ) ;
public static SSLContext function ( HttpsCertificate arg0 ) { try { KeyStore keyStore = KeyStore . getInstance ( " JKS " ) ;
private ImmutableMap < String , RequestExtractor < ? > > toVariables ( ImmutableMap < String , TextContainer > props ) { return copyOf ( Maps . transformEntries ( props , toVariable ( ) ) ) ; }
public Elements function ( ) { return nextElementSiblings ( true ) ; }
protected static RequestExtractor function ( final Method arg0 , final String arg1 ) { try { return RequestExtractor . class . cast ( arg0 . invoke ( null , arg1 ) ) ;
@Test void function ( ) throws IOException { Connection . Response res = Jsoup . connect ( RedirectServlet . Url ) . data ( RedirectServlet . LocationParam , echoUrl ) . header ( " Random-Header-name " , " hello " ) . proxy ( proxy . hostname , proxy . port ) . execute ( ) ; assertVia ( res ) ; Document doc = res . parse ( ) ; assertEquals ( echoUrl , doc . location ( ) ) ; assertEquals ( " hello " , ihVal ( " Random-Header-name " , doc ) ) ; assertVia ( res ) ; }
private HttpUriRequestBase function ( final HttpRequest arg0 , final URL arg1 ) { FullHttpRequest httpRequest = ( ( DefaultHttpRequest ) arg0 ) . toFullHttpRequest ( ) ; return prepareRemoteRequest ( httpRequest , arg1 ) ; }
public void function ( ) { FileResourceReader reader = new FileResourceReader ( text ( new File ( " src/test/resources/unknown.response " ) . getPath ( ) ) , Optional . < Charset > absent ( ) ) ; reader . readFor ( Optional . < Request > absent ( ) ) ; }
@Test public void function ( ) throws MalformedURLException { Connection con = HttpConnection . connect ( new URL ( " http://example.com " ) ) ; assertEquals ( " http://example.com " , con . request ( ) . url ( ) . toExternalForm ( ) ) ; }
public void function ( ) throws Exception { server . request ( eq ( xpath ( " /response/parameters/id/text() " ) , " 3 " ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ChannelHandlerContext arg0 ) throws Exception { arg0 . writeAndFlush ( defaultShutdownKey + " \ r \ n " ) ;
public static boolean function ( WebSocketImpl arg0 , ByteChannel arg1 ) throws IOException { ByteBuffer buffer = arg0 . outQueue . peek ( ) ; if ( buffer = = null ) { if ( arg1 instanceof WrappedByteChannel ) { WrappedByteChannel c = ( WrappedByteChannel ) arg1 ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do { arg1 . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { arg0 . outQueue . poll ( ) ; buffer = arg0 . outQueue . peek ( ) ; } } while ( buffer ! = null ) ; } if ( arg0 . isClosed ( ) ) { synchronized ( arg0 ) { arg1 . close ( ) ; } } return arg1 instanceof WrappedByteChannel = = true ? ! ( ( WrappedByteChannel ) arg1 ) . isNeedWrite ( ) : true ; }
private static HttpURLConnection function ( Connection . Request arg0 ) throws IOException { HttpURLConnection conn = ( HttpURLConnection ) arg0 . url ( ) . openConnection ( ) ; conn . setRequestMethod ( arg0 . method ( ) . name ( ) ) ; conn . setInstanceFollowRedirects ( false ) ; conn . setConnectTimeout ( arg0 . timeout ( ) ) ; conn . setReadTimeout ( arg0 . timeout ( ) ) ; if ( arg0 . method ( ) . hasBody ( ) ) conn . setDoOutput ( true ) ; if ( arg0 . cookies ( ) . size ( ) > 0 ) conn . addRequestProperty ( " Cookie " , getRequestCookieString ( arg0 ) ) ; for ( Map . Entry < String , String > header : arg0 . headers ( ) . entrySet ( ) ) { conn . addRequestProperty ( header . getKey ( ) , header . getValue ( ) ) ; } return conn ; }
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; org . apache . http . HttpResponse httpResponse = helper . postForResponse ( remoteUrl ( " /targets " ) , mapper . writeValueAsString ( resource1 ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 201 ) ) ; assertThat ( httpResponse . getFirstHeader ( " Location " ) . getValue ( ) , is ( " /targets/123 " ) ) ; }
public void function ( ) { BinaryFrame frame = new BinaryFrame ( ) ; assertEquals ( Opcode . BINARY , frame . getOpcode ( ) , " Opcode must be equal " ) ; assertTrue ( frame . isFin ( ) , " Fin must be set " ) ; assertFalse ( frame . getTransfereMasked ( ) , " TransferedMask must not be set " ) ; assertEquals ( 0 , frame . getPayloadData ( ) . capacity ( ) , " Payload must be empty " ) ; assertFalse ( frame . isRSV1 ( ) , " RSV1 must be false " ) ; assertFalse ( frame . isRSV2 ( ) , " RSV2 must be false " ) ; assertFalse ( frame . isRSV3 ( ) , " RSV3 must be false " ) ; try { frame . isValid ( ) ;
public void function ( ) { ID3v1 id3v1Tag = new ID3v1TagForTesting ( ) ; ID3v2 id3v2Tag = new ID3v2TagForTesting ( ) ; ID3Wrapper wrapper = new ID3Wrapper ( id3v1Tag , id3v2Tag ) ; wrapper . setComment ( " a comment " ) ; assertEquals ( " a comment " , id3v1Tag . getComment ( ) ) ; assertEquals ( " a comment " , id3v2Tag . getComment ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.14.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public boolean function ( ByteBuffer arg0 ) throws IOException { arg0 . clear ( ) ; int read = sockchannel . read ( arg0 ) ; arg0 . flip ( ) ; if ( read = = - 1 ) { if ( draft = = null ) { closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ; } else if ( draft . getCloseHandshakeType ( ) = = CloseHandshakeType . NONE ) { closeConnection ( CloseFrame . NORMAL , true ) ; } else if ( draft . getCloseHandshakeType ( ) = = CloseHandshakeType . ONEWAY ) { if ( role = = Role . SERVER ) closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ; else closeConnection ( CloseFrame . NORMAL , true ) ; } else { closeConnection ( CloseFrame . ABNORMAL_CLOSE , true ) ; } return false ; } return read ! = 0 ; }
void function ( ) { if ( bufPos < 1 ) throw new UncheckedIOException ( new IOException ( " No buffer left to unconsume " ) ) ; bufPos - - ; }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; TextFrame frame = new TextFrame ( ) ; try { deflateExtension . isFrameValid ( frame ) ; fail ( " Frame not valid. RSV1 must be set. " ) ; } catch ( Exception e ) { } frame . setRSV1 ( true ) ; try { deflateExtension . isFrameValid ( frame ) ; } catch ( Exception e ) { fail ( " Frame is valid. " ) ; } frame . setRSV2 ( true ) ; try { deflateExtension . isFrameValid ( frame ) ; fail ( " Only RSV1 bit must be set. " ) ; } catch ( Exception e ) { } ContinuousFrame contFrame = new ContinuousFrame ( ) ; contFrame . setRSV1 ( true ) ; try { deflateExtension . isFrameValid ( contFrame ) ; fail ( " RSV1 must only be set for first fragments.Continuous frames can't have RSV1 bit set. " ) ; } catch ( Exception e ) { } contFrame . setRSV1 ( false ) ; try { deflateExtension . isFrameValid ( contFrame ) ;
public boolean function ( String arg0 ) { Validate . notEmpty ( arg0 , " Cookie name must not be empty " ) ; return cookies . containsKey ( arg0 ) ; }
public void function ( ) { ID3v2ChapterTOCFrameData frameData1 = new ID3v2ChapterTOCFrameData ( false , true , false , null , new String [ ] { " ch1 " , " ch2 " } ) ; ID3v2ChapterTOCFrameData frameData2 = new ID3v2ChapterTOCFrameData ( false , true , false , null , new String [ ] { " ch1 " , " ch2 " } ) ; assertEquals ( frameData1 , frameData2 ) ; }
protected static byte [ ] function ( CharBuffer arg0 , String arg1 ) throws CharacterCodingException { Charset charset = Charset . forName ( arg1 ) ; CharsetEncoder encoder = charset . newEncoder ( ) ; ByteBuffer byteBuffer = encoder . encode ( arg0 ) ; return BufferTools . copyBuffer ( byteBuffer . array ( ) , 0 , byteBuffer . limit ( ) ) ; }
public void function ( ) throws IOException { assertThat ( helper . get ( " http://localhost:8080/foo " ) , is ( " bar " ) ) ; }
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { arg0 . append ( " <!DOCTYPE  " ) . append ( attr ( " name " ) ) ; if ( ! StringUtil . isBlank ( attr ( " publicId " ) ) ) arg0 . append ( "  PUBLIC  \" " ) . append ( attr ( " publicId " ) ) . append ( " \" " ) ; if ( ! StringUtil . isBlank ( attr ( " systemId " ) ) ) arg0 . append ( "   \" " ) . append ( attr ( " systemId " ) ) . append ( " \" " ) ; arg0 . append ( '>' ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.3.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { executor . onCompleteResponse ( arg0 , arg1 ) ; }
private Function < Map . Entry < String , String > , String > function ( final ImmutableMap < String , String > arg0 ) { return new Function < Map . Entry < String , String > , String > ( ) { @Override
public int function ( ) { final int prime = 31 ; int result = 1 ; result = prime * result + ( ( value = = null ) ? 0 : value . hashCode ( ) ) ; return result ; }
public synchronized void function ( Marker arg0 ) { if ( arg0 = = null ) { throw new IllegalArgumentException ( " A null value cannot be added to a Marker as child. " ) ; } if ( this . contains ( arg0 ) ) { return ;
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return startsWith ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " query.json " ) ; assertThat ( helper . get ( remoteUrl ( " /empty-query?param " ) ) , is ( " response_for_empty_query_request " ) ) ; }
public static HttpServer function ( final int arg0 , final MocoConfig . . . arg1 ) { return ActualHttpServer . createQuietServer ( of ( arg0 ) , arg1 ) ; }
public static SocketServer function ( final int arg0 ) { return ActualSocketServer . createQuietServer ( of ( arg0 ) ) ; }
List < Node > function ( String arg0 , Element arg1 , String arg2 , Parser arg3 ) { return parseFragment ( arg0 , arg2 , arg3 ) ; }
public boolean function ( ) { return channel instanceof ISSLChannel ; }
public FilterResult function ( Node arg0 , int arg1 ) { return ( " p " . equals ( arg0 . nodeName ( ) ) ) ? FilterResult . REMOVE : FilterResult . CONTINUE ; }
public String function ( ) { StringBuilder accum = StringUtil . stringBuilder ( ) ; outerHtml ( accum ) ; return accum . toString ( ) ; }
private Elements function ( arg0 String arg1 , boolean arg2 , boolean arg3 ) { Elements els = new Elements ( ) ; Evaluator eval = arg1 ! = null ? QueryParser . parse ( arg1 ) : null ; for ( Element e : this ) { do { Element sib = arg2 ? e . nextElementSibling ( ) : e . previousElementSibling ( ) ; if ( sib = = null ) break ; if ( eval = = null | | sib . is ( eval ) ) els . add ( sib ) ; e = sib ; } while ( arg3 ) ; } return els ; }
public static ResponseHandler function ( final RecorderConfig . . . arg0 ) { RecorderConfigurations configurations = RecorderConfigurations . create ( null , arg0 ) ; return new DynamicRecordHandler ( configurations ) ; }
public HandshakeBuilder function ( ClientHandshake arg0 , ServerHandshakeBuilder arg1 ) throws InvalidHandshakeException { arg1 . put ( " Upgrade " , " websocket " ) ; arg1 . put ( " Connection " , arg0 . getFieldValue ( " Connection " ) ) ; arg1 . setHttpStatusMessage ( " Switching Protocols " ) ; String seckey = arg0 . getFieldValue ( " Sec-WebSocket-Key " ) ; if ( seckey = = null ) throw new InvalidHandshakeException ( " missing Sec-WebSocket-Key " ) ; arg1 . put ( " Sec-WebSocket-Accept " , generateFinalKey ( seckey ) ) ; return arg1 ; }
private HttpServer function ( Iterable < ? extends RunnerSetting > arg0 , Optional < Integer > arg1 ) { HttpServer server = ActualHttpServer . createLogServer ( arg1 ) ; for ( RunnerSetting setting : arg0 ) { HttpServer parsedServer = httpServerParser . parseServer ( setting . getStream ( ) , arg1 , toConfigs ( setting ) ) ; server = mergeServer ( server , parsedServer ) ; } return server ; }
protected MessageContent function ( final Request arg0 ) { return MessageContent . content ( ) . withContent ( toJson ( this . pojo ) ) . build ( ) ; }
public Optional < InputSource > function ( final Request arg0 , final ContentRequestExtractor arg1 ) { Optional < MessageContent > content = arg1 . extract ( arg0 ) ; if ( content . isPresent ( ) ) { return of ( new InputSource ( new ByteArrayInputStream ( content . get ( ) . getContent ( ) ) ) ) ; } return absent ( ) ; }
public boolean function ( ) throws InterruptedException { connect ( ) ; connectLatch . await ( ) ; return engine . isOpen ( ) ; }
public void function ( String arg0 , AbstractID3v2FrameData arg1 ) { subframes . add ( new ID3v2Frame ( arg0 , arg1 . toBytes ( ) ) ) ; }
public void function ( ) { InputStream stream = getResourceAsStream ( " settings/fileroot-settings.json " ) ; ImmutableList < GlobalSetting > globalSettings = parser . parse ( stream ) ; assertThat ( globalSettings . get ( 0 ) . includes ( ) . get ( 0 ) , is ( join ( " src " , " test " , " resources " , " settings " , " fileroot.json " ) ) ) ; assertThat ( globalSettings . get ( 0 ) . getContext ( ) , is ( " /fileroot " ) ) ; assertThat ( globalSettings . get ( 0 ) . getFileRoot ( ) , is ( " src/test/resources " ) ) ; }
public void function ( ) throws Exception { byte [ ] bytes = { 'A' , 'd' , 'd' , 'r' , 'e' , 's' , 's' , 0 , ( byte ) 0x00 } ; ID3v2PopmFrameData iD3v2PopmFrameData = new ID3v2PopmFrameData ( false , bytes ) ; assertEquals ( " Address " , iD3v2PopmFrameData . getAddress ( ) ) ; }
public ServerHandshakeBuilder function ( WebSocket arg0 , Draft arg1 , ClientHandshake arg2 ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
public void function ( ) throws Exception { byte [ ] bytes = BufferTools . stringToByteBuffer ( " xxxxx " + T_FRAME , 0 , 5 + T_FRAME . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( bytes , 8 ) ; ID3v2ObseleteFrame frame = new ID3v2ObseleteFrame ( bytes , 5 ) ; assertEquals ( 40 , frame . getLength ( ) ) ; assertEquals ( " TP1 " , frame . getId ( ) ) ; String s = " 0ARTISTABCDEFGHIJKLMNOPQRSTUVWXYZ0 " ; byte [ ] expectedBytes = BufferTools . stringToByteBuffer ( s , 0 , s . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( expectedBytes , 0 ) ; assertTrue ( Arrays . equals ( expectedBytes , frame . getData ( ) ) ) ; }
public String function ( ) { return " Framedata{ optcode: " + getOpcode ( ) + " , fin: " + isFin ( ) + " , masked: " + getTransfereMasked ( ) + " , payloadlength: " + unmaskedpayload . limit ( ) + " , payload: " + Charsetfunctions . utf8Bytes ( new String ( unmaskedpayload . array ( ) ) ) + " } " ; }
private static Server function ( ) { return new Server ( new InetSocketAddress ( Localhost , 0 ) ) ; }
public void function ( ) { String styleContents = " foo < bar > qux {color:white;} " ; String html = " <head><style> " + styleContents + " </style></head> " ; Document doc = Jsoup . parse ( html ) ; Element head = doc . head ( ) ; Element style = head . selectFirst ( " style " ) ; assertNotNull ( style ) ; assertEquals ( styleContents , style . html ( ) ) ; style . html ( styleContents ) ; assertEquals ( styleContents , style . html ( ) ) ; assertEquals ( " " , style . text ( ) ) ; style . text ( styleContents ) ; assertEquals ( " " , style . text ( ) ) ; assertEquals ( styleContents , style . html ( ) ) ; }
public boolean function ( ) { return empty | | selfClosing ; }
public void function ( ) { connections . clear ( ) ; connections . addAll ( connections ( ) ) ; long current = ( System . currentTimeMillis ( ) - ( connectionLostTimeout * 1500 ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; if ( webSocketImpl . getLastPong ( ) < current ) { if ( WebSocketImpl . DEBUG ) System . out . println ( " Closing connection due to no pong received:  " + conn . toString ( ) ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , false ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { if ( WebSocketImpl . DEBUG ) System . out . println ( " Trying to ping a non open connection:  " + conn . toString ( ) ) ; } } } } connections . clear ( ) ; }
public static ResponseHandler function ( final String arg0 ) { return new RecordHandler ( RequestRecorder . getRecorder ( arg0 ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div title='Tags &amp;c.'><img src=foo.png><p><!-- comment -->Hello<p>there " ) ; assertEquals ( " <html><head></head><body><div title= \" Tags &amp;c. \" ><img src= \" foo.png \"  /><p><!-- comment -->Hello</p><p>there</p></div></body></html> " , TextUtil . stripNewlines ( doc . outerHtml ( ) ) ) ;
public Document function ( String arg0 , String arg1 ) { Document doc = treeBuilder . parse ( arg0 , arg1 , trackErrors ) ; errors = treeBuilder . getErrors ( ) ; return doc ; }
public final void function ( WebSocket arg0 ) { try { key . interestOps ( SelectionKey . OP_READ | SelectionKey . OP_WRITE ) ;
public boolean function ( Element arg0 ) { Element el = ( Element ) arg0 ; if ( tag ! = null & & ! el . tagName ( ) . equals ( tag ) ) return false ; if ( cls ! = null & & ! el . className ( ) . equals ( cls ) ) return false ; if ( id ! = null & & ! el . id ( ) . equals ( id ) ) return false ; return true ; }
protected final void function ( byte [ ] arg0 ) throws InvalidDataException { if ( unsynchronisation & & BufferTools . sizeSynchronisationWouldSubtract ( arg0 ) > 0 ) { byte [ ] synchronisedBytes = BufferTools . synchroniseBuffer ( arg0 ) ;
protected void function ( ChannelBuffer arg0 ) { arg0 . writeBytes ( resources [ current ( ) ] . asByteArray ( ) ) ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object arg3 ) { handleNormalizedLoggingCall ( arg0 , arg1 , arg2 , new Object [ ] { arg3 } , null ) ; }
public boolean function ( Marker arg0 ) { return isWarnEnabled ( ) ; }
public void function ( ChannelHandlerContext arg0 ) throws Exception { arg0 . writeAndFlush ( shutdownKey + " \ r \ n " ) . addListener ( ChannelFutureListener . CLOSE ) ; }
String function ( ) { return lastStartTag ; }
boolean function ( String arg0 ) { return inSpecificScope ( arg0 , new String [ ] { " html " , " table " } , null ) ; }
@Test public void function ( ) { Connection con = HttpConnection . connect ( " http://example.com/ " ) ; con . timeout ( 1000 ) ; assertEquals ( 1000 , con . request ( ) . timeout ( ) ) ; }
public Optional < String > function ( final HttpRequest arg0 ) { Optional < ImmutableMap < String , String > > cookies = extractor . extract ( arg0 ) ; return cookies . isPresent ( ) ? fromNullable ( cookies . get ( ) . get ( this . key ) ) : Optional . < String > absent ( ) ; }
public boolean function ( String arg0 , String arg1 ) { return parentNode ! = null & & parentNode instanceof Element & & ( ( Element ) parentNode ) . elementIs ( arg0 , arg1 ) ;
protected final void function ( final HttpRequest arg0 , final MutableHttpResponse arg1 ) { String value = header . getValue ( ) . readFor ( arg0 ) . toString ( ) ; arg1 . addHeader ( header . getName ( ) , value ) ; }
public StartArgs function ( String [ ] arg0 ) { try { return doParse ( this . serverType , arg0 ) ;
public Watcher function ( final File arg0 ) { return create ( fileRunner , arg0 ) ; }
public boolean function ( ) { return validateTSLCertificates ; }
public Draft function ( ) { ArrayList < IExtension > newExtensions = new ArrayList < IExtension > ( ) ; for ( IExtension iExtension : getKnownExtensions ( ) ) { newExtensions . add ( iExtension . copyInstance ( ) ) ; } ArrayList < IProtocol > newProtocols = new ArrayList < IProtocol > ( ) ; for ( IProtocol iProtocol : getKnownProtocols ( ) ) { newProtocols . add ( iProtocol . copyInstance ( ) ) ; } return new Draft_6455 ( newExtensions , newProtocols ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <p><img src=foo.png id=1><img src=bar.jpg id=2><img src=qux.JPEG id=3><img src=old.gif><img></p> " ) ; Elements imgs = SelectMatch . match ( doc , Parser . parse ( " img[src~=(?i) \\ .(png|jpe?g)] " ) ) ; assertEquals ( 3 , imgs . size ( ) ) ; assertEquals ( " 1 " , imgs . get ( 0 ) . id ( ) ) ; assertEquals ( " 2 " , imgs . get ( 1 ) . id ( ) ) ; assertEquals ( " 3 " , imgs . get ( 2 ) . id ( ) ) ; }
public void function ( SessionContext arg0 ) { HttpRequest request = arg0 . getRequest ( ) ; FullHttpResponse response = arg0 . getResponse ( ) ; CloseableHttpClient httpclient = HttpClients . createDefault ( ) ; try { FullHttpRequest httpRequest = ( ( com . github . dreamhead . moco . model . DefaultHttpRequest ) arg0 . getRequest ( ) ) . toFullHttpRequest ( ) ;
public void function ( ) throws Exception { testHandshakeRejection ( 11 ) ; }
public void function ( ) throws IOException { this . buffer . rewind ( ) ; int bytesRead = this . socketChannel . read ( this . buffer ) ; if ( bytesRead = = - 1 ) close ( ) ; if ( bytesRead > 0 ) { this . buffer . rewind ( ) ;
public void function ( ) throws Exception { server . request ( startsWith ( header ( " foo " ) , " bar " ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { EncodedText encodedText = new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , TEST_STRING ) ; assertEquals ( EncodedText . CHARSET_ISO_8859_1 , encodedText . getCharacterSet ( ) ) ; assertEquals ( TEST_STRING , encodedText . toString ( ) ) ; EncodedText encodedText2 = new EncodedText ( EncodedText . TEXT_ENCODING_ISO_8859_1 , encodedText . toBytes ( ) ) ; assertEquals ( encodedText , encodedText2 ) ; }
public LoggingEventBuilder function ( Marker arg0 ) { loggingEvent . addMarker ( arg0 ) ; return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 4.1.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
static String function ( CtBehavior arg0 , LocalVariableAttribute arg1 , int arg2 ) { if ( arg1 = = null ) { return Integer . toString ( arg2 + 1 ) ; } int modifiers = arg0 . getModifiers ( ) ; int j = arg2 ; if ( Modifier . isSynchronized ( modifiers ) ) { j + + ; } if ( Modifier . isStatic ( modifiers ) = = false ) { j + + ; } String variableName = arg1 . variableName ( j ) ; if ( variableName . equals ( " this " ) ) { System . err . println ( " this returned as a parameter name for  " + arg0 . getName ( ) + "  index  " + j + " , names are probably shifted. " ) ; } return variableName ; }
public void function ( ) { final Elements sel = html . select ( " :only-of-type " ) ; assertEquals ( 6 , sel . size ( ) ) ; assertEquals ( " head " , sel . get ( 0 ) . tagName ( ) ) ; assertEquals ( " body " , sel . get ( 1 ) . tagName ( ) ) ; assertEquals ( " span " , sel . get ( 2 ) . tagName ( ) ) ; assertEquals ( " br " , sel . get ( 3 ) . tagName ( ) ) ; assertEquals ( " p " , sel . get ( 4 ) . tagName ( ) ) ; assertTrue ( sel . get ( 4 ) . hasClass ( " empty " ) ) ; assertEquals ( " em " , sel . get ( 5 ) . tagName ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " post_foo " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " 0XCAFEBABE " ) ) ; }
private org . apache . hc . core5 . http . HttpVersion function ( final FullHttpRequest arg0 ) { HttpVersion protocolVersion = arg0 . protocolVersion ( ) ; return new org . apache . hc . core5 . http . HttpVersion ( protocolVersion . majorVersion ( ) , protocolVersion . minorVersion ( ) ) ; }
public final Builder function ( final FailoverContainer arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( String arg0 ) { System . out . println ( " got:  " + arg0 ) ;
int function ( ) { if ( ! isTrackNewlines ( ) ) return pos ( ) + 1 ; int i = lineNumIndex ( ) ; if ( i = = - 1 ) return pos ( ) + 1 ; if ( i < 0 ) i = Math . abs ( i ) - 2 ; return pos ( ) - newlinePositions . get ( i ) + 1 ; }
public void function ( ) throws Exception { testProtocolRejection ( 27 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " opc " ) ) ) ) ;
void function ( ) { commentPending = new Token . Comment ( ) ; }
protected void function ( RequestMatcher arg0 , ResponseHandler arg1 ) { if ( arg1 ! = null ) { this . response ( arg1 ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 ) { if ( ! logger . isInfoEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 )
public LatencyContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_NUMBER_INT ) { return LatencyContainer . latency ( arg0 . getLongValue ( ) ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; InternalLatencyContainer container = get ( arg0 . readValuesAs ( InternalLatencyContainer . class ) , 0 ) ; return LatencyContainer . latencyWithUnit ( container . duration , TimeUnit . valueOf ( container . unit . toUpperCase ( ) + 'S' ) ) ; } throw arg1 . mappingException ( LatencyContainer . class , currentToken ) ; }
public Whitelist function ( String . . . arg0 ) { for ( String tagName : arg0 ) { tagNames . add ( TagName . valueOf ( tagName ) ) ; } return this ; }
@Test public void function ( ) { String html = " <html><head><title>First!</title></head><body><p class= \" foo > bar \" >First post! <img src= \" foo.png \"  /></p></body></html> " ; Document doc = Jsoup . parse ( html ) ; Element p = doc . child ( 1 ) . child ( 0 ) ; assertEquals ( " p " , p . tagName ( ) ) ; assertEquals ( " foo > bar " , p . attr ( " class " ) ) ; }
public void function ( Object arg0 , Object arg1 ) { lbLogger . warn ( ( String ) arg0 , arg1 ) ; }
public void function ( ) { try { helper . get ( " http://localhost:9090/foo " ) ;
private LogRecord function ( LoggingEvent arg0 , Level arg1 ) { String format = arg0 . getMessage ( ) ; Object [ ] arguments = arg0 . getArgumentArray ( ) ; FormattingTuple ft = MessageFormatter . arrayFormat ( format , arguments ) ; if ( ft . getThrowable ( ) ! = null & & arg0 . getThrowable ( ) ! = null ) { throw new IllegalArgumentException ( " both last element in argument array and last argument are of type Throwable " ) ; } Throwable t = arg0 . getThrowable ( ) ; if ( ft . getThrowable ( ) ! = null ) { t = ft . getThrowable ( ) ; throw new IllegalStateException ( " fix above code " ) ; } LogRecord record = new LogRecord ( arg1 , ft . getMessage ( ) ) ; record . setLoggerName ( arg0 . getLoggerName ( ) ) ; record . setMillis ( arg0 . getTimeStamp ( ) ) ; record . setSourceClassName ( EventConstants . NA_SUBST ) ; record . setSourceMethodName ( EventConstants . NA_SUBST ) ; record . setThrown ( t ) ; return record ; }
private void function ( ) { String key = tq . consumeToAny ( " = " , " != " , " ^= " , " $= " , " *= " , " ] " ) ; Validate . notEmpty ( key ) ; if ( tq . matchChomp ( " ] " ) ) { elements . addAll ( root . getElementsByAttribute ( key ) ) ;
public void function ( ) throws IOException { Connection session = Jsoup . newSession ( ) ; Document doc1 = session . newRequest ( ) . url ( CookieServlet . Url ) . data ( CookieServlet . LocationParam , EchoServlet . Url ) . data ( CookieServlet . SetCookiesParam , " 1 " ) . get ( ) ; assertEquals ( EchoServlet . Url , doc1 . location ( ) ) ; assertEchoServlet ( doc1 ) ; Document doc2 = session . newRequest ( ) . url ( EchoServlet . Url ) . get ( ) ; assertEchoServlet ( doc2 ) ; Document doc3 = session . newRequest ( ) . url ( CookieServlet . Url ) . get ( ) ; assertCookieServlet ( doc3 ) ; }
private static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { return new MatchMatcher < T > ( arg0 , arg1 ) ; }
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; Throwable t = new UnsupportedOperationException ( " Test " ) ; logger . throwing ( t ) ; logger . throwing ( XLogger . Level . DEBUG , t ) ; assertEquals ( 2 , listAppender . list . size ( ) ) ; verifyWithException ( ( LoggingEvent ) listAppender . list . get ( 0 ) , " throwing " , t ) ; LoggingEvent event = ( LoggingEvent ) listAppender . list . get ( 1 ) ; verifyWithLevelAndException ( event , XLogger . Level . DEBUG , " throwing " , t ) ;
public void function ( ) { connections . clear ( ) ; connections . addAll ( connections ( ) ) ; long current = ( System . currentTimeMillis ( ) - ( connectionLostTimeout * 1500 ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; if ( webSocketImpl . getLastPong ( ) < current ) { if ( WebSocketImpl . DEBUG ) System . out . println ( " Closing connection due to no pong received:  " + conn . toString ( ) ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , false ) ; } else { webSocketImpl . sendPing ( ) ; } } } connections . clear ( ) ; }
public void function ( ) throws Exception { InputStream asStream = this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( " foo.request " ) ; byte [ ] bytes = ByteStreams . toByteArray ( asStream ) ; assertThat ( helper . postContent ( root ( ) , new String ( bytes ) ) , is ( " foo " ) ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) { return true ; } if ( ! ( arg0 instanceof EventData | | arg0 instanceof Map ) ) { return false ; } Map < String , Object > map = ( arg0 instanceof EventData ) ? ( ( EventData ) arg0 ) . getEventMap ( ) : ( Map < String , Object > ) arg0 ; return this . eventData . equals ( map ) ; }
public String function ( ) { StringBuilder sb = StringUtil . borrowBuilder ( ) ; for ( Node childNode : childNodes ) { if ( childNode instanceof DataNode ) { DataNode data = ( DataNode ) childNode ; sb . append ( data . getWholeData ( ) ) ; } else if ( childNode instanceof Comment ) { Comment comment = ( Comment ) childNode ; sb . append ( comment . getData ( ) ) ; } else if ( childNode instanceof Element ) { Element element = ( Element ) childNode ; String elementData = element . data ( ) ; sb . append ( elementData ) ; } else if ( childNode instanceof CDataNode ) { CDataNode cDataNode = ( CDataNode ) childNode ; sb . append ( cDataNode . getWholeText ( ) ) ; } } return StringUtil . releaseBuilder ( sb ) ; }
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " Resource should not be null " ) ; return eq ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
public void function ( ServiceReference arg0 , int arg1 , String arg2 , Throwable arg3 ) { switch ( arg1 ) { case LOG_DEBUG :
public void function ( ) { { Abbreviator abb = new Abbreviator ( 2 , 100 , FS ) ; String r = abb . abbreviate ( INPUT_0 ) ; assertEquals ( INPUT_0 , r ) ; } { Abbreviator abb = new Abbreviator ( 3 , 8 , FS ) ; String r = abb . abbreviate ( INPUT_0 ) ; assertEquals ( " /abc/.../ABC " , r ) ; } { Abbreviator abb = new Abbreviator ( 3 , 8 , FS ) ;
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { return true ;
static String function ( String arg0 , Document . OutputSettings arg1 ) { StringBuilder accum = new StringBuilder ( arg0 . length ( ) * 2 ) ; escape ( accum , arg0 , arg1 , false , false , false ) ; return accum . toString ( ) ; }
public void function ( ) { PingFrame frame = new PingFrame ( ) ; assertEquals ( " Opcode must be equal " , Opcode . PING , frame . getOpcode ( ) ) ; assertEquals ( " Fin must be set " , true , frame . isFin ( ) ) ; assertEquals ( " TransferedMask must not be set " , false , frame . getTransfereMasked ( ) ) ; assertEquals ( " Payload must be empty " , 0 , frame . getPayloadData ( ) . capacity ( ) ) ; assertEquals ( " RSV1 must be false " , false , frame . isRSV1 ( ) ) ; assertEquals ( " RSV2 must be false " , false , frame . isRSV2 ( ) ) ; assertEquals ( " RSV3 must be false " , false , frame . isRSV3 ( ) ) ; try { frame . isValid ( ) ;
public int function ( ) { if ( parent ( ) = = null ) return 0 ; return indexInList ( this , parent ( ) . childElementsList ( ) ) ; }
static final public void function ( String arg0 , Throwable arg1 ) { getTarget ( ) . println ( SLF4J_ERROR_PREFIX + arg0 ) ; getTarget ( ) . println ( SLF4J_ERROR_PREFIX + " Reported exception: " ) ; arg1 . printStackTrace ( getTarget ( ) ) ; }
public static void function ( EventData arg0 ) { if ( eventLogger . instanceofLAL ) { ( ( LocationAwareLogger ) eventLogger . logger ) . log ( EVENT_MARKER , FQCN ,
public void function ( ) throws Exception { server . response ( cors ( ) ) ; running ( server , ( ) - > { ClassicHttpResponse response = helper . getResponseWithHeader ( root ( ) , of ( " Origin " , " https://www.github.com/ " ) ) ;
@Test public void function ( ) { Parser parser = Parser . htmlParser ( ) ; parser . settings ( new ParseSettings ( true , true ) ) ; Document doc = parser . parseInput ( " <div id=1><SPAN ID=2> " , " " ) ; assertEquals ( " <html> <head></head> <body> <div id= \" 1 \" > <SPAN ID= \" 2 \" ></SPAN> </div> </body> </html> " , StringUtil . normaliseWhitespace ( doc . outerHtml ( ) ) ) ; Element div = doc . selectFirst ( " #1 " ) ; div . after ( " <TaG ID=one>One</TaG> " ) ; assertEquals ( " <TaG ID= \" one \" >One</TaG> " , TextUtil . stripNewlines ( div . nextElementSibling ( ) . outerHtml ( ) ) ) ; }
public static List < Node > function ( String arg0 , Element arg1 , String arg2 ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( arg0 , arg1 , arg2 ) ; }
protected int function ( Element arg0 , Element arg1 ) { Element parent = arg1 . parent ( ) ; if ( parent = = null ) return 0 ; int pos = 0 ; final int size = parent . childNodeSize ( ) ; for ( int i = 0 ; i < size ; i + + ) { Node node = parent . childNode ( i ) ; if ( node . normalName ( ) . equals ( arg1 . normalName ( ) ) ) pos + + ; if ( node = = arg1 ) break ; } return pos ; }
public void function ( ) { while ( server . getConnectionLostTimeout ( ) = = 60 ) { } countServerDownLatch . countDown ( ) ; }
public static MocoMonitor function ( final String arg0 , final Charset arg1 ) { return new LogMonitor ( new DefaultLogFormatter ( ) , new FileLogWriter ( checkNotNullOrEmpty ( arg0 , " Filename should not be null or empty " ) , of ( checkNotNull ( arg1 , " Charset should not be null " ) ) ) ) ; }
public void function ( ) throws IOException { String content = Request . Post ( remoteUrl ( " /template " ) ) . bodyForm ( new BasicNameValuePair ( " name " , " dreamhead " ) ) . execute ( ) . returnContent ( ) . asString ( ) ; assertThat ( content , is ( " dreamhead " ) ) ; }
protected HttpServer function ( final ImmutableList < SessionSetting > arg0 , final Optional < Integer > arg1 , final MocoConfig . . . arg2 ) { int actualPort = arg1 . or ( 0 ) ; ActualHttpServer targetServer = ActualHttpServer . createLogServer ( actualPort , arg2 ) ; for ( SessionSetting session : arg0 ) { logger . debug ( " Parse session: {} " , session ) ; targetServer = targetServer . mergeServer ( session . newHttpServer ( actualPort , arg2 ) ) ; } return targetServer ; }
public Range . AttributeRange function ( String arg0 ) { if ( ! hasKey ( arg0 ) ) return UntrackedAttr ; Map < String , Range . AttributeRange > ranges = ( Map < String , Range . AttributeRange > ) userData ( AttrRangeKey ) ; if ( ranges = = null ) return Range . AttributeRange . UntrackedAttr ; Range . AttributeRange range = ranges . get ( arg0 ) ; return range ! = null ? range : Range . AttributeRange . UntrackedAttr ; }
public boolean function ( ) { boolean seen = false ; while ( matchesWhitespace ( ) ) { consume ( ) ; seen = true ; } return seen ; }
public void function ( ) { ID3v2CommentFrameData frameData1 = new ID3v2CommentFrameData ( false , null , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , new EncodedText ( ( byte ) 0 , TEST_VALUE ) ) ; ID3v2CommentFrameData frameData2 = new ID3v2CommentFrameData ( false , null , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , new EncodedText ( ( byte ) 0 , TEST_VALUE ) ) ; assertEquals ( frameData1 , frameData2 ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { info ( arg1 , arg2 , arg3 ) ; }
protected boolean function ( final JsonNode arg0 , final JsonNode arg1 ) { if ( arg0 = = null ) { return false ; } if ( arg1 . isNull ( ) ) { return true ; } if ( arg0 . isNumber ( ) & & arg1 . isNumber ( ) ) { return true ; } if ( arg0 . isBoolean ( ) & & arg1 . isBoolean ( ) ) { return true ; } if ( arg0 . isTextual ( ) & & arg1 . isTextual ( ) ) { return true ; } if ( arg0 . isObject ( ) & & arg1 . isObject ( ) ) { return Streams . stream ( arg1 . fieldNames ( ) ) . allMatch ( name - > doMatch ( arg0 . get ( name ) , arg1 . get ( name ) ) ) ; } if ( arg0 . isArray ( ) & & arg1 . isArray ( ) ) { if ( arg0 . isEmpty ( ) ) { return true ; } JsonNode templateNode = arg0 . get ( 0 ) ; return Streams . stream ( arg1 ) . allMatch ( node - > doMatch ( templateNode , node ) ) ; } return false ; }
private HttpRequestBase function ( final FullHttpRequest arg0 , final URL arg1 ) { HttpRequestBase remoteRequest = createBaseRequest ( arg1 , arg0 . method ( ) ) ; for ( Map . Entry < String , String > entry : arg0 . headers ( ) ) { if ( isRequestHeader ( entry ) ) { remoteRequest . addHeader ( entry . getKey ( ) , entry . getValue ( ) ) ; } } return remoteRequest ; }
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { return new EqRequestMatcher < T > ( checkNotNull ( arg0 , " extractor should not be null " ) , arg1 ) ; }
@Test public void function ( ) { String html = " &amp &quot &reg &icy &hopf &icy; &hopf; " ; Document doc = Jsoup . parse ( html ) ; doc . outputSettings ( ) . escapeMode ( Entities . EscapeMode . extended ) ; assertEquals ( StringUtil . normaliseWhitespace ( " &amp; &quot; &reg; &amp;icy &amp;hopf &icy; &hopf; " ) , doc . body ( ) . html ( ) ) ; }
private Configuration function ( StringTemplateLoader arg0 , Optional < Charset > arg1 ) { Configuration cfg = new Configuration ( CURRENT_VERSION ) ; cfg . setObjectWrapper ( new DefaultObjectWrapperBuilder ( CURRENT_VERSION ) . build ( ) ) ; cfg . setDefaultEncoding ( arg1 . or ( Charset . defaultCharset ( ) ) . name ( ) ) ; cfg . setTemplateLoader ( arg0 ) ; return cfg ; }
protected StartArgs function ( final CommandLine arg0 ) { String port = arg0 . getOptionValue ( " p " ) ; String config = arg0 . getOptionValue ( " c " ) ; String globalSettings = arg0 . getOptionValue ( " g " ) ; String shutdownPort = arg0 . getOptionValue ( " s " ) ; String env = arg0 . getOptionValue ( " e " ) ; if ( config = = null & & globalSettings = = null ) { throw new ParseArgException ( " config or global setting is required " ) ; } if ( config ! = null & & globalSettings ! = null ) { throw new ParseArgException ( " config and global settings can not be set at the same time " ) ; } if ( globalSettings = = null & & env ! = null ) { throw new ParseArgException ( " environment must be configured with global settings " ) ; } if ( arg0 . getArgs ( ) . length ! = 1 ) { throw new ParseArgException ( " only one arg not allowed " ) ; } return httpsArgs ( ) . withPort ( getPort ( port ) ) . withShutdownPort ( getPort ( shutdownPort ) ) . withConfigurationFile ( config ) . withSettings ( globalSettings ) . withEnv ( env ) . withHttpsArg ( httpsArg ( arg0 ) ) . build ( ) ; }
public static Resource function ( String arg0 ) { return new ClasspathFileResource ( checkNotNull ( arg0 , " Null filename is not allowed " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.9.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) { this . mocoRunnerWatcher . stopMonitor ( ) ; this . runner . stop ( ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { if ( isErrorEnabled ( arg0 ) ) { handle_0ArgsCall ( Level . ERROR , arg0 , arg1 , arg2 ) ;
protected void function ( ChannelBuffer arg0 ) { try { arg0 . writeBytes ( toByteArray ( is ) ) ;
public void function ( ) { SelectorParseException exception = assertThrows ( SelectorParseException . class , ( ) - > QueryParser . parse ( " div / foo " ) ) ; assertEquals ( " Could not parse query '/': unexpected token at '/' " , exception . getMessage ( ) ) ; }
Element function ( Token . StartTag arg0 ) { Tag tag = Tag . valueOf ( arg0 . name ( ) , settings ) ; if ( arg0 . hasAttributes ( ) ) arg0 . attributes . deduplicate ( settings ) ; Element el = new Element ( tag , null , settings . normalizeAttributes ( arg0 . attributes ) ) ; insertNode ( el ) ; if ( arg0 . isSelfClosing ( ) ) { if ( ! tag . isKnownTag ( ) ) tag . setSelfClosing ( ) ; } else { stack . add ( el ) ; } return el ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.6.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 250 ) ; }
public void function ( ) throws Exception { ID3v2 id3tag = new ID3v24Tag ( ) ; setTagFields ( id3tag ) ; id3tag . setGenreDescription ( " Bebop " ) ; assertEquals ( " Bebop " , id3tag . getGenreDescription ( ) ) ; assertEquals ( - 1 , id3tag . getGenre ( ) ) ; Map < String , ID3v2FrameSet > frameSets = id3tag . getFrameSets ( ) ; ID3v2FrameSet frameSet = frameSets . get ( " TCON " ) ; List < ID3v2Frame > frames = frameSet . getFrames ( ) ; ID3v2Frame frame = frames . get ( 0 ) ; byte [ ] bytes = frame . getData ( ) ; String genre = BufferTools . byteBufferToString ( bytes , 1 , bytes . length - 1 ) ; assertEquals ( " Bebop " , genre ) ; }
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; logger . entry ( ) ; logger . entry ( 1 ) ; logger . entry ( " test " ) ; assertEquals ( 3 , listAppender . list . size ( ) ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 0 ) , " entry " ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 1 ) , " entry with (1) " ) ; verify ( ( LoggingEvent ) listAppender . list . get ( 2 ) , " entry with (test) " ) ; }
@Test public void function ( ) { OpenSafelist openSafelist = new OpenSafelist ( Safelist . relaxed ( ) ) ; Safelist safelist = Safelist . relaxed ( ) ; String html = " <p><opentag openattr>Hello</opentag></p> " ; String openClean = Jsoup . clean ( html , openSafelist ) ; String clean = Jsoup . clean ( html , safelist ) ; assertEquals ( " <p><opentag openattr= \" \" >Hello</opentag></p> " , TextUtil . stripNewlines ( openClean ) ) ; assertEquals ( " <p>Hello</p> " , clean ) ; }
public Element function ( String arg0 ) { empty ( ) ; append ( arg0 ) ; return this ; }
protected Optional < String > function ( final HttpRequest arg0 ) { return of ( arg0 . getUri ( ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { differentiatedLog ( null , CATEGORY_FQCN , LocationAwareLogger . DEBUG_INT , arg0 , arg1 ) ;
public void function ( final ChannelHandlerContext arg0 ) throws Exception { if ( websocketServer ! = null ) { websocketServer . disconnect ( arg0 . channel ( ) ) ;
private HttpRequestBase function ( final FullHttpRequest arg0 , final URL arg1 ) { HttpRequestBase remoteRequest = createRemoteRequest ( arg0 , arg1 ) ; RequestConfig config = RequestConfig . custom ( ) . setRedirectsEnabled ( false ) . setSocketTimeout ( 0 ) . setStaleConnectionCheckEnabled ( true ) . build ( ) ; remoteRequest . setConfig ( config ) ; remoteRequest . setProtocolVersion ( createVersion ( arg0 ) ) ; long contentLength = HttpUtil . getContentLength ( arg0 , - 1 ) ; if ( contentLength > 0 & & remoteRequest instanceof HttpEntityEnclosingRequest ) { HttpEntityEnclosingRequest entityRequest = ( HttpEntityEnclosingRequest ) remoteRequest ; entityRequest . setEntity ( createEntity ( arg0 . content ( ) , contentLength ) ) ; } return remoteRequest ; }
public void function ( FrameworkEvent arg0 ) { if ( arg0 . getType ( ) = = FrameworkEvent . ERROR ) { errorList . add ( arg0 ) ;
public String function ( final Response arg0 ) { HttpResponse httpResponse = ( HttpResponse ) arg0 ; return new StringBuilder ( ) . append ( responseProtocolLine ( httpResponse ) )
public String function ( ) { String closer = isSelfClosing ( ) ? " /> " : " > " ; if ( hasAttributes ( ) & & attributes . size ( ) > 0 ) return " < " + toStringName ( ) + "   " + attributes . toString ( ) + closer ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 125 ) ;
private Function < ? super GlobalSetting , File > function ( ) { return new Function < GlobalSetting , File > ( ) { @Override
public void function ( ) { FramedataImpl1 binary = FramedataImpl1 . get ( Opcode . BINARY ) ; assertEquals ( " Frame must be binary " , true , binary instanceof BinaryFrame ) ; FramedataImpl1 text = FramedataImpl1 . get ( Opcode . TEXT ) ; assertEquals ( " Frame must be text " , true , text instanceof TextFrame ) ; FramedataImpl1 closing = FramedataImpl1 . get ( Opcode . CLOSING ) ; assertEquals ( " Frame must be closing " , true , closing instanceof CloseFrame ) ; FramedataImpl1 continuous = FramedataImpl1 . get ( Opcode . CONTINUOUS ) ; assertEquals ( " Frame must be continuous " , true , continuous instanceof ContinuousFrame ) ; FramedataImpl1 ping = FramedataImpl1 . get ( Opcode . PING ) ; assertEquals ( " Frame must be ping " , true , ping instanceof PingFrame ) ; FramedataImpl1 pong = FramedataImpl1 . get ( Opcode . PONG ) ; assertEquals ( " Frame must be pong " , true , pong instanceof PongFrame ) ; try { FramedataImpl1 . get ( null ) ;
public void function ( ) throws Exception { server . request ( exist ( jsonPath ( " $.book.price " ) ) ) . response ( " jsonpath match success " ) ; running ( server , new Runnable ( ) { @Override
protected static void function ( String arg0 ) { throw new UnsupportedOperationException ( " Operation [logRawDiagnostic] is not supported in jcl-over-slf4j. See also  " + UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J ) ;
protected void function ( Node . . . arg0 ) { for ( Node child : arg0 ) { reparentChild ( child ) ;
public void function ( ) throws Exception { server . resource ( " targets " , head ( " 1 " ) . response ( header ( " ETag " , " Moco " ) ) ) ; running ( server , ( ) - > { HttpResponse httpResponse = helper . headForResponse ( remoteUrl ( " /targets/1 " ) ) ;
public static void function ( String arg0 , String arg1 ) throws IllegalArgumentException { if ( arg0 = = null ) { throw new IllegalArgumentException ( " key parameter cannot be null " ) ; } if ( mdcAdapter = = null ) { throw new IllegalStateException ( " MDCAdapter cannot be null. See also  " + NULL_MDCA_URL ) ; } mdcAdapter . put ( arg0 , arg1 ) ; }
public ImmutableList < GlobalSetting > function ( InputStream arg0 ) { try { List < GlobalSetting > settings = mapper . readValue ( arg0 , factory . constructCollectionType ( List . class , GlobalSetting . class ) ) ;
Logger function ( ) { return _delegate ! = null ? _delegate : makeEventRecodingLogger ( ) ; }
public void function ( ) { connections . clear ( ) ; connections . addAll ( getConnections ( ) ) ; long current = ( System . currentTimeMillis ( ) - ( connectionLostTimeout * 1500 ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; if ( webSocketImpl . getLastPong ( ) < current ) { if ( WebSocketImpl . DEBUG ) System . out . println ( " Closing connection due to no pong received:  " + conn . toString ( ) ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , false ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { if ( WebSocketImpl . DEBUG ) System . out . println ( " Trying to ping a non open connection:  " + conn . toString ( ) ) ; } } } } connections . clear ( ) ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object [ ] arg3 ) { Throwable throwableCandidate = MessageFormatter . getThrowableCandidate ( arg3 ) ; if ( throwableCandidate ! = null ) { Object [ ] trimmedCopy = MessageFormatter . trimmedCopy ( arg3 ) ;
public void function ( WebSocketImpl arg0 , Framedata arg1 ) throws InvalidDataException { throw new UnsupportedOperationException ( " This draft is not supported any more. Please use Draft_6455. " ) ; }
private SocketServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { int port = arg1 . getPort ( ) . orElse ( 0 ) ; SocketServer socketServer = ActualSocketServer . createLogServer ( port ) ; for ( RunnerSetting setting : arg0 ) { SocketServer parsedServer = socketParser . parseServer ( setting . getStreams ( ) , port , toConfigs ( setting ) ) ; socketServer = mergeServer ( socketServer , parsedServer ) ; } return socketServer ; }
public static ResponseHandler function ( final ResponseHandler arg0 , final ResponseHandler . . . arg1 ) { if ( arg1 . length = = 0 ) { return arg0 ; } return new AndResponseHandler ( asIterable ( arg0 , arg1 ) ) ; }
public final HttpsArgs function ( ) { return new HttpsArgs ( port , shutdownPort , configurationFile , settings , env , httpsArg ) ; }
static ParseErrorList function ( int arg0 ) { return new ParseErrorList ( INITIAL_CAPACITY , arg0 ) ; }
public Resource function ( ) { if ( text ! = null ) { return text ( text ) ; } if ( file ! = null ) { return file ( file ) ; } if ( url ! = null ) { return url ( url ) ; } if ( pathResource ! = null ) { return pathResource ( pathResource ) ; } return null ; }
public void function ( ) throws Exception { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( " " ) , TEST_URL ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 0 , 0 , 'h' , 't' , 't' , 'p' , ':' , '/' , '/' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , 'G' , 'H' , 'I' , 'J' , 'K' , 'L' , 'M' , 'N' , 'O' , 'P' , 'Q' } ; assertArrayEquals ( expectedBytes , bytes ) ; ID3v2UrlFrameData frameDataCopy = new ID3v2UrlFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
public boolean function ( final Request arg0 ) { Optional < String > content = extractor . extract ( arg0 ) ; return content . isPresent ( ) & & doMatch ( arg0 , content . get ( ) ) ; }
public void function ( ) throws IOException { thrown . expect ( IllegalArgumentException . class ) ; Base64 . encodeBytesToBytes ( new byte [ ] { 83 , 10 , 91 , 67 , 42 , - 1 , 107 , 62 , 91 , 67 } , 8 , 6 , 26 ) ; }
private MocoRunnerWatcher function ( final File [ ] arg0 , final FileAlterationListener arg1 ) { return new CompositeRunnerWatcher ( from ( arg0 ) . transform ( new Function < File , MocoRunnerWatcher > ( ) { @Override
public void function ( ) throws Exception { server . response ( cors ( allowOrigin ( " foo " ) , allowMethods ( " GET " ) ) ) ; running ( server , ( ) - > { ClassicHttpResponse response = helper . getResponseWithHeader ( root ( ) , of ( " Origin " , " www.github.com " ) ) ;
public void function ( ) throws Exception { assertThat ( helper . postContent ( remoteUrl ( " /proxy/1 " ) , " proxy " ) , is ( " proxy " ) ) ; }
protected StartArgs function ( final CommandLine arg0 ) { String port = arg0 . getOptionValue ( " p " ) ; String config = arg0 . getOptionValue ( " c " ) ; String globalSettings = arg0 . getOptionValue ( " g " ) ; String shutdownPort = arg0 . getOptionValue ( " s " ) ; String env = arg0 . getOptionValue ( " e " ) ; if ( config = = null & & globalSettings = = null ) { throw new ParseArgException ( " config or global setting is required " ) ; } if ( config ! = null & & globalSettings ! = null ) { throw new ParseArgException ( " config and global settings can not be set at the same time " ) ; } if ( globalSettings = = null & & env ! = null ) { throw new ParseArgException ( " environment must be configured with global settings " ) ; } if ( arg0 . getArgs ( ) . length ! = 1 ) { throw new ParseArgException ( " only one arg not allowed " ) ; } return httpArgs ( ) . withPort ( getPort ( port ) )
public void function ( ) { Evaluator . IsLastChild evaluator = new Evaluator . IsLastChild ( ) ; assertEquals ( " :last-child " , evaluator . toString ( ) ) ; }
public final T function ( final String arg0 ) { this . arg0 = arg0 ( arg0 ) ; return self ( ) ; }
public static RequestMatcher function ( XPath arg0 , String arg1 ) { return new XPathRequestMatcher ( arg0 , arg1 ) ; }
public void function ( ) { String currentDir = System . getProperty ( " user.dir " ) ; System . out . println ( " currentDir: " + currentDir ) ; Logger logger = LoggerFactory . getLogger ( Issue324Test . class ) ; logger . debug ( " hello " ) ; }
public void function ( ) throws UnsupportedEncodingException { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " TAG- " ; BufferTools . stringIntoByteBuffer ( s , 1 , 2 , buffer , 4 ) ; byte [ ] expectedBuffer = { 0 , 0 , 0 , 0 , BYTE_A , BYTE_G , 0 , 0 , 0 , 0 } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
public static boolean function ( int arg0 ) { return arg0 = = ' ' | | arg0 = = '\t' | | arg0 = = '\n' | | arg0 = = '\f' | | arg0 = = '\r' | | arg0 = = 160 ;
public Handshakedata function ( ByteBuffer arg0 , Role arg1 ) throws InvalidHandshakeException { return translateHandshakeHttp ( arg0 , arg1 ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { delegate ( ) . trace ( arg0 , arg1 , arg2 ) ; }
public final WebSocketServer function ( final String arg0 ) { checkArgument ( websocketServer = = null , " Only one websocket can be setup " ) ; this . websocketServer = new ActualWebSocketServer ( checkNotNullOrEmpty ( arg0 , " uri should not be null or empty " ) ) ; return websocketServer ; }
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { Response dumpedResponse = failoverResponse ( arg0 ) ; arg1 . setProtocolVersion ( HttpVersion . valueOf ( dumpedResponse . getVersion ( ) ) ) ; arg1 . setStatus ( HttpResponseStatus . valueOf ( dumpedResponse . getStatusCode ( ) ) ) ; for ( Map . Entry < String , String > entry : dumpedResponse . getHeaders ( ) . entrySet ( ) ) { arg1 . headers ( ) . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } if ( arg1 instanceof HttpContent ) { HttpContent content = ( HttpContent ) arg1 ;
@Test public void function ( ) { Connection con = HttpConnection . connect ( " http://example.com/ " ) ; con . referrer ( " http://foo.com " ) ; assertEquals ( " http://foo.com " , con . request ( ) . header ( " Referer " ) ) ; }
public void function ( final HttpRequest arg0 ) { tape . write ( name , arg0 ) ; }
public WebSocketServer function ( final String arg0 ) { this . websocketServer = new WebSocketServer ( arg0 ) ; return websocketServer ; }
public void function ( ) { } } ; Set < Thread > threadSet2 = Thread . getAllStackTraces ( ) . keySet ( ) ; Assert . assertEquals ( threadSet1 , threadSet2 ) ; } }
public final void function ( WebSocket arg0 , ByteBuffer arg1 ) { onMessage ( arg0 , arg1 ) ; }
public void function ( ) { server . mount ( MOUNT_DIR , to ( " /dir " ) , exclude ( " *.response " ) ) ; running ( server , new Runnable ( ) { @Override
public Builder function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
private void function ( ) { tq . consume ( " :containsData " ) ; String searchText = TokenQueue . unescape ( tq . chompBalanced ( '(' , ')' ) ) ; Validate . notEmpty ( searchText , " :containsData(text) query must not be empty " ) ; evals . add ( new Evaluator . ContainsData ( searchText ) ) ; }
public static RestSetting function ( final String arg0 , final ResponseHandler arg1 , final ResponseHandler . . . arg2 ) { return new HeadSingleRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , Optional . < RequestMatcher > absent ( ) ,
public void function ( ) { byte [ ] frameData = { BYTE_FF , BYTE_DB , BYTE_A2 , BYTE_40 } ; try { new MpegFrameForTesting ( frameData ) ;
public static Resource function ( final String arg0 ) { return arg0 ( HttpProtocolVersion . versionOf ( checkNotNullOrEmpty ( arg0 , " Version should not be null " ) ) ) ; }
public static ActualHttpServer function ( final Optional < Integer > arg0 , final MocoMonitor arg1 , final MocoConfig . . . arg2 ) { return new ActualHttpServer ( arg0 , null , new ThreadSafeMonitor ( arg1 ) , arg2 ) ; }
public static MocoEventAction function ( MocoEventAction arg0 , LatencyProcedure arg1 ) { return new MocoAsyncAction ( checkNotNull ( arg0 , " Action should not be null " ) , checkNotNull ( arg1 , " Procedure should not be null " ) ) ; }
public byte [ ] function ( HttpRequest arg0 ) { try { return toByteArray ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ) ;
public boolean function ( ) { return ignoreContentType ; }
public boolean function ( ) { return delegate ( ) . isInfoEnabled ( ) ; }
protected void function ( String arg0 , String arg1 , ParseErrorList arg2 , ParseSettings arg3 ) { super . initialiseParse ( arg0 , arg1 , arg2 , arg3 ) ; state = HtmlTreeBuilderState . Initial ; originalState = null ; baseUriSetFromDoc = false ; headElement = null ; formElement = null ; contextElement = null ; formattingElements = new ArrayList < > ( ) ; pendingTableCharacters = new ArrayList < > ( ) ; emptyEnd = new Token . EndTag ( ) ; framesetOk = true ; fosterInserts = false ; fragmentParsing = false ; }
static String function ( StringBuilder arg0 , StopWatch arg1 ) { DurationUnit du = selectDurationUnitForDisplay ( arg1 ) ; return durationInDurationUnitsAsStr ( arg1 . elapsedTime ( ) , du ) ; }
public int function ( ) { return childElementsList ( ) . size ( ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /random " ) ) ) . response ( template ( " ${random()} " ) ) ; running ( server , ( ) - > { String response = helper . get ( remoteUrl ( " /random " ) ) ;
public static ByteBuffer function ( InputStream arg0 , int arg1 ) throws IOException { Validate . isTrue ( arg1 > = 0 , " maxSize must be 0 (unlimited) or larger " ) ; final boolean capped = arg1 > 0 ; final byte [ ] buffer = new byte [ capped & & arg1 < bufferSize ? arg1 : bufferSize ] ; final ByteArrayOutputStream outStream = new ByteArrayOutputStream ( capped ? arg1 : bufferSize ) ; int read ; int remaining = arg1 ; while ( true ) { read = arg0 . read ( buffer ) ; if ( read = = - 1 ) break ; if ( capped ) { if ( read > = remaining ) { outStream . write ( buffer , 0 , remaining ) ; break ; } remaining - = read ; } outStream . write ( buffer , 0 , read ) ; } return ByteBuffer . wrap ( outStream . toByteArray ( ) ) ; }
char [ ] function ( Character arg0 , boolean arg1 ) { if ( reader . isEmpty ( ) ) return null ; if ( arg0 ! = null & & arg0 = = reader . current ( ) ) return null ; if ( reader . matchesAnySorted ( notCharRefCharsSorted ) ) return null ; final char [ ] charRef = charRefHolder ; reader . mark ( ) ; if ( reader . matchConsume ( " # " ) ) { boolean isHexMode = reader . matchConsumeIgnoreCase ( " X " ) ;
public void function ( final BaseSetting arg0 ) { for ( MocoConfig config : configs ) { arg0 . apply ( config ) ; } this . settings . add ( arg0 ) ; }
public void function ( ) { PongFrame frame = new PongFrame ( ) ; assertEquals ( " Frame must extend dataframe " , true , frame instanceof ControlFrame ) ; }
public void function ( ) { assertEquals ( BLUE_STR , blue . getName ( ) ) ; assertTrue ( blue . contains ( blue ) ) ; Marker blue2 = factory . getMarker ( BLUE_STR ) ; assertEquals ( BLUE_STR , blue2 . getName ( ) ) ; assertEquals ( blue , blue2 ) ; assertTrue ( blue . contains ( blue2 ) ) ; assertTrue ( blue2 . contains ( blue ) ) ; }
public Connection function ( boolean arg0 ) { req . arg0 ( arg0 ) ; return this ; }
public void function ( ) throws UnsupportedEncodingException { String original = " \ u03B3 \ u03B5 \ u03B9 \ u03AC  \ u03C3 \ u03BF \ u03C5 " ; byte buffer [ ] = BufferTools . stringToByteBuffer ( original , 2 , original . length ( ) - 5 , " UTF-16LE " ) ; String converted = BufferTools . byteBufferToString ( buffer , 0 , buffer . length , " UTF-16LE " ) ; assertEquals ( " \ u03B9 \ u03AC  " , converted ) ; }
public static @Nullable Element function ( Evaluator arg0 , Element arg1 ) { arg0 . reset ( ) ; FirstFinder finder = new FirstFinder ( arg0 ) ; return finder . find ( arg1 , arg1 ) ; }
public byte [ ] function ( HttpRequest arg0 ) { try { return toByteArray ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ) ;
public static < T > T function ( final InputStream arg0 , final Class < T > arg1 ) { try { return DEFAULT_MAPPER . readValue ( arg0 , arg1 ) ;
public void function ( ) throws Exception { byte bytes [ ] = { ( byte ) 0x48 , ( byte ) 0x45 , ( byte ) 0x4C , ( byte ) 0x4C , ( byte ) 0x4F , ( byte ) 0x20 , ( byte ) 0x74 , ( byte ) 0x68 , ( byte ) 0x65 , ( byte ) 0x72 , ( byte ) 0x65 , ( byte ) 0x21 } ; String hexString = asHex ( bytes ) ; assertEquals ( " 48 45 4c 4c 4f 20 74 68 65 72 65 21 " , hexString ) ; assertTrue ( Arrays . equals ( bytes , fromHex ( hexString ) ) ) ; }
private HttpsArg function ( CommandLine arg0 ) { String https = arg0 . getOptionValue ( " https " ) ; String keystore = arg0 . getOptionValue ( " keystore " ) ; String cert = arg0 . getOptionValue ( " cert " ) ; if ( https ! = null ) { if ( keystore = = null | | cert = = null ) { throw new ParseArgException ( " keystore and cert must be set for HTTPS " ) ; } return new HttpsArg ( https , keystore , cert ) ; } throw new ParseArgException ( " HTTPS arguments are expected " ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isErrorEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 ) ;
public void function ( ) { System . setProperty ( LoggerFactory . BINDING_PROP , " com.example.ServiceProvider " ) ; SLF4JServiceProvider provider = LoggerFactory . loadExplicitlySpecified ( classLoaderOfLoggerFactory ) ; assertNull ( provider ) ; assertTrue ( mockedSyserr . toString ( ) . contains ( " Failed to instantiate the specified SLF4JServiceProvider (com.example.ServiceProvider) " ) ) ; }
public void function ( ) throws IOException { String url = FileServlet . urlTo ( " /htmltests/large.html " ) ; Connection . Response defaultRes = Jsoup . connect ( url ) . execute ( ) ; Connection . Response smallRes = Jsoup . connect ( url ) . maxBodySize ( 50 * 1024 ) . execute ( ) ; Connection . Response mediumRes = Jsoup . connect ( url ) . maxBodySize ( 200 * 1024 ) . execute ( ) ; Connection . Response largeRes = Jsoup . connect ( url ) . maxBodySize ( 300 * 1024 ) . execute ( ) ; Connection . Response unlimitedRes = Jsoup . connect ( url ) . maxBodySize ( 0 ) . execute ( ) ; int actualDocText = 269541 ; assertEquals ( actualDocText , defaultRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( 49165 , smallRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( 196577 , mediumRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( actualDocText , largeRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( actualDocText , unlimitedRes . parse ( ) . text ( ) . length ( ) ) ; }
private static boolean function ( CtBehavior arg0 ) throws NotFoundException { if ( arg0 instanceof CtMethod = = false ) { return false ; } CtClass returnType = ( ( CtMethod ) arg0 ) . getReturnType ( ) ; String returnTypeName = returnType . getName ( ) ; boolean isVoidMethod = " void " . equals ( returnTypeName ) ; boolean methodReturnsValue = isVoidMethod = = false ; return methodReturnsValue ; }
@Test public void function ( ) { TokenQueue q = new TokenQueue ( " i \\ .d i \\ \\ d " ) ; assertEquals ( " i.d " , q . consumeCssIdentifier ( ) ) ; assertTrue ( q . consumeWhitespace ( ) ) ; assertEquals ( " i \\ d " , q . consumeCssIdentifier ( ) ) ; assertTrue ( q . isEmpty ( ) ) ; }
public boolean function ( final HttpRequest arg0 ) { HttpMethod method = arg0 . getMethod ( ) ; return method . equals ( HttpMethod . OPTIONS ) | | Arrays . stream ( methods ) . anyMatch ( m - > method . name ( ) . equalsIgnoreCase ( m ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.31 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
@Test public void function ( ) { assertEquals ( " Data " , Jsoup . parse ( " <script>Data " ) . select ( " script " ) . first ( ) . data ( ) ) ; assertEquals ( " Data</sc " , Jsoup . parse ( " <script>Data</sc " ) . select ( " script " ) . first ( ) . data ( ) ) ; assertEquals ( " Data</-sc " , Jsoup . parse ( " <script>Data</-sc " ) . select ( " script " ) . first ( ) . data ( ) ) ; assertEquals ( " Data</sc- " , Jsoup . parse ( " <script>Data</sc- " ) . select ( " script " ) . first ( ) . data ( ) ) ; assertEquals ( " Data</sc-- " , Jsoup . parse ( " <script>Data</sc-- " ) . select ( " script " ) . first ( ) . data ( ) ) ; assertEquals ( " Data " , Jsoup . parse ( " <script>Data</script> " ) . select ( " script " ) . first ( ) . data ( ) ) ; assertEquals ( " Data</script " , Jsoup . parse ( " <script>Data</script " ) . select ( " script " ) . first ( ) . data ( ) ) ; }
public List < FormElement > function ( ) { ArrayList < FormElement > forms = new ArrayList < FormElement > ( ) ; for ( Element el : contents ) if ( el instanceof FormElement ) forms . add ( ( FormElement ) el ) ; return forms ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( group ( " foo " ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-record " ) ) ) . response ( record ( group ( " foo " ) , identifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( group ( " foo " ) , identifier ( " ${req.queries['type']} " ) , modifier ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-replay " ) ) ) . response ( replay ( group ( " foo " ) , identifier ( " ${req.queries['type']} " ) , modifier ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /foo-record?type=blah " ) , " foo " ) ;
public MessageContent function ( final Optional < ? extends Request > arg0 ) { if ( ! arg0 . isPresent ( ) ) { throw new IllegalArgumentException ( " Request is required to read template " ) ; } StringTemplateLoader templateLoader = new StringTemplateLoader ( ) ; MessageContent messageContent = this . template . readFor ( arg0 ) ; String templateSource = messageContent . toString ( ) ; templateLoader . putTemplate ( TEMPLATE_NAME , templateSource ) ; Configuration cfg = createConfiguration ( templateLoader , messageContent . getCharset ( ) ) ; try { Template template = cfg . getTemplate ( TEMPLATE_NAME ) ;
public void function ( ClientHandshakeBuilder arg0 ) throws InvalidHandshakeException { assert ( readystate ! = READYSTATE . CONNECTING ) : " shall only be called once " ; this . handshakerequest = draft . postProcessHandshakeRequestAsClient ( arg0 ) ; try { wsl . onWebsocketHandshakeSentAsClient ( this , this . handshakerequest ) ; } catch ( InvalidDataException e ) { throw new InvalidHandshakeException ( " Handshake data rejected by client. " ) ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; throw new InvalidHandshakeException ( " rejected because of " + e ) ; } write ( draft . createHandshake ( this . handshakerequest , role ) ) ; }
@Test public void function ( ) { StringBuilder sb = new StringBuilder ( BufferSize ) ; do { sb . append ( " LargeTagName " ) ; } while ( sb . length ( ) < BufferSize ) ; String tag = sb . toString ( ) ; String html = " < " + tag + " >One</ " + tag + " > " ; Document doc = Parser . htmlParser ( ) . settings ( ParseSettings . preserveCase ) . parseInput ( html , " " ) ; Elements els = doc . select ( tag ) ; assertEquals ( 1 , els . size ( ) ) ; Element el = els . first ( ) ; assertNotNull ( el ) ; assertEquals ( " One " , el . text ( ) ) ; assertEquals ( tag , el . tagName ( ) ) ; }
void function ( Token . Character arg0 ) { Element el = currentElement ( ) ; insertCharacterToElement ( arg0 , el ) ; }
@Test public void function ( ) { String h = " <a href=1>#</a><base href='/2/'><a href='3'>#</a><base href='http://bar'><a href=4>#</a> " ; Document doc = Jsoup . parse ( h , " http://foo/ " ) ; assertEquals ( " http://bar " , doc . baseUri ( ) ) ; Elements anchors = doc . getElementsByTag ( " a " ) ; assertEquals ( 3 , anchors . size ( ) ) ; assertEquals ( " http://foo/ " , anchors . get ( 0 ) . baseUri ( ) ) ; assertEquals ( " http://foo/2/ " , anchors . get ( 1 ) . baseUri ( ) ) ; assertEquals ( " http://bar " , anchors . get ( 2 ) . baseUri ( ) ) ; assertEquals ( " http://foo/1 " , anchors . get ( 0 ) . absUrl ( " href " ) ) ; assertEquals ( " http://foo/2/3 " , anchors . get ( 1 ) . absUrl ( " href " ) ) ; assertEquals ( " http://bar/4 " , anchors . get ( 2 ) . absUrl ( " href " ) ) ; }
void function ( ) { doctypePending = new Token . Doctype ( ) ; }
public void function ( String arg0 ) { if ( isTraceEnabled ( ) ) { handle_0ArgsCall ( Level . TRACE , null , arg0 , null ) ;
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( " foo " , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-record " ) ) ) . response ( record ( " bar " , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( " foo " , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-replay " ) ) ) . response ( replay ( " bar " , template ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /foo-record?type=blah " ) , " foo " ) ;
public void function ( ) { final List < Integer > first = Iterables . asIterable ( 1 , new Integer [ ] { 2 , 3 } ) ; assertThat ( first . get ( 0 ) , is ( 1 ) ) ; assertThat ( first . get ( 1 ) , is ( 2 ) ) ; assertThat ( first . get ( 2 ) , is ( 3 ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( null , new Integer [ 0 ] ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( 1 , null ) ) ; final List < Integer > second = Iterables . asIterable ( 1 , 2 , new Integer [ ] { 3 , 4 } ) ; assertThat ( second . get ( 0 ) , is ( 1 ) ) ; assertThat ( second . get ( 1 ) , is ( 2 ) ) ; assertThat ( second . get ( 2 ) , is ( 3 ) ) ; assertThat ( second . get ( 3 ) , is ( 4 ) ) ; }
public void function ( ByteBuffer arg0 ) { assert ( arg0 . hasRemaining ( ) ) ; if ( DEBUG ) System . out . println ( " process( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) , arg0 . position ( ) , arg0 . remaining ( ) ) ) + " } " ) ; if ( getReadyState ( ) ! = READYSTATE . NOT_YET_CONNECTED ) { if ( getReadyState ( ) = = READYSTATE . OPEN ) { decodeFrames ( arg0 ) ; } } else { if ( decodeHandshake ( arg0 ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) ! = arg0 . hasRemaining ( ) | | ! arg0 . hasRemaining ( ) ) ; if ( arg0 . hasRemaining ( ) ) { decodeFrames ( arg0 ) ; } else if ( tmpHandshakeBytes . hasRemaining ( ) ) { decodeFrames ( tmpHandshakeBytes ) ; } } } assert ( isClosing ( ) | | isFlushAndClose ( ) | | ! arg0 . hasRemaining ( ) ) ; }
public void function ( ) throws IOException { FileWrapper fileWrapper = new FileWrapper ( VALID_FILENAME ) ; System . out . println ( fileWrapper . getFilename ( ) ) ; System . out . println ( VALID_FILENAME ) ; assertEquals ( fileWrapper . getFilename ( ) , Paths . get ( VALID_FILENAME ) . toAbsolutePath ( ) . toString ( ) ) ; assertTrue ( fileWrapper . getLastModified ( ) > 0 ) ; assertEquals ( fileWrapper . getLength ( ) , VALID_FILE_LENGTH ) ; }
public void function ( ) throws UnsupportedEncodingException { byte buffer [ ] = new byte [ 10 ] ; Arrays . fill ( buffer , ( byte ) 0 ) ; String s = " \ u03B3 \ u03B5 \ u03B9 \ u03AC " ; BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , 0 , " UTF-16BE " ) ; byte [ ] expectedBuffer = { 0x03 , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac , 0 , 0 } ; assertArrayEquals ( expectedBuffer , buffer ) ; }
private static void function ( ) { final LinkedBlockingQueue < SubstituteLoggingEvent > queue = SUBST_PROVIDER . getSubstituteLoggerFactory ( ) . getEventQueue ( ) ; final int queueSize = queue . size ( ) ; int count = 0 ; final int maxDrain = 128 ; List < SubstituteLoggingEvent > eventList = new ArrayList < SubstituteLoggingEvent > ( maxDrain ) ; while ( true ) { int numDrained = queue . drainTo ( eventList , maxDrain ) ;
private < T extends Node > List < T > function ( Class < T > arg0 ) { ArrayList < T > nodes = new ArrayList < > ( ) ; for ( Element el : this ) { for ( int i = 0 ; i < el . childNodeSize ( ) ; i + + ) { Node node = el . childNode ( i ) ; if ( arg0 . isInstance ( node ) ) nodes . add ( arg0 . cast ( node ) ) ; } } return nodes ; }
private void function ( byte [ ] arg0 ) throws IOException , NoSuchAlgorithmException { byte [ ] handshakeBytes = this . remoteHandshake . array ( ) ; String handshake = new String ( handshakeBytes , UTF8_CHARSET ) ; this . handshakeComplete = true ; if ( this . wsl . onHandshakeRecieved ( this , handshake , arg0 ) ) { this . wsl . onOpen ( this ) ;
public Profiler function ( String arg0 ) { Profiler nestedProfiler = new Profiler ( arg0 ) ; nestedProfiler . setProfilerRegistry ( profilerRegistry ) ; childList . add ( nestedProfiler ) ; return nestedProfiler ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( log . isTraceEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arrayFormat ( arg0 , arg1 ) ;
public Iterator < E > function ( ) { return new DescendingIterator < E > ( size ( ) ) ; }
public Optional < ImmutableMap < String , String > > function ( HttpRequest arg0 ) { return of ( doExtract ( arg0 ) ) ; }
public void function ( ) { when ( request . getUri ( ) ) . thenReturn ( " /foo?param=bar " ) ; assertThat ( extractor . extract ( request ) , is ( " bar " ) ) ; }
public void function ( ) throws Exception { running ( server , ( ) - > assertThat ( helper . get ( root ( ) ) , is ( " bar " ) ) ) ; }
public List < Element > function ( ) { if ( parentNode = = null ) { return null ; } List < Element > siblings = parent ( ) . childElementsList ( ) ; int index = indexInList ( this , siblings ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index + 1 ) { return siblings . subList ( index + 1 , siblings . size ( ) ) ; } return null ; }
private void function ( String arg0 , String arg1 ) { assertEquals ( arg0 . toLowerCase ( Locale . ROOT ) , arg1 . toLowerCase ( Locale . ROOT ) ) ; }
public boolean function ( ) { return type = = Authenticator . RequestorType . SERVER ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 2.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 30 ) ; }
public boolean function ( String arg0 ) { return URI_ID . equalsIgnoreCase ( arg0 ) ; }
public void function ( ) throws Exception { final HttpServer server = httpServer ( port ( ) , hit ) ; running ( server , ( ) - > { try { helper . get ( remoteUrl ( " /foo " ) ) ; } catch ( IOException ignored ) { } } ) ; hit . verify ( unexpected ( ) , times ( 1 ) ) ; }
public static MountTo function ( String arg0 ) { return new MountTo ( arg0 ) ; }
public void function ( ) { String xml = " <One>One</One> " ; Document doc = Jsoup . parse ( xml , " " , Parser . xmlParser ( ) ) ; Elements one = doc . select ( " One " ) ; one . append ( " <Two ID=2>Two</Two> " ) ; assertEquals ( " <One>One<Two ID= \" 2 \" >Two</Two></One> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
public void function ( final SessionContext arg0 ) { arg0 . join ( group ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element div = doc . getElementById ( " 1 " ) ; div . prepend ( " <p>there</p><p>now</p> " ) ; assertEquals ( " <p>there</p><p>now</p><p>Hello</p> " , TextUtil . stripNewlines ( div . html ( ) ) ) ; Elements ps = doc . select ( " p " ) ; for ( int i = 0 ; i < ps . size ( ) ; i + + ) { assertEquals ( i , ps . get ( i ) . siblingIndex ) ;
public Builder function ( boolean arg0 ) { addEntryExit = arg0 ; return this ; }
@Test public void function ( ) { String h = " <a href=/>link</a> " ; Document doc = Jsoup . parse ( h ) ; assertEquals ( " <a href= \" / \" >link</a> " , doc . body ( ) . html ( ) ) ; }
public static ContentResource function ( final Resource arg0 ) { return contentResource ( id ( " json " ) , jsonConfigApplier ( arg0 ) , arg0 . reader ( ContentResourceReader . class ) ) ; }
@Test public void function ( ) { validateNestedQuotes ( " <html><body><a id= \" identifier \"  onclick= \" func('arg') \"  /></body></html> " , " a[onclick*= \" ('arg \" ] " ) ; validateNestedQuotes ( " <html><body><a id= \" identifier \"  onclick=func('arg') /></body></html> " , " a[onclick*= \" ('arg \" ] " ) ; validateNestedQuotes ( " <html><body><a id= \" identifier \"  onclick='func( \" arg \" )' /></body></html> " , " a[onclick*='( \" arg'] " ) ; validateNestedQuotes ( " <html><body><a id= \" identifier \"  onclick=func( \" arg \" ) /></body></html> " , " a[onclick*='( \" arg'] " ) ; }
public static RequestExtractor function ( final String arg0 ) { return new HeaderRequestExtractor ( checkNotNull ( arg0 , " Null header name is not allowed " ) ) ; }
@Test void function ( ) { assertEquals ( " https://example.com/foo bar/ " , resolve ( " HTTPS://example.com/example/ " , " ../foo bar/ " ) ) ; }
public URL function ( final HttpRequest arg0 ) { return toUrl ( url . readFor ( arg0 ) . toString ( ) ) ; }
public void function ( ) throws Exception { Draft_6455 draft_6455 = new Draft_6455 ( ) ; assertEquals ( 1 , draft_6455 . getKnownProtocols ( ) . size ( ) ) ; draft_6455 = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > emptyList ( ) ) ; assertEquals ( 0 , draft_6455 . getKnownProtocols ( ) . size ( ) ) ; draft_6455 = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ; assertEquals ( 1 , draft_6455 . getKnownProtocols ( ) . size ( ) ) ; ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " chat " ) ) ; protocols . add ( new Protocol ( " test " ) ) ; draft_6455 = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ; assertEquals ( 2 , draft_6455 . getKnownProtocols ( ) . size ( ) ) ; }
public Whitelist function ( boolean arg0 ) { preserveRelativeLinks = arg0 ; return this ; }
private Document function ( final InputSource arg0 , final DocumentBuilder arg1 ) throws SAXException { try { Document document = arg1 . parse ( arg0 ) ;
public void function ( SSLSocketFactory arg0 ) { this . arg0 = arg0 ; }
public RecorderIdentifier function ( final MocoConfig arg0 ) { Resource applied = resource . apply ( arg0 ) ; if ( applied ! = this . resource ) { return new RecorderIdentifier ( ( ContentResource ) applied ) ; } return this ; }
public String function ( ) { return name + " = "
public Options function ( ) { Options options = new Options ( ) ; options . addOption ( configOption ( ) ) ; options . addOption ( portOption ( ) ) ; options . addOption ( ShutdownPortOption . shutdownPortOption ( ) ) ; options . addOption ( settingsOption ( ) ) ; options . addOption ( envOption ( ) ) ; options . addOption ( keyStore ( ) ) ; options . addOption ( cert ( ) ) ; return options ; }
public void function ( ) { ByteBuffer byteBuffer = ByteBufferUtils . getEmptyByteBuffer ( ) ; assertEquals ( " limit must be 0 " , byteBuffer . limit ( ) , 0 ) ; }
public void function ( WebSocket arg0 , String arg1 ) { this . sendToAll ( arg1 ) ; System . out . println ( arg0 + " :  " + arg1 ) ; }
public String function ( final String arg0 , final String arg1 , final CookieAttribute . . . arg2 ) { DefaultCookie cookie = new DefaultCookie ( arg0 , arg1 ) ; for ( CookieAttribute option : arg2 ) { ( ( ActualCookieAttribute ) option ) . visit ( cookie ) ; } return ServerCookieEncoder . STRICT . encode ( cookie ) ; }
public T function ( String arg0 , String arg1 ) { Validate . notEmpty ( arg0 ) ; arg1 = arg1 = = null ? " " : arg1 ; List < String > values = headers ( arg0 ) ; if ( values . isEmpty ( ) ) { values = new ArrayList < > ( ) ; headers . put ( arg0 , values ) ; } values . add ( fixHeaderEncoding ( arg1 ) ) ; return ( T ) this ; }
public void function ( ) throws Exception { DefaultExtension defaultExtension = new DefaultExtension ( ) ; assertEquals ( " " , defaultExtension . getProvidedExtensionAsClient ( ) ) ; }
protected void function ( Reader arg0 , String arg1 , ParseErrorList arg2 , ParseSettings arg3 ) { super . initialiseParse ( arg0 , arg1 , arg2 , arg3 ) ; stack . add ( doc ) ; doc . outputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml ) ; }
public Failover function ( ) { if ( this . status = = null ) { return playback ( failover ) ; } return playback ( failover , this . status ) ; }
static boolean function ( final char [ ] arg0 , final int arg1 , int arg2 , final String arg3 ) { if ( arg2 = = arg3 . length ( ) ) { int i = arg1 ; int j = 0 ; while ( arg2 - - ! = 0 ) { if ( arg0 [ i + + ] ! = arg3 . charAt ( j + + ) ) return false ; } return true ; } return false ; }
public void function ( ) throws Exception { List < Plain > plains = Jsons . toObjects ( helper . get ( remoteUrl ( " /targets?foo=bar " ) ) , Plain . class ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; HttpResponse response = helper . getResponse ( remoteUrl ( " /targets " ) ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 404 ) ) ; }
private Watcher function ( final File [ ] arg0 , final FileAlterationListener arg1 ) { return new CompositeWatcher ( from ( arg0 ) . transform ( new Function < File , Watcher > ( ) { @Override
public final ResponseHandler function ( ) { Failover failover = getFailover ( ) ; if ( hasProxyConfig ( ) ) { return Moco . proxy ( getProxyConfig ( ) , failover ) ; } return Moco . proxy ( url . asResource ( ) , failover ) ; }
public static int function ( Handshakedata arg0 ) { String vers = arg0 . getFieldValue ( " Sec-WebSocket-Version " ) ; if ( vers . length ( ) > 0 ) { int v ; try { v = new Integer ( vers . trim ( ) ) ; return v ; } catch ( NumberFormatException e ) { return - 1 ; } } return - 1 ; }
public void function ( ) { if ( closeHandshakeComplete ) { return ; } closeHandshakeComplete = true ; try { handleWrite ( ) ; sockchannel . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } this . wsl . onClose ( this ) ; if ( draft ! = null ) draft . reset ( ) ; currentframe = null ; handshakerequest = null ; }
public void function ( ) { logger . warn ( marker , message ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . WARN , marker , null , null ) ; }
public void function ( ) { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , TEST_URL ) ; assertFalse ( frameData . equals ( null ) ) ; }
public LoggingEventBuilder function ( String arg0 , Supplier < Object > arg1 ) { return this ; }
private ImmutableMap < String , RequestExtractor < ? > > toVariables ( ImmutableMap < String , String > props ) { return copyOf ( Maps . transformEntries ( props , toVariable ( ) ) ) ; }
private static Maps . EntryTransformer < String , String , RequestExtractor < ? > > toVariable ( ) { return new Maps . EntryTransformer < String , String , RequestExtractor < ? > > ( ) { @Override
public void function ( ) throws IOException { String shutdownMocoKey = " _SHUTDOWN_MOCO_KEY " ; int shutdownPort = 9527 ; RunnerFactory factory = new RunnerFactory ( shutdownPort , shutdownMocoKey ) ; runner = factory . createRunner ( new StartArgs ( port ( ) , shutdownPort , " src/test/resources/foo.json " , null , null ) ) ; runner . run ( ) ; try { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; } catch ( HttpHostConnectException e ) { fail ( e . getMessage ( ) ) ; } runner . stop ( ) ; shutdownMoco ( shutdownPort , shutdownMocoKey ) ; }
public void function ( final String arg0 , final RestSetting . . . arg1 ) { checkNotNull ( arg0 , " Resource name should not be null " ) ; checkNotNull ( arg1 , " Rest settings should not be null " ) ; this . request ( InternalApis . context ( resourceRoot ( arg0 ) ) ) . response ( new RestHandler ( arg0 , arg1 ) ) ; }
public void function ( ) throws IOException , NoSuchAlgorithmException { SSLParametersWebSocketServerFactory webSocketServerFactory = new SSLParametersWebSocketServerFactory ( SSLContext . getDefault ( ) , new SSLParameters ( ) ) ; SocketChannel channel = SocketChannel . open ( ) ; try { ByteChannel result = webSocketServerFactory . wrapChannel ( channel , null ) ; } catch ( NotYetConnectedException e ) { } channel . close ( ) ; }
public void function ( ) { Connection con = Jsoup . connect ( " http://infohound.net/tools/404 " ) ; boolean threw = false ; try { Document doc = con . get ( ) ; } catch ( IOException e ) { threw = true ; } assertTrue ( threw ) ; }
public void function ( ) throws Exception { final MocoMonitor monitor = mock ( MocoMonitor . class ) ; final HttpServer server = httpServer ( monitor ) ; server . get ( by ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( server . port ( ) , " /foo " ) ) , is ( " bar " ) ) ) ; verify ( monitor ) . onMessageArrived ( any ( HttpRequest . class ) ) ; verify ( monitor ) . onMessageLeave ( any ( HttpResponse . class ) ) ; verify ( monitor , Mockito . never ( ) ) . onException ( any ( Exception . class ) ) ; }
public static ContentResource function ( final TextContainer arg0 ) { if ( arg0 . isRawText ( ) ) { return text ( arg0 . getText ( ) ) ; } if ( arg0 . isForTemplate ( ) ) { if ( arg0 . hasProperties ( ) ) { return template ( arg0 . getText ( ) , toVariables ( arg0 . getProps ( ) ) ) ; } return template ( arg0 . getText ( ) ) ; } throw new IllegalArgumentException ( " Unknown  " + arg0 + "  for event action setting " ) ; }
public Whitelist function ( String arg0 , String arg1 ) { super . removeEnforcedAttribute ( arg0 , arg1 ) ; return this ; }
private static MessageContent function ( final FullHttpRequest arg0 ) { long contentLength = HttpUtil . getContentLength ( arg0 , - 1 ) ; if ( contentLength < = 0 ) { return content ( ) . build ( ) ; } return content ( ) . withContent ( new ByteBufInputStream ( arg0 . content ( ) ) ) . build ( ) ; }
private static String function ( String arg0 ) { try { URL u = new URL ( arg0 ) ;
private RequestMatcher function ( RequestSetting arg0 , Function < Map . Entry < String , String > , RequestMatcher > arg1 ) { Map < String , String > collection = getCollection ( arg0 ) ; if ( collection = = null ) { return null ; } return createRequestMatcher ( arg0 , transform ( collection . entrySet ( ) , arg1 ) ) ; }
public BaseRequestSetting function ( String arg0 ) { return new ContentRequestSetting ( this , arg0 ) ; }
public boolean function ( Marker arg0 ) { return isErrorEnabled ( ) ; }
public void function ( ) throws IOException { File in = ParseTest . getFile ( " /htmltests/namespaces.xhtml " ) ; org . jsoup . nodes . Document jsoupDoc ; jsoupDoc = Jsoup . parse ( in , " UTF-8 " ) ; Document doc ; org . jsoup . helper . W3CDom jDom = new org . jsoup . helper . W3CDom ( ) ; doc = jDom . fromJsoup ( jsoupDoc ) ; Node htmlEl = doc . getChildNodes ( ) . item ( 0 ) ; assertEquals ( " http://www.w3.org/1999/xhtml " , htmlEl . getNamespaceURI ( ) ) ; assertEquals ( " html " , htmlEl . getLocalName ( ) ) ; assertEquals ( " html " , htmlEl . getNodeName ( ) ) ; Node epubTitle = htmlEl . getChildNodes ( ) . item ( 2 ) . getChildNodes ( ) . item ( 3 ) ; assertEquals ( " http://www.idpf.org/2007/ops " , epubTitle . getNamespaceURI ( ) ) ; assertEquals ( " title " , epubTitle . getLocalName ( ) ) ; assertEquals ( " epub:title " , epubTitle . getNodeName ( ) ) ; Node xSection = epubTitle . getNextSibling ( ) . getNextSibling ( ) ; assertEquals ( " urn:test " , xSection . getNamespaceURI ( ) ) ; assertEquals ( " section " , xSection . getLocalName ( ) ) ; assertEquals ( " x:section " , xSection . getNodeName ( ) ) ; }
public Set < Entry < String , String > > function ( ) { return new EntrySet ( ) ; }
protected HttpUriRequest function ( final String arg0 , final Request arg1 ) { HttpPost targetRequest = new HttpPost ( arg0 ) ; targetRequest . setEntity ( asEntity ( content , arg1 ) ) ; return targetRequest ; }
public static Document function ( File arg0 , arg1 String arg2 , String arg3 ) throws IOException { InputStream stream = new FileInputStream ( arg0 ) ; String name = Normalizer . lowerCase ( arg0 . getName ( ) ) ; if ( name . endsWith ( " .gz " ) | | name . endsWith ( " .z " ) ) { boolean zipped ; try { zipped = ( stream . read ( ) = = 0x1f & & stream . read ( ) = = 0x8b ) ; } finally { stream . close ( ) ; } stream = zipped ? new GZIPInputStream ( new FileInputStream ( arg0 ) ) : new FileInputStream ( arg0 ) ; } return parseInputStream ( stream , arg2 , arg3 , Parser . htmlParser ( ) ) ; }
public void function ( ) throws InvalidDataException { super . isValid ( ) ; if ( code = = CloseFrame . NO_UTF8 & & reason = = null ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 , " Received text is no valid utf8 string! " ) ; } if ( code = = CloseFrame . NOCODE & & 0 < reason . length ( ) ) { throw new InvalidDataException ( PROTOCOL_ERROR , " A close frame must have a closecode if it has a reason " ) ; } if ( ( code > CloseFrame . UNEXPECTED_CONDITION & & code < 3000 & & code ! = CloseFrame . TLS_ERROR ) ) { throw new InvalidDataException ( PROTOCOL_ERROR , " Trying to send an illegal close code! " ) ; } if ( code = = CloseFrame . ABNORMAL_CLOSE | | code = = CloseFrame . TLS_ERROR | | code = = CloseFrame . NOCODE | | code > 4999 | | code < 1000 | | code = = 1004 ) { throw new InvalidFrameException ( " closecode must not be sent over the wire:  " + code ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div>One</div><div>Two</div><span>Three</span><p>Fou<i>r</i></p> " ) ; String text = doc . text ( ) ; String wholeText = doc . wholeText ( ) ; assertEquals ( " One Two Three Four " , text ) ; assertEquals ( " OneTwoThreeFour " , wholeText ) ; assertEquals ( " OneTwo " , Jsoup . parse ( " <span>One</span><span>Two</span> " ) . text ( ) ) ; }
public void function ( ) { request = new DefaultFullHttpRequest ( HttpVersion . HTTP_1_0 , HttpMethod . DELETE , " /foo " ) ; assertThat ( extractor . extract ( request ) , is ( HttpMethod . DELETE . toString ( ) ) ) ; }
public String function ( ) { return consumeEscapedCssIdentifier ( CssIdentifierChars ) ; }
public HandshakeBuilder function ( Handshakedata arg0 , HandshakeBuilder arg1 ) { throw new RuntimeException ( " not yet implemented " ) ; }
public boolean function ( final String arg0 ) { return arg0 . startsWith ( expected . readFor ( ( Request ) null ) . toString ( ) ) ; }
protected void function ( ) { try { Thread . sleep ( FileMocoRunnerMonitor . INTERVAL * 2 ) ;
static Parser function ( Node arg0 ) { Document doc = arg0 . ownerDocument ( ) ; return doc ! = null & & doc . parser ( ) ! = null ? doc . parser ( ) : new Parser ( new HtmlTreeBuilder ( ) ) ; }
public final boolean function ( ) { return charset . isPresent ( ) ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div><p>One</p>...<p>One</p>...<p>One</p> " ) ; Elements ps = doc . select ( " p " ) ; assertEquals ( 0 , ps . get ( 0 ) . elementSiblingIndex ( ) ) ; assertEquals ( 1 , ps . get ( 1 ) . elementSiblingIndex ( ) ) ; assertEquals ( 2 , ps . get ( 2 ) . elementSiblingIndex ( ) ) ; }
public void function ( WebSocket arg0 , Exception arg1 ) { arg1 . printStackTrace ( ) ; if ( arg0 ! = null ) {
void function ( ) { Element last = lastFormattingElement ( ) ; if ( last = = null | | onStack ( last ) ) return ; Element entry = last ; int size = formattingElements . size ( ) ; int ceil = size - maxUsedFormattingElements ; if ( ceil < 0 ) ceil = 0 ; int pos = size - 1 ; boolean skip = false ; while ( true ) { if ( pos = = ceil ) { skip = true ; break ; } entry = formattingElements . get ( - - pos ) ; if ( entry = = null | | onStack ( entry ) ) break ; } while ( true ) { if ( ! skip )
@Test public void function ( ) { String html = " <html><head><title>Frame Test</title></head><frameset id=id><frame src=foo.html></frameset> " ; Document doc = Jsoup . parse ( html ) ; Element head = doc . head ( ) ; assertNotNull ( head ) ; assertEquals ( " Frame Test " , doc . title ( ) ) ; assertNull ( doc . selectFirst ( " body " ) ) ; Element body = doc . body ( ) ; assertNotNull ( body ) ; assertEquals ( " " , body . html ( ) ) ; assertNotNull ( doc . selectFirst ( " body " ) ) ; String expected = " <html> \ n " + "  <head> \ n " + "   <title>Frame Test</title> \ n " + "  </head> \ n " + "  <frameset id= \" id \" > \ n " + "   <frame src= \" foo.html \" > \ n " + "  </frameset> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( expected , doc . html ( ) ) ; }
public RequestMatcher function ( RequestMatcher arg0 ) { return arg0 . apply ( config ) ; }
public static File function ( final File arg0 ) { File parentFile = arg0 . getParentFile ( ) ; if ( parentFile = = null ) { return new File ( " . " ) ; } return parentFile ; }
private void function ( HttpRequest arg0 , HttpResponse arg1 , arg2 . arg3 . arg4 . HttpResponse arg5 ) throws IOException { int statusCode = arg5 . getStatusLine ( ) . getStatusCode ( ) ; if ( statusCode = = HttpResponseStatus . BAD_REQUEST . getCode ( ) ) { failover . failover ( arg0 , arg1 ) ; return ; } setupNormalResponse ( arg1 , arg5 ) ; failover . onCompleteResponse ( arg0 , arg1 ) ; }
public void function ( ) throws Exception { Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; String msg = " hello world  " + diff ; logger . info ( msg ) ; List < String > list = sps . stringList ; assertMsgContains ( list , 0 , " Class path contains multiple SLF4J bindings. " ) ; assertMsgContains ( list , 1 , " Found binding in " ) ; assertMsgContains ( list , 2 , " Found binding in " ) ; assertMsgContains ( list , 3 , " See http://www.slf4j.org/codes.html " ) ; assertMsgContains ( list , 4 , " Actual binding is of type [ " ) ; }
public void function ( ) throws Exception { HttpResponse httpResponse = helper . deleteForResponse ( remoteUrl ( " /targets/2 " ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 404 ) ) ; }
public boolean function ( final File arg0 ) { return file . getName ( ) . equals ( arg0 . getName ( ) ) ; }
private void function ( MpegFrame arg0 , int arg1 ) throws InvalidDataException { if ( sampleRate ! = arg0 . getSampleRate ( ) ) throw new InvalidDataException ( " Inconsistent frame header " ) ; if ( ! layer . equals ( arg0 . getLayer ( ) ) ) throw new InvalidDataException ( " Inconsistent frame header " ) ; if ( ! version . equals ( arg0 . getVersion ( ) ) ) throw new InvalidDataException ( " Inconsistent frame header " ) ; if ( arg1 + arg0 . getLengthInBytes ( ) > getLength ( ) ) throw new InvalidDataException ( " Frame would extend beyond end of file " ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>One<p>Two<p>Three<p>Four " ) ; Elements ps = doc . select ( " p " ) ; assertEquals ( 4 , ps . size ( ) ) ; ps . replaceAll ( el - > { Element div = doc . createElement ( " div " ) ; div . text ( el . text ( ) ) ; return div ; } ) ; for ( Element p : ps ) { assertEquals ( " div " , p . tagName ( ) ) ; } assertEquals ( " <div> One</div><div> Two</div><div> Three</div><div> Four</div> " , TextUtil . normalizeSpaces ( doc . body ( ) . html ( ) ) ) ; }
public void function ( HttpRequest arg0 , HttpResponse arg1 ) { if ( detector . hasHeader ( arg1 , name ) ) { arg1 . removeHeader ( name ) ; } HttpHeaders . addHeader ( arg1 , name , new String ( resource . asByteArray ( arg0 ) ) ) ; }
public KeyVal function ( String arg0 ) { Validate . notEmptyParam ( arg0 , " arg0 " ) ; this . arg0 = arg0 ; return this ; }
protected Log function ( String arg0 ) throws LogConfigurationException { Logger logger = LoggerFactory . getLogger ( arg0 ) ; return new SLF4JLog ( logger ) ; }
public void function ( ) throws IOException { String xmlUrl = " http://direct.infohound.net/tools/parse-xml.xml " ; Connection con = Jsoup . connect ( xmlUrl ) . parser ( Parser . htmlParser ( ) ) ; Document doc = con . get ( ) ; Connection . Request req = con . request ( ) ; assertTrue ( req . parser ( ) . getTreeBuilder ( ) instanceof HtmlTreeBuilder ) ; assertEquals ( " <html> <head></head> <body> <xml> <link>one <table> Two </table> </xml> </body> </html> " , StringUtil . normaliseWhitespace ( doc . outerHtml ( ) ) ) ; }
public static void function ( ) { java . util . logging . Logger rootLogger = getRootLogger ( ) ; java . util . logging . Handler [ ] handlers = rootLogger . getHandlers ( ) ; for ( int i = 0 ; i < handlers . length ; i + + ) { rootLogger . removeHandler ( handlers [ i ] ) ;
public void function ( Object arg0 , Throwable arg1 ) { logger . debug ( String . valueOf ( arg0 ) , arg1 ) ; }
public void function ( ) { if ( thread ! = null ) throw new IllegalStateException ( " This instance of  " + getClass ( ) . getSimpleName ( ) + "  can only be started once the same time. " ) ; thread = Thread . currentThread ( ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; server . socket ( ) . bind ( new java . net . InetSocketAddress ( port ) ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; } catch ( IOException ex ) { onError ( null , ex ) ; return ; } while ( ! thread . isInterrupted ( ) ) { SelectionKey key = null ;
public static < T extends ConfigApplier < T > > ImmutableList < T > function ( final List < T > arg0 , final MocoConfig . . . arg1 ) { checkNotNull ( arg0 , " config items should not be null " ) ; return arg0 . stream ( ) . map ( item - > configItem ( item , arg1 ) )
private void function ( InvalidDataException arg0 ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( arg0 . getCloseCode ( ) , arg0 . getMessage ( ) , false ) ; }
private void function ( int arg0 , boolean arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { if ( arg0 < MINIMUM_BUFFER_LENGTH + 1 ) throw new IllegalArgumentException ( " Buffer too small " ) ; this . arg0 = arg0 ; this . arg1 = arg1 ; try ( SeekableByteChannel seekableByteChannel = Files . newByteChannel ( path , StandardOpenOption . READ ) ) { initId3v1Tag ( seekableByteChannel ) ;
public void function ( ) { assertNull ( DataUtil . getCharsetFromContentType ( " text/html; charset= " ) ) ; assertNull ( DataUtil . getCharsetFromContentType ( " text/html; charset=; " ) ) ; }
public void function ( ) { NewJFrame inst = new NewJFrame ( ) ; inst . setLocationRelativeTo ( null ) ; inst . setVisible ( true ) ; }
private Map < String , TextContainer > function ( final Map < String , TextContainer > arg0 ) { if ( arg0 ! = null ) { return arg0 ; } return ImmutableMap . of ( ) ; }
public static boolean function ( byte arg0 , int arg1 ) { return ( ( arg0 & ( 0x01 < < arg1 ) ) ! = 0 ) ; }
public void function ( ) { startArgsParser . parse ( new String [ ] { " start " , " -p " , " 12306 " , " -c " , " foo.json " , " -g " , " settings.json " } ) ; }
void function ( Tokeniser arg0 , CharacterReader arg1 ) { handleDataDoubleEscapeTag ( arg0 , arg1 , ScriptDataEscaped , ScriptDataDoubleEscaped ) ; }
private Mp3File function ( File arg0 , int arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { Mp3File mp3File = loadAndCheckTestMp3 ( arg0 , arg1 ) ; return loadAndCheckTestMp3WithCustomTag ( mp3File ) ; }
public Object function ( Request arg0 ) { return text ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isTraceEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 ) ;
private byte [ ] function ( byte [ ] arg0 ) { byte [ ] transformed = new byte [ arg0 . length ] ; for ( int i = 0 ; i < arg0 . length ; i + + ) { transformed [ i ] = ( byte ) ( arg0 [ i ] + 1 ) ; } return transformed ; }
public void function ( ) throws Exception { JDK14LoggerFactory factory = new JDK14LoggerFactory ( ) ; org . slf4j . Logger logger = factory . getLogger ( loggerName ) ; logger . info ( " test message " ) ; assertCorrectLoggerName ( ) ; }
public void function ( ) throws Exception { assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " event " ) ) ; verify ( handler , never ( ) ) . writeToResponse ( Matchers . < SessionContext > anyObject ( ) ) ; Idles . idle ( 2000 ) ; }
public static JsonRunner function ( Iterable < ? extends RunnerSetting > arg0 , int arg1 ) { return new JsonRunner ( arg0 , arg1 ) ; }
@Test public void function ( ) { String html = " <table><tr><td>text</td><!-- Comment --></tr></table> " ; Document node = Jsoup . parseBodyFragment ( html ) ; assertEquals ( " <html><head></head><body><table><tbody><tr><td>text</td><!-- Comment --></tr></tbody></table></body></html> " , TextUtil . stripNewlines ( node . outerHtml ( ) ) ) ; }
public boolean function ( Collection < ? > arg0 ) { return contents . containsAll ( arg0 ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null ) return false ; return getClass ( ) = = arg0 . getClass ( ) ; }
public static < T , R > R function ( final Function < T , R > arg0 , final T arg1 ) { R result = arg0 . apply ( arg1 ) ; if ( result = = null ) { throw new NullPointerException ( " Null returned from function " ) ; } return result ; }
public static void function ( ) { if ( mdcAdapter = = null ) { throw new IllegalStateException ( " MDCAdapter cannot be null. See also  " + NULL_MDCA_URL ) ; } mdcAdapter . clear ( ) ; }
public boolean function ( HttpRequest arg0 ) { return ( arg0 . getUri ( ) . equals ( uri ) ) ; }
public RestSetting function ( final MocoProcedure arg0 ) { return this . response ( with ( checkNotNull ( arg0 , " Procedure should not be null " ) ) ) ; }
@Test public void function ( ) { TokenQueue tq = new TokenQueue ( " :contains(one (two)  \\ (  \\ )  \\ ) three) four " ) ; String pre = tq . consumeTo ( " ( " ) ; String guts = tq . chompBalanced ( '(' , ')' ) ; String remainder = tq . remainder ( ) ; assertEquals ( " :contains " , pre ) ; assertEquals ( " one (two)  \\ (  \\ )  \\ ) three " , guts ) ; assertEquals ( " one (two) ( ) ) three " , TokenQueue . unescape ( guts ) ) ; assertEquals ( "  four " , remainder ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( ! logger . isTraceEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) . getMessage ( ) ;
public Resource function ( MocoConfig arg0 , Resource arg1 ) { return arg1 ; }
private boolean function ( Map . Entry < String , String > arg0 , String arg1 ) { return arg1 . equalsIgnoreCase ( arg0 . getKey ( ) ) ; }
public void function ( String arg0 ) throws IOException { for ( WebSocket c : this . connections ) { c . sendFrame ( arg0 ) ;
public void function ( ) { StartArgs args = new StartArgsParser ( ServerType . SOCKET ) . parse ( new String [ ] { " start " , " -c " , " foo.json " } ) ; assertThat ( args . isSocket ( ) , is ( true ) ) ; }
public static ImmutableMap < String , String [ ] > function ( final Map < String , String > arg0 ) { ImmutableMap . Builder < String , String [ ] > builder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { builder . put ( entry . getKey ( ) , new String [ ] { entry . getValue ( ) } ) ; } return builder . build ( ) ; }
public void function ( ) { LimitExceededException limitExceededException = new LimitExceededException ( ) ; assertEquals ( " The close code has to be TOOBIG " , CloseFrame . TOOBIG , limitExceededException . getCloseCode ( ) ) ; assertEquals ( " The message has to be empty " , null , limitExceededException . getMessage ( ) ) ; limitExceededException = new LimitExceededException ( " Message " ) ; assertEquals ( " The close code has to be TOOBIG " , CloseFrame . TOOBIG , limitExceededException . getCloseCode ( ) ) ; assertEquals ( " The message has to be the argument " , " Message " , limitExceededException . getMessage ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.1.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " post_method.json " , PORT ) ; helper . get ( " http://localhost:9090/post " ) ; }
protected String [ ] function ( String arg0 ) { return Strings . tokenizeToStringArray ( arg0 , this . pathSeparator , this . trimTokens , true ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { delegate ( ) . info ( arg0 , arg1 , arg2 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " post_method.json " ) ; helper . get ( remoteUrl ( " /post " ) ) ; }
protected void function ( Reader arg0 , String arg1 , Parser arg2 ) { super . initialiseParse ( arg0 , arg1 , arg2 ) ; doc . outputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml )
private LogRecord function ( LoggingEvent arg0 , Level arg1 ) { String format = arg0 . getMessage ( ) ; Object [ ] arguments = arg0 . getArgumentArray ( ) ; FormattingTuple ft = MessageFormatter . arrayFormat ( format , arguments ) ; if ( ft . getThrowable ( ) ! = null & & arg0 . getThrowable ( ) ! = null ) { throw new IllegalArgumentException ( " both last element in argument array and last argument are of type Throwable " ) ; } Throwable t = arg0 . getThrowable ( ) ; if ( ft . getThrowable ( ) ! = null ) { t = ft . getThrowable ( ) ; throw new IllegalStateException ( " fix above code " ) ; } LogRecord record = new LogRecord ( arg1 , ft . getMessage ( ) ) ; record . setLoggerName ( arg0 . getLoggerName ( ) ) ; record . setMillis ( arg0 . getTimeStamp ( ) ) ; record . setSourceClassName ( EventConstants . NA_SUBST ) ; record . setSourceMethodName ( EventConstants . NA_SUBST ) ; record . setThrown ( t ) ; return record ; }
public void function ( ) { Evaluator . ContainsOwnText evaluator = new Evaluator . ContainsOwnText ( " example " ) ; assertEquals ( " :containsOwn(example) " , evaluator . toString ( ) ) ; }
public String function ( ) { return String . format ( " [%s*=%s] " , key , value ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div style='bold'><p title=qux><p><b style></b></p></div> " ) ; List < Element > els = doc . getElementsByAttribute ( " style " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " div " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " b " , els . get ( 1 ) . tagName ( ) ) ; List < Element > none = doc . getElementsByAttribute ( " class " ) ; assertEquals ( 0 , none . size ( ) ) ; }
private void function ( ByteBuffer arg0 ) { if ( DEBUG ) System . out . println ( " write( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) ) ) + " } " ) ; outQueue . add ( arg0 ) ; wsl . onWriteDemand ( this ) ; }
public void function ( String arg0 , Throwable arg1 ) { log ( LOG_LEVEL_TRACE , arg0 , arg1 ) ; }
public boolean function ( ) { return this . operation = = null ; }
public Builder function ( final String arg0 ) { this . arg0 = arg0 ; return this ; }
protected Object function ( ) throws ObjectStreamException { return LoggerFactory . getLogger ( getName ( ) ) ; }
public void function ( ) throws Exception { server . get ( by ( uri ( " /foo " ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /context/foo " ) ) , is ( " foo " ) ) ) ; }
public void function ( ) { parse ( ServerType . HTTP , " start " , " -p " , " 12306 " , " -e " , " foo " ) ; }
public void function ( ) throws Exception { ID3v2 id3tag = new ID3v23Tag ( ) ; setTagFields ( id3tag ) ; byte [ ] data = id3tag . toBytes ( ) ; ID3v2 id3tagCopy = new ID3v23Tag ( data ) ; assertEquals ( 2340 , data . length ) ; assertEquals ( id3tag , id3tagCopy ) ; }
@Test public void function ( ) { Node node = new Element ( Tag . valueOf ( " p " ) , " " ) ; Element el = new Element ( Tag . valueOf ( " p " ) , " " ) ; assertEquals ( 0 , node . siblingIndex ( ) ) ; assertEquals ( 0 , node . siblingNodes ( ) . size ( ) ) ; assertNull ( node . previousSibling ( ) ) ; assertNull ( node . nextSibling ( ) ) ; assertEquals ( 0 , el . siblingElements ( ) . size ( ) ) ; assertNull ( el . previousElementSibling ( ) ) ; assertNull ( el . nextElementSibling ( ) ) ; }
public void function ( ) throws Exception { ID3v1Tag id3v1tag = new ID3v1Tag ( ) ; id3v1tag . setTitle ( " TITLE " ) ; id3v1tag . setArtist ( " ARTIST " ) ; id3v1tag . setAlbum ( " ALBUM " ) ; id3v1tag . setYear ( " 2001 " ) ; id3v1tag . setComment ( " COMMENT " ) ; id3v1tag . setTrack ( " 254 " ) ; id3v1tag . setGenre ( 0x8d ) ; byte [ ] expectedBuffer = BufferTools . stringToByteBuffer ( VALID_TAG_WITH_WHITESPACE , 0 , VALID_TAG_WITH_WHITESPACE . length ( ) ) ; replaceSpacesWithNulls ( expectedBuffer ) ; expectedBuffer [ expectedBuffer . length - 3 ] = 0x00 ; expectedBuffer [ expectedBuffer . length - 2 ] = - 0x02 ; expectedBuffer [ expectedBuffer . length - 1 ] = - 0x73 ; assertTrue ( Arrays . equals ( expectedBuffer , id3v1tag . toBytes ( ) ) ) ; }
private void function ( Channel arg0 , HttpRequest arg1 ) { for ( BaseRequestSetting requestSetting : requestSettings ) { if ( requestSetting . match ( arg1 ) ) { arg0 . write ( createResponse ( requestSetting ) ) ; return ; } } if ( anyRequestSetting ! = null ) { arg0 . write ( createResponse ( anyRequestSetting ) ) ;
public void function ( ) { EncodedText encodedText = new EncodedText ( ( byte ) 0 , BUFFER_WITH_A_BACK_TICK ) ; assertEquals ( " I " + ( char ) ( 96 ) + " m " , encodedText . toString ( ) ) ; }
public void function ( Marker arg0 , String arg1 ) { delegate ( ) . error ( arg0 , arg1 ) ; }
public void function ( String arg0 , Object arg1 ) { if ( ! logger . isErrorEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( null , fqcn , LocationAwareLogger . ERROR_INT , arg0 , new Object [ ] { arg1 } , null ) ;
public boolean function ( ) { assert ( ! flushandclosestate | | readystate = = READYSTATE . CONNECTING ) ; return readystate = = READYSTATE . CONNECTING ; }
private static Options function ( ) { Options options = new Options ( ) ; options . addOption ( configOption ( ) ) ; options . addOption ( portOption ( ) ) ; options . addOption ( shutdownPortOption ( ) ) ; options . addOption ( settingsOption ( ) ) ; options . addOption ( envOption ( ) ) ; return options ; }
public void function ( ) throws Exception { server . request ( by ( text ( " foo " ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
public boolean function ( Element arg0 , Element arg1 ) { for ( Evaluator s : evaluators ) { if ( ! s . matches ( arg0 , arg1 ) ) return false ; } return true ; }
public boolean function ( String arg0 ) { int len = arg0 . length ( ) ; if ( len > remainingLength ( ) ) return false ; String check = queue . substring ( pos , pos + len ) ; return arg0 . equalsIgnoreCase ( check ) ; }
public boolean function ( final Map . Entry < String , String > arg0 ) { return isSameHeaderName ( arg0 . getKey ( ) , key ) ; }
public void function ( Marker arg0 , String arg1 , Object [ ] arg2 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg1 , arg2 )
public void function ( HttpRequest arg0 ) { writer . write ( formatter . format ( arg0 ) ) ; }
public void function ( Marker arg0 , String arg1 ) { logger . warn ( arg0 , arg1 ) ; }
String function ( ) { final int start = pos ; final int remaining = length ; final char [ ] val = input ; while ( pos < remaining ) { final char c = val [ pos ] ; if ( c = = '\t' | | c = = '\n' | | c = = '\r' | | c = = '\f' | | c = = ' ' | | c = = '/' | | c = = '>' | | c = = TokeniserState . nullChar ) break ; pos + + ; } return pos > start ? cacheString ( start , pos - start ) : " " ; }
public Builder function ( final Map < String , TextContainer > arg0 ) { this . arg0 = arg0 ; return this ; }
public void function ( ) { String xhtml = " <html xmlns='http://www.w3.org/1999/xhtml'><body id='One'><div>hello</div></body></html> " ; Document doc = Jsoup . parse ( xhtml , Parser . xmlParser ( ) ) ; doc . select ( " [xmlns] " ) . removeAttr ( " xmlns " ) ; Elements elements = doc . selectXpath ( " //*[local-name()='body'] " ) ; assertEquals ( 1 , elements . size ( ) ) ; elements = doc . selectXpath ( " //body " ) ; assertEquals ( 1 , elements . size ( ) ) ; assertEquals ( " One " , elements . first ( ) . id ( ) ) ; }
public byte [ ] function ( Optional < HttpRequest > arg0 ) { return uri . getBytes ( ) ; }
public void function ( ) throws Exception { anotherServer = httpsServer ( 12306 , DEFAULT_CERTIFICATE , context ( " /bar " ) ) ; HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , new Runnable ( ) { @Override
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( by ( uri ( " /path " ) ) ) ) ; server . request ( xml ( " <request><parameters><id>1</id></parameters></request> " ) ) . response ( " foo " ) ; running ( server , ( ) - > helper . postFile ( root ( ) , " foo.xml " ) ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 13 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ) ;
private static HandshakeBuilder function ( String [ ] arg0 , String arg1 ) throws InvalidHandshakeException { if ( ! " 101 " . equals ( arg0 [ 1 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid status code received: %s Status line: %s " , arg0 [ 1 ] , arg1 ) ) ; } if ( ! " HTTP/1.1 " . equalsIgnoreCase ( arg0 [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid status line received: %s Status line: %s " , arg0 [ 0 ] , arg1 ) ) ; } HandshakeBuilder handshake = new HandshakeImpl1Server ( ) ; ServerHandshakeBuilder serverhandshake = ( ServerHandshakeBuilder ) handshake ; serverhandshake . setHttpStatus ( Short . parseShort ( arg0 [ 1 ] ) ) ; serverhandshake . setHttpStatusMessage ( arg0 [ 2 ] ) ; return handshake ; }
public static Resource function ( final String arg0 ) { return new UriResource ( checkNotNull ( arg0 , " Null URI is not allowed " ) ) ; }
public void function ( String arg0 , Object arg1 ) { if ( logger . isLoggable ( Level . WARNING ) ) { if ( arg0 instanceof String ) {
protected final MessageContent function ( final Request arg0 ) { return this . resource . readFor ( of ( arg0 ) ) ; }
@Test public void function ( ) { Token t = token ( " <div id= \" foo \"  width=500> " ) ; assertTrue ( t . isStartTag ( ) ) ; assertFalse ( t . isEndTag ( ) ) ; assertEquals ( " div " , t . getTagName ( ) ) ; assertEquals ( " id= \" foo \"  width=500 " , t . getAttributeString ( ) ) ; }
private CountingHandler function ( ) { Handler [ ] handlers = julOrgLogger . getHandlers ( ) ; for ( Handler h : handlers ) { if ( h instanceof CountingHandler ) return ( CountingHandler ) h ; } return null ; }
private Supplier < String > function ( final FullHttpRequest arg0 ) { return Suppliers . memoize ( new Supplier < String > ( ) { @Override
public void function ( final Session arg0 , final CloseReason arg1 ) { this . arg0 = null ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.2.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( String arg0 , Object arg1 ) { recordEventwithoutMarkerArgArray ( Level . TRACE , arg0 , new Object [ ] { arg1 } , null ) ; }
private void function ( StringBuffer arg0 , String arg1 ) { catalogField ( arg0 , arg1 , false ) ; }
private HttpRequestBase function ( final FullHttpRequest arg0 , final URL arg1 ) { HttpRequestBase remoteRequest = createRemoteRequest ( arg0 , arg1 ) ; remoteRequest . setConfig ( createRequestConfig ( ) ) ; long contentLength = HttpUtil . getContentLength ( arg0 , - 1 ) ; if ( contentLength > 0 & & remoteRequest instanceof HttpEntityEnclosingRequest ) { HttpEntityEnclosingRequest entityRequest = ( HttpEntityEnclosingRequest ) remoteRequest ; entityRequest . setEntity ( createEntity ( arg0 . content ( ) , contentLength ) ) ; } return remoteRequest ; }
public final boolean function ( ) { return this . configurationFile . isPresent ( ) ; }
void function ( LoggingEvent arg0 , String arg1 , Throwable arg2 ) { verify ( arg0 , arg1 ) ; assertEquals ( arg2 . toString ( ) , arg0 . getThrowableStrRep ( ) [ 0 ] ) ; }
public void function ( ) throws Exception { HttpResponse response = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) ; Header header = response . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " bar " ) ) ; ByteArrayOutputStream outstream = new ByteArrayOutputStream ( ) ; response . getEntity ( ) . writeTo ( outstream ) ; assertThat ( new String ( outstream . toByteArray ( ) ) , is ( " hello " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.10.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private void function ( ) { String className = tq . consumeCssIdentifier ( ) ; Validate . notEmpty ( className ) ; evals . add ( new Evaluator . Class ( className . trim ( ) . toLowerCase ( ) ) ) ; }
public static ResponseHandler function ( final String arg0 ) { return new DynamicReplayHandler ( RecorderRegistry . defaultRegistry ( ) , text ( arg0 ) ) ; }
public Whitelist function ( boolean arg0 ) { super . preserveRelativeLinks ( arg0 ) ; return this ; }
public boolean function ( final String arg0 ) { return arg0 . equals ( expected . readFor ( Optional . < Request > absent ( ) ) . toString ( ) ) ; }
public Thread function ( Runnable arg0 ) { return new WebsocketExecutorThread ( arg0 ) ; }
public Resource function ( MocoConfig arg0 , Resource arg1 ) { if ( arg0 . isFor ( headerResource . id ( ) ) ) { return headerResource ( key , arg1 . apply ( arg0 ) ) ; } return arg1 ; }
public void function ( WebSocket arg0 , Framedata arg1 ) { arg0 . sendFrame ( new PongFrame ( ( PingFrame ) arg1 ) ) ; }
public void function ( ) throws Exception { ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " chat " ) ) ; protocols . add ( new Protocol ( " chat2 " ) ) ; testProtocolRejection ( 16 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ) ; }
private void function ( int arg0 , String arg1 , Throwable arg2 ) { if ( arg2 ! = null ) { arg1 + = '\n' + Log . getStackTraceString ( arg2 ) ; } Log . println ( arg0 , name , arg1 ) ; }
private void function ( WebSocket arg0 , Exception arg1 ) { log . error ( " Shutdown due to fatal error " , arg1 ) ; onError ( arg0 , arg1 ) ; if ( decoders ! = null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selectorthread ! = null ) { selectorthread . interrupt ( ) ; } try { stop ( ) ;
public void function ( ) throws Exception { copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 41 ) ; copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 256 ) ; copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 1024 ) ; copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 5000 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.1.6 " ) ; assertEquals ( " INFORMATIONAL " , testResult . get ( " behavior " ) ) ; assertEquals ( " INFORMATIONAL " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 50 ) ;
public static Priority function ( String arg0 ) { return Level . toLevel ( arg0 ) ; }
static < T extends Node > List < T > function ( String arg0 , Element arg1 , Class < T > arg2 ) { Validate . notEmpty ( arg0 ) ; Validate . notNull ( arg1 ) ; Validate . notNull ( arg2 ) ; W3CDom w3c = new W3CDom ( ) ; org . w3c . dom . Document wDoc = w3c . fromJsoup ( arg1 ) ; NodeList nodeList = w3c . selectXpath ( arg0 , wDoc ) ; return w3c . sourceNodes ( nodeList , arg2 ) ; }
public static JsonRunner function ( final Iterable < ? extends InputStream > arg0 , final StartArgs arg1 ) { return newJsonRunnerWithSetting ( from ( arg0 ) . transform ( toRunnerSetting ( ) ) , arg1 ) ; }
public void function ( BundleContext arg0 ) { Logger logger = LoggerFactory . getLogger ( this . getClass ( ) ) ; logger . info ( " Activator.start() " ) ; m_context = arg0 ; }
private Function < String , InputStream > function ( ) { return input - > { try {
public static RestServer function ( final int arg0 , final MocoConfig . . . arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; checkNotNull ( arg1 , " Config should not be null " ) ; return new ActualRestServer ( arg0 , null , new QuietMonitor ( ) , checkNotNull ( arg1 , " Configuration should not be null " ) ) ;
private boolean function ( final Header arg0 ) { return ! IGNORED_RESPONSE_HEADERS . contains ( arg0 . getName ( ) . toUpperCase ( ) ) ; }
void function ( Appendable arg0 , int arg1 , Document . OutputSettings arg2 ) throws IOException { if ( arg2 . prettyPrint ( ) & & ( ( siblingIndex ( ) = = 0 & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . formatAsBlock ( ) & & ! isBlank ( ) ) | | ( arg2 . outline ( ) & & siblingNodes ( ) . size ( ) > 0 & & ! isBlank ( ) ) ) ) indent ( arg0 , arg1 , arg2 ) ; boolean normaliseWhite = arg2 . prettyPrint ( ) & & ! Element . preserveWhitespace ( parent ( ) ) ; Entities . escape ( arg0 , coreValue ( ) , arg2 , false , normaliseWhite , false ) ; }
public MocoRunnerMonitor function ( final File arg0 , final Iterable < File > arg1 , final FileRunner arg2 ) { ImmutableList < File > files = ImmutableList . < File > builder ( ) . add ( arg0 ) . addAll ( arg1 ) . build ( ) ; return new FilesMocoRunnerMonitor ( files , createListener ( arg2 ) ) ; }
private < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final TextContainer arg1 ) { if ( " true " . equalsIgnoreCase ( arg1 . getText ( ) ) ) { return exist ( arg0 ) ; } if ( " false " . equalsIgnoreCase ( arg1 . getText ( ) ) ) { return not ( exist ( arg0 ) ) ; } throw new RuntimeException ( String . format ( " Unknown exist parameter: [%s] " , arg1 . getText ( ) ) ) ; }
public void function ( ) throws Exception { server . response ( json ( ( request ) - > { PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; return pojo ; } ) ) ; final PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; running ( server , ( ) - > JsonSupport . assertEquals ( pojo , helper . getResponse ( root ( ) ) ) ) ; }
private void function ( WebSocketImpl arg0 , RuntimeException arg1 ) { log . error ( " Runtime exception during onWebsocketMessage " , arg1 ) ; arg0 . getWebSocketListener ( ) . onWebsocketError ( arg0 , arg1 ) ; }
public List < Comment > function ( ) { return nodesOfType ( Comment . class ) ; }
public void function ( ) { try { assertThat ( helper . get ( root ( ) ) , is ( " bar " ) ) ;
public final U function ( final U arg0 ) { U newServer = createMergeServer ( arg0 ) ; newServer . addSettings ( this . getSettings ( ) ) ; newServer . addSettings ( arg0 . getSettings ( ) ) ; newServer . anySetting ( configuredAnyMatcher ( ) , this . configuredAnyResponseHandler ( ) ) ; newServer . anySetting ( arg0 . configuredAnyMatcher ( ) , arg0 . configuredAnyResponseHandler ( ) ) ; newServer . addEvents ( this . eventTriggers ) ; newServer . addEvents ( arg0 . eventTriggers ) ; newServer . addExtension ( this ) ; newServer . addExtension ( arg0 ) ; return newServer ; }
public void function ( String arg0 , Throwable arg1 ) { delegate ( ) . warn ( arg0 , arg1 ) ; }
private RequestMatcher function ( final String arg0 , final Object arg1 ) { if ( " json " . equalsIgnoreCase ( arg0 ) ) { return by ( json ( arg1 ) ) ; } if ( arg1 instanceof Map ) { return createCompositeMatcher ( arg0 , castToMap ( arg1 ) ) ; } if ( arg1 instanceof TextContainer ) { return createSingleTextMatcher ( arg0 , ( TextContainer ) arg1 ) ; } if ( arg1 instanceof StructSetting ) { final StructSetting struct = ( StructSetting ) arg1 ; if ( struct . isJson ( ) ) { return Moco . struct ( json ( struct . getJson ( ) ) ) ; } if ( struct . isXml ( ) ) { return Moco . struct ( xml ( struct . getXml ( ) ) ) ; } throw new IllegalArgumentException ( " Unknown struct configuration:  " + struct ) ; } throw new IllegalArgumentException ( " unknown configuration : " + arg1 ) ; }
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final String arg1 ) { return ApiUtils . endsWith ( checkNotNull ( arg0 , " Extractor should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Expected resource should not be null " ) ) ) ;
public void function ( String arg0 , Object arg1 ) { if ( ! logger . isTraceEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( null , fqcn , LocationAwareLogger . TRACE_INT , arg0 , new Object [ ] { arg1 } , null ) ;
public Element function ( ) { if ( attributes ! = null ) { super . clearAttributes ( ) ; if ( attributes . size ( ) = = 0 ) attributes = null ; } return this ; }
private String function ( ) { StringBuilder sq = StringUtil . borrowBuilder ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matches ( " ( " ) ) sq . append ( " ( " ) . append ( tq . chompBalanced ( '(' , ')' ) ) . append ( " ) " ) ; else if ( tq . matches ( " [ " ) ) sq . append ( " [ " ) . append ( tq . chompBalanced ( '[' , ']' ) ) . append ( " ] " ) ; else if ( tq . matchesAny ( Combinators ) ) if ( sq . length ( ) > 0 ) break ; else tq . consume ( ) ; else sq . append ( tq . consume ( ) ) ; } return StringUtil . releaseBuilder ( sq ) ; }
public void function ( ) throws Exception { Draft_6455 draft_6455 = new Draft_6455 ( Collections . < IExtension > singletonList ( new TestExtension ( ) ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ; Draft_6455 draftCopy = ( Draft_6455 ) draft_6455 . copyInstance ( ) ; draft_6455 . acceptHandshakeAsServer ( handshakedataProtocolExtension ) ; assertNotEquals ( draft_6455 , draftCopy ) ; assertEquals ( draft_6455 . getKnownProtocols ( ) , draftCopy . getKnownProtocols ( ) ) ; assertEquals ( draft_6455 . getKnownExtensions ( ) , draftCopy . getKnownExtensions ( ) ) ; assertNotEquals ( draft_6455 . getProtocol ( ) , draftCopy . getProtocol ( ) ) ; assertNotEquals ( draft_6455 . getExtension ( ) , draftCopy . getExtension ( ) ) ; }
public InetAddress function ( URI arg0 ) throws UnknownHostException { return InetAddress . getByName ( arg0 . getHost ( ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { if ( logger . isLoggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , arg0 , arg1 ) ;
private HttpsArg function ( final CommandLine arg0 ) { String https = arg0 . getOptionValue ( " https " ) ; String keystore = arg0 . getOptionValue ( " keystore " ) ; String cert = arg0 . getOptionValue ( " cert " ) ; if ( https ! = null ) { if ( keystore = = null | | cert = = null ) { throw new ParseArgException ( " keystore and cert must be set for HTTPS " ) ; } return new HttpsArg ( https , keystore , cert ) ; } throw new ParseArgException ( " HTTPS arguments are expected " ) ; }
public Connection function ( boolean arg0 ) { req . validateTLSCertificates ( arg0 ) ; return this ; }
@Test public void function ( ) { String h1 = " <p " ; Document doc = Jsoup . parse ( h1 ) ; assertEquals ( 1 , doc . getElementsByTag ( " p " ) . size ( ) ) ; String h2 = " <div id=1<p id='2' " ; doc = Jsoup . parse ( h2 ) ; Element d = doc . getElementById ( " 1 " ) ; assertEquals ( 1 , d . children ( ) . size ( ) ) ; Element p = doc . getElementById ( " 2 " ) ; assertNotNull ( p ) ; }
private boolean function ( Token arg0 , TreeBuilder arg1 ) { boolean processed = arg1 . processEndTag ( " tr " ) ; if ( processed ) return arg1 . process ( arg0 ) ;
private int function ( byte [ ] arg0 , int arg1 ) { BufferTools . stringIntoByteBuffer ( FOOTER_TAG , 0 , FOOTER_TAG . length ( ) , arg0 , arg1 ) ; String s [ ] = version . split ( " . " ) ; if ( s . length > 0 ) { byte majorVersion = Byte . parseByte ( s [ 0 ] ) ; arg0 [ arg1 + MAJOR_VERSION_OFFSET ] = majorVersion ; } if ( s . length > 1 ) { byte minorVersion = Byte . parseByte ( s [ 0 ] ) ; arg0 [ arg1 + MINOR_VERSION_OFFSET ] = minorVersion ; } packFlags ( arg0 , arg1 ) ; BufferTools . packSynchsafeInteger ( getDataLength ( ) , arg0 , arg1 + DATA_LENGTH_OFFSET ) ; return arg1 + FOOTER_LENGTH ; }
public static void function ( String [ ] arg0 ) throws URISyntaxException { Draft_6455 draft_ocppOnly = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " ocpp2.0 " ) ) ) ; ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " ocpp2.0 " ) ) ; protocols . add ( new Protocol ( " " ) ) ; Draft_6455 draft_ocppAndFallBack = new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ; ChatServer chatServer = new ChatServer ( 8887 , draft_ocppOnly ) ; chatServer . start ( ) ; }
private Runner function ( StartArgs arg0 ) { File settingsFile = new File ( arg0 . getSettings ( ) ) ; FileRunner fileRunner = createSettingFileRunner ( settingsFile , arg0 ) ; SettingRunner runner = ( SettingRunner ) fileRunner . getRunner ( ) ; Monitor fileMonitor = monitorFactory . createSettingMonitor ( settingsFile , runner . getFiles ( ) , fileRunner ) ; return new MonitorRunner ( fileRunner , fileMonitor ) ; }
private static boolean function ( String arg0 ) { return arg0 = = null | | arg0 . startsWith ( " text " ) | | arg0 . endsWith ( " javascript " ) ; }
public void function ( ) throws Exception { server = httpServer ( port ( ) , request ( eq ( header ( " foo " ) , " bar " ) ) ) ; server . response ( " blah " ) ; assertThrows ( HttpResponseException . class , ( ) - > running ( server , ( ) - > helper . get ( root ( ) ) ) ) ; }
private Mp3File function ( Mp3File arg0 ) throws NotSupportedException , IOException , UnsupportedTagException , InvalidDataException { String saveFilename = arg0 . getFilename ( ) + " .copy " ; try { arg0 . save ( saveFilename ) ;
public HttpsCertificate function ( final HttpsArg arg0 ) { return arg0 . getCertificate ( ) ; }
public void function ( MocoConfig arg0 ) { this . resource . apply ( arg0 ) ; this . localCache . apply ( arg0 ) ; }
private static boolean function ( Class < ? > arg0 , Class < ? > arg1 ) { return ! arg1 . isAssignableFrom ( arg0 ) ; }
public boolean function ( FullHttpRequest arg0 ) { return this . matcher . match ( arg0 ) & & this . handler ! = null ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isWarnEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . WARN_INT , arg1 , new Object [ ] { arg2 , arg3 } , null ) ;
public void function ( ) { FileResourceReader reader = new FileResourceReader ( text ( new File ( " src/test/resources/foo.response " ) . getPath ( ) ) ) ; assertThat ( reader . readFor ( Optional . < Request > absent ( ) ) . toString ( ) , is ( " foo.response " ) ) ; }
public HttpResponseSetting function ( final HttpResponseSetting arg0 , final String arg1 ) { return this . redirectTo ( arg0 , text ( checkNotNullOrEmpty ( arg1 , " URL should not be null " ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " , port ( ) ) ; HttpResponse response = Request . Get ( remoteUrl ( " /response_header " ) ) . execute ( ) . returnResponse ( ) ; assertThat ( response . getHeaders ( " content-type " ) [ 0 ] . getValue ( ) , is ( " application/json " ) ) ; assertThat ( response . getHeaders ( " foo " ) [ 0 ] . getValue ( ) , is ( " bar " ) ) ; }
public TextContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . FIELD_NAME ) { String operation = strip ( arg0 . getText ( ) ) ; JsonToken token = arg0 . nextToken ( ) ; if ( isForTemplate ( operation ) & & token = = JsonToken . START_OBJECT ) { Template template = arg0 . readValueAs ( Template . class ) ; arg0 . nextToken ( ) ; return template . template ( ) ; } if ( token = = JsonToken . VALUE_STRING ) { String text = strip ( arg0 . getText ( ) ) ; arg0 . nextToken ( ) ; return builder ( ) . withOperation ( operation ) . withText ( text ) . build ( ) ; } } return ( TextContainer ) arg1 . handleUnexpectedToken ( TextContainer . class , arg0 ) ; }
public void function ( ) throws IOException , NoSuchAlgorithmException { DefaultSSLWebSocketServerFactory webSocketServerFactory = new DefaultSSLWebSocketServerFactory ( SSLContext . getDefault ( ) ) ; SocketChannel channel = SocketChannel . open ( ) ; try { ByteChannel result = webSocketServerFactory . wrapChannel ( channel , null ) ; } catch ( NotYetConnectedException e ) { } channel . close ( ) ; }
public void function ( ) { ID3v2ChapterTOCFrameData frameData = new ID3v2ChapterTOCFrameData ( false , true , false , " toc1 " , new String [ ] { " ch1 " , " ch2 " } ) ; assertEquals ( frameData , frameData ) ; }
public void function ( ) { logger . debug ( marker , message , param1 , param2 ) ; SubstituteLoggingEvent event = queue . poll ( ) ; verifyMessage ( event , Level . DEBUG , marker , twoParams , null ) ; }
public String function ( String arg0 , String arg1 ) throws IOException { return postBytes ( arg0 , arg1 . getBytes ( ) ) ; }
protected final String function ( Object arg0 ) { if ( arg0 = = null ) { return ( String ) arg0 ;
@Test void function ( ) { String html = " <!doctype html><title>Foo</title><p>Bar. " ; Document doc = Jsoup . parse ( html , TrackingXmlParser ) ; StringBuilder track = new StringBuilder ( ) ; doc . forEachNode ( node - > accumulatePositions ( node , track ) ) ; assertEquals ( " #document:0-0~40-40; #doctype:0-15; title:15-22~25-33; #text:22-25; p:33-36~40-40; #text:36-40;  " , track . toString ( ) ) ; }
@Test public void function ( ) { Document orig = Jsoup . parse ( " <p>test<br></p> " ) ; orig . outputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml ) ; orig . outputSettings ( ) . escapeMode ( Entities . EscapeMode . xhtml ) ; Safelist whitelist = Safelist . none ( ) . addTags ( " p " , " br " ) ; Document result = new Cleaner ( whitelist ) . clean ( orig ) ; assertEquals ( Document . OutputSettings . Syntax . xml , result . outputSettings ( ) . syntax ( ) ) ; assertEquals ( " <p>test<br /></p> " , result . body ( ) . html ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.13.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( final Cookie arg0 ) { arg0 . setMaxAge ( maxAge ) ; }
public static HttpServer function ( final int arg0 , final MocoMonitor arg1 , final MocoMonitor arg2 , final MocoMonitor . . . arg3 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualHttpServer . createHttpServerWithMonitor ( of ( arg0 ) , ApiUtils . mergeMonitor ( checkNotNull ( arg1 , " Monitor should not be null " ) ,
public Element function ( String arg0 ) { Validate . notNull ( arg0 ) ; empty ( ) ; TextNode textNode = new TextNode ( arg0 , baseUri ) ; appendChild ( textNode ) ; return this ; }
public void function ( ) { slf4jMessageFormatter_TwoArg ( RUN_LENGTH ) ; double duration = slf4jMessageFormatter_TwoArg ( RUN_LENGTH ) ; long referencePerf = 60 ; BogoPerf . assertDuration ( duration , referencePerf , REFERENCE_BIPS ) ; }
public boolean function ( ) { if ( traceCapable ) { return logger . isTraceEnabled ( ) ;
public Whitelist function ( String arg0 , String arg1 , String arg2 ) { Validate . notEmpty ( arg0 ) ; Validate . notEmpty ( arg1 ) ; Validate . notEmpty ( arg2 ) ; TagName tagName = TagName . valueOf ( arg0 ) ; tagNames . add ( tagName ) ; AttributeKey attrKey = AttributeKey . valueOf ( arg1 ) ; AttributeValue attrVal = AttributeValue . valueOf ( arg2 ) ; if ( enforcedAttributes . containsKey ( tagName ) ) { enforcedAttributes . get ( tagName ) . put ( attrKey , attrVal ) ; } else { Map < AttributeKey , AttributeValue > attrMap = new HashMap < > ( ) ; attrMap . put ( attrKey , attrVal ) ; enforcedAttributes . put ( tagName , attrMap ) ; } return this ; }
private static ImmutableMap < String , String [ ] > function ( final QueryStringDecoder arg0 ) { return arg0 . parameters ( ) . entrySet ( ) . stream ( ) . collect ( toImmutableMap ( Map . Entry : : getKey , entry - > entry . getValue ( ) . toArray ( new String [ 0 ] ) ) ) ;
public HttpResponse function ( final String arg0 ) throws IOException { return execute ( Request . Delete ( arg0 ) ) ; }
public void function ( ) throws Exception { final ResponseHandler handler = mock ( ResponseHandler . class ) ; server . request ( and ( by ( uri ( " /target " ) ) , by ( " content " ) ) ) . response ( handler ) ; server . request ( by ( uri ( " /event " ) ) ) . response ( " event " ) . on ( complete ( async ( post ( remoteUrl ( " /target " ) , text ( " content " ) ) ) ) ) ; running ( server , ( ) - > { assertThat ( helper . get ( remoteUrl ( " /event " ) ) , is ( " event " ) ) ; verify ( handler , never ( ) ) . writeToResponse ( any ( SessionContext . class ) ) ; Idles . idle ( 2 , TimeUnit . SECONDS ) ; } ) ; verify ( handler ) . writeToResponse ( any ( SessionContext . class ) ) ; }
@Override public void function ( ) throws IOException { super . reset ( ) ; remaining = maxSize - markPos ; readPos = markPos ; }
public static RestServer function ( final int arg0 , final MocoMonitor arg1 , final MocoMonitor arg2 , final MocoMonitor . . . arg3 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return new ActualRestServer ( arg0 , null , mergeMonitor ( checkNotNull ( arg1 , " Monitor should not be null " ) ,
Document function ( String arg0 , String arg1 , boolean arg2 ) { state = HtmlTreeBuilderState . Initial ; return super . parse ( arg0 , arg1 , arg2 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div class='mellow yellow'><span class=mellow>Hello <b class='yellow'>Yellow!</b></span><p>Empty</p></div> " ) ; List < Element > els = doc . getElementsWithClass ( " mellow " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " div " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " span " , els . get ( 1 ) . tagName ( ) ) ; List < Element > els2 = doc . getElementsWithClass ( " yellow " ) ; assertEquals ( 2 , els2 . size ( ) ) ; assertEquals ( " div " , els2 . get ( 0 ) . tagName ( ) ) ; assertEquals ( " b " , els2 . get ( 1 ) . tagName ( ) ) ; List < Element > none = doc . getElementsWithClass ( " solo " ) ; assertEquals ( 0 , none . size ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { warn ( arg1 , arg2 , arg3 ) ; }
public Optional < MocoConfig > function ( ) { if ( context ! = null ) { return of ( Moco . context ( context ) ) ; } return empty ( ) ; }
public @Nullable Element function ( ) { if ( parentNode = = null ) return null ; List < Element > siblings = parent ( ) . childElementsList ( ) ; int index = indexInList ( this , siblings ) ; if ( siblings . size ( ) > index + 1 ) return siblings . get ( index + 1 ) ;
private Elements function ( boolean arg0 ) { tq . consume ( arg0 ? " :containsOwn " : " :contains " ) ; String searchText = TokenQueue . unescape ( tq . chompBalanced ( '(' , ')' ) ) ; Validate . notEmpty ( searchText , " :contains(text) query must not be empty " ) ; return arg0 ? root . getElementsContainingOwnText ( searchText ) : root . getElementsContainingText ( searchText ) ; }
public static MocoEventAction function ( final MocoEventAction arg0 , final LatencyProcedure arg1 ) { return new MocoAsyncAction ( checkNotNull ( arg0 , " Action should not be null " ) , checkNotNull ( arg1 , " Procedure should not be null " ) ) ;
public void function ( String arg0 , String arg1 ) { map . put ( arg0 , arg1 ) ; }
static String function ( StringBuffer arg0 , StopWatch arg1 ) { DurationUnit du = selectDurationUnitForDisplay ( arg1 ) ; return durationInDunrationUnitsAsStr ( arg1 . getResultInNanos ( ) , du ) ; }
public void function ( ) throws Exception { byte [ ] buffer = TestHelper . loadFile ( " src/test/resources/v23tagwithbpmfloat.mp3 " ) ; ID3v2 id3tag = ID3v2TagFactory . createTag ( buffer ) ; assertEquals ( 84 , id3tag . getBPM ( ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { recordEvent ( Level . WARN , arg0 , null , arg1 ) ; }
public boolean function ( FullHttpRequest arg0 ) { String relativePath = extractor . extract ( arg0 ) ; return isTarget ( relativePath ) & & new File ( dir , relativePath ) . exists ( ) ; }
private Function < HttpHeader , ResponseHandler > function ( ) { return new Function < HttpHeader , ResponseHandler > ( ) { @Override
public static StringBuilder function ( ) { return BuilderPool . borrow ( ) ; }
public void function ( ) throws IOException , InterruptedException { int port = SocketUtil . getAvailablePort ( ) ; CountDownLatch countServerDownLatch = new CountDownLatch ( 1 ) ; MyWebSocketServer server = new MyWebSocketServer ( port ) ; assertEquals ( port , server . getPort ( ) ) ; server = new MyWebSocketServer ( 0 , countServerDownLatch ) ; assertEquals ( 0 , server . getPort ( ) ) ; server . start ( ) ; countServerDownLatch . await ( ) ; assertNotEquals ( 0 , server . getPort ( ) ) ; }
protected LogFactory function ( final String arg0 , final ClassLoader arg1 , final ClassLoader arg2 ) { throw new UnsupportedOperationException ( " Operation [logRawDiagnostic] is not supported in jcl-over-slf4j. See also  "
private void function ( Logger arg0 ) throws InvocationTargetException , IllegalAccessException { for ( Method m : Logger . class . getDeclaredMethods ( ) ) { if ( ! EXCLUDED_METHODS . contains ( m . getName ( ) ) ) {
public void function ( ) throws Exception { Response response = Request . Get ( root ( ) ) . version ( HttpVersion . HTTP_1_1 ) . addHeader ( " Connection " , " keep-alive " ) . execute ( ) ; assertThat ( response . returnResponse ( ) . getFirstHeader ( " Connection " ) , nullValue ( ) ) ; }
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_T , BYTE_A , BYTE_G } ; assertEquals ( " TAG " , BufferTools . byteBufferToString ( buffer , 5 , 3 ) ) ; }
public T function ( URL arg0 ) { Validate . notNull ( arg0 , " URL must not be null " ) ; this . arg0 = arg0 ; return ( T ) this ; }
@Test void function ( ) { boolean threw = false ; try { Validate . notNull ( null ) ; } catch ( ValidationException e ) { threw = true ; assertEquals ( " Object must not be null " , e . getMessage ( ) ) ; StackTraceElement [ ] stackTrace = e . getStackTrace ( ) ; for ( StackTraceElement trace : stackTrace ) { assertNotEquals ( trace . getClassName ( ) , Validate . class . getName ( ) ) ; } assertTrue ( stackTrace . length > = 1 ) ; } Assertions . assertTrue ( threw ) ; }
private byte function ( Opcode arg0 ) { if ( arg0 = = Opcode . CONTINUOUS ) return 0 ; else if ( arg0 = = Opcode . TEXT ) return 1 ; else if ( arg0 = = Opcode . BINARY ) return 2 ; else if ( arg0 = = Opcode . CLOSING ) return 8 ; else if ( arg0 = = Opcode . PING ) return 9 ; else if ( arg0 = = Opcode . PONG ) return 10 ; throw new RuntimeException ( " Don't know how to handle  " + arg0 . toString ( ) ) ; }
static void function ( Appendable arg0 , String arg1 , OutputSettings arg2 , int arg3 ) throws IOException { doEscape ( arg1 , arg0 , arg2 . escapeMode ( ) , arg2 . syntax ( ) , arg2 . charset ( ) , arg3 ) ; }
public void function ( ) { assertNull ( LoggerFactory . loadExplicitlySpecified ( null ) ) ; }
public void function ( String arg0 , Throwable arg1 ) { if ( logger . isLoggable ( Level . SEVERE ) ) { log ( SELF , Level . SEVERE , arg0 , arg1 ) ;
public byte [ ] function ( FullHttpRequest arg0 ) { try { return toByteArray ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ) ;
public static void function ( final SocketServer arg0 , final Runnable arg1 ) throws Exception { doRunning ( runner ( checkNotNull ( arg0 ) ) , checkNotNull ( arg1 ) ) ; }
@Test public void function ( ) { String html = " <p>test</p><div /><div>Two</div> " ; Parser parser = Parser . htmlParser ( ) . setTrackErrors ( 5 ) ; parser . parseInput ( html , " " ) ; assertEquals ( 1 , parser . getErrors ( ) . size ( ) ) ; assertEquals ( " 18: Tag cannot be self closing; not a void tag " , parser . getErrors ( ) . get ( 0 ) . toString ( ) ) ; assertFalse ( Jsoup . isValid ( html , Whitelist . relaxed ( ) ) ) ; String clean = Jsoup . clean ( html , Whitelist . relaxed ( ) ) ; assertEquals ( " <p>test</p> <div></div> <div> Two </div> " , StringUtil . normaliseWhitespace ( clean ) ) ; }
private boolean function ( Document . OutputSettings arg0 ) { return tag ( ) . isInline ( ) & & ! tag ( ) . isEmpty ( )
public void function ( ) { String result ; Integer p0 = i1 ; Integer [ ] p1 = new Integer [ ] { i2 , i3 } ; System . out . println ( " [ " + Arrays . toString ( new int [ ] { 1 , 2 } ) + " ] " ) ; result = MessageFormatter . format ( " {}{} " , p0 , p1 ) ; assertEquals ( p0 + Arrays . toString ( p1 ) , result ) ; { Object [ ] pa = new Object [ ] { " a " , p1 } ; result = MessageFormatter . arrayFormat ( " {}{} " , pa ) ; assertEquals ( " a " + Arrays . toString ( p1 ) , result ) ; } { Object [ ] pa = new Object [ ] { " a " , new int [ ] { 1 , 2 } } ;
public void function ( final String arg0 ) { clearMessage ( ) ; ByteBuffer buffer = ByteBuffer . wrap ( arg0 . getBytes ( ) ) ; try { this . userSession . getAsyncRemote ( ) . sendPing ( buffer ) ;
@Test public void function ( ) { String h = " <TD BGCOLOR= \" #EEEEFF \"  CLASS= \" NavBarCell1 \" >    <A HREF= \" deprecated-list.html \" ><FONT CLASS= \" NavBarFont1 \" ><B>Deprecated</B></FONT></A>&nbsp;</TD> " ; Document doc = Jsoup . parse ( h ) ; Element a = doc . select ( " a " ) . first ( ) ; assertEquals ( " Deprecated " , a . text ( ) ) ; assertEquals ( " font " , a . child ( 0 ) . tagName ( ) ) ; assertEquals ( " b " , a . child ( 0 ) . child ( 0 ) . tagName ( ) ) ; }
public void function ( ) { if ( instanceofLAL & & logger . isTraceEnabled ( ENTRY_MARKER ) ) { ( ( LocationAwareLogger ) logger ) . log ( EXIT_MARKER , FQCN ,
public int function ( ByteBuffer arg0 ) { return transfereTo ( inData , arg0 ) ; }
public void function ( Framedata arg0 ) { engine . sendFrame ( arg0 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " seq.json " ) ; assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; assertThat ( helper . get ( root ( ) ) , is ( " bar " ) ) ; assertThat ( helper . get ( root ( ) ) , is ( " bar " ) ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { formatAndLog ( LOG_LEVEL_WARN , arg0 , arg1 , arg2 ) ; }
public final void function ( final Request arg0 ) { try ( CloseableHttpClient client = HttpClients . createDefault ( ) ) { final HttpUriRequest actionRequest = prepareRequest ( arg0 ) ;
private ByteBuffer function ( ByteBuffer arg0 , int arg1 ) { if ( arg1 > arg0 . capacity ( ) ) { arg0 = ByteBuffer . allocate ( arg1 ) ; } else { arg0 = ByteBuffer . allocate ( arg0 . capacity ( ) * 2 ) ; } return arg0 ; }
protected void function ( SocketChannel arg0 ) throws Exception { ChannelPipeline pipeline = arg0 . pipeline ( ) ; if ( serverSetting . isSecure ( ) ) { SSLEngine sslEngine = MocoSslContextFactory . createServerContext ( serverSetting . getCertificate ( ) ) . createSSLEngine ( ) ; sslEngine . setUseClientMode ( false ) ; pipeline . addLast ( " ssl " , new SslHandler ( sslEngine ) ) ; } pipeline . addLast ( " decoder " , new HttpRequestDecoder ( ) ) ; pipeline . addLast ( " aggregator " , new HttpObjectAggregator ( 1048576 ) ) ; pipeline . addLast ( " encoder " , new HttpResponseEncoder ( ) ) ; pipeline . addLast ( " handler " , new MocoHandler ( serverSetting ) ) ; }
public void function ( ) throws Exception { HttpResponse httpResponse = helper . postForResponse ( remoteUrl ( " /targets " ) , Jsons . toJson ( resource1 ) ) ; assertThat ( httpResponse . getStatusLine ( ) . getStatusCode ( ) , is ( 201 ) ) ; assertThat ( httpResponse . getFirstHeader ( " Location " ) . getValue ( ) , is ( " /targets/123 " ) ) ; }
public boolean function ( HttpRequest arg0 ) { long contentLength = HttpHeaders . getContentLength ( arg0 ) ; ChannelBuffer contentBuffer = arg0 . getContent ( ) ; String content = contentBuffer . toString ( ( int ) ( contentBuffer . capacity ( ) - contentLength ) , ( int ) contentLength , Charset . defaultCharset ( ) ) ; return content . equals ( this . content ) ; }
public static String function ( String arg0 ) { arg0 = arg0 . replaceAll ( " \\ n \\ s* " , " " ) ; return arg0 ; }
private void function ( Level arg0 ) { switch ( arg0 ) { case TRACE : logger . trace ( message , exception ) ; break ; case DEBUG : logger . debug ( message , exception ) ; break ; case INFO : logger . info ( message , exception ) ; break ; case WARN : logger . warn ( message , exception ) ; break ; case ERROR : logger . error ( message , exception ) ; break ; } verifyMessageWithoutMarker ( arg0 , null , exception ) ; }
public void function ( ) { Marker profilerMarker = MarkerFactory . getMarker ( PROFILER_MARKER_NAME ) ; if ( logger = = null ) { throw new NullPointerException ( " If you invoke the log() method, then you must associate a logger with this profiler. " ) ; } if ( logger . isDebugEnabled ( profilerMarker ) ) { DurationUnit du = Util . selectDurationUnitForDisplay ( globalStopWatch ) ;
public boolean function ( HttpRequest arg0 ) { return this . matcher . match ( arg0 ) ; }
private void function ( Level arg0 , Marker arg1 , String arg2 , Object [ ] arg3 , Throwable arg4 ) { SubstituteLoggingEvent loggingEvent = new SubstituteLoggingEvent ( ) ; loggingEvent . setTimeStamp ( System . currentTimeMillis ( ) ) ; loggingEvent . setLevel ( arg0 ) ; loggingEvent . setLogger ( logger ) ; loggingEvent . setLoggerName ( name ) ; loggingEvent . addMarker ( arg1 ) ; loggingEvent . setMessage ( arg2 ) ; loggingEvent . setThreadName ( Thread . currentThread ( ) . getName ( ) ) ; loggingEvent . setArgumentArray ( arg3 ) ; loggingEvent . setThrowable ( arg4 ) ; eventQueue . add ( loggingEvent ) ; }
private void function ( Object arg0 , Collection < WebSocket > arg1 ) { String sData = null ; if ( arg0 instanceof String ) { sData = ( String ) arg0 ; } ByteBuffer bData = null ; if ( arg0 instanceof ByteBuffer ) { bData = ( ByteBuffer ) arg0 ; } if ( sData = = null & & bData = = null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; List < WebSocket > clientCopy ; synchronized ( arg1 ) { clientCopy = new ArrayList < WebSocket > ( arg1 ) ; } for ( WebSocket client : clientCopy ) { if ( client ! = null ) {
public static Elements function ( String arg0 , Element arg1 ) { return new Selector ( arg0 , arg1 ) . select ( ) ; }
String function ( ) { bufferUp ( ) ; final int start = bufPos ; final int remaining = bufLength ; final char [ ] val = charBuf ; while ( bufPos < remaining ) { final char c = val [ bufPos ] ; if ( c = = '\t' | | c = = '\n' | | c = = '\r' | | c = = '\f' | | c = = ' ' | | c = = '/' | | c = = '>' | | c = = '<' | | c = = TokeniserState . nullChar ) break ; bufPos + + ; } return bufPos > start ? cacheString ( charBuf , stringCache , start , bufPos - start ) : " " ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isTraceEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 ) . getMessage ( ) ;
protected Optional < ImmutableMap < String , String > > function ( final HttpRequest arg0 ) { HttpPostRequestDecoder decoder = null ; try { DefaultHttpDataFactory factory = new DefaultHttpDataFactory ( DefaultHttpDataFactory . MINSIZE ) ;
public ReplayContainer function ( final JsonParser arg0 , final DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return new ReplayContainer ( helper . text ( arg0 ) , null ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; InternalReplayContainer value = arg0 . readValueAs ( InternalReplayContainer . class ) ; return value . toContainer ( ) ; } return ( ReplayContainer ) arg1 . handleUnexpectedToken ( ReplayContainer . class , arg0 ) ; }
public void function ( HttpRequest arg0 , MutableHttpResponse arg1 ) { arg1 . addHeader ( " Access-Control-Expose-Headers " , String . join ( " , " , headers ) ) ; }
public void function ( ) throws Exception { DefaultExtension defaultExtension = new DefaultExtension ( ) ; BinaryFrame binaryFrame = new BinaryFrame ( ) ; binaryFrame . setPayload ( ByteBuffer . wrap ( " test " . getBytes ( ) ) ) ; defaultExtension . decodeFrame ( binaryFrame ) ; assertEquals ( ByteBuffer . wrap ( " test " . getBytes ( ) ) , binaryFrame . getPayloadData ( ) ) ; }
protected Runner function ( String [ ] arg0 ) { StartArgs startArgs = parse ( ServerType . SOCKET , arg0 ) ; return factory . createRunner ( startArgs ) ; }
public void function ( ) { System . setProperty ( LOGGER_FACTORY_PROPERTY , " org.slf4j.XLoggerFAFactory " ) ; Logger logger = LoggerFactory . getLogger ( " foo " ) ; if ( ! ( logger instanceof XLogger ) ) { fail ( " returned logger of type  " + logger . getClass ( ) . getName ( ) + "  is not of type SimpleLogger " ) ;
public Node function ( String arg0 ) { Validate . notEmpty ( arg0 ) ; Element wrapBody = Parser . parseBodyFragmentRelaxed ( arg0 , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) return null ; Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChildren ( this ) ; if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i + + ) { Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }
public static Failover function ( final String arg0 , final int . . . arg1 ) { return new Failover ( ApiUtils . failoverExecutor ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , FailoverStrategy . FAILOVER ,
void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { String html = Entities . escape ( getWholeText ( ) , arg2 ) ; if ( parent ( ) instanceof Element & & ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } if ( siblingIndex ( ) = = 0 & & parentNode instanceof Element & & ( ( Element ) parentNode ) . tag ( ) . canContainBlock ( ) & & ! isBlank ( ) ) indent ( arg0 , arg1 ) ; arg0 . append ( html ) ; }
public MessageContent function ( final Optional < ? extends Request > arg0 ) { return MessageContent . content ( ) . withContent ( toJson ( pojo ) ) . build ( ) ; }
protected Setting < SocketResponseSetting > function ( final RequestMatcher arg0 ) { return new SocketSetting ( arg0 ) ; }
public void function ( ) throws Exception { server . request ( by ( " foo " ) , by ( uri ( " /foo " ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
public Optional < String > function ( final Request arg0 ) { return of ( this . text ) ; }
public static RestSetting function ( final String arg0 , final RequestMatcher arg1 , final ResponseHandler . . . arg2 ) { return new HeadRestSetting ( checkNotNullOrEmpty ( arg0 , " ID should not be null or empty " ) , of ( checkNotNull ( arg1 , " Head matcher should be not null " ) ) ,
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { delegate ( ) . warn ( arg0 , arg1 , arg2 ) ; }
protected RestSetting function ( final Optional < RequestMatcher > arg0 , final ResponseHandler arg1 ) { return new PostRestSetting ( arg0 , arg1 ) ; }
protected void function ( byte [ ] arg0 ) throws InvalidDataException { String filetype ; try { filetype = BufferTools . byteBufferToString ( arg0 , 1 , 3 ) ; } catch ( UnsupportedEncodingException e ) { filetype = " unknown " ; } mimeType = " image/ " + filetype . toLowerCase ( ) ; pictureType = arg0 [ 4 ] ; int marker ; for ( marker = 5 ; marker < arg0 . length ; marker + + ) { if ( arg0 [ marker ] = = 0 ) break ; } description = new EncodedText ( arg0 [ 0 ] , BufferTools . copyBuffer ( arg0 , 5 , marker - 5 ) ) ; marker + = description . getTerminator ( ) . length ; imageData = BufferTools . copyBuffer ( arg0 , marker , arg0 . length - marker ) ; }
public void function ( String arg0 ) { if ( duplicate ) other . print ( arg0 ) ; stringList . add ( arg0 ) ; }
public PongWebSocketFrame function ( final PingWebSocketFrame arg0 ) { ByteBuf content = arg0 . content ( ) ; byte [ ] bytes = toByteArray ( content ) ; for ( PingPongSetting setting : settings ) { if ( Arrays . equals ( bytes , setting . getPing ( ) . getBytes ( ) ) ) { ByteBuf buf = ByteBufs . toByteBuf ( setting . getPong ( ) . getBytes ( ) ) ; return new PongWebSocketFrame ( buf ) ; } } throw new IllegalArgumentException ( ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { arg1 . error ( this ) ; return false ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " html " ) ) { return InBody . process ( arg0 , arg1 ) ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " head " ) ) { Element head = arg1 . insert ( arg0 . asStartTag ( ) ) ; arg1 . setHeadElement ( head ) ; arg1 . transition ( InHead ) ; } else if ( arg0 . isEndTag ( ) & & ( StringUtil . in ( arg0 . asEndTag ( ) . name ( ) , " head " , " body " , " html " , " br " ) ) ) { arg1 . processStartTag ( " head " ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . error ( this ) ; return false ; } else { arg1 . processStartTag ( " head " ) ; return arg1 . process ( arg0 ) ; } return true ; }
@Test public void function ( ) throws NoSuchMethodException { Annotation [ ] declaredAnnotations = TreeBuilder . class . getPackage ( ) . getDeclaredAnnotations ( ) ; boolean seen = false ; for ( Annotation annotation : declaredAnnotations ) { if ( annotation . annotationType ( ) . isAssignableFrom ( NullMarked . class ) ) seen = true ; } assertTrue ( seen ) ;
public boolean function ( ) { return _delegate = = null ; }
private int function ( byte [ ] arg0 , int arg1 ) { try { BufferTools . stringIntoByteBuffer ( FOOTER_TAG , 0 , FOOTER_TAG . length ( ) , arg0 , arg1 ) ; } catch ( UnsupportedEncodingException e ) { } String s [ ] = version . split ( " . " ) ; if ( s . length > 0 ) { byte majorVersion = Byte . parseByte ( s [ 0 ] ) ; arg0 [ arg1 + MAJOR_VERSION_OFFSET ] = majorVersion ; } if ( s . length > 1 ) { byte minorVersion = Byte . parseByte ( s [ 0 ] ) ; arg0 [ arg1 + MINOR_VERSION_OFFSET ] = minorVersion ; } packFlags ( arg0 , arg1 ) ; BufferTools . packSynchsafeInteger ( getDataLength ( ) , arg0 , arg1 + DATA_LENGTH_OFFSET ) ; return arg1 + FOOTER_LENGTH ; }
public String function ( ) { final String remainder = queue . substring ( pos , queue . length ( ) ) ; pos = queue . length ( ) ; return remainder ; }
private Optional < HttpsCertificate > function ( Optional < HttpsCertificate > arg0 ) { if ( this . isSecure ( ) ) { return this . arg0 ; } if ( arg0 . isPresent ( ) ) { return arg0 ; } return absent ( ) ; }
public void function ( ) throws Exception { server . response ( status ( 200 ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.21.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
@Test public void function ( ) { String h = " <div class=foo><ol><li>One<li>Two<li>Three</ol></div> " ; Document doc = Jsoup . parse ( h ) ; Elements els = doc . select ( " .foo > ol, ol > li + li " ) ; assertEquals ( 3 , els . size ( ) ) ; assertEquals ( " ol " , els . get ( 0 ) . tagName ( ) ) ; assertEquals ( " Two " , els . get ( 1 ) . text ( ) ) ; assertEquals ( " Three " , els . get ( 2 ) . text ( ) ) ; }
public void function ( ) throws Exception { server . resource ( " targets " , head ( " 1 " , eq ( query ( " name " ) , " foo " ) ) ) ; running ( server , new Runnable ( ) { @Override
public byte [ ] function ( Optional < HttpRequest > arg0 ) { try { return toByteArray ( file ) ;
private static boolean function ( Set < URL > arg0 ) { return arg0 . size ( ) > 1 ; }
public void function ( ) { final Document doc = createXmlDocument ( " 1.0 " , " changeThis " , true ) ; doc . charset ( Charset . forName ( charsetIso8859 ) ) ; final String xmlCharsetISO = " <?xml version= \" 1.0 \"  encoding= \" " + charsetIso8859 + " \" ?> \ n " + " <root> \ n " + "  node \ n " + " </root> " ; assertEquals ( xmlCharsetISO , doc . toString ( ) ) ; XmlDeclaration selectedNode = ( XmlDeclaration ) doc . childNode ( 0 ) ; assertEquals ( charsetIso8859 , doc . charset ( ) . name ( ) ) ; assertEquals ( charsetIso8859 , selectedNode . attr ( " encoding " ) ) ; assertEquals ( doc . charset ( ) , doc . outputSettings ( ) . charset ( ) ) ; }
public List < Attribute > function ( ) { ArrayList < Attribute > list = new ArrayList < > ( size ) ; for ( int i = 0 ; i < size ; i + + ) { Attribute attr = new Attribute ( keys [ i ] , vals [ i ] , Attributes . this ) ; list . add ( attr ) ; } return Collections . unmodifiableList ( list ) ; }
public String function ( ) { return accum . toString ( ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 6 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ) ; }
public static DataNode function ( String arg0 , String arg1 ) { String data = StringEscapeUtils . unescapeHtml ( arg0 ) ; return new DataNode ( data , arg1 ) ; }
@Test public void function ( ) { String html = " <html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html> " ; Document doc = Jsoup . parse ( html ) ; Element body = doc . getBody ( ) ; Comment comment = ( Comment ) body . childNode ( 0 ) ; assertEquals ( "  <table><tr><td></table>  " , comment . getData ( ) ) ; Element p = body . child ( 0 ) ; TextNode text = ( TextNode ) p . childNode ( 0 ) ; assertEquals ( " Hello " , text . getWholeText ( ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { recordEvent ( Level . ERROR , arg0 , arg1 , arg2 , null ) ; }
public void function ( ) throws Exception { PlainA pojo = new PlainA ( ) ; pojo . code = 1 ; pojo . message = " message " ; server . request ( as ( Moco . json ( pojo ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . postContent ( root ( ) , " { \ n \ t \" code \" :2, \ n \ t \" message \" : \" information \" \ n} " ) , is ( " foo " ) ) ) ; }
private void function ( ) { hasAttrName = true ; if ( attrNameS ! = null ) { attrName . append ( attrNameS ) ;
public boolean function ( String arg0 ) { return arg0 . startsWith ( new String ( expected . readFor ( null ) ) ) ; }
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { WebSocketImpl . DEBUG = true ; int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ServerAdditionalHeaderExample s = new ServerAdditionalHeaderExample ( port ) ; s . start ( ) ; System . out . println ( " Server started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
default LoggingEventBuilder function ( Level arg0 ) { return new DefaultLoggingEventBuilder ( this , arg0 ) ; }
public void function ( ) throws IOException { RunnerFactory factory = new RunnerFactory ( SHUTDOWN_MOCO_KEY ) ; runner = factory . createRunner ( new StartArgs ( ServerType . HTTP , port ( ) , null , " src/test/resources/foo.json " , null , null , null ) ) ; runner . run ( ) ; try { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; } catch ( HttpHostConnectException e ) { fail ( e . getMessage ( ) ) ; } ShutdownRunner shutdownRunner = ( ShutdownRunner ) runner ; int port = shutdownRunner . shutdownPort ( ) ; shutdownMoco ( port , SHUTDOWN_MOCO_KEY ) ; waitChangeHappens ( ) ; helper . get ( root ( ) ) ; }
public void function ( ) throws IOException , UnsupportedTagException , InvalidDataException { loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 41 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 256 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 1024 ) ; loadAndCheckTestMp3WithTags ( MP3_WITH_ID3V1_AND_ID3V23_TAGS , 5000 ) ; }
public void function ( WebSocket arg0 , ByteBuffer arg1 ) { countReceiveDownLatch . countDown ( ) ; }
publicvoid function ( WebSocket arg0 , Framedata arg1 ) { onFragment ( arg0 , arg1 ) ; }
void function ( Document . OutputSettings arg0 ) { Document doc = Jsoup . parse ( " <div> \ nFoo \ n<p> \ nBar \ nqux</p></div> \ n<script> \ n alert('Hello!'); \ n</script> " ) ; doc . outputSettings ( arg0 ) ; String html = doc . html ( ) ; Document doc2 = Jsoup . parse ( html ) ; doc2 . outputSettings ( arg0 ) ; String html2 = doc2 . html ( ) ; assertEquals ( html , html2 ) ; }
@Test public void function ( ) { StringBuilder builder = new StringBuilder ( ) ; for ( int i = 0 ; i < 100000 ; i + + ) { builder . insert ( 0 , " <i> " ) ; builder . append ( " </i> " ) ; } Document doc = Jsoup . parse ( builder . toString ( ) ) ; doc . clone ( ) ; }
public void function ( final Server arg0 ) { runner = newRunner ( arg0 ) ; runner . start ( ) ; logger . info ( " Server is started at {} " , arg0 . port ( ) ) ; }
public void function ( ) throws Exception { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , TEST_URL ) ; assertEquals ( frameData , frameData ) ; }
public static LatencyContainer function ( long arg0 ) { return latencyWithUnit ( arg0 , TimeUnit . MILLISECONDS ) ; }
protected HttpServer function ( int arg0 ) { return httpServer ( arg0 ) ; }
public boolean function ( Object arg0 ) { if ( ! ( arg0 instanceof AbstractID3v2Tag ) ) return false ; if ( super . equals ( arg0 ) ) return true ; AbstractID3v2Tag other = ( AbstractID3v2Tag ) arg0 ; if ( unsynchronisation ! = other . unsynchronisation ) return false ; if ( extendedHeader ! = other . extendedHeader ) return false ; if ( experimental ! = other . experimental ) return false ; if ( footer ! = other . footer ) return false ; if ( compression ! = other . compression ) return false ; if ( dataLength ! = other . dataLength ) return false ; if ( extendedHeaderLength ! = other . extendedHeaderLength ) return false ; if ( version = = null ) { if ( other . version ! = null ) return false ; } else if ( other . version = = null ) return false ; else if ( ! version . equals ( other . version ) ) return false ; if ( frameSets = = null ) { if ( other . frameSets ! = null ) return false ; } else if ( other . frameSets = = null ) return false ; else if ( ! frameSets . equals ( other . frameSets ) ) return false ; return true ; }
public void function ( ) { final List < Integer > first = Iterables . asIterable ( 1 , new Integer [ ] { 2 , 3 } ) ; assertThat ( first . get ( 0 ) , is ( 1 ) ) ; assertThat ( first . get ( 1 ) , is ( 2 ) ) ; assertThat ( first . get ( 2 ) , is ( 3 ) ) ; assertThat ( first . size ( ) , is ( 3 ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( null , new Integer [ 0 ] ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( 1 , null ) ) ; final List < Integer > second = Iterables . asIterable ( 1 , 2 , new Integer [ ] { 3 , 4 } ) ; assertThat ( second . get ( 0 ) , is ( 1 ) ) ; assertThat ( second . get ( 1 ) , is ( 2 ) ) ; assertThat ( second . get ( 2 ) , is ( 3 ) ) ; assertThat ( second . get ( 3 ) , is ( 4 ) ) ; assertThat ( second . size ( ) , is ( 4 ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( null , 2 , new Integer [ 0 ] ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( 1 , null , new Integer [ 0 ] ) ) ; assertThrows ( NullPointerException . class , ( ) - > Iterables . asIterable ( 1 , 2 , null ) ) ; }
public static void function ( String arg0 , Object arg1 ) { if ( arg1 ! = null ) { put ( arg0 , arg1 . toString ( ) ) ;
public RestSetting function ( final RestHeadSetting arg0 ) { return MocoRest . head ( arg0 . id ) . response ( arg0 . getResponseHandler ( ) ) ; }
public Element function ( ) { List < Element > siblings = parent ( ) . children ( ) ; return siblings . size ( ) > 1 ? siblings . get ( 0 ) : null ; }
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( " HTTP/1.1 " ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest another = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( " HTTP/1.1 " ) . withMethod ( " POST " ) . withContent ( " different " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( request ) . match ( another ) , is ( false ) ) ; }
public static XPath function ( String arg0 ) { return new XPath ( arg0 ) ; }
public void function ( boolean arg0 ) { this . arg0 = arg0 ; }
final boolean function ( ) { return type = = TokenType . Comment ; }
protected static boolean function ( String arg0 [ ] ) { if ( arg0 . length < 2 ) { return false ; } rename = arg0 [ 0 ] ; if ( rename . indexOf ( '@' ) < 0 ) { return false ; } filename = arg0 [ 1 ] ; return true ; }
@Test void function ( ) { Element node = new Element ( " div " ) ; assertNull ( node . parentNode ( ) ) ; node . remove ( ) ; assertNull ( node . parentNode ( ) ) ; }
public final void function ( WebSocket arg0 ) { WebSocketImpl conn = ( WebSocketImpl ) arg0 ; try { conn . key . interestOps ( SelectionKey . OP_READ | SelectionKey . OP_WRITE ) ; } catch ( CancelledKeyException e ) { conn . outQueue . clear ( ) ; } selector . wakeup ( ) ; }
public void function ( ) throws IOException { assertThat ( helper . getForStatus ( remoteUrl ( " /cookie " ) ) , is ( 302 ) ) ; assertThat ( helper . get ( remoteUrl ( " /cookie " ) ) , is ( " true " ) ) ; }
public final SocketArgs function ( ) { return new SocketArgs ( port , shutdownPort , configurationFile ) ; }
public String function ( final String arg0 , final byte [ ] arg1 , final Charset arg2 ) throws IOException { return executeAsString ( Request . post ( arg0 ) . bodyByteArray ( arg1 , ContentType . create ( " text/plain " , arg2 ) ) ) ;
public void function ( FullHttpRequest arg0 ) { log ( " Request received: \ n \ n%s \ n " , requestDumper . dump ( arg0 ) ) ; }
public void function ( ) { String result ; Integer p0 = i1 ; Integer [ ] p1 = new Integer [ ] { i2 , i3 } ; result = MessageFormatter . format ( " {}{} " , p0 , p1 ) ; assertEquals ( " 1[2, 3] " , result ) ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , p1 } ) ; assertEquals ( " a[2, 3] " , result ) ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , new byte [ ] { 1 , 2 } } ) ; assertEquals ( " a[1, 2] " , result ) ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , new int [ ] { 1 , 2 } } ) ; assertEquals ( " a[1, 2] " , result ) ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , new float [ ] { 1 , 2 } } ) ; assertEquals ( " a[1.0, 2.0] " , result ) ; result = MessageFormatter . arrayFormat ( " {}{} " , new Object [ ] { " a " , new double [ ] { 1 , 2 } } ) ; assertEquals ( " a[1.0, 2.0] " , result ) ;
protected < T > T function ( String arg0 , Object arg1 , Class < T > arg2 ) { return invokeTarget ( arg0 , arg1 , arg2 , arg1 . getClass ( ) ) ; }
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null | | getClass ( ) ! = arg0 . getClass ( ) ) return false ; SubstituteLogger that = ( SubstituteLogger ) arg0 ; if ( ! name . equals ( that . name ) ) return false ; return true ; }
public static ContentResource function ( final String arg0 , Charset arg1 ) { return fileResource ( new File ( checkNotNullOrEmpty ( arg0 , " Filename should not be null " ) ) , of ( arg1 ) ) ; }
public void function ( String arg0 ) { this . arg0 = arg0 ; }
public boolean function ( ) { return this . content ! = null & & this . content . isRawText ( ) ;
public void function ( ) { assertArrayEquals ( new byte [ ] { 102 , 111 , 111 , 66 , 97 , 114 } , Charsetfunctions . utf8Bytes ( " fooBar " ) ) ;
protected final HttpHeader [ ] function ( final MocoConfig arg0 ) { HttpHeader [ ] appliedHeaders = new HttpHeader [ this . headers . length ] ; for ( int i = 0 ; i < headers . length ; i + + ) { HttpHeader header = headers [ i ] ; Resource appliedValue = header . getValue ( ) . apply ( arg0 ) ; appliedHeaders [ i ] = new HttpHeader ( header . getName ( ) , appliedValue ) ; } return appliedHeaders ; }
public void function ( ) throws Exception { org . apache . http . HttpResponse response = helper . getResponse ( remoteUrl ( " /targets " ) ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; HttpEntity entity = response . getEntity ( ) ; List < Plain > plains = mapper . readValue ( entity . getContent ( ) , new TypeReference < List < Plain > > ( ) { } ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; }
public static byte [ ] function ( byte [ ] arg0 ) { int count = sizeUnsynchronisationWouldAdd ( arg0 ) ; if ( count = = 0 ) return arg0 ; byte [ ] newBuffer = new byte [ arg0 . length + count ] ; int j = 0 ; for ( int i = 0 ; i < arg0 . length - 1 ; i + + ) { newBuffer [ j + + ] = arg0 [ i ] ; if ( arg0 [ i ] = = ( byte ) 0xff & & ( ( arg0 [ i + 1 ] & ( byte ) 0xe0 ) = = ( byte ) 0xe0 | | arg0 [ i + 1 ] = = 0 ) ) { newBuffer [ j + + ] = 0 ; } } newBuffer [ j + + ] = arg0 [ arg0 . length - 1 ] ; if ( arg0 [ arg0 . length - 1 ] = = ( byte ) 0xff ) { newBuffer [ j + + ] = 0 ; } return newBuffer ; }
public RequestMatcher function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( MocoConfig . REQUEST_ID ) ) { return ( RequestMatcher ) arg0 . apply ( this ) ; } if ( arg0 . isFor ( resource . id ( ) ) ) { return new XmlRequestMatcher ( this . extractor , resource . apply ( arg0 ) ) ; } return this ; }
public void function ( ) throws Exception { server . post ( and ( by ( uri ( " /target " ) ) , by ( " proxy " ) ) ) . response ( " 0XCAFEBABE " ) ; final File tempFile = tempFolder . newFile ( ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) , failover ( tempFile . getAbsolutePath ( ) ) ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( StringBuffer arg0 ) { arg0 . append ( " MP3 Data \ n " ) ; showField ( arg0 , " Filename " , extractFilename ( mp3file . getFilename ( ) ) ) ; showField ( arg0 , " Size " , Long . toString ( mp3file . getLength ( ) ) ) ; showField ( arg0 , " Length " , formatTime ( mp3file . getLengthInSeconds ( ) ) ) ; showField ( arg0 , " Version " , mp3file . getVersion ( ) ) ; showField ( arg0 , " Layer " , mp3file . getLayer ( ) ) ; showField ( arg0 , " Sample rate " , Integer . toString ( mp3file . getSampleRate ( ) ) , " Hz " ) ; showField ( arg0 , " Bitrate " , Integer . toString ( mp3file . getBitrate ( ) ) , " kbps ( " + vbrString ( mp3file . isVbr ( ) ) + " ) " ) ; showField ( arg0 , " Channel mode " , mp3file . getChannelMode ( ) ) ; }
public static ResponseHandler function ( final String arg0 , final MocoGroup arg1 ) { return broadcast ( text ( arg0 ) , arg1 ) ; }
public Character function ( ) { Character c = queue . charAt ( pos ) ; pos + + ; return c ; }
private static HandshakeBuilder function ( String [ ] arg0 , String arg1 ) throws InvalidHandshakeException { if ( ! " GET " . equalsIgnoreCase ( arg0 [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid request method received: %s Status line: %s " , arg0 [ 0 ] , arg1 ) ) ; } if ( ! " HTTP/1.1 " . equalsIgnoreCase ( arg0 [ 2 ] ) ) { throw new InvalidHandshakeException ( String . format ( " Invalid status line received: %s Status line: %s " , arg0 [ 2 ] , arg1 ) ) ; } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client ( ) ; clienthandshake . setResourceDescriptor ( arg0 [ 1 ] ) ; return clienthandshake ; }
public static ResponseHandler function ( final String arg0 ) { return proxy ( arg0 , Failover . EMPTY_FAILOVER ) ; }
public void function ( ) { SimpleLogger simpleLogger = new SimpleLogger ( " a.b " ) ; assertEquals ( " info " , simpleLogger . recursivelyComputeLevelString ( ) ) ; }
@Test void function ( ) { String html = "   <h1>before</h1> <div <!--= \" \"  id= \" hidden \"  --= \" \" > <h1>within</h1> </div> <h1>after</h1> " ; Document doc = Jsoup . parse ( html ) ; assertEquals ( " <h1>before</h1><div <!--= \" \"  id= \" hidden \"  --= \" \" ><h1>within</h1></div><h1>after</h1> " , TextUtil . normalizeSpaces ( doc . body ( ) . html ( ) ) ) ; Element div = doc . expectFirst ( " div " ) ; assertNotNull ( div . attribute ( " <!-- " ) ) ; assertEquals ( " hidden " , div . attr ( " id " ) ) ; assertNotNull ( div . attribute ( " -- " ) ) ; }
void function ( String . . . arg0 ) { for ( int pos = stack . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element el = stack . get ( pos ) ;
private void function ( ByteBuffer arg0 ) { if ( DEBUG ) System . out . println ( " write( " + arg0 . remaining ( ) + " ): { " + ( arg0 . remaining ( ) > 1000 ? " too big to display " : new String ( arg0 . array ( ) ) ) + " } " ) ; try { outQueue . put ( arg0 ) ; } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } wsl . onWriteDemand ( this ) ; }
public void function ( String arg0 , Object arg1 ) { logger . error ( arg0 , arg1 ) ; }
void function ( LoggingEvent arg0 , String arg1 , Throwable arg2 ) { verify ( arg0 , arg1 ) ; assertEquals ( arg2 . toString ( ) , arg0 . getThrowableStrRep ( ) [ 0 ] ) ; }
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , put ( anyId ( ) ) . response ( status ( 200 ) ) ) ; running ( server , ( ) - > { HttpResponse httpResponse1 = helper . putForResponse ( remoteUrl ( " /targets/1 " ) ,
public void function ( ) throws Exception { Response response = Request . Get ( root ( ) ) . version ( HttpVersion . HTTP_1_0 ) . addHeader ( " Connection " , " keep-alive " ) . execute ( ) ; String connection = response . returnResponse ( ) . getFirstHeader ( " Connection " ) . getValue ( ) ; assertThat ( connection , is ( " keep-alive " ) ) ; }
public void function ( ) { Map < String , String > map = inheritableThreadLocal . get ( ) ; if ( map ! = null ) { map . clear ( ) ;
@Test public void function ( ) { org . jsoup . nodes . Document jdoc = Jsoup . parse ( " <body><div><p>One</div><div><p>Two " ) ; W3CDom w3CDom = new W3CDom ( ) ; Element jDiv = jdoc . selectFirst ( " div " ) ; assertNotNull ( jDiv ) ; Document doc = w3CDom . fromJsoup ( jDiv ) ; Node div = doc . getFirstChild ( ) ; assertEquals ( " div " , div . getLocalName ( ) ) ; assertEquals ( jDiv , div . getUserData ( W3CDom . SourceProperty ) ) ; Node textNode = div . getFirstChild ( ) . getFirstChild ( ) ; assertEquals ( " One " , textNode . getTextContent ( ) ) ; assertEquals ( Node . TEXT_NODE , textNode . getNodeType ( ) ) ; org . jsoup . nodes . TextNode jText = ( TextNode ) jDiv . childNode ( 0 ) . childNode ( 0 ) ; assertEquals ( jText , textNode . getUserData ( W3CDom . SourceProperty ) ) ; }
private void function ( ) { assertNotNull ( " no log record " , mockHandler . record ) ; assertNotNull ( " missing logger name " , mockHandler . record . getLoggerName ( ) ) ; }
public void function ( ) throws Exception { server . post ( eq ( form ( " name " ) , " dreamhead " ) ) . response ( " foobar " ) ; running ( server , ( ) - > { org . apache . http . client . fluent . Request request = Post ( root ( ) ) . bodyForm ( new BasicNameValuePair ( " name " , " dreamhead " ) ) ;
boolean function ( Token arg0 , TreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { arg1 . error ( this ) ; return false ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " html " ) ) { return InBody . process ( arg0 , arg1 ) ; } else if ( arg0 . isStartTag ( ) & & arg0 . asStartTag ( ) . name ( ) . equals ( " head " ) ) { Element head = arg1 . insert ( arg0 . asStartTag ( ) ) ; arg1 . setHeadElement ( head ) ; arg1 . transition ( InHead ) ; } else if ( arg0 . isEndTag ( ) & & ( StringUtil . in ( arg0 . asEndTag ( ) . name ( ) , " head " , " body " , " html " , " br " ) ) ) { arg1 . process ( new Token . StartTag ( " head " ) ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . error ( this ) ; return false ; } else { arg1 . process ( new Token . StartTag ( " head " ) ) ; return arg1 . process ( arg0 ) ; } return true ; }
public ResponseHandler function ( Map . Entry < String , String > arg0 ) { return cookie ( arg0 . getKey ( ) , arg0 . getValue ( ) ) ; }
public void function ( ) throws IOException , NoSuchAlgorithmException { CustomSSLWebSocketServerFactory webSocketServerFactory = new CustomSSLWebSocketServerFactory ( SSLContext . getDefault ( ) , null , null ) ; SocketChannel channel = SocketChannel . open ( ) ; try { ByteChannel result = webSocketServerFactory . wrapChannel ( channel , null ) ; } catch ( NotYetConnectedException e ) { } channel . close ( ) ; webSocketServerFactory = new CustomSSLWebSocketServerFactory ( SSLContext . getDefault ( ) , new String [ ] { " TLSv1.2 " } , new String [ ] { " TLS_RSA_WITH_AES_128_CBC_SHA " , " TLS_RSA_WITH_AES_256_CBC_SHA " } ) ; channel = SocketChannel . open ( ) ; try { ByteChannel result = webSocketServerFactory . wrapChannel ( channel , null ) ; } catch ( NotYetConnectedException e ) { } channel . close ( ) ; }
public void function ( ) throws IOException { String url = FileServlet . urlTo ( " /htmltests/xml-test.xml " ) ; Connection con = Jsoup . connect ( url ) . method ( Connection . Method . HEAD ) . data ( FileServlet . ContentTypeParam , " text/xml " ) ; final Connection . Response response = con . execute ( ) ; assertEquals ( " text/xml " , response . header ( " Content-Type " ) ) ; assertEquals ( " " , response . body ( ) ) ; Document doc = response . parse ( ) ; assertEquals ( " " , doc . text ( ) ) ; }
public static Function < RestGetSetting , RestSetting > function ( ) { return new Function < RestGetSetting , RestSetting > ( ) { @Override
public void function ( ) { Logger log = LoggerFactory . getLogger ( NopBundleTest . class ) ; log . debug ( " Testing probe " ) ; BundleContext context = getBundleContext ( ) ; ServiceReference ref = context . getServiceReference ( Probe . class . getName ( ) ) ; assertNotNull ( " Service Reference is null " , ref ) ; Probe probe = ( Probe ) context . getService ( ref ) ; assertNotNull ( " Cannot find the probe service " , probe ) ; try { probe . testCommonslogging ( ) ; fail ( " Expected exception while testing commons logging. " ) ; } catch ( Throwable t ) { log . debug ( " Failed to execute the probe.testCommonsLogging.  " + t ) ; } context . ungetService ( ref ) ; log . debug ( " Tested probe. " ) ; }
public void function ( ) { String xml = " <CHECK>One</CHECK><TEST ID=1>Check</TEST> " ; Document doc = Jsoup . parse ( xml , " " , Parser . xmlParser ( ) ) ; assertEquals ( " <CHECK>One</CHECK><TEST ID= \" 1 \" >Check</TEST> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
private void function ( Framedata arg0 ) throws InvalidDataException { if ( arg0 . getOpcode ( ) = = Opcode . TEXT ) { wsl . onMessage ( this , Charsetfunctions . stringUtf8 ( arg0 . getPayloadData ( ) ) ) ;
private boolean function ( InetSocketAddress arg0 ) { try { client = SocketChannel . open ( ) ; client . configureBlocking ( false ) ; client . connect ( arg0 ) ; selector = Selector . open ( ) ; this . conn = new WebSocket ( client , new LinkedBlockingQueue < ByteBuffer > ( ) , this , draft , Integer . MAX_VALUE ) ; if ( client ! = null ) { client . register ( selector , SelectionKey . OP_CONNECT ) ; } } catch ( IOException ex ) { onError ( conn , ex ) ; return false ; } return true ; }
public void function ( Marker arg0 , String arg1 ) { recordEvent ( Level . WARN , arg0 , arg1 , null , null ) ; }
public Iterator < Attribute > function ( ) { return asList ( ) . iterator ( ) ; }
@Test public void function ( ) { boolean threw = false ; try { Evaluator parse = QueryParser . parse ( " section > a[href= \" " ) ; } catch ( IllegalArgumentException e ) { threw = true ; } assertTrue ( threw ) ; }
public void function ( String arg0 ) throws WebsocketNotConnectedException { if ( arg0 = = null ) throw new IllegalArgumentException ( " Cannot send 'null' data to a WebSocketImpl. " ) ; send ( draft . createFrames ( arg0 , role = = Role . CLIENT ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { Header header = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) . getFirstHeader ( " foo " ) ; assertThat ( header . getValue ( ) , is ( " foo.response " ) ) ; }
private void function ( WebSocket arg0 , RuntimeException arg1 ) { onError ( arg0 , arg1 ) ; try { selector . close ( ) ; } catch ( IOException e1 ) { onError ( null , e1 ) ; } for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ;
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; deflateExtension . setDeflater ( new Deflater ( Deflater . DEFAULT_COMPRESSION , false ) ) ; assertEquals ( deflateExtension . getDeflater ( ) , new Deflater ( Deflater . DEFAULT_COMPRESSION , false ) ) ; }
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://direct.infohound.net/tools/302-cookie.pl " ) ; Connection . Response res = con . execute ( ) ; Map < String , String > cookies = res . cookies ( ) ; assertEquals ( " asdfg123 " , cookies . get ( " token " ) ) ; assertEquals ( " jhy " , cookies . get ( " uid " ) ) ; Document doc = Jsoup . connect ( echoUrl ) . cookies ( cookies ) . get ( ) ; assertEquals ( " token=asdfg123; uid=jhy " , ihVal ( " Cookie " , doc ) ) ; }
public void function ( ) { if ( getMessage ( ) ! = null ) { System . out . println ( getMessage ( ) ) ;
public ResponseHandler function ( final MocoConfig arg0 ) { ResponseHandler handler = super . apply ( arg0 ) ; if ( handler ! = this ) { return handler ; } Resource appliedResource = this . resource . apply ( arg0 ) ; if ( appliedResource ! = this . resource ) { return new ContentHandler ( ( ContentResource ) appliedResource ) ; } return this ; }
private static ContentResource function ( Identifiable arg0 , ResourceConfigApplier arg1 , ContentResourceReader arg2 ) { return new ContentResource ( arg0 , arg1 , arg2 ) ; }
private void function ( ) { if ( trackErrors ) errors . add ( new ParseError ( " Invalid character reference " , reader . pos ( ) ) ) ;
private < T > Dumper < T > function ( final T arg0 , ImmutableMap < Class < ? extends T > , Dumper < T > > arg1 ) { for ( Class < ? extends T > dumperClass : arg1 . keySet ( ) ) { if ( dumperClass . isInstance ( arg0 ) ) { return arg1 . get ( dumperClass ) ; } } throw new IllegalArgumentException ( " Unknown target type: " + arg0 . getClass ( ) ) ; }
public void function ( ) { serverThread = new Thread ( this ) ; serverThread . start ( ) ; }
public static NormalizedParameters function ( String arg0 , Object [ ] arg1 , Throwable arg2 ) { if ( arg2 ! = null ) { return new NormalizedParameters ( arg0 , arg1 , arg2 ) ; } if ( arg1 = = null | | arg1 . length = = 0 ) { return new NormalizedParameters ( arg0 , arg1 , arg2 ) ; } Throwable throwableCandidate = NormalizedParameters . getThrowableCandidate ( arg1 ) ; if ( throwableCandidate ! = null ) { Object [ ] trimmedArguments = MessageFormatter . trimmedCopy ( arg1 ) ;
private void function ( final Channel arg0 ) { if ( connected ! = null ) { MessageContent messageContent = this . connected . readFor ( ( Request ) null ) ;
private Supplier < ImmutableMap < String , String > > function ( final HttpHeaders arg0 ) { return Suppliers . memoize ( new Supplier < ImmutableMap < String , String > > ( ) { @Override
@Test void function ( ) { String html = " <p xsi:CLASS=On>One</p> " ; Document doc = Jsoup . parse ( html , TrackingHtmlParser ) ; Element p = doc . expectFirst ( " p " ) ; Attribute attr = p . attribute ( " xsi:class " ) ; assertNotNull ( attr ) ; String expectedRange = " 1,4:3-1,13:12=1,14:13-1,16:15 " ; assertEquals ( expectedRange , attr . sourceRange ( ) . toString ( ) ) ; attr . setKey ( " class " ) ; assertEquals ( expectedRange , attr . sourceRange ( ) . toString ( ) ) ; assertEquals ( " class= \" On \" " , attr . html ( ) ) ; }
public void function ( ) throws UnsupportedEncodingException { String original = " 1234567890QWERTYUIOP " ; try { BufferTools . stringToByteBuffer ( original , - 1 , 1 ) ; fail ( " StringIndexOutOfBoundsException expected but not thrown " ) ; } catch ( StringIndexOutOfBoundsException e ) { } try { BufferTools . stringToByteBuffer ( original , original . length ( ) , 1 ) ;
void function ( StringBuilder arg0 ) { String html = StringEscapeUtils . escapeHtml ( getWholeText ( ) ) ; if ( parent ( ) instanceof Element & & ! ( ( Element ) parent ( ) ) . preserveWhitespace ( ) ) { html = normaliseWhitespace ( html ) ; } arg0 . append ( html ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isInfoEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 )
public void function ( final SessionContext arg0 ) { MessageContent content = this . content . readFor ( arg0 . getRequest ( ) ) ; ByteBuf byteBuf = ByteBufs . toByteBuf ( content . getContent ( ) ) ; arg0 . getGroup ( ) . writeAndFlush ( new BinaryWebSocketFrame ( byteBuf ) ) ; }
public boolean function ( final HttpRequest arg0 ) { Optional < String > content = extractor . extract ( arg0 ) ; return content . isPresent ( ) & & doMatch ( arg0 , content . get ( ) ) ; }
public Elements function ( String arg0 ) { Validate . notEmpty ( arg0 ) ; for ( Element element : contents ) { element . wrap ( arg0 ) ; } return this ; }
public Draft function ( ) { ArrayList < IExtension > newExtensions = new ArrayList < IExtension > ( ) ; for ( IExtension iExtension : getKnownExtensions ( ) ) { newExtensions . add ( iExtension . copyInstance ( ) ) ; } ArrayList < IProtocol > newProtocols = new ArrayList < IProtocol > ( ) ; for ( IProtocol iProtocol : getKnownProtocols ( ) ) { newProtocols . add ( iProtocol . copyInstance ( ) ) ; } return new Draft_6455 ( newExtensions , newProtocols , maxFrameSize ) ; }
public int function ( ) { final int prime = 31 ; int result = super . hashCode ( ) ; result = prime * result + Arrays . hashCode ( children ) ; result = prime * result + ( ( id = = null ) ? 0 : id . hashCode ( ) ) ; result = prime * result + ( isOrdered ? 1231 : 1237 ) ; result = prime * result + ( isRoot ? 1231 : 1237 ) ; result = prime * result + ( ( subframes = = null ) ? 0 : subframes . hashCode ( ) ) ; return result ; }
@Test void function ( ) { StreamParser copy ; try ( StreamParser streamer = basic ( ) ) { copy = streamer ; assertFalse ( isClosed ( copy ) ) ; } assertTrue ( isClosed ( copy ) ) ; }
public final boolean function ( final Request arg0 ) { return this . ping . match ( arg0 ) ; }
public void function ( String arg0 ) { responseWithContentHandler ( new ContentHandler ( arg0 ) ) ; }
private < V extends ConfigApplier < V > > V function ( final V arg0 ) { return configItem ( arg0 , this . configs ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " cookie.json " ) ; Cookie decodeCookie = getCookie ( " /cookie-with-max-age " ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; assertThat ( decodeCookie . maxAge ( ) , is ( 3600L ) ) ; }
public void function ( ) { MocoHttpServer server = new MocoHttpServer ( ActualHttpServer . createLogServer ( of ( 8080 ) ) ) ; server . start ( ) ; server . stop ( ) ; server . stop ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <table><tr><td>1</td></tr></table> " ) ; Element table = doc . select ( " tbody " ) . first ( ) ; table . prepend ( " <tr><td>2</td></tr> " ) ; assertEquals ( " <table><tbody><tr><td>2</td></tr><tr><td>1</td></tr></tbody></table> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; Elements ps = doc . select ( " tr " ) ; for ( int i = 0 ; i < ps . size ( ) ; i + + ) { assertEquals ( i , ps . get ( i ) . siblingIndex ) ;
public void function ( ) throws Exception { final SocketServer server = jsonSocketServer ( port ( ) , file ( " src/test/resources/base.json " ) ) ; running ( server , new Runnable ( ) { @Override
public T function ( final String arg0 ) { this . arg0 = arg0 ( arg0 ) ; return self ( ) ; }
public BaseSetting function ( final MocoConfig arg0 ) { RequestMatcher appliedMatcher = configItem ( this . matcher , arg0 ) ; if ( arg0 . isFor ( " uri " ) & & this . matcher = = appliedMatcher ) { appliedMatcher = new AndRequestMatcher ( of ( appliedMatcher , context ( arg0 . apply ( " " ) ) ) ) ; } BaseSetting setting = new BaseSetting ( appliedMatcher ) ; setting . handler = configItem ( this . handler , arg0 ) ; setting . eventTriggers = configItems ( eventTriggers , arg0 ) ; return setting ; }
private Predicate < Map . Entry < String , String > > function ( final String arg0 ) { return new Predicate < Map . Entry < String , String > > ( ) { @Override
@Test void function ( ) { boolean threw = false ; try { Jsoup . connect ( " jsoup.org/test " ) ; } catch ( IllegalArgumentException e ) { threw = true ; assertEquals ( " The supplied URL, 'jsoup.org/test', is malformed. Make sure it is an absolute URL, and starts with 'http://' or 'https://'. " , e . getMessage ( ) ) ; } assertTrue ( threw ) ; }
MocoRunnerWatcher function ( final FileRunner arg0 , final File . . . arg1 ) ; }
public WebSocketImpl function ( WebSocketAdapter arg0 , Draft arg1 , SocketChannel arg2 ) { if ( sslContext ! = null ) try { SSLEngine e = sslContext . createSSLEngine ( ) ; e . setUseClientMode ( false ) ; return new WebSocketImpl ( arg0 , arg1 , new SSLSocketChannel ( arg2 , e ) ) ; } catch ( Exception e1 ) { } return new WebSocketImpl ( arg0 , arg1 , arg2 ) ; }
public MocoEventAction function ( ) { Optional < ContentResource > postContent = postContent ( ) ; if ( postContent . isPresent ( ) ) { return post ( this . url . asResource ( ) , postContent . get ( ) ) ; } throw new IllegalArgumentException ( " content or json should be setup for post event " ) ; }
public final RequestMatcher function ( final MocoConfig arg0 ) { if ( arg0 . isFor ( resource . id ( ) ) ) { return newAppliedMatcher ( resource . apply ( arg0 ) ) ; } return this ; }
public LoggingEventBuilder function ( Supplier < Object > arg0 ) { loggingEvent . addArgument ( arg0 . get ( ) ) ; return this ; }
public static BootstrapTask function ( final String arg0 ) { return new StartTask ( arg0 , new SocketArgsParser ( ) ) ; }
public ResponseHandler function ( final MocoConfig arg0 ) { return and ( StreamSupport . stream ( handlers . spliterator ( ) , false ) . map ( handler - > handler . apply ( arg0 ) )
public static Test function ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( UtilTest . class ) ; suite . addTestSuite ( ProfilerTest . class ) ; return suite ; }
public void function ( ) throws Exception { webSocketServer . connected ( " hello " ) ; running ( server , ( ) - > { new Endpoint ( new URI ( " ws://localhost:12306/unknown/ " ) ) ;
private ImmutableList < Session > function ( final File arg0 ) { try { List < Session > sessions = Jsons . toObject ( new FileInputStream ( arg0 ) , new TypeReference < List < Session > > ( ) { } ) ;
@Test public void function ( ) { Document doc = Jsoup . parse ( " <html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body></html> " ) ; assertEquals ( " <html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html> " , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.6.9 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
public void function ( ) throws Exception { ID3v2PictureFrameData frameData = new ID3v2PictureFrameData ( false , TEST_MIME_TYPE , ( byte ) 3 , new EncodedText ( EncodedText . TEXT_ENCODING_UTF_16 , TEST_DESCRIPTION_UNICODE ) , DUMMY_IMAGE_DATA ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 0x01 , 'm' , 'i' , 'm' , 'e' , '/' , 't' , 'y' , 'p' , 'e' , 0 , 0x03 , ( byte ) 0xff , ( byte ) 0xfe , ( byte ) 0xb3 , 0x03 , ( byte ) 0xb5 , 0x03 , ( byte ) 0xb9 , 0x03 , ( byte ) 0xac , 0x03 , 0 , 0 , 1 , 2 , 3 , 4 , 5 } ; assertArrayEquals ( expectedBytes , bytes ) ; ID3v2PictureFrameData frameDataCopy = new ID3v2PictureFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
public void function ( final String arg0 ) { clearMessage ( ) ; this . userSession . getAsyncRemote ( ) . sendText ( arg0 ) ; }
public void function ( ) throws Exception { server . response ( binary ( ( request ) - > new ByteArrayInputStream ( new byte [ ] { 1 , 2 , 3 } ) ) ) ; running ( server , ( ) - > { byte [ ] asBytes = helper . getAsBytes ( root ( ) ) ;
private SocketServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { int port = arg1 . getPort ( ) . orElse ( 0 ) ; SocketServer socketServer = null ; if ( arg1 . isQuiet ( ) ) { socketServer = ActualSocketServer . createQuietServer ( port ) ; } else { socketServer = ActualSocketServer . createLogServer ( port ) ; } for ( RunnerSetting setting : arg0 ) { SocketServer parsedServer = socketParser . parseServer ( setting . getStreams ( ) , port , arg1 . isQuiet ( ) , toConfigs ( setting ) ) ; socketServer = mergeServer ( socketServer , parsedServer ) ; } return socketServer ; }
public final void function ( final String arg0 , final int arg1 , final ChannelHandler arg2 ) { EventLoopGroup group = new NioEventLoopGroup ( ) ; Bootstrap bootstrap = new Bootstrap ( ) ; bootstrap . group ( group ) . channel ( NioSocketChannel . class ) . remoteAddress ( arg0 , arg1 ) . option ( ChannelOption . TCP_NODELAY , true ) . handler ( arg2 ) ; try { Channel channel = bootstrap . connect ( ) . sync ( ) . channel ( ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.9 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ServerHandshake arg0 ) { countDownLatchConnect . countDown ( ) ; }
public final ResponseHandler function ( final MocoConfig < ? > arg0 ) { return this ; }
public void function ( ) throws Exception { assertThat ( helper . get ( root ( ) ) , is ( " foo.response " ) ) ; }
public void function ( ) throws IOException { String json = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) . getFirstHeader ( " content-type " ) . getValue ( ) ; assertThat ( json , is ( " application/json " ) ) ; String bar = Request . Get ( root ( ) ) . execute ( ) . returnResponse ( ) . getFirstHeader ( " foo " ) . getValue ( ) ; assertThat ( bar , is ( " bar " ) ) ; }
private static Resource function ( final String arg0 , final FileContainer arg1 ) { Optional < Charset > charset = arg1 . getCharset ( ) ; String text = arg1 . getName ( ) . getText ( ) ; return asResource ( arg0 , text ( text ) , charset ) ; }
public Elements function ( ) { for ( Element element : this ) { element . empty ( ) ; } return this ; }
void function ( Appendable arg0 , int arg1 , Document . OutputSettings arg2 ) throws IOException { if ( siblingIndex > 0 & & arg2 . prettyPrint ( ) ) arg0 . append ( '\n' ) ; if ( arg2 . syntax ( ) = = Syntax . html & & ! has ( PUBLIC_ID ) & & ! has ( SYSTEM_ID ) ) { arg0 . append ( " <!doctype " ) ; } else { arg0 . append ( " <!DOCTYPE " ) ; } if ( has ( NAME ) ) arg0 . append ( "   " ) . append ( attr ( NAME ) ) ; if ( has ( PUB_SYS_KEY ) ) arg0 . append ( "   " ) . append ( attr ( PUB_SYS_KEY ) ) ; if ( has ( PUBLIC_ID ) ) arg0 . append ( "   \" " ) . append ( attr ( PUBLIC_ID ) ) . append ( '"' ) ; if ( has ( SYSTEM_ID ) ) arg0 . append ( "   \" " ) . append ( attr ( SYSTEM_ID ) ) . append ( '"' ) ; arg0 . append ( '>' ) ; }
public void function ( Marker arg0 , String arg1 , int arg2 , String arg3 , Throwable arg4 ) { Level julLevel ; switch ( arg2 ) { case LocationAwareLogger . TRACE_INT : julLevel = Level . FINEST ; break ; case LocationAwareLogger . DEBUG_INT : julLevel = Level . FINE ; break ; case LocationAwareLogger . INFO_INT : julLevel = Level . INFO ; break ; case LocationAwareLogger . WARN_INT : julLevel = Level . WARNING ; break ; case LocationAwareLogger . ERROR_INT : julLevel = Level . SEVERE ; break ; default : throw new IllegalStateException ( " Level number  " + arg2 + "  is not recognized. " ) ; } log ( arg1 , julLevel , arg3 , arg4 ) ; }
public static MocoJunitRunner function ( final int arg0 , final Resource arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; checkNotNull ( arg1 , " File should not be null " ) ; return new MocoJunitRunner ( runner ( jsonHttpServer ( arg0 , arg1 ) ) ) ; }
protected void function ( ) { try { Thread . sleep ( FileMonitor . INTERVAL * 2 ) ;
private ElementList function ( ) { tq . consumeWhitespace ( ) ; while ( ! tq . isEmpty ( ) ) { if ( tq . matchChomp ( " # " ) ) { byId ( ) ; } else if ( tq . matchChomp ( " . " ) ) { byClass ( ) ; } else if ( tq . matchesWord ( ) ) { byTag ( ) ; } else if ( tq . matchChomp ( " [ " ) ) { byAttribute ( ) ; } else { throw new SelectorParseException ( " Could not parse query  " + query ) ; } } return elements ; }
public void function ( ) { ID3Wrapper wrapper = new ID3Wrapper ( null , null ) ; wrapper . clearCopyright ( ) ; }
public static void function ( ) { LogManager . getLogManager ( ) . getLogger ( " " ) . addHandler ( new SLF4JBridgeHandler ( ) ) ;
public static List < Node > function ( String arg0 , Element arg1 , String arg2 ) { HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder ( ) ; return treeBuilder . parseFragment ( arg0 , arg1 , arg2 , ParseErrorList . noTracking ( ) ) ; }
public void function ( ) throws Exception { server . response ( content ( text ( " foo " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws IOException { assertThat ( helper . get ( root ( ) ) , is ( " foo " ) ) ; changeFileContent ( response , " bar " ) ; assertThat ( helper . get ( root ( ) ) , is ( " bar " ) ) ; }
public void function ( ) { assertTrue ( comp . contains ( comp ) ) ; assertTrue ( comp . contains ( blue ) ) ; }
public byte [ ] function ( final Optional < ? extends Request > arg0 ) { try { return toByteArray ( this . getClass ( ) . getClassLoader ( ) . getResourceAsStream ( filename ) ) ;
public void function ( ) throws IOException { Connection con = Jsoup . connect ( " http://direct.infohound.net/tools/302-rel.pl " ) ; Document doc = con . post ( ) ; assertTrue ( doc . title ( ) . contains ( " HTML Tidy Online " ) ) ; }
private void function ( ) { StringBuilder textAccum = new StringBuilder ( ) ; while ( ! tq . matches ( " < " ) & & ! tq . isEmpty ( ) ) { textAccum . append ( tq . consume ( ) ) ; } TextNode textNode = TextNode . createFromEncoded ( textAccum . toString ( ) ) ; last ( ) . addChild ( textNode ) ; }
private static Stream < File > function ( ) { File [ ] files = FuzzFixesIT . testDir . listFiles ( ) ; assertNotNull ( files ) ; assertTrue ( files . length > 10 ) ; return Stream . of ( files ) ; }
public Watcher function ( final File arg0 , final Iterable < File > arg1 , final FileRunner arg2 ) { ImmutableList < File > files = ImmutableList . < File > builder ( ) . add ( arg0 ) . addAll ( arg1 ) . build ( ) ; return factory . createWatcher ( listener ( arg2 ) , files . toArray ( new File [ 0 ] ) ) ; }
public void function ( Object arg0 ) { logger . log ( null , FQCN , LocationAwareLogger . ERROR_INT , String . valueOf ( arg0 ) , null ) ;
public void function ( ) { Document doc = Jsoup . parse ( " <title>Hello there</title> <div><p>Hello</p><p>there</p></div> <div>Another</div> " ) ; assertEquals ( " <title>Hello there</title> " , doc . select ( " title " ) . first ( ) . outerHtml ( ) ) ; assertEquals ( " <div> \ n <p>Hello</p> \ n <p>there</p> \ n</div> " , doc . select ( " div " ) . first ( ) . outerHtml ( ) ) ; assertEquals ( " <div> \ n <p>Hello</p> \ n <p>there</p> \ n</div>  \ n<div> \ n Another \ n</div> " , doc . select ( " body " ) . first ( ) . html ( ) ) ; }
public void function ( Logger arg0 , LogRecord arg1 ) { int julLevelValue = arg1 . getLevel ( ) . intValue ( ) ; if ( julLevelValue < = TRACE_LEVEL_THRESHOLD ) { arg0 . trace ( arg1 . getMessage ( ) , arg1 . getThrown ( ) ) ;
public static String function ( Collection arg0 , String arg1 ) { return join ( arg0 . iterator ( ) , arg1 ) ; }
public int function ( ByteBuffer arg0 ) throws IOException { if ( ! isHandShakeComplete ( ) ) { processHandshake ( ) ; return 0 ; } int num = socketChannel . write ( wrap ( arg0 ) ) ; if ( writeEngineResult . getStatus ( ) = = SSLEngineResult . Status . CLOSED ) { throw new EOFException ( " Connection is closed " ) ; } return num ;
public static byte [ ] function ( String arg0 ) { try { return arg0 . getBytes ( " UTF8 " ) ;
public void function ( ) throws Exception { Draft_6455 draft_6455 = new Draft_6455 ( ) ; TextFrame curframe = new TextFrame ( ) ; curframe . setPayload ( ByteBuffer . wrap ( Charsetfunctions . utf8Bytes ( " Test0 " ) ) ) ; curframe . setTransferemasked ( false ) ; List < Framedata > createdFrame = draft_6455 . createFrames ( " Test0 " , false ) ; assertEquals ( 1 , createdFrame . size ( ) ) ; assertEquals ( curframe , createdFrame . get ( 0 ) ) ; curframe = new TextFrame ( ) ; curframe . setPayload ( ByteBuffer . wrap ( Charsetfunctions . utf8Bytes ( " Test0 " ) ) ) ; curframe . setTransferemasked ( true ) ; createdFrame = draft_6455 . createFrames ( " Test0 " , true ) ; assertEquals ( 1 , createdFrame . size ( ) ) ; assertEquals ( curframe , createdFrame . get ( 0 ) ) ; }
public void function ( ) throws Exception { server . request ( exist ( xpath ( " /request/parameters/id/text() " ) ) ) . response ( " foo " ) ; running ( server , ( ) - > assertThat ( helper . postFile ( root ( ) , " foo.xml " ) , is ( " foo " ) ) ) ; }
private void function ( int arg0 , boolean arg1 ) throws IOException , UnsupportedTagException , InvalidDataException { if ( arg0 < MINIMUM_BUFFER_LENGTH + 1 ) throw new IllegalArgumentException ( " Buffer too small " ) ; this . arg0 = arg0 ; this . arg1 = arg1 ; try ( SeekableByteChannel seekableByteChannel = Files . newByteChannel ( path , StandardOpenOption . READ ) ) { initId3v1Tag ( seekableByteChannel ) ;
public void function ( ) { ID3v1 id3v1Tag = new ID3v1TagForTesting ( ) ; ID3v2 id3v2Tag = new ID3v2TagForTesting ( ) ; ID3Wrapper wrapper = new ID3Wrapper ( id3v1Tag , id3v2Tag ) ; wrapper . setYear ( " a year " ) ; assertEquals ( " a year " , id3v1Tag . getYear ( ) ) ; assertEquals ( " a year " , id3v2Tag . getYear ( ) ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { Token . Doctype d = arg0 . asDoctype ( ) ; DocumentType doctype = new DocumentType ( arg1 . settings . normalizeTag ( d . getName ( ) ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) ) ; doctype . setPubSysKey ( d . getPubSysKey ( ) ) ; arg1 . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) arg1 . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ; arg1 . transition ( BeforeHtml ) ; } else { arg1 . transition ( BeforeHtml ) ; return arg1 . process ( arg0 ) ; } return true ; }
public void function ( ) throws Exception { byte [ ] buffer = BufferTools . stringToByteBuffer ( VALID_TAG , 0 , VALID_TAG . length ( ) ) ; buffer [ buffer . length - 3 ] = 0x00 ; buffer [ buffer . length - 2 ] = 0x01 ; buffer [ buffer . length - 1 ] = 0x0D ; ID3v1Tag id3v1tag = new ID3v1Tag ( buffer ) ; assertEquals ( " TITLE1234567890123456789012345 " , id3v1tag . getTitle ( ) ) ; assertEquals ( " ARTIST123456789012345678901234 " , id3v1tag . getArtist ( ) ) ; assertEquals ( " ALBUM1234567890123456789012345 " , id3v1tag . getAlbum ( ) ) ; assertEquals ( " 2001 " , id3v1tag . getYear ( ) ) ; assertEquals ( " COMMENT123456789012345678901 " , id3v1tag . getComment ( ) ) ; assertEquals ( " 1 " , id3v1tag . getTrack ( ) ) ; assertEquals ( 0x0d , id3v1tag . getGenre ( ) ) ; assertEquals ( " Pop " , id3v1tag . getGenreDescription ( ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.9.4 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { server . request ( eq ( xpath ( " /request/parameters/id/text() " ) , " 1 " ) ) . response ( " foo " ) ; server . request ( eq ( xpath ( " /request/parameters/id/text() " ) , " 2 " ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
private void function ( SelectionKey arg0 , WebSocket arg1 , IOException arg2 ) { if ( arg1 ! = null ) { arg1 . closeConnection ( CloseFrame . ABNORMAL_CLOSE , arg2 . getMessage ( ) ) ;
private static void function ( StringBuilder arg0 , long [ ] arg1 ) { arg0 . append ( '[' ) ; final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { arg0 . append ( arg1 [ i ] ) ; if ( i ! = len - 1 ) arg0 . append ( " ,  " ) ; } arg0 . append ( ']' ) ; }
private void function ( File arg0 ) { if ( arg0 . isDirectory ( ) ) { pl . onDirectory ( arg0 ) ;
public Element function ( String arg0 ) { Validate . notNull ( arg0 ) ; TextNode node = new TextNode ( arg0 ) ; prependChild ( node ) ; return this ; }
public Document function ( arg0 . arg1 . arg2 . Document arg3 ) { Validate . notNull ( arg3 ) ; DocumentBuilder builder ; try {
public void function ( ) throws Exception { HttpServer mergedServer = ( ( ActualHttpServer ) anotherServer ) . mergeServer ( ( ActualHttpServer ) httpServer ) ; running ( mergedServer , ( ) - > assertThat ( helper . get ( remoteUrl ( " /foo/anything " ) ) , is ( " foo " ) ) ) ; }
protected MessageContent function ( final HttpRequest arg0 ) { FileResourceReader reader = new FileResourceReader ( asResource ( arg0 ) ) ; return reader . readFor ( arg0 ) ; }
public boolean function ( String arg0 ) { String [ ] requestedExtensions = arg0 . split ( " , " ) ; for ( String extension : requestedExtensions ) { ExtensionRequestData extensionData = ExtensionRequestData . parseExtensionRequest ( extension ) ; if ( ! EXTENSION_REGISTERED_NAME . equalsIgnoreCase ( extensionData . getExtensionName ( ) ) ) continue ; Map < String , String > headers = extensionData . getExtensionParameters ( ) ; requestedParameters . putAll ( headers ) ; return true ; } return false ; }
public void function ( final SessionContext arg0 ) { arg0 . getHttpResponse ( ) . setStatus ( status . code ( ) ) ; }
public void function ( Exception arg0 ) { Assert . fail ( arg0 . toString ( ) + "  should not occur " ) ; }
public boolean function ( Marker arg0 ) { return logger . isDebugEnabled ( arg0 ) ; }
private Predicate < Path > function ( final Path arg0 ) { return new Predicate < Path > ( ) { @Override
public final void function ( WebSocket arg0 , String arg1 ) { onMessage ( arg0 , arg1 ) ; }
boolean function ( String arg0 ) { int scanLength = arg0 . length ( ) ; if ( scanLength > length - pos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset + + ) if ( arg0 . charAt ( offset ) ! = input [ pos + offset ] ) return false ; return true ; }
public void function ( String arg0 ) { Map < String , String > map = ( Map < String , String > ) inheritableThreadLocal . get ( ) ; if ( map ! = null ) { map . remove ( arg0 ) ;
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /get_event_with_header " ) ) , is ( " get_foo_with_header " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( Files . toString ( file , Charset . defaultCharset ( ) ) , containsString ( " 0XMOCOHEADER " ) ) ; }
public void function ( ) { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false ) ; assertEquals ( " ID3v2ChapterFrameData [id=null, startTime=0, endTime=0, startOffset=0, endOffset=0, subframes=[]] " ,
public boolean function ( final String arg0 ) { return TAPE . equalsIgnoreCase ( arg0 ) ; }
@Test public void function ( ) { StringBuilder builder = new StringBuilder ( ) ; while ( builder . length ( ) < maxBufferLen * 4 ) builder . append ( " Lorem ipsum dolor sit amet, consectetur adipiscing elit. " ) ; String content = builder . toString ( ) ; CharacterReader reader = new CharacterReader ( content ) ; reader . trackNewlines ( true ) ; assertEquals ( " 1:1 " , reader . cursorPos ( ) ) ; while ( ! reader . isEmpty ( ) ) reader . consume ( ) ; assertEquals ( 131096 , reader . pos ( ) ) ; assertEquals ( reader . pos ( ) + 1 , reader . columnNumber ( ) ) ; assertEquals ( 1 , reader . lineNumber ( ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( header ( " foo " , template ( " ${req.method} " ) ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) throws Exception { server . proxy ( from ( " /proxy " ) . to ( remoteUrl ( " /target " ) ) ) ; running ( server , new Runnable ( ) { @Override
public Setting function ( RequestMatcher arg0 ) { return requestByHttpMethod ( HttpMethod . PUT , arg0 ) ; }
public MessageContent function ( JsonParser arg0 , DeserializationContext arg1 ) throws IOException , JsonProcessingException { return content ( ) . withContent ( arg0 . getText ( ) ) . build ( ) ; }
public void function ( ) { final Document docNoCharset = Document . createShell ( " " ) ; docNoCharset . updateMetaCharsetElement ( true ) ; docNoCharset . charset ( Charset . forName ( charsetUtf8 ) ) ; assertEquals ( charsetUtf8 , docNoCharset . select ( " meta[charset] " ) . first ( ) . attr ( " charset " ) ) ; final String htmlCharsetUTF8 = " <html> \ n " + "  <head> \ n " + "   <meta charset= \" " + charsetUtf8 + " \" > \ n " + "  </head> \ n " + "  <body></body> \ n " + " </html> " ; assertEquals ( htmlCharsetUTF8 , docNoCharset . toString ( ) ) ; }
public static Document function ( Path arg0 , arg1 String arg2 , String arg3 , Parser arg4 ) throws IOException { return parseInputStream ( openStream ( arg0 ) , arg2 , arg3 , arg4 ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 ) { delegate ( ) . debug ( arg0 , arg1 , arg2 ) ; }
public void function ( Exception arg0 ) { fail ( " There should not be an exception " ) ; }
public static RecorderConfigurations function ( final Iterable < RecorderConfig > arg0 ) { RecorderConfigurations configurations = new RecorderConfigurations ( ) ; for ( RecorderConfig config : arg0 ) { if ( config . isFor ( RecorderConfig . GROUP ) ) { configurations . group = ( RecorderGroup ) config ; } else if ( config . isFor ( RecorderConfig . TAPE ) ) { configurations . tape = ( RecorderTape ) config ; } else if ( config . isFor ( RecorderConfig . IDENTIFIER ) ) { configurations . identifier = ( RecorderIdentifier ) config ; } else if ( config . isFor ( RecorderConfig . MODIFIER ) ) { configurations . modifier = ( RecorderModifier ) config ; } else { throw new IllegalArgumentException ( " Unknown recorder config: " + config ) ; } } return configurations ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
boolean function ( String arg0 ) { int scanLength = arg0 . length ( ) ; if ( scanLength > length - pos ) return false ; for ( int offset = 0 ; offset < scanLength ; offset + + ) { char upScan = Character . toUpperCase ( arg0 . charAt ( offset ) ) ; char upTarget = Character . toUpperCase ( input [ pos + offset ] ) ; if ( upScan ! = upTarget ) return false ; } return true ; }
protected Log function ( String arg0 ) throws LogConfigurationException { Log instance = null ; try { Object params [ ] = new Object [ 1 ] ;
public static < T > RequestMatcher function ( final RequestExtractor < T > arg0 , final String arg1 ) { return ApiUtils . startsWith ( checkNotNull ( arg0 , " Extractor should not be null " ) , text ( checkNotNullOrEmpty ( arg1 , " Expected resource should not be null " ) ) ) ;
public void function ( String arg0 ) { if ( logger . isLoggable ( Level . WARNING ) ) { log ( SELF , Level . WARNING , arg0 , null ) ;
public void function ( String arg0 ) { int i = indexOfKeyIgnoreCase ( arg0 ) ; if ( i ! = NotFound ) remove ( i ) ;
public static String function ( byte [ ] arg0 ) { return stringAscii ( arg0 , 0 , arg0 . length ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.7 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 11 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ) ;
public static RequestMatcher function ( final Resource arg0 ) { checkNotNull ( arg0 , " resource should not be null " ) ; return eq ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
public void function ( FullHttpRequest arg0 ) { this . requests . add ( arg0 ) ; }
boolean function ( Token arg0 , TreeBuilder arg1 ) { if ( arg0 . isCharacter ( ) ) { arg1 . insert ( arg0 . asCharacter ( ) ) ; } else if ( arg0 . isEOF ( ) ) { arg1 . error ( this ) ; arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; return arg1 . process ( arg0 ) ; } else if ( arg0 . isEndTag ( ) ) { arg1 . pop ( ) ; arg1 . transition ( arg1 . originalState ( ) ) ; } return true ; }
public boolean function ( DefaultHttpRequest arg0 ) { return super . match ( arg0 ) & & doMatch ( method , arg0 . method ) & & doMatch ( queries , arg0 . queries ) ;
public void function ( ) throws Exception { server . response ( cors ( allowOrigin ( " https://www.github.com/ " ) ) ) ; running ( server , ( ) - > { ClassicHttpResponse response = helper . getResponseWithHeader ( root ( ) , of ( " Origin " , " https://www.github.com/ " ) ) ;
private void function ( ) { tq . consume ( " :has " ) ; String subQuery = tq . chompBalanced ( '(' , ')' ) ; Validate . notEmpty ( subQuery , " :has(el) subselect must not be empty " ) ;
public static void function ( String [ ] arg0 ) { int port = 88 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ChatServer s = new ChatServer ( port ) ; s . start ( ) ; System . out . println ( " ChatServer started on port:  " + s . getPort ( ) ) ; }
public void function ( WebSocket arg0 ) { try { this . sendToAll ( arg0 + "  entered the room! " ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; } System . out . println ( arg0 + "  entered the room! " ) ; }
public void function ( String arg0 , Object . . . arg1 ) { formatAndLog ( Log . ERROR , arg0 , arg1 ) ; }
public RestSetting function ( final ResponseHandler arg0 , final ResponseHandler . . . arg1 ) { return createSetting ( Optional . fromNullable ( matcher ) , and ( checkNotNull ( arg0 , " Post response handler should not be null " ) ,
public T function ( String arg0 ) { headers . remove ( arg0 ) ; return ( T ) this ; }
public void function ( WebSocket arg0 , ByteBuffer arg1 ) { throw new OutOfMemoryError ( " Some intentional error " ) ; }
public ImmutableMap < String , String > function ( ) { Optional < ImmutableMap < String , String > > forms = new FormsRequestExtractor ( ) . extract ( DefaultHttpRequest . this ) ; return forms . orElseGet ( emptyMapSupplier ( ) ) ; }
public void function ( Object arg0 , Throwable arg1 ) { innerLog ( null , CATEGORY_FQCN , LocationAwareLogger . DEBUG_INT , arg0 , arg1 ) ; }
public void function ( ) { HttpRequest request = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Cookie " , " loggedIn=true " , " Host " , " localhost:12306 " ) ) . build ( ) ; HttpRequest failover = DefaultHttpRequest . builder ( ) . withUri ( " /uri " ) . withVersion ( HttpProtocolVersion . VERSION_1_1 ) . withMethod ( " POST " ) . withContent ( " proxy " ) . withHeaders ( of ( " Host " , " localhost:12306 " ) ) . build ( ) ; assertThat ( new HttpRequestFailoverMatcher ( failover ) . match ( request ) , is ( true ) ) ; }
public void function ( MocoConfig arg0 ) { if ( arg0 . isFor ( " uri " ) ) { this . extractor = new MountPathExtractor ( target . apply ( arg0 ) ) ;
void function ( Tokeniser arg0 , CharacterReader arg1 ) { if ( arg1 . matchesLetter ( ) ) { String name = arg1 . consumeLetterSequence ( ) ; arg0 . dataBuffer . append ( name . toLowerCase ( ) ) ; arg0 . emit ( name ) ; return ; } char c = arg1 . consume ( ) ; switch ( c ) { case '\t' :
public Node function ( ) { if ( parentNode = = null ) return null ; List < Node > siblings = parentNode . childNodes ; Integer index = siblingIndex ( ) ; Validate . notNull ( index ) ; if ( siblings . size ( ) > index + 1 ) return siblings . get ( index + 1 ) ;
private void function ( Element arg0 ) { List < Node > toMove = new ArrayList < Node > ( ) ; for ( Node node : arg0 . childNodes ) { if ( node instanceof TextNode ) { TextNode tn = ( TextNode ) node ; if ( ! tn . isBlank ( ) ) toMove . add ( tn ) ; } } for ( int i = toMove . size ( ) - 1 ; i > = 0 ; i - - ) { Node node = toMove . get ( i ) ;
public int [ ] function ( ) { ProfilerRegistry profilerRegistry = ProfilerRegistry . getThreadContextInstance ( ) ; Profiler sortProfiler = profilerRegistry . get ( NESTED_PROFILER_NAME ) ; sortProfiler . start ( " SORT " ) ; int [ ] sortedArray = sort ( ) ; sortProfiler . start ( " PRUNE_COMPOSITES " ) ; int result [ ] = pruneComposites ( sortedArray ) ; return result ; }
public Iterator < Element > function ( ) { return it ; }
public Element function ( arg0 . arg1 . arg2 . Consumer < ? super Element > arg3 ) { Validate . notNull ( arg3 ) ; NodeTraversor . traverse ( ( node , depth ) - > { if ( node instanceof Element ) arg3 . accept ( ( Element ) node ) ; } , this ) ; return this ; }
public void function ( ) { Assert . assertArrayEquals ( new byte [ ] { 102 , 111 , 111 , 66 , 97 , 114 } , Charsetfunctions . utf8Bytes ( " fooBar " ) ) ;
public void function ( ) { Marker parent = factory . getMarker ( PARENT_MARKER_STR ) ; Marker child = factory . getMarker ( CHILD_MARKER_STR ) ; for ( int i = 0 ; i < 10 ; i + + ) { parent . add ( child ) ; } Iterator < Marker > iterator = parent . iterator ( ) ; assertTrue ( iterator . hasNext ( ) ) ; assertEquals ( CHILD_MARKER_STR , iterator . next ( ) . toString ( ) ) ; assertFalse ( iterator . hasNext ( ) ) ; }
public void function ( String arg0 , String arg1 ) { if ( headers = = null ) { headers = new TreeMap < > ( String . CASE_INSENSITIVE_ORDER ) ; } headers . put ( arg0 , arg1 ) ; }
public void function ( ) throws Exception { server . request ( by ( version ( " HTTP/1.0 " ) ) ) . response ( " foo " ) ; running ( server , new Runnable ( ) { @Override
public void function ( ) { int LEN = 1000 * 1000 * 10 ; debugLoop ( LEN ) ; double avg = debugLoop ( LEN ) ; long referencePerf = 93 ; BogoPerf . assertDuration ( avg , referencePerf , REFERENCE_BIPS ) ;
public static String function ( final String arg0 , final String arg1 , final String . . . arg2 ) { String finalPath = actualJoin ( arg0 , arg1 ) ; return Arrays . stream ( arg2 ) . reduce ( finalPath , Files : : actualJoin , Files : : actualJoin ) ;
@Test void function ( ) { String xml = " <body style= \" color: red \"   \"  name \" ><div = \" \" ></div></body> " ; Document doc = Jsoup . parse ( xml , Parser . xmlParser ( ) ) ; assertEquals ( Syntax . xml , doc . outputSettings ( ) . syntax ( ) ) ; String out = doc . html ( ) ; assertEquals ( " <body style= \" color: red \"  name= \" \" ><div></div></body> " , out ) ; }
protected RestSettingBuilder function ( ) { return MocoRest . head ( id ( ) ) ; }
public String function ( ) { StringBuilder accum = new StringBuilder ( ) ; html ( accum ) ; return accum . toString ( ) ; }
public void function ( Marker arg0 , String arg1 , Throwable arg2 ) { if ( ! logger . isInfoEnabled ( ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn ,
public void function ( ) throws Exception { server . request ( and ( by ( " foo " ) , by ( uri ( " /foo " ) ) ) ) . response ( text ( " bar " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( byte [ ] arg0 , int arg1 , int arg2 ) throws java . io . IOException { if ( suspendEncoding ) { this . out . write ( arg0 , arg1 , arg2 ) ; return ; } for ( int i = 0 ; i < arg2 ; i + + ) { write ( arg0 [ arg1 + i ] ) ;
public Watcher function ( final File arg0 ) { return create ( listener , arg0 ) ; }
private ContentResource function ( ) { if ( this . text ! = null ) { return Moco . text ( text ) ; } if ( this . file ! = null ) { return Moco . file ( file ) ; } throw new IllegalArgumentException ( " Content is required for broadcast setting " ) ; }
public final Attributes function ( ) { ensureAttributes ( ) ; return ( Attributes ) value ; }
public void function ( LoggingEvent arg0 ) { int levelInt = arg0 . getLevel ( ) . toInt ( ) ; if ( ! isLevelEnabled ( levelInt ) ) { return ; } NormalizedParameters np = NormalizedParameters . normalize ( arg0 ) ; innerHandleNormalizedLoggingCall ( arg0 . getLevel ( ) , arg0 . getMarkers ( ) , np . getMessage ( ) , np . getArguments ( ) , arg0 . getThrowable ( ) ) ; }
public void function ( ) throws Exception { LoggerFactoryFriend . reset ( ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.22 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
private Predicate < Cookie > function ( final String arg0 ) { return new Predicate < Cookie > ( ) { @Override
public void function ( ) throws IOException { byte [ ] src = new byte [ ] { 113 , 42 , 123 , 99 , 10 , - 33 , 75 , 30 , 88 , 99 , 113 , 42 , 123 , 99 , 10 , - 33 , 75 , 31 , 88 , 99 , 113 , 42 , 123 , 99 , 10 , - 33 , 75 , 32 , 88 , 99 , 113 , 42 , 123 , 99 , 10 , - 33 , 75 , 33 , 88 , 99 , 113 , 42 , 123 , 99 , 10 , - 33 , 75 , 34 , 88 , 99 , 113 , 42 , 123 , 99 , 10 , - 33 , 75 , 35 , 88 , 99 , 55 , 60 } ; byte [ ] excepted = new byte [ ] { 99 , 83 , 112 , 55 , 89 , 119 , 114 , 102 , 83 , 120 , 53 , 89 , 89 , 51 , 69 , 113 , 101 , 50 , 77 , 75 , 51 , 48 , 115 , 102 , 87 , 71 , 78 , 120 , 75 , 110 , 116 , 106 , 67 , 116 , 57 , 76 , 73 , 70 , 104 , 106 , 99 , 83 , 112 , 55 , 89 , 119 , 114 , 102 , 83 , 121 , 70 , 89 , 89 , 51 , 69 , 113 , 101 , 50 , 77 , 75 , 51 , 48 , 115 , 105 , 87 , 71 , 78 , 120 , 75 , 110 , 116 , 106 , 67 , 116 , 57 , 76 , 10 , 73 , 49 , 104 , 106 , 78 , 122 , 119 , 61 } ; Assert . assertArrayEquals ( excepted , Base64 . encodeBytesToBytes ( src , 0 , 62 , 8 ) ) ; }
public void function ( ) throws Exception { webSocketServer . connected ( " hello " ) ; assertThrows ( RuntimeException . class , ( ) - > running ( server , ( ) - > new Endpoint ( new URI ( " ws://localhost:12306/unknown/ " ) ) ) ) ;
public void function ( String arg0 ) { if ( logger . isLoggable ( Level . WARNING ) ) { log ( SELF , Level . WARNING , arg0 , null ) ;
private static boolean function ( String arg0 ) { if ( arg0 = = null ) return false ; if ( arg0 . contains ( " org/slf4j/impl/StaticLoggerBinder " ) ) return true ; if ( arg0 . contains ( " org.slf4j.impl.StaticLoggerBinder " ) ) return true ; return false ; }
public boolean function ( Element arg0 , Element arg1 ) { for ( Element e : arg1 . getAllElements ( ) ) { if ( e ! = arg1 & & evaluator . matches ( arg1 , e ) ) return true ; } return false ; }
public static ControllableInputStream function ( arg0 InputStream arg1 , int arg2 ) { if ( arg1 instanceof ControllableInputStream ) return ( ControllableInputStream ) arg1 ;
private boolean function ( final Header arg0 ) { return ! IGNORED_RESPONSE_HEADERS . contains ( arg0 . getName ( ) ) ; }
public void function ( int arg0 ) throws InterruptedException { stop ( arg0 , " " ) ; }
public void function ( ) { PerMessageDeflateExtension deflateExtension = new PerMessageDeflateExtension ( ) ; deflateExtension . setThreshold ( 11 ) ; String str = " Hello World " ; byte [ ] message = str . getBytes ( ) ; TextFrame frame = new TextFrame ( ) ; frame . setPayload ( ByteBuffer . wrap ( message ) ) ; deflateExtension . encodeFrame ( frame ) ; assertTrue ( frame . isRSV1 ( ) ) ; str = " Hello Worl " ; message = str . getBytes ( ) ; frame = new TextFrame ( ) ; frame . setPayload ( ByteBuffer . wrap ( message ) ) ; deflateExtension . encodeFrame ( frame ) ; assertFalse ( frame . isRSV1 ( ) ) ; }
public void function ( ) throws IOException { String url = " http://direct.infohound.net/tools/large.html " ; Connection . Response defaultRes = Jsoup . connect ( url ) . execute ( ) ; Connection . Response smallRes = Jsoup . connect ( url ) . maxBodySize ( 50 * 1024 ) . execute ( ) ; Connection . Response mediumRes = Jsoup . connect ( url ) . maxBodySize ( 200 * 1024 ) . execute ( ) ; Connection . Response largeRes = Jsoup . connect ( url ) . maxBodySize ( 300 * 1024 ) . execute ( ) ; Connection . Response unlimitedRes = Jsoup . connect ( url ) . maxBodySize ( 0 ) . execute ( ) ; int actualDocText = 269541 ; assertEquals ( actualDocText , defaultRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( 49165 , smallRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( 196577 , mediumRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( actualDocText , largeRes . parse ( ) . text ( ) . length ( ) ) ; assertEquals ( actualDocText , unlimitedRes . parse ( ) . text ( ) . length ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " template_with_function.json " ) ; String response = helper . get ( remoteUrl ( " /random_template_with_format " ) ) ; String target = Splitter . on ( '.' ) . splitToList ( response ) . get ( 1 ) ; assertThat ( target . length ( ) , is ( 6 ) ) ; }
private boolean function ( ArrayList < Element > arg0 , Element arg1 ) { for ( int pos = arg0 . size ( ) - 1 ; pos > = 0 ; pos - - ) { Element next = arg0 . get ( pos ) ; if ( next = = arg1 ) { return true ; } } return false ; }
public void function ( String arg0 , Throwable arg1 ) { logger . log ( FQCN , Level . INFO , arg0 , arg1 ) ; }
public void function ( ) throws Exception { JsonSupport . assertEquals ( " {code:1, message: \" message \" } " , helper . getResponse ( root ( ) ) ) ; }
public boolean function ( arg0 Object arg1 ) { if ( this = = arg1 ) return true ; if ( arg1 = = null | | getClass ( ) ! = arg1 . getClass ( ) ) return false ; Attribute attribute = ( Attribute ) arg1 ; if ( key ! = null ? ! key . equals ( attribute . key ) : attribute . key ! = null ) return false ; return val ! = null ? val . equals ( attribute . val ) : attribute . val = = null ; }
protected void function ( StringBuilder arg0 , int arg1 , Document . OutputSettings arg2 ) { arg0 . append ( " \ n " ) . append ( StringUtil . padding ( arg1 * arg2 . indentAmount ( ) ) ) ; }
@Override public void function ( RequestAuthenticator arg0 , HttpURLConnection arg1 ) { AuthenticationHandler authenticator = new AuthenticationHandler ( arg0 ) ; arg1 . setAuthenticator ( authenticator ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.15 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { Plain response1 = getResource ( " /targets/1 " ) ; assertThat ( response1 . code , is ( 1 ) ) ; assertThat ( response1 . message , is ( " hello " ) ) ; Plain response2 = getResource ( " /targets/2 " ) ; assertThat ( response2 . code , is ( 2 ) ) ; assertThat ( response2 . message , is ( " world " ) ) ; }
@Test public void function ( ) { String html = " <p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo " ; Parser parser = Parser . htmlParser ( ) . setTrackErrors ( 500 ) ; Document doc = Jsoup . parse ( html , " http://example.com " , parser ) ; List < ParseError > errors = parser . getErrors ( ) ; assertEquals ( 5 , errors . size ( ) ) ; assertEquals ( " 20: Attributes incorrectly present on end tag " , errors . get ( 0 ) . toString ( ) ) ; assertEquals ( " 35: Unexpected token [Doctype] when in state [InBody] " , errors . get ( 1 ) . toString ( ) ) ; assertEquals ( " 36: Invalid character reference: invalid named referenece 'arrgh' " , errors . get ( 2 ) . toString ( ) ) ; assertEquals ( " 50: Self closing flag not acknowledged " , errors . get ( 3 ) . toString ( ) ) ; assertEquals ( " 61: Unexpectedly reached end of file (EOF) in input state [TagName] " , errors . get ( 4 ) . toString ( ) ) ; }
public static void function ( String [ ] arg0 ) throws InterruptedException , IOException { WebSocket . DEBUG = true ; int port = 8887 ; try { port = Integer . parseInt ( arg0 [ 0 ] ) ; } catch ( Exception ex ) { } ChatServer s = new ChatServer ( port ) ; s . start ( ) ; System . out . println ( " ChatServer started on port:  " + s . getPort ( ) ) ; BufferedReader sysin = new BufferedReader ( new InputStreamReader ( System . in ) ) ; while ( true ) { String in = sysin . readLine ( ) ;
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${var} " , " var " , var ( ( request ) - > " TEMPLATE " ) ) ) ; running ( server , ( ) - > assertThat ( helper . get ( remoteUrl ( " /template " ) ) , is ( " TEMPLATE " ) ) ) ; }
public void function ( ) throws Exception { ID3v2ChapterFrameData frameData = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2TextFrameData subFrameData = new ID3v2TextFrameData ( false , new EncodedText ( " Hello there " ) ) ; frameData . addSubframe ( " TIT2 " , subFrameData ) ; byte [ ] bytes = frameData . toBytes ( ) ; byte [ ] expectedBytes = { 'c' , 'h' , '1' , 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , ( byte ) 0x7c , 0 , 0 , 0 , 3 , 0 , 0 , 1 , ( byte ) 0x90 , 'T' , 'I' , 'T' , '2' , 0 , 0 , 0 , ( byte ) 0xc , 0 , 0 , 0 , 'H' , 'e' , 'l' , 'l' , 'o' , ' ' , 't' , 'h' , 'e' , 'r' , 'e' } ; assertArrayEquals ( expectedBytes , bytes ) ; ID3v2ChapterFrameData frameDataCopy = new ID3v2ChapterFrameData ( false , bytes ) ; assertEquals ( frameData , frameDataCopy ) ; }
private boolean function ( ) { return this . pingpongs ! = null & & ! this . pingpongs . isEmpty ( ) ; }
private Predicate < PropertyDescriptor > function ( ) { return new Predicate < PropertyDescriptor > ( ) { @Override
public Connection function ( Connection . Response arg0 ) { res = arg0 ; return this ; }
public void function ( ) { WebsocketNotConnectedException websocketNotConnectedException = new WebsocketNotConnectedException ( ) ; assertNotNull ( websocketNotConnectedException ) ; }
public void function ( ) throws Exception { assertThat ( helper . get ( " http://localhost: " + server . port ( ) ) , is ( " foo " ) ) ; }
public boolean function ( Marker arg0 ) { if ( arg0 = = null ) { throw new IllegalArgumentException ( " Other cannot be null " ) ; } if ( this . equals ( arg0 ) ) { return true ; } if ( hasReferences ( ) ) { for ( int i = 0 ; i < refereceList . size ( ) ; i + + ) { Marker ref = ( Marker ) refereceList . get ( i ) ; if ( ref . contains ( arg0 ) ) { return true ; } } } return false ; }
private void function ( int arg0 ) { if ( childNodeSize ( ) = = 0 ) return ; final List < Node > childNodes = ensureChildNodes ( ) ; final int size = childNodes . size ( ) ; for ( int i = arg0 ; i < size ; i + + ) { childNodes . get ( i ) . setSiblingIndex ( i ) ;
public void function ( Object arg0 ) { differentiatedLog ( null , CATEGORY_FQCN , LocationAwareLogger . ERROR_INT , arg0 , null ) ;
public void function ( ) { String url = " http://direct.infohound.net/tools/404 " ; Connection con = Jsoup . connect ( url ) ; boolean threw = false ; try { Document doc = con . get ( ) ; } catch ( HttpStatusException e ) { threw = true ; assertEquals ( " org.jsoup.HttpStatusException: HTTP error fetching URL. Status=404, URL=http://direct.infohound.net/tools/404 " , e . toString ( ) ) ; assertEquals ( url , e . getUrl ( ) ) ; assertEquals ( 404 , e . getStatusCode ( ) ) ; } catch ( IOException e ) { } assertTrue ( threw ) ; }
public void function ( ) throws Exception { server . response ( url ( " http://www.github.com " ) ) ; running ( server , new Runnable ( ) { @Override
public static MocoConfig function ( final String arg0 ) { return new MocoContextConfig ( arg0 ) ; }
final public boolean function ( Marker arg0 ) { return false ; }
public void function ( ) throws Exception { server . request ( by ( file ( " src/test/resources/gbk.response " , Charset . forName ( " GBK " ) ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
@Test void function ( ) { String html = " <body><template id=1><table><tr><template id=2><td>One</td><td>Two</td></template></tr></template></body> " ; Document doc = Jsoup . parse ( html ) ; String want = " <html><head></head><body><template id= \" 1 \" ><table><tbody><tr><template id= \" 2 \" ><td>One</td><td>Two</td></template></tr></tbody></table></template></body></html> " ; assertEquals ( want , TextUtil . stripNewlines ( doc . html ( ) ) ) ; Element tmplTbl = doc . selectFirst ( " template#1 " ) ; Element tmplRow = doc . selectFirst ( " template#2 " ) ; assertNotNull ( tmplRow ) ; assertNotNull ( tmplTbl ) ; tmplRow . appendChild ( tmplRow . clone ( ) ) ; doc . select ( " template " ) . unwrap ( ) ; want = " <html><head></head><body><table><tbody><tr><td>One</td><td>Two</td><td>One</td><td>Two</td></tr></tbody></table></body></html> " ; assertEquals ( want , TextUtil . stripNewlines ( doc . html ( ) ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <h1>Hello <h2>There <hgroup><h1>Another<h2>headline</hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup> " ) ; assertEquals ( " <h1>Hello </h1><h2>There <hgroup><h1>Another</h1><h2>headline</h2></hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup></h2> " , TextUtil . stripNewlines ( doc . body ( ) . html ( ) ) ) ; }
private void function ( final String arg0 , final Object arg1 ) { this . headers . put ( arg0 , newValues ( arg0 , arg1 ) ) ; }
public static ResponseHandler function ( final ProxyConfig arg0 , final Failover arg1 ) { return new ProxyBatchResponseHandler ( checkNotNull ( arg0 ) , checkNotNull ( arg1 ) ) ; }
public boolean function ( String arg0 ) { return true ; }
public void function ( ) throws Exception { byte [ ] buffer = TestHelper . loadFile ( " src/test/resources/v23tagwithchapters.mp3 " ) ; ID3v2 id3tag = ID3v2TagFactory . createTag ( buffer ) ; ArrayList < ID3v2ChapterTOCFrameData > chapterTOCs = id3tag . getChapterTOC ( ) ; assertEquals ( 1 , chapterTOCs . size ( ) ) ; ID3v2ChapterTOCFrameData tocFrameData = chapterTOCs . get ( 0 ) ; assertEquals ( " toc1 " , tocFrameData . getId ( ) ) ; String expectedChildren [ ] = { " ch1 " , " ch2 " , " ch3 " } ; assertArrayEquals ( expectedChildren , tocFrameData . getChildren ( ) ) ; ArrayList < ID3v2Frame > subFrames = tocFrameData . getSubframes ( ) ; assertEquals ( 0 , subFrames . size ( ) ) ; }
public ResponseHandler function ( ResponseSetting arg0 ) { FluentIterable < ResponseHandler > handlers = from ( getFields ( arg0 . getClass ( ) ) ) . filter ( isValidField ( arg0 ) ) . transform ( fieldToResponseHandler ( arg0 ) ) ; return getResponseHandler ( handlers . toList ( ) ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 13 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " chat " ) ) ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; String header = Request . Get ( remoteUrl ( " /favicon.ico " ) ) . execute ( ) . returnResponse ( ) . getHeaders ( " Content-Type " ) [ 0 ] . getValue ( ) ; assertThat ( header , is ( " image/png " ) ) ; }
protected final ResponseHandler function ( ) { return configured ( this . handler ) ; }
public void function ( arg0 final File arg1 ) { File file = new File ( arg1 , " glob-absolute.json " ) ; String path = file . getAbsolutePath ( ) ; ImmutableList < String > files = Globs . glob ( path ) ; assertThat ( files . contains ( path ) , is ( true ) ) ; }
public void function ( ) throws Exception { server . request ( by ( uri ( " /template " ) ) ) . response ( template ( " ${var} " , " var " , " TEMPLATE " ) ) ; running ( server , new Runnable ( ) { @Override
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { trace ( arg1 , arg2 ) ; }
private int function ( ByteBuffer arg0 ) { if ( arg0 . remaining ( ) = = 0 ) { return 0 ; } int posBefore ; posBefore = arg0 . position ( ) ; if ( arg0 . remaining ( ) < = outAppData . remaining ( ) ) { outAppData . put ( arg0 ) ; } else { while ( arg0 . hasRemaining ( ) & & outAppData . hasRemaining ( ) ) { outAppData . put ( arg0 . get ( ) ) ; } } return arg0 . position ( ) - posBefore ; }
public void function ( ) { MocoHttpsServer server = new MocoHttpsServer ( createLogServer ( of ( port ( ) ) , MocoTestHelper . CERTIFICATE ) ) ; server . stop ( ) ; }
public Optional < String > function ( HttpRequest arg0 ) { return fromNullable ( arg0 . getQueries ( ) . get ( this . param ) ) ; }
String function ( ) { if ( lastStartCloseSeq = = null ) lastStartCloseSeq = " </ " + lastStartTag ; return lastStartCloseSeq ; }
public static Tag function ( String arg0 ) { Validate . notNull ( arg0 ) ; arg0 = arg0 . trim ( ) . toLowerCase ( ) ; Validate . notEmpty ( arg0 ) ; Tag tag = tags . get ( arg0 ) ; if ( tag = = null ) { tag = new Tag ( arg0 ) ; tag . isBlock = false ; tag . canContainBlock = true ; } return tag ; }
public boolean function ( ) { return isLevelEnabled ( LOG_LEVEL_DEBUG ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 1.1.6 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 30 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.1.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
@Test public void function ( ) { StringBuilder commentData = new StringBuilder ( BufferSize ) ; do { commentData . append ( " blah blah blah blah  " ) ; } while ( commentData . length ( ) < BufferSize ) ; String expectedCommentData = commentData . toString ( ) ; String testMarkup = " <html><body><! " + expectedCommentData + " ></body></html> " ; Parser parser = new Parser ( new HtmlTreeBuilder ( ) ) ; Document doc = parser . parseInput ( testMarkup , " " ) ; Node commentNode = doc . body ( ) . childNode ( 0 ) ; assertTrue ( commentNode instanceof Comment , " Expected comment node " ) ; assertEquals ( expectedCommentData , ( ( Comment ) commentNode ) . getData ( ) ) ; }
public void function ( ) { Element el = new Element ( " a " ) ; el . append ( " <span>Hello</span> " ) ; assertEquals ( " <a><span>Hello</span></a> " , el . outerHtml ( ) ) ; Element span = el . selectFirst ( " span " ) ; assertNotNull ( span ) ; Element el2 = span . root ( ) ; assertSame ( el , el2 ) ; Document doc = Jsoup . parse ( " <div><p>One<p>Two<p>Three " ) ; Element div = doc . selectFirst ( " div " ) ; assertSame ( doc , div . root ( ) ) ; assertSame ( doc , div . ownerDocument ( ) ) ; }
public boolean function ( ) { return ( remainingLength ( ) > = 2 & & queue . charAt ( pos ) = = '<' & & Character . isLetter ( queue . charAt ( pos + 1 ) ) ) ; }
boolean function ( Token arg0 , HtmlTreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { Token . Doctype d = arg0 . asDoctype ( ) ; DocumentType doctype = new DocumentType ( arg1 . settings . normalizeTag ( d . getName ( ) ) , d . getPubSysKey ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , arg1 . getBaseUri ( ) ) ; arg1 . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) arg1 . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ; arg1 . transition ( BeforeHtml ) ; } else { arg1 . transition ( BeforeHtml ) ; return arg1 . process ( arg0 ) ; } return true ; }
String function ( String arg0 ) { int offset = nextIndexOf ( arg0 ) ; if ( offset ! = - 1 ) { String consumed = cacheString ( pos , offset ) ;
public void function ( ) { for ( Level level : Level . values ( ) ) { messageWith3ArgsPlusException ( level ) ;
private static void function ( StringBuilder arg0 , Object [ ] arg1 , Map arg2 ) { arg0 . append ( '[' ) ; if ( ! arg2 . containsKey ( arg1 ) ) { arg2 . put ( arg1 , null ) ; final int len = arg1 . length ; for ( int i = 0 ; i < len ; i + + ) { deeplyAppendParameter ( arg0 , arg1 [ i ] , arg2 ) ; if ( i ! = len - 1 ) arg0 . append ( " ,  " ) ; } arg2 . remove ( arg1 ) ; } else { arg0 . append ( " ... " ) ; } arg0 . append ( ']' ) ; }
public static ResponseHandler function ( final String arg0 , final RecorderTape arg1 , final ContentResource arg2 ) { return new DynamicRecordHandler ( RecorderRegistry . registryOf ( arg0 , new TapeRecorderFactory ( arg1 ) ) , arg2 ) ;
public static String function ( final Object arg0 ) { try { return DEFAULT_MAPPER . writeValueAsString ( arg0 ) ;
@Test public void function ( ) { String html = " He'llo &copy; \"  > " ; CharacterReader r = new CharacterReader ( html ) ; assertEquals ( " He'llo  " , r . consumeAttributeQuoted ( false ) ) ; assertEquals ( '&' , r . consume ( ) ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " get_method.json " , port ( ) ) ; helper . postContent ( remoteUrl ( " /get " ) , " " ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " mount.json " ) ; helper . get ( remoteUrl ( " /mount-include/foo.bar " ) ) ; }
public String function ( final String arg0 , final String arg1 , final CookieAttribute . . . arg2 ) { Cookie cookie = new DefaultCookie ( arg0 , arg1 ) ; for ( CookieAttribute option : arg2 ) { ( ( ActualCookieAttribute ) option ) . visit ( cookie ) ; } return ServerCookieEncoder . STRICT . encode ( cookie ) ; }
private HttpEntity function ( final ContentResource arg0 , final Request arg1 ) { return new InputStreamEntity ( arg0 . readFor ( of ( arg1 ) ) . toInputStream ( ) , getContentType ( ( HttpRequest ) arg1 ) ) ; }
@Test public void function ( ) { String html = " <script type= \" text/javascript \" >//<![CDATA[ \ n \ n  foo(); \ n//]]></script> " ; Document doc = Jsoup . parse ( html ) ; String data = " //<![CDATA[ \ n \ n  foo(); \ n//]]> " ; Element script = doc . selectFirst ( " script " ) ; assertEquals ( " " , script . text ( ) ) ; assertEquals ( data , script . data ( ) ) ; assertEquals ( html , script . outerHtml ( ) ) ; DataNode dataNode = ( DataNode ) script . childNode ( 0 ) ; assertEquals ( data , dataNode . getWholeData ( ) ) ;
private void function ( LogService arg0 , ServiceReference arg1 ) { arg0 . log ( arg1 , LogService . LOG_DEBUG , " Loaded bundles " ) ; arg0 . log ( arg1 , LogService . LOG_INFO , " Found LogService.  " ) ; arg0 . log ( arg1 , LogService . LOG_WARNING , " Found LogService.  " ) ; arg0 . log ( arg1 , LogService . LOG_ERROR , " Found LogService.  " , new Exception ( " just a test. " ) ) ; }
private static String function ( final String arg0 , final String arg1 ) { return joinFiles ( arg0 , arg1 ) . getPath ( ) ; }
public PongResponse function ( final Resource arg0 ) { PingPongSetting setting = new PingPongSetting ( arg0 ) ; settings . add ( setting ) ; return setting ; }
public static Test function ( ) { TestSuite suite = new TestSuite ( ) ; suite . addTestSuite ( MDCStrLookupTest . class ) ; suite . addTestSuite ( XLoggerTest . class ) ; suite . addTestSuite ( EventLoggerTest . class ) ; return suite ; }
private @Nullable static String function ( arg0 String arg1 ) { if ( arg1 = = null | | arg1 . length ( ) = = 0 ) return null ; arg1 = arg1 . trim ( ) . replaceAll ( " [ \" '] " , " " ) ; try { if ( Charset . isSupported ( arg1 ) ) return arg1 ; arg1 = arg1 . toUpperCase ( Locale . ENGLISH ) ; if ( Charset . isSupported ( arg1 ) ) return arg1 ; } catch ( IllegalCharsetNameException e ) { } return null ; }
public boolean function ( Element arg0 , Element arg1 ) { it . restart ( arg1 ) ; while ( it . hasNext ( ) ) { Element el = it . next ( ) ; if ( el = = arg1 ) continue ; if ( evaluator . matches ( arg1 , el ) ) return true ; } return false ; }
public void function ( ) { when ( request . getMethod ( ) ) . thenReturn ( HttpMethod . GET . toString ( ) ) ; assertThat ( extractor . extract ( request ) . get ( ) , is ( HttpMethod . GET . toString ( ) ) ) ; }
public static RequestMatcher function ( RequestMatcher . . . arg0 ) { return new AndRequestMatcher ( arg0 ) ; }
public static Session function ( arg0 ( " request " ) HttpRequest request , arg0 ( " response " ) HttpResponse response ) { Session session = new Session ( ) ; session . request = request ; session . response = response ; return session ; }
public void function ( ChannelHandlerContext arg0 ) throws Exception { new Thread ( new Runnable ( ) { @Override
public boolean function ( ) { return slf4jLogger . isDebugEnabled ( ) ; }
private int function ( Priority arg0 ) { switch ( arg0 . level ) { case Level . TRACE_INT :
public boolean function ( Element arg0 , Element arg1 ) { Element parent = arg1 . parent ( ) ; if ( parent ! = null ) return sel . matches ( arg0 , parent ) ; return false ; }
boolean function ( Token arg0 , TreeBuilder arg1 ) { if ( isWhitespace ( arg0 ) ) { return true ; } else if ( arg0 . isComment ( ) ) { arg1 . insert ( arg0 . asComment ( ) ) ; } else if ( arg0 . isDoctype ( ) ) { Token . Doctype d = arg0 . asDoctype ( ) ; DocumentType doctype = new DocumentType ( d . getName ( ) , d . getPublicIdentifier ( ) , d . getSystemIdentifier ( ) , arg1 . getBaseUri ( ) ) ; arg1 . getDocument ( ) . appendChild ( doctype ) ; if ( d . isForceQuirks ( ) ) arg1 . getDocument ( ) . quirksMode ( Document . QuirksMode . quirks ) ; arg1 . transition ( BeforeHtml ) ; } else { arg1 . transition ( BeforeHtml ) ; return arg1 . process ( arg0 ) ; } return true ; }
public char function ( ) { bufferUp ( ) ; return isEmptyNoBufferUp ( ) ? EOF : charBuf [ bufPos ] ; }
public void function ( ) { assertTrue ( blue . contains ( BLUE_STR ) ) ; }
public static ResponseHandler function ( final String arg0 , final Resource arg1 ) { return AndResponseHandler . and ( header ( HttpHeaders . CONTENT_DISPOSITION , format ( " attachment; filename=%s " , checkNotNullOrEmpty ( arg0 , " Filename should not be null or empty " ) ) ) ,
public static HttpServer function ( final int arg0 , final Resource arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return parseHttpServer ( checkNotNull ( arg1 , " resource should not be null " ) , arg0 ) ; }
@Test public void function ( ) { String h = " <!DOCTYPE html><body><img async checked='checked' src='&<> \" '>&lt;&gt;&amp;&quot;<foo />bar " ; Document doc = Jsoup . parse ( h ) ; doc . outputSettings ( ) . syntax ( Syntax . html ) ; assertEquals ( " <!doctype html> \ n " + " <html> \ n " + "  <head></head> \ n " + "  <body> \ n " + "   <img async checked src= \" &amp;<>&quot; \" >&lt;&gt;&amp; \" <foo />bar \ n " + "  </body> \ n " + " </html> " , doc . html ( ) ) ; doc . outputSettings ( ) . syntax ( Document . OutputSettings . Syntax . xml ) ; assertEquals ( " <!DOCTYPE html> \ n " + " <html> \ n " +
private String function ( LoggingEvent arg0 , String arg1 ) { StringBuilder sb = null ; if ( loggingEvent . getMarkers ( ) ! = null ) { sb = new StringBuilder ( ) ; for ( Marker marker : arg0 . getMarkers ( ) ) { sb . append ( marker ) ; sb . append ( ' ' ) ; } } if ( arg0 . getKeyValuePairs ( ) ! = null ) { if ( sb = = null ) { sb = new StringBuilder ( ) ; } for ( KeyValuePair kvp : arg0 . getKeyValuePairs ( ) ) { sb . append ( kvp . key ) ; sb . append ( '=' ) ; sb . append ( kvp . value ) ; sb . append ( ' ' ) ; } } if ( sb ! = null ) { sb . append ( arg1 ) ;
public static HttpServer function ( final int arg0 , final MocoConfig . . . arg1 ) { checkArgument ( arg0 > 0 , " Port must be greater than zero " ) ; return ActualHttpServer . createQuietServer ( arg0 , checkNotNull ( arg1 , " Configuration should not be null " ) ) ; }
protected RequestMatcher function ( final RequestExtractor < T > arg0 , final Resource arg1 ) { return new ContainMatcher < > ( arg0 , arg1 ) ; }
private HttpServer function ( final Iterable < ? extends RunnerSetting > arg0 , final StartArgs arg1 ) { HttpServer server = createBaseHttpServer ( arg0 , arg1 ) ; server . request ( by ( uri ( " /favicon.ico " ) ) ) . response ( with ( pathResource ( " favicon.png " ) ) , header ( HttpHeaders . CONTENT_TYPE , " image/png " ) ) ; return server ; }
public void function ( WebSocket arg0 , String arg1 ) { onMessage ( arg1 ) ; }
public void function ( Framedata arg0 ) throws InvalidFrameException { ByteBuffer b = arg0 . getPayloadData ( ) ; if ( unmaskedpayload = = null ) { unmaskedpayload = ByteBuffer . allocate ( b . remaining ( ) ) ; b . mark ( ) ; unmaskedpayload . put ( b ) ; b . reset ( ) ; } else { b . mark ( ) ; unmaskedpayload . position ( unmaskedpayload . limit ( ) ) ; unmaskedpayload . limit ( unmaskedpayload . capacity ( ) ) ; if ( unmaskedpayload . hasRemaining ( ) ) unmaskedpayload . put ( b ) ; if ( b . hasRemaining ( ) ) { ByteBuffer tmp = ByteBuffer . allocate ( b . remaining ( ) + unmaskedpayload . capacity ( ) ) ; unmaskedpayload . flip ( ) ; tmp . put ( unmaskedpayload ) ; tmp . put ( b ) ; unmaskedpayload = tmp ; } unmaskedpayload . rewind ( ) ; b . reset ( ) ; } fin = arg0 . isFin ( ) ; }
public void function ( final Throwable arg0 ) { for ( MocoMonitor monitor : monitors ) { monitor . onException ( arg0 ) ;
public void function ( Exception arg0 ) { exs [ finalI ] = arg0 ; }
public void function ( String arg0 , Throwable arg1 ) { if ( logger . isLoggable ( Level . INFO ) ) { log ( SELF , Level . INFO , arg0 , arg1 ) ;
public void function ( ) throws Exception { helper . connect ( ) ; assertThat ( helper . send ( " foo " , 3 ) , is ( " bar " ) ) ; assertThat ( helper . send ( " anything " , 4 ) , is ( " blah " ) ) ; helper . close ( ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { if ( ! logger . isDebugEnabled ( arg0 ) ) return ; if ( instanceofLAL ) {
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 7.3.2 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { helper . get ( remoteUrl ( " /dir/dir.response " ) ) ; }
protected void function ( ) { try { idle ( INTERVAL * 3 , TimeUnit . MILLISECONDS ) ;
private HttpResponse function ( final HttpRequest arg0 , final URL arg1 ) { try ( CloseableHttpClient client = createClient ( ) ) { try {
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.22.11 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws Exception { testProtocolRejection ( 28 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , Collections . < IProtocol > singletonList ( new Protocol ( " opc " ) ) ) ) ;
public void function ( ) throws Exception { byte [ ] bytes = BufferTools . stringToByteBuffer ( LONG_T_FRAME , 0 , LONG_T_FRAME . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( bytes , 3 ) ; ID3v2ObseleteFrame frame = new ID3v2ObseleteFrame ( bytes , 0 ) ; assertEquals ( 263 , frame . getLength ( ) ) ; assertEquals ( " TP1 " , frame . getId ( ) ) ; String s = " 0Metamorphosis A a very long album B a very long album C a very long album D a very long album E a very long album F a very long album G a very long album H a very long album I a very long album J a very long album K a very long album L a very long album M0 " ; byte [ ] expectedBytes = BufferTools . stringToByteBuffer ( s , 0 , s . length ( ) ) ; TestHelper . replaceNumbersWithBytes ( expectedBytes , 0 ) ; assertTrue ( Arrays . equals ( expectedBytes , frame . getData ( ) ) ) ; }
public Builder function ( final Map < String , String > arg0 ) { if ( arg0 ! = null ) { ImmutableMap . Builder < String , String [ ] > builder = ImmutableMap . builder ( ) ; for ( Map . Entry < String , String > entry : arg0 . entrySet ( ) ) { builder . put ( entry . getKey ( ) , new String [ ] { entry . getValue ( ) } ) ; } this . arg0 = builder . build ( ) ; } return this ; }
public void function ( ) { Logger logger = LoggerFactory . getLogger ( " testNullParameter_BUG78 " ) ; String [ ] parameters = null ; String msg = " hello {} " ; logger . debug ( msg , ( Object [ ] ) parameters ) ; assertEquals ( 1 , listAppender . list . size ( ) ) ; LoggingEvent e = ( LoggingEvent ) listAppender . list . get ( 0 ) ; assertEquals ( msg , e . getMessage ( ) ) ; }
private Range function ( final List arg0 ) { final Object end = arg0 . get ( 0 ) ; if ( end instanceof SimpleNumber ) { return getSingleRange ( ( SimpleNumber ) end ) ; } return new Range ( Optional . empty ( ) , Optional . empty ( ) ) ; }
@Test public void function ( ) throws IOException { File in = ParseTest . getFile ( " /fuzztests/1539.html " ) ; Document doc = Jsoup . parse ( in , " UTF-8 " ) ; assertNotNull ( doc ) ; Document docXml = Jsoup . parse ( new FileInputStream ( in ) , " UTF-8 " , " https://example.com " , Parser . xmlParser ( ) ) ; assertNotNull ( docXml ) ;
public void function ( String arg0 , Object arg1 ) { if ( log . isInfoEnabled ( ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 ) ;
public void function ( ) throws Exception { server . request ( by ( uri ( " /foo-record " ) ) ) . response ( record ( " foo " , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-record " ) ) ) . response ( record ( " bar " , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /foo-replay " ) ) ) . response ( replay ( " foo " , template ( " ${req.queries['type']} " ) ) ) ; server . request ( by ( uri ( " /bar-replay " ) ) ) . response ( replay ( " bar " , template ( " ${req.queries['type']} " ) ) ) ; running ( server , ( ) - > { helper . postContent ( remoteUrl ( " /foo-record?type=blah " ) , " foo " ) ;
public void function ( ) throws Exception { ArrayList < IProtocol > protocols = new ArrayList < IProtocol > ( ) ; protocols . add ( new Protocol ( " chat1 " ) ) ; protocols . add ( new Protocol ( " chat2 " ) ) ; protocols . add ( new Protocol ( " chat3 " ) ) ; testProtocolRejection ( 21 , new Draft_6455 ( Collections . < IExtension > emptyList ( ) , protocols ) ) ; }
public void function ( ) throws Exception { get ( " 1/1 " ) . response ( status ( 200 ) ) ; }
public String function ( String arg0 ) { Map < String , String > map = inheritableThreadLocalMap . get ( ) ; if ( ( map ! = null ) & & ( arg0 ! = null ) ) { return map . get ( arg0 ) ;
public static ResponseHandler function ( final String arg0 ) { return with ( arg0 ( arg0 ) ) ; }
public Element function ( String arg0 ) { if ( tagName ( ) . equals ( " textarea " ) ) text ( arg0 ) ; else attr ( " arg0 " , arg0 ) ; return this ; }
public LoggingEventBuilder function ( String arg0 , Object arg1 ) { return singleton ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = folder . newFile ( ) ; System . setOut ( new PrintStream ( new FileOutputStream ( file ) ) ) ; assertThat ( helper . get ( remoteUrl ( " /event-with-json-post " ) ) , is ( " post_json_foo " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) , containsString ( " 0XMOCOJSON " ) ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.2.1 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public < T extends Appendable > T function ( T arg0 ) { for ( Node node : childNodes ) node . outerHtml ( arg0 ) ; return arg0 ; }
static public String function ( String arg0 ) { if ( mdcAdapter = = null ) { throw new IllegalStateException ( MDC_APAPTER_CANNOT_BE_NULL_MESSAGE ) ; } return mdcAdapter . popByKey ( arg0 ) ; }
public void function ( ) throws Exception { root . getLoggerRepository ( ) . resetConfiguration ( ) ; }
public void function ( ) throws Exception { byte buffer [ ] = new byte [ 10 ] ; String s = " TAG- " ; try { BufferTools . stringIntoByteBuffer ( s , 0 , 1 , buffer , 10 ) ; fail ( " ArrayIndexOutOfBoundsException expected but not thrown " ) ; } catch ( ArrayIndexOutOfBoundsException e ) { } try { BufferTools . stringIntoByteBuffer ( s , 0 , s . length ( ) , buffer , buffer . length - s . length ( ) + 1 ) ;
public void function ( ContentStream arg0 ) { responseWithContentHandler ( new ContentHandler ( arg0 . asByteArray ( ) ) ) ; }
private HttpEntity function ( final ContentResource arg0 , final Request arg1 ) { MediaType type = content . getContentType ( ( HttpRequest ) arg1 ) ; ContentType contentType = ContentType . create ( type . type ( ) + " / " + type . subtype ( ) , type . charset ( ) . or ( Charset . defaultCharset ( ) ) ) ; return new InputStreamEntity ( arg0 . readFor ( of ( arg1 ) ) . toInputStream ( ) , contentType ) ; }
public void function ( ) throws IOException { InputStream stream = null ; try { stream = getResourceAsStream ( " settings/settings.json " ) ;
@Test void function ( ) { Document doc = Jsoup . parse ( html ) ; StringBuilder seen = new StringBuilder ( ) ; doc . nodeStream ( ) . filter ( node - > node instanceof TextNode ) . forEach ( node - > trackSeen ( node , seen ) ) ; assertEquals ( " One;Two;Three;Four; " , seen . toString ( ) ) ; }
protected Element function ( arg0 Node arg1 ) { Element clone = ( Element ) super . doClone ( arg1 ) ; clone . attributes = attributes ! = null ? attributes . clone ( ) : null ; clone . childNodes = new NodeList ( clone , childNodes . size ( ) ) ; clone . childNodes . addAll ( childNodes ) ; clone . setBaseUri ( baseUri ( ) ) ; return clone ; }
public static < ExtractorType1 , ExtractorType2 > ContentResource function ( final ContentResource arg0 , final String arg1 , final RequestExtractor < ExtractorType1 > arg2 , final String arg3 , final RequestExtractor < ExtractorType2 > arg4 ) { return templateResource ( checkNotNull ( arg0 , " Template should not be null " ) , ImmutableMap . of ( checkNotNullOrEmpty ( arg1 , " Template variable name should not be null " ) ,
public void function ( ) { XLogger logger = XLoggerFactory . getXLogger ( " UnitTest " ) ; logger . exit ( ) ; assertEquals ( Integer . valueOf ( 0 ) , logger . exit ( 0 ) ) ; assertEquals ( Boolean . FALSE , logger . exit ( false ) ) ; assertEquals ( 3 , listAppender . list . size ( ) ) ; verify ( listAppender . list . get ( 0 ) , " exit " ) ; verify ( listAppender . list . get ( 1 ) , " exit with (0) " ) ; verify ( listAppender . list . get ( 2 ) , " exit with (false) " ) ; }
private void function ( WebSocket arg0 , RuntimeException arg1 ) { onError ( arg0 , arg1 ) ; try { selector . close ( ) ; } catch ( IOException e1 ) { onError ( null , e1 ) ; } decoders . shutdown ( ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " foo.json " ) ; assertThat ( helper . postContent ( root ( ) , " text_request " ) , is ( " response_for_text_request " ) ) ; }
protected RequestMatcher function ( final Resource arg0 , final ContentRequestExtractor arg1 ) { return new XmlContentRequestMatcher ( arg0 , arg1 ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p>One <span>two</span> three</p> " ) ; Element p = doc . select ( " p " ) . first ( ) ; p . childNode ( 0 ) . remove ( ) ; assertEquals ( " two three " , p . text ( ) ) ; assertEquals ( " <span>two</span> three " , TextUtil . stripNewlines ( p . html ( ) ) ) ; }
public void function ( ) throws Exception { runTestScenarioReconnect ( false ) ; }
@Test void function ( ) throws IOException { StreamParser streamer = basic ( ) ; Document doc = streamer . complete ( ) ; assertTrue ( isClosed ( streamer ) ) ; }
public void function ( Marker arg0 , String arg1 , Object . . . arg2 ) { trace ( arg1 , arg2 ) ; }
public boolean function ( ) { return ! isEmpty ( ) & & Character . isLetterOrDigit ( peek ( ) ) ; }
public static RequestMatcher function ( Resource arg0 ) { return new JsonRequestMatcher ( extractor ( arg0 . id ( ) ) , arg0 ) ; }
public static ResponseHandler function ( final Resource . . . arg0 ) { checkArgument ( arg0 . length > 0 , " Sequence contents should not be null " ) ; return newSeq ( FluentIterable . from ( copyOf ( arg0 ) ) . transform ( ApiUtils . resourceToResourceHandler ( ) ) ) ; }
@Override void function ( Tokeniser arg0 , CharacterReader arg1 ) { if ( arg1 . matchesAsciiAlpha ( ) ) { String name = arg1 . consumeLetterSequence ( ) ; arg0 . tagPending . appendTagName ( name ) ; arg0 . dataBuffer . append ( name ) ; return ; } char c = arg1 . consume ( ) ; switch ( c ) { case '\t' :
protected Option function ( ) { Option option = new Option ( null , " keystore " , true , " Key store password " ) ; option . setType ( String . class ) ; option . setRequired ( false ) ; return option ; }
public Connection . Request function ( int arg0 ) { Validate . isTrue ( arg0 > = 0 , " maxSize must be 0 (unlimited) or larger " ) ; maxBodySizeBytes = arg0 ; return this ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 5.9 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 10 ) ; }
public void function ( ) throws IOException { runWithConfiguration ( " cookie.json " ) ; DefaultCookie decodeCookie = getCookie ( " /cookie-with-same-site " ) ; assertThat ( decodeCookie . name ( ) , is ( " login " ) ) ; assertThat ( decodeCookie . value ( ) , is ( " true " ) ) ; assertThat ( decodeCookie . sameSite ( ) , is ( CookieHeaderNames . SameSite . Lax ) ) ; }
public void function ( ) throws Exception { server . request ( startsWith ( uri ( " /foo " ) ) ) . response ( " bar " ) ; running ( server , new Runnable ( ) { @Override
public static MocoEventAction function ( final Resource arg0 , final Object arg1 , final HttpHeader arg2 , final HttpHeader . . . arg3 ) { return post ( checkNotNull ( arg0 , " URL should not be null " ) , Jsons . toJson ( checkNotNull ( arg1 , " Content should not be null " ) ) ,
public void function ( Marker arg0 , String arg1 , int arg2 , String arg3 , Object [ ] arg4 , Throwable arg5 ) { Level log4jLevel ; switch ( arg2 ) { case LocationAwareLogger . TRACE_INT : log4jLevel = traceCapable ? Level . TRACE : Level . DEBUG ; break ; case LocationAwareLogger . DEBUG_INT : log4jLevel = Level . DEBUG ; break ; case LocationAwareLogger . INFO_INT : log4jLevel = Level . INFO ; break ; case LocationAwareLogger . WARN_INT : log4jLevel = Level . WARN ; break ; case LocationAwareLogger . ERROR_INT : log4jLevel = Level . ERROR ; break ; default : throw new IllegalStateException ( " Level number  " + arg2 + "  is not recognized. " ) ; } final FormattingTuple ft = MessageFormatter . arrayFormat ( arg3 , arg4 , arg5 ) ; logger . log ( arg1 , log4jLevel , ft . getMessage ( ) , ft . getThrowable ( ) ) ; }
public void function ( ) throws Exception { Mp3File mp3File = new Mp3File ( MP3_WITH_INCOMPLETE_MPEG_FRAME , 256 , false ) ; assertTrue ( mp3File . hasId3v1Tag ( ) ) ; assertTrue ( mp3File . hasId3v2Tag ( ) ) ; }
private ImmutableList < Session > function ( File arg0 ) { try { List < Session > sessions = mapper . readValue ( arg0 , factory . constructCollectionType ( List . class , Session . class ) ) ;
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( isErrorEnabled ( arg0 ) ) { handle2ArgsCall ( Level . ERROR , arg0 , arg1 , arg2 , arg3 ) ;
public static HttpsCertificate function ( ContentResource arg0 , String arg1 , String arg2 ) { return new HttpsCertificate ( arg0 , arg1 , arg2 ) ; }
@Test public void function ( ) { String html = " <a href='/foo'>Link</a><img src='/bar'> <img src='javascript:alert()'> " ; String clean = Jsoup . clean ( html , " http://example.com/ " , Whitelist . basicWithImages ( ) . preserveRelativeLinks ( true ) ) ; assertEquals ( " <a href= \" /foo \"  rel= \" nofollow \" >Link</a> \ n<img src= \" /bar \" >  \ n<img> " , clean ) ; }
public TextContainer function ( JsonParser arg0 , DeserializationContext arg1 ) throws IOException { JsonToken currentToken = arg0 . getCurrentToken ( ) ; if ( currentToken = = JsonToken . VALUE_STRING ) { return text ( arg0 ) ; } if ( currentToken = = JsonToken . START_OBJECT ) { arg0 . nextToken ( ) ; return textContainer ( arg0 , arg1 ) ; } throw arg1 . mappingException ( TextContainer . class , currentToken ) ; }
public void function ( ) throws Exception { server . post ( and ( by ( uri ( " /target " ) ) , by ( " proxy " ) ) ) . response ( " proxy " ) ; final File tempFile = File . createTempFile ( " temp " , " " ) ; server . request ( by ( uri ( " /proxy " ) ) ) . response ( proxy ( remoteUrl ( " /target " ) , failover ( tempFile . getAbsolutePath ( ) ) ) ) ; running ( server , new Runnable ( ) { @Override
private void function ( LoggingEvent arg0 ) { if ( logger instanceof LoggingEventAware ) { ( ( LoggingEventAware ) logger ) . log ( arg0 ) ;
@Test void function ( ) { String html = " <span id=1>One</span><html attr=foo><body class=2>Two</body><head title=3><body class=ok data=bar> " ; Document doc = Jsoup . parse ( html , TrackingHtmlParser ) ; StringBuilder elTrack = new StringBuilder ( ) ; doc . forEachNode ( node - > accumulatePositions ( node , elTrack ) ) ; StringBuilder atTrack = new StringBuilder ( ) ; doc . forEachNode ( node - > accumulateAttributePositions ( node , atTrack ) ) ; assertEquals ( " #document:0-0~98-98; html:0-0~98-98; head:0-0~0-0; body:0-0~53-60; span:0-11~14-21; #text:11-14; #text:50-53;  " , elTrack . toString ( ) ) ; assertEquals ( " attr:27-31=32-35; class:42-47=48-49; data:89-93=94-97; id:6-8=9-10;  " , atTrack . toString ( ) ) ; assertEquals ( " <html attr= \" foo \" ><head></head><body class= \" 2 \"  data= \" bar \" ><span id= \" 1 \" >One</span>Two </body></html> " , TextUtil . normalizeSpaces ( doc . html ( ) ) ) ; }
private int function ( ByteBuffer arg0 ) throws SSLException { assert ( arg0 . hasRemaining ( ) ) ; if ( inData . hasRemaining ( ) ) { return transfereTo ( inData , arg0 ) ; } assert ( ! inData . hasRemaining ( ) ) ; inData . clear ( ) ; if ( inCrypt . hasRemaining ( ) ) { unwrap ( ) ; int amount = transfereTo ( inData , arg0 ) ; if ( amount > 0 ) return amount ; } return 0 ; }
public void function ( ) throws Exception { RestServer server = restServer ( 12306 ) ; final Plain resource1 = new Plain ( ) ; resource1 . code = 1 ; resource1 . message = " hello " ; server . resource ( " targets " , post ( ) . response ( status ( 201 ) , header ( " Location " , " /targets/123 " ) ) ) ; running ( server , ( ) - > { HttpResponse httpResponse = helper . postForResponse ( remoteUrl ( " /targets " ) ,
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.8 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ; }
public static URL function ( URL arg0 , String arg1 ) throws MalformedURLException { arg1 = stripControlChars ( arg1 ) ; if ( arg1 . startsWith ( " ? " ) ) arg1 = arg0 . getPath ( ) + arg1 ; URL url = new URL ( arg0 , arg1 ) ; String fixedFile = extraDotSegmentsPattern . matcher ( url . getFile ( ) ) . replaceFirst ( " / " ) ; if ( url . getRef ( ) ! = null ) { fixedFile = fixedFile + " # " + url . getRef ( ) ; } return new URL ( url . getProtocol ( ) , url . getHost ( ) , url . getPort ( ) , fixedFile ) ; }
public void function ( String arg0 , Object arg1 , Object arg2 ) { if ( logger . isLoggable ( Level . FINEST ) ) { FormattingTuple ft = MessageFormatter . arg0 ( arg0 , arg1 , arg2 ) ;
@Test void function ( ) { Document doc = Jsoup . parse ( " <div class='vds-items_flex-end [&amp;_>_*:first-child]:vds-pt_0'>One</div><div class='vds-items_flex-end'>Two</div> " ) ; Element div = doc . expectFirst ( " div " ) ; String selector = div . cssSelector ( ) ; assertEquals ( " html > body > div.vds-items_flex-end. \\ [ \\ &_ \\ >_ \\ * \\ :first-child \\ ] \\ :vds-pt_0 " , selector ) ; Elements selected = doc . select ( selector ) ; assertEquals ( 1 , selected . size ( ) ) ; assertEquals ( selected . first ( ) , div ) ; }
public void function ( ) { Abbreviator abb = new Abbreviator ( 2 , 100 , FS ) ; String r = abb . abbreviate ( " hello " ) ; assertEquals ( " hello " , r ) ;
@Test void function ( ) { TextNode tn = TextNode . createFromEncoded ( " &lt;One&gt; " ) ; assertEquals ( " <One> " , tn . text ( ) ) ; }
@Test void function ( ) { Document doc = Jsoup . parse ( " <title>Hello</title> <p>One<p>Two " ) ; String expect = " <html> \ n <head> \ n  <title>Hello</title> \ n </head> \ n <body> \ n  <p>One</p> \ n  <p>Two</p> \ n </body> \ n</html> " ; assertEquals ( expect , doc . html ( ) ) ; }
public final ResponseHandler function ( final MocoConfig arg0 ) { FluentIterable < ResponseHandler > transformedResources = from ( copyOf ( handlers ) ) . transform ( applyConfig ( arg0 ) ) ; return newCollectionHandler ( transformedResources ) ; }
@Test public void function ( ) { String dirty = " <a>One</a> <a href>Two</a> " ; Safelist relaxedWithAnchor = Safelist . relaxed ( ) . addProtocols ( " a " , " href " , " # " ) ; String clean = Jsoup . clean ( dirty , relaxedWithAnchor ) ; assertEquals ( " <a>One</a> <a>Two</a> " , clean ) ; }
public void function ( String arg0 , Throwable arg1 ) { log ( LOG_LEVEL_ERROR , arg0 , arg1 ) ; }
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 6.12.5 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; Assume . assumeTrue ( " Duration:  " + testResult . getInt ( " duration " ) , testResult . getInt ( " duration " ) < 10 ) ;
private HttpServer function ( List < SessionSetting > arg0 , int arg1 ) throws IOException { HttpServer server = new HttpServer ( arg1 ) ; for ( SessionSetting session : arg0 ) { logger . debug ( " Parse session: {} " , session ) ; if ( session . isMount ( ) ) { MountSetting mount = session . getMount ( ) ; server . mount ( mount . getDir ( ) , to ( mount . getUri ( ) ) , getMountPredicates ( mount ) ) ; } else if ( session . isAnyResponse ( ) ) { server . response ( getContent ( session ) ) ; } else { server . request ( requestMatcherParser . createRequestMatcher ( session . getRequest ( ) ) ) . response ( getContent ( session ) ) ; } } return server ; }
public void function ( String arg0 , Object . . . arg1 ) { delegate ( ) . debug ( arg0 , arg1 ) ; }
final public boolean function ( Marker arg0 ) { return false ; }
public void function ( ) throws IOException { runWithConfiguration ( " rest/rest.json " ) ; org . apache . http . HttpResponse response = helper . getResponseWithHeader ( remoteUrl ( " /all-resources " ) , of ( HttpHeaders . CONTENT_TYPE , " application/json " ) ) ; assertThat ( response . getStatusLine ( ) . getStatusCode ( ) , is ( 200 ) ) ; HttpEntity entity = response . getEntity ( ) ; List < Plain > plains = Jsons . toObjects ( entity . getContent ( ) , Plain . class ) ; assertThat ( plains . size ( ) , is ( 2 ) ) ; }
public void function ( ) { try { assertThat ( helper . postContent ( " http://localhost:8080/foo " , " foo " ) , is ( " bar " ) ) ;
public boolean function ( FullHttpRequest arg0 ) { return true ; }
private Object function ( ) throws ObjectStreamException { if ( getClass ( ) = = Level . class ) { return toLevel ( level ) ; } return this ; }
public void function ( ) throws Exception { server . request ( by ( pathResource ( " foo.request " ) ) ) . response ( " foo " ) ; running ( server , ( ) - > { URL resource = Resources . getResource ( " foo.request " ) ;
private static byte function ( byte [ ] arg0 ) { if ( arg0 . length > = 2 & & arg0 [ 0 ] = = ( byte ) 0xff & & arg0 [ 1 ] = = ( byte ) 0xfe ) { return TEXT_ENCODING_UTF_16 ;
public boolean function ( Object arg0 ) { if ( this = = arg0 ) return true ; if ( arg0 = = null | | getClass ( ) ! = arg0 . getClass ( ) ) return false ; Attribute attribute = ( Attribute ) arg0 ; if ( key ! = null ? ! key . equals ( attribute . key ) : attribute . key ! = null ) return false ; return val ! = null ? val . equals ( attribute . val ) : attribute . val = = null ; }
public boolean function ( final Request arg0 ) { for ( RequestMatcher matcher : matchers ) { if ( ! matcher . match ( arg0 ) ) { return false ; } } return true ; }
final void function ( char arg0 ) { ensureAttrValue ( ) ; attrValue . arg0 ( arg0 ) ; }
public void function ( ) { jdkMessageFormatter ( RUN_LENGTH ) ; double duration = jdkMessageFormatter ( RUN_LENGTH ) ; System . out . println ( " jdk duration =  " + duration + "  nanos " ) ; }
public void function ( ) { monitor . onException ( t ) ; }
public static ContentResource function ( final Function < Request , byte [ ] > arg0 ) { return contentResource ( id ( " binary " ) , DO_NOTHING_APPLIER , new ContentResourceReader ( ) { @Override
public void function ( ) throws NoSuchAlgorithmException { CustomSSLWebSocketServerFactory webSocketServerFactory = new CustomSSLWebSocketServerFactory ( SSLContext . getDefault ( ) , null , null ) ; CustomWebSocketAdapter webSocketAdapter = new CustomWebSocketAdapter ( ) ; WebSocketImpl webSocketImpl = webSocketServerFactory . createWebSocket ( webSocketAdapter , new Draft_6455 ( ) ) ; assertNotNull ( " webSocketImpl != null " , webSocketImpl ) ; webSocketImpl = webSocketServerFactory . createWebSocket ( webSocketAdapter , Collections . < Draft > singletonList ( new Draft_6455 ( ) ) ) ; assertNotNull ( " webSocketImpl != null " , webSocketImpl ) ; }
protected MessageContent function ( final Request arg0 ) { return this . resource . readFor ( of ( arg0 ) ) ; }
public void function ( ) throws Exception { byte [ ] buffer = { BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_DASH , BYTE_T , BYTE_A , BYTE_G } ; try { BufferTools . byteBufferToString ( buffer , buffer . length - 2 , 3 ) ;
public void function ( ) { ID3v2UrlFrameData frameData = new ID3v2UrlFrameData ( false , new EncodedText ( ( byte ) 0 , TEST_DESCRIPTION ) , TEST_URL ) ; assertFalse ( frameData . equals ( " 8 " ) ) ; }
public static RequestMatcher function ( RequestExtractor arg0 , String arg1 ) { return new EqRequestMatcher ( arg0 , arg1 ) ; }
public static VerificationMode function ( int arg0 ) { checkArgument ( arg0 > 0 , " Times count must be greater than zero " ) ; return new AtMostVerification ( arg0 ) ; }
public void function ( arg0 final Path arg1 ) throws IOException { runWithConfiguration ( " event.json " ) ; File file = arg1 . resolve ( " tempfile " ) . toFile ( ) ; System . setOut ( new PrintStream ( file ) ) ; assertThat ( helper . get ( remoteUrl ( " /get_event_with_header " ) ) , is ( " get_foo_with_header " ) ) ; idle ( IDLE , TimeUnit . MILLISECONDS ) ; assertThat ( asCharSource ( file , Charset . defaultCharset ( ) ) . read ( ) , containsString ( " 0XMOCOHEADER " ) ) ; }
public static HttpsServer function ( final HttpsCertificate arg0 , final MocoConfig . . . arg1 ) { return ActualHttpServer . createHttpsQuietServer ( 0 , checkNotNull ( arg0 , " Certificate should not be null " ) , arg1 ) ; }
public void function ( ) { MocoHttpServer server = new MocoHttpServer ( ActualHttpServer . createLogServer ( of ( port ( ) ) ) ) ; server . stop ( ) ; }
public RequestMatcher function ( final MocoConfig arg0 ) { Resource appliedResource = this . resource . apply ( arg0 ) ; if ( appliedResource = = this . resource ) { return this ; } return new JsonRequestMatcher ( this . extractor , appliedResource ) ; }
public void function ( Marker arg0 , String arg1 , Object arg2 , Object arg3 ) { if ( ! logger . isDebugEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arg1 ( arg1 , arg2 , arg3 ) ;
@Test void function ( ) { String html = " <img multi='&#55357;&#56495;' single='&#128175;' hexsingle='&#x1f4af;'> " ; Document document = Jsoup . parse ( html ) ; Element img = document . expectFirst ( " img " ) ; assertEquals ( " \ uD83D \ uDCAF " , img . attr ( " multi " ) ) ; assertEquals ( " \ uD83D \ uDCAF " , img . attr ( " single " ) ) ; assertEquals ( " \ uD83D \ uDCAF " , img . attr ( " hexsingle " ) ) ; assertEquals ( " <img multi= \" \ uD83D \ uDCAF \"  single= \" \ uD83D \ uDCAF \"  hexsingle= \" \ uD83D \ uDCAF \" > " , img . outerHtml ( ) ) ; img . ownerDocument ( ) . outputSettings ( ) . charset ( " ascii " ) ; assertEquals ( " <img multi= \" &#x1f4af; \"  single= \" &#x1f4af; \"  hexsingle= \" &#x1f4af; \" > " , img . outerHtml ( ) ) ; }
public Connection function ( String arg0 , String arg1 , InputStream arg2 , String arg3 ) { req . data ( KeyVal . create ( arg0 , arg1 , arg2 ) . arg3 ( arg3 ) ) ; return this ; }
public void function ( InputStream arg0 , int arg1 ) { runner . run ( httpServerParser . parseServer ( arg0 , arg1 ) ) ; }
@Override public void function ( Node arg0 , int arg1 ) { if ( arg0 instanceof Element ) { Element prev = ( ( Element ) arg0 ) . previousElementSibling ( ) ;
private Elements function ( ) { String className = tq . consumeClassName ( ) ; Validate . notEmpty ( className ) ; return root . getElementsByClass ( className ) ; }
final Tag function ( String arg0 ) { tagName = arg0 ; normalName = lowerCase ( arg0 ) ; return this ; }
public void function ( ) { List < Token > tokens = TokenStream . create ( " <html><body><p>Hello world!</p></body></html> " ) . asList ( ) ; assertEquals ( " Correct num tokens " , 7 , tokens . size ( ) ) ; }
public static ContentResource function ( final Resource arg0 , final Optional < Charset > arg1 ) { return fileResource ( checkNotNull ( arg0 , " Filename should not be null " ) , checkNotNull ( arg1 , " Charset should not be null " ) , Optional . < MocoConfig > absent ( ) ) ; }
public Builder function ( String arg0 ) { this . arg0 = arg0 ; return this ; }
public final HttpsArgs function ( ) { return new HttpsArgs ( port , shutdownPort , configurationFile , settings , env , quiet , httpsArg ) ; }
public void function ( ) throws IOException { ProtocolVersion version = helper . getResponse ( root ( ) ) . getProtocolVersion ( ) ; assertThat ( version . getMajor ( ) , is ( 1 ) ) ; assertThat ( version . getMinor ( ) , is ( 0 ) ) ; }
public static ActualSocketServer function ( int arg0 ) { return new ActualSocketServer ( arg0 , new QuietMonitor ( ) ) ; }
public Object function ( final List arg0 ) { Optional < Long > range = getRange ( arg0 ) ; Optional < ? extends NumberFormat > format = getFormat ( arg0 ) ; double result = new Random ( ) . nextDouble ( ) * range . orElse ( 1L ) ; if ( format . isPresent ( ) ) { return format . get ( ) . format ( result ) ; } return result ; }
public void function ( ) throws Exception { copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 41 ) ; copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 256 ) ; copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 1024 ) ; copyAndCheckTestMp3WithUnicodeFields ( MP3_WITH_ID3V23_UNICODE_TAGS , 5000 ) ; copyAndCheckTestMp3WithUnicodeFields ( new File ( MP3_WITH_ID3V23_UNICODE_TAGS ) , 41 ) ; copyAndCheckTestMp3WithUnicodeFields ( new File ( MP3_WITH_ID3V23_UNICODE_TAGS ) , 256 ) ; copyAndCheckTestMp3WithUnicodeFields ( new File ( MP3_WITH_ID3V23_UNICODE_TAGS ) , 1024 ) ; copyAndCheckTestMp3WithUnicodeFields ( new File ( MP3_WITH_ID3V23_UNICODE_TAGS ) , 5000 ) ; }
protected boolean function ( final Request arg0 , final Iterable < RequestMatcher > arg1 ) { for ( RequestMatcher matcher : arg1 ) { if ( matcher . match ( arg0 ) ) { return true ; } } return false ; }
public Element function ( String arg0 ) { Validate . notEmpty ( arg0 ) ; Element wrapBody = Parser . parseBodyFragment ( arg0 , baseUri ) . body ( ) ; Elements wrapChildren = wrapBody . children ( ) ; Element wrap = wrapChildren . first ( ) ; if ( wrap = = null ) return null ; Element deepest = getDeepChild ( wrap ) ; parentNode . replaceChild ( this , wrap ) ; deepest . addChild ( this ) ; if ( wrapChildren . size ( ) > 1 ) { for ( int i = 1 ; i < wrapChildren . size ( ) ; i + + ) { Element remainder = wrapChildren . get ( i ) ; remainder . parentNode . removeChild ( remainder ) ; wrap . appendChild ( remainder ) ; } } return this ; }
public void function ( ) { Document doc = Jsoup . parse ( " <div id=1><p>Hello</p></div> " ) ; Element div = doc . getElementById ( " 1 " ) ; div . prependElement ( " p " ) . text ( " Before " ) ; assertEquals ( " Before " , div . child ( 0 ) . text ( ) ) ; assertEquals ( " Hello " , div . child ( 1 ) . text ( ) ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <div><abc:def id=1>Hello</abc:def></div> <abc:def class=bold id=2>There</abc:def> " ) ; Elements byTag = doc . select ( " *|def " ) ; assertSelectedIds ( byTag , " 1 " , " 2 " ) ; Elements byAttr = doc . select ( " .bold " ) ; assertSelectedIds ( byAttr , " 2 " ) ; Elements byTagAttr = doc . select ( " *|def.bold " ) ; assertSelectedIds ( byTagAttr , " 2 " ) ; Elements byContains = doc . select ( " *|def:contains(e) " ) ; assertSelectedIds ( byContains , " 1 " , " 2 " ) ; }
public void function ( String arg0 , Throwable arg1 ) { log . error ( arg0 , arg1 ) ; }
private void function ( final Request arg0 ) { for ( MocoEventTrigger eventTrigger : eventTriggers ) { if ( eventTrigger . isFor ( MocoEvent . COMPLETE ) ) {
public static MocoEventAction function ( final String arg0 ) { return new MocoRequestAction ( checkNotNull ( arg0 , " URL should not be null " ) , " GET " , Optional . < ContentResource > absent ( ) ) ; }
private StartArgs function ( final int arg0 , final String arg1 ) { return httpArgs ( ) . withPort ( arg0 ) . withEnv ( arg1 ) . build ( ) ; }
@Test public void function ( ) { Document doc = Jsoup . parse ( " <p><span>One</span> Two <span>Three</span> " ) ; Elements els = doc . select ( " span ~ p:matchText " ) ; assertEquals ( 1 , els . size ( ) ) ; assertEquals ( " Two " , els . text ( ) ) ; }
public void function ( Marker arg0 , String arg1 ) { if ( ! logger . isErrorEnabled ( arg0 ) ) return ; if ( instanceofLAL ) { ( ( LocationAwareLogger ) logger ) . log ( arg0 , fqcn , LocationAwareLogger . ERROR_INT , arg1 , null , null ) ;
@Test public void function ( ) { String query = " .foo > ol, ol > li + li " ; Evaluator eval = QueryParser . parse ( query ) ; assertTrue ( eval instanceof CombiningEvaluator . Or ) ; CombiningEvaluator . Or or = ( CombiningEvaluator . Or ) eval ; assertEquals ( 2 , or . evaluators . size ( ) ) ; CombiningEvaluator . And andLeft = ( CombiningEvaluator . And ) or . evaluators . get ( 0 ) ; CombiningEvaluator . And andRight = ( CombiningEvaluator . And ) or . evaluators . get ( 1 ) ; assertEquals ( " .foo > ol " , andLeft . toString ( ) ) ; assertEquals ( 2 , andLeft . evaluators . size ( ) ) ; assertEquals ( " ol > li + li " , andRight . toString ( ) ) ; assertEquals ( 2 , andRight . evaluators . size ( ) ) ; assertEquals ( query , eval . toString ( ) ) ; }
private void function ( String arg0 , String arg1 ) { assertThat ( asContent ( messageWithHeaders ( defaultHeadersFor ( arg0 ) ) ) , is ( arg1 ) ) ; }
private RecordingHandler function ( ) { Handler [ ] handlers = julOrgLogger . getHandlers ( ) ; for ( Handler h : handlers ) { if ( h instanceof RecordingHandler ) return ( RecordingHandler ) h ; } return null ; }
public void function ( ) { } }
@Test public void function ( ) { String html = " <div title='Surf &amp; Turf'>Reef &amp; Beef</div> " ; Document doc = Jsoup . parse ( html ) ; Element div = doc . getElementsByTag ( " div " ) . get ( 0 ) ; assertEquals ( " Surf & Turf " , div . attr ( " title " ) ) ; assertEquals ( " Reef & Beef " , div . text ( ) ) ; }
@Test public void function ( ) { String h = " <div class=head><p class=first>Hello</p><p>There</p></div><p>None</p> " ; Document doc = Jsoup . parse ( h ) ; Elements els = doc . select ( " .head p " ) ; assertEquals ( 2 , els . size ( ) ) ; assertEquals ( " Hello " , els . get ( 0 ) . text ( ) ) ; assertEquals ( " There " , els . get ( 1 ) . text ( ) ) ; Elements p = doc . select ( " p.first " ) ; assertEquals ( 1 , p . size ( ) ) ; assertEquals ( " Hello " , p . get ( 0 ) . text ( ) ) ; Elements empty = doc . select ( " p .first " ) ; assertEquals ( 0 , empty . size ( ) ) ; }
public void function ( final String [ ] arg0 ) { final Runner runner = createRunner ( arg0 ) ; final Stopwatch stopwatch = Stopwatch . createStarted ( ) ; runner . run ( ) ; Runtime . getRuntime ( ) . addShutdownHook ( new Thread ( ( ) - > { runner . stop ( ) ;
public void function ( ) { JSONObject testResult = jsonObject . getJSONObject ( " 9.4.3 " ) ; assertEquals ( " OK " , testResult . get ( " behavior " ) ) ; assertEquals ( " OK " , testResult . get ( " behaviorClose " ) ) ; assertTrue ( testResult . getInt ( " duration " ) < 350 ) ; }
public final String function ( final String arg0 ) { if ( ! this . headers . containsKey ( arg0 ) ) { return null ; } String [ ] values = this . headers . get ( arg0 ) ; return values [ 0 ] ; }
public static String function ( ByteBuffer arg0 ) throws InvalidDataException { CharsetDecoder decode = StandardCharsets . UTF_8 . newDecoder ( ) ; decode . onMalformedInput ( codingErrorAction ) ; decode . onUnmappableCharacter ( codingErrorAction ) ; String s ; try { arg0 . mark ( ) ; s = decode . decode ( arg0 ) . toString ( ) ; arg0 . reset ( ) ; } catch ( CharacterCodingException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 , e ) ; } return s ; }
public boolean function ( String arg0 ) { String protocolHeader = patternSpace . matcher ( arg0 ) . replaceAll ( " " ) ; String [ ] headers = patternComma . split ( protocolHeader ) ; for ( String header : headers ) { if ( providedProtocol . equals ( header ) ) { return true ; } } return false ; }
public Watcher function ( final File arg0 , final FileRunner arg1 ) { return factory . createWatcher ( listener ( arg1 ) , arg0 ) ; }
public Node function ( Node arg0 ) { Validate . notNull ( arg0 ) ; Validate . notNull ( parentNode ) ; if ( arg0 . parentNode = = parentNode ) arg0 . remove ( ) ; parentNode . addChildren ( siblingIndex + 1 , arg0 ) ; return this ; }
protected boolean function ( final String arg0 ) { int count = 0 ; int current = 0 ; while ( current < arg0 . length ( ) ) { int index = arg0 . indexOf ( substring , current ) ; if ( index > 0 ) { count + + ; current = index + substring . length ( ) ; } else { break ; } } return count = = targetCount ; }
public void function ( ) { ID3v2ChapterFrameData frameData1 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 380 , 3 , 400 ) ; ID3v2ChapterFrameData frameData2 = new ID3v2ChapterFrameData ( false , " ch1 " , 1 , 280 , 3 , 400 ) ; assertNotEquals ( frameData1 , frameData2 ) ; }
public static String function ( final String arg0 ) { if ( ! RESERVED_NAME . contains ( checkNotNullOrEmpty ( arg0 , " Template variable name should not be null " ) ) ) { return arg0 ; } throw new IllegalArgumentException ( " Template variable name should not be same with reserved name " ) ; }
public Iterator < ConversionRule > function ( ) { return list . iterator ( ) ; }
public void function ( ) { ID3Wrapper wrapper = new ID3Wrapper ( null , null ) ; wrapper . clearEncoder ( ) ; }
public Document function ( ) throws IOException { Validate . isTrue ( executed , " Request must be executed (with .execute(), .get(), or .post() before parsing response " ) ; if ( byteData ! = null ) { bodyStream = new ByteArrayInputStream ( byteData . array ( ) ) ; inputStreamRead = false ; } Validate . isFalse ( inputStreamRead , " Input stream already read and parsed, cannot re-read. " ) ; Document doc = DataUtil . parseInputStream ( bodyStream , charset , url . toExternalForm ( ) , req . parser ( ) ) ; doc . connection ( new HttpConnection ( req , this ) ) ; charset = doc . outputSettings ( ) . charset ( ) . name ( ) ; inputStreamRead = true ; safeClose ( ) ; return doc ; }
public void function ( ) throws IOException { assertThat ( helper . getWithVersion ( remoteUrl ( " /proxy " ) , HttpVersion . HTTP_1_0 ) , is ( " 1.0 " ) ) ; assertThat ( helper . getWithVersion ( remoteUrl ( " /proxy " ) , HttpVersion . HTTP_1_1 ) , is ( " 1.1 " ) ) ; }
public void function ( ) { Evaluator . TagStartsWith evaluator = new Evaluator . TagStartsWith ( " ns " ) ; assertEquals ( " ns|* " , evaluator . toString ( ) ) ; }
public Safelist function ( String arg0 , String arg1 , String . . . arg2 ) { Validate . notEmpty ( arg0 ) ; Validate . notEmpty ( arg1 ) ; Validate . notNull ( arg2 ) ; TagName tagName = TagName . valueOf ( arg0 ) ; AttributeKey attrKey = AttributeKey . valueOf ( arg1 ) ; Map < AttributeKey , Set < Protocol > > attrMap ; Set < Protocol > protSet ; if ( this . arg2 . containsKey ( tagName ) ) { attrMap = this . arg2 . get ( tagName ) ; } else { attrMap = new HashMap < > ( ) ; this . arg2 . put ( tagName , attrMap ) ; } if ( attrMap . containsKey ( attrKey ) ) { protSet = attrMap . get ( attrKey ) ; } else { protSet = new HashSet < > ( ) ; attrMap . put ( attrKey , protSet ) ; } for ( String protocol : arg2 ) { Validate . notEmpty ( protocol ) ; Protocol prot = Protocol . valueOf ( protocol ) ; protSet . add ( prot ) ; } return this ; }
void function ( Appendable arg0 , int arg1 , Document . OutputSettings arg2 ) { try { arg0 . append ( " ]]> " ) ;
public String function ( String arg0 ) { return ( String ) org . apache . log4j . MDC . get ( arg0 ) ; }
static boolean function ( String arg0 ) { return arg0 ! = null & & arg0 . length ( ) > 1 & & arg0 . charAt ( 0 ) = = InternalPrefix ; }
public void function ( String arg0 , Object . . . arg1 ) { if ( ! logger . isErrorEnabled ( ) ) return ; if ( instanceofLAL ) { String formattedMessage = MessageFormatter . arrayFormat ( arg0 , arg1 )
@Test public void function ( ) { Document doc = Jsoup . parse ( " <title>Check</title> <div>Hello there</div> " ) ; doc . outputSettings ( ) . indentAmount ( 0 ) ; assertTrue ( doc . html ( ) . contains ( doc . select ( " title " ) . outerHtml ( ) ) ) ; assertTrue ( doc . html ( ) . contains ( doc . select ( " div " ) . outerHtml ( ) ) ) ; }
public synchronized void function ( int arg0 , String arg1 , boolean arg2 ) { if ( getReadyState ( ) = = ReadyState . CLOSED ) { return ; } if ( getReadyState ( ) = = ReadyState . OPEN ) { if ( arg0 = = CloseFrame . ABNORMAL_CLOSE ) { setReadyState ( ReadyState . CLOSING ) ; } } if ( key ! = null ) { key . cancel ( ) ; } if ( channel ! = null ) { try { channel . close ( ) ; } catch ( IOException e ) { if ( e . getMessage ( ) . equals ( " Broken pipe " ) ) { log . warn ( " Caught IOException: Broken pipe during closeConnection(): {} " , e ) ; } else { log . error ( " Exception during channel.close(); {} " , e ) ; wsl . onWebsocketError ( this , e ) ; } } } try { this . wsl . onWebsocketClose ( this , arg0 , arg1 , arg2 ) ; } catch ( RuntimeException e ) { wsl . onWebsocketError ( this , e ) ; } if ( draft ! = null ) draft . reset ( ) ; handshakerequest = null ; setReadyState ( ReadyState . CLOSED ) ; }
